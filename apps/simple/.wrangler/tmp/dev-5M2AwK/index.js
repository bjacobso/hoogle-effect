var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// .wrangler/tmp/bundle-89CmXI/strip-cf-connecting-ip-header.js
function stripCfConnectingIPHeader(input, init) {
  const request = new Request(input, init);
  request.headers.delete("CF-Connecting-IP");
  return request;
}
__name(stripCfConnectingIPHeader, "stripCfConnectingIPHeader");
globalThis.fetch = new Proxy(globalThis.fetch, {
  apply(target, thisArg, argArray) {
    return Reflect.apply(target, thisArg, [
      stripCfConnectingIPHeader.apply(null, argArray)
    ]);
  }
});

// ../../node_modules/.pnpm/unenv@2.0.0-rc.14/node_modules/unenv/dist/runtime/_internal/utils.mjs
function createNotImplementedError(name) {
  return new Error(`[unenv] ${name} is not implemented yet!`);
}
__name(createNotImplementedError, "createNotImplementedError");
function notImplemented(name) {
  const fn = /* @__PURE__ */ __name(() => {
    throw createNotImplementedError(name);
  }, "fn");
  return Object.assign(fn, { __unenv__: true });
}
__name(notImplemented, "notImplemented");
function notImplementedClass(name) {
  return class {
    __unenv__ = true;
    constructor() {
      throw new Error(`[unenv] ${name} is not implemented yet!`);
    }
  };
}
__name(notImplementedClass, "notImplementedClass");

// ../../node_modules/.pnpm/unenv@2.0.0-rc.14/node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs
var _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();
var _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;
var nodeTiming = {
  name: "node",
  entryType: "node",
  startTime: 0,
  duration: 0,
  nodeStart: 0,
  v8Start: 0,
  bootstrapComplete: 0,
  environment: 0,
  loopStart: 0,
  loopExit: 0,
  idleTime: 0,
  uvMetricsInfo: {
    loopCount: 0,
    events: 0,
    eventsWaiting: 0
  },
  detail: void 0,
  toJSON() {
    return this;
  }
};
var PerformanceEntry = class {
  __unenv__ = true;
  detail;
  entryType = "event";
  name;
  startTime;
  constructor(name, options) {
    this.name = name;
    this.startTime = options?.startTime || _performanceNow();
    this.detail = options?.detail;
  }
  get duration() {
    return _performanceNow() - this.startTime;
  }
  toJSON() {
    return {
      name: this.name,
      entryType: this.entryType,
      startTime: this.startTime,
      duration: this.duration,
      detail: this.detail
    };
  }
};
__name(PerformanceEntry, "PerformanceEntry");
var PerformanceMark = /* @__PURE__ */ __name(class PerformanceMark2 extends PerformanceEntry {
  entryType = "mark";
  constructor() {
    super(...arguments);
  }
  get duration() {
    return 0;
  }
}, "PerformanceMark");
var PerformanceMeasure = class extends PerformanceEntry {
  entryType = "measure";
};
__name(PerformanceMeasure, "PerformanceMeasure");
var PerformanceResourceTiming = class extends PerformanceEntry {
  entryType = "resource";
  serverTiming = [];
  connectEnd = 0;
  connectStart = 0;
  decodedBodySize = 0;
  domainLookupEnd = 0;
  domainLookupStart = 0;
  encodedBodySize = 0;
  fetchStart = 0;
  initiatorType = "";
  name = "";
  nextHopProtocol = "";
  redirectEnd = 0;
  redirectStart = 0;
  requestStart = 0;
  responseEnd = 0;
  responseStart = 0;
  secureConnectionStart = 0;
  startTime = 0;
  transferSize = 0;
  workerStart = 0;
  responseStatus = 0;
};
__name(PerformanceResourceTiming, "PerformanceResourceTiming");
var PerformanceObserverEntryList = class {
  __unenv__ = true;
  getEntries() {
    return [];
  }
  getEntriesByName(_name, _type) {
    return [];
  }
  getEntriesByType(type) {
    return [];
  }
};
__name(PerformanceObserverEntryList, "PerformanceObserverEntryList");
var Performance = class {
  __unenv__ = true;
  timeOrigin = _timeOrigin;
  eventCounts = /* @__PURE__ */ new Map();
  _entries = [];
  _resourceTimingBufferSize = 0;
  navigation = void 0;
  timing = void 0;
  timerify(_fn, _options) {
    throw createNotImplementedError("Performance.timerify");
  }
  get nodeTiming() {
    return nodeTiming;
  }
  eventLoopUtilization() {
    return {};
  }
  markResourceTiming() {
    return new PerformanceResourceTiming("");
  }
  onresourcetimingbufferfull = null;
  now() {
    if (this.timeOrigin === _timeOrigin) {
      return _performanceNow();
    }
    return Date.now() - this.timeOrigin;
  }
  clearMarks(markName) {
    this._entries = markName ? this._entries.filter((e) => e.name !== markName) : this._entries.filter((e) => e.entryType !== "mark");
  }
  clearMeasures(measureName) {
    this._entries = measureName ? this._entries.filter((e) => e.name !== measureName) : this._entries.filter((e) => e.entryType !== "measure");
  }
  clearResourceTimings() {
    this._entries = this._entries.filter((e) => e.entryType !== "resource" || e.entryType !== "navigation");
  }
  getEntries() {
    return this._entries;
  }
  getEntriesByName(name, type) {
    return this._entries.filter((e) => e.name === name && (!type || e.entryType === type));
  }
  getEntriesByType(type) {
    return this._entries.filter((e) => e.entryType === type);
  }
  mark(name, options) {
    const entry = new PerformanceMark(name, options);
    this._entries.push(entry);
    return entry;
  }
  measure(measureName, startOrMeasureOptions, endMark) {
    let start;
    let end;
    if (typeof startOrMeasureOptions === "string") {
      start = this.getEntriesByName(startOrMeasureOptions, "mark")[0]?.startTime;
      end = this.getEntriesByName(endMark, "mark")[0]?.startTime;
    } else {
      start = Number.parseFloat(startOrMeasureOptions?.start) || this.now();
      end = Number.parseFloat(startOrMeasureOptions?.end) || this.now();
    }
    const entry = new PerformanceMeasure(measureName, {
      startTime: start,
      detail: {
        start,
        end
      }
    });
    this._entries.push(entry);
    return entry;
  }
  setResourceTimingBufferSize(maxSize) {
    this._resourceTimingBufferSize = maxSize;
  }
  addEventListener(type, listener, options) {
    throw createNotImplementedError("Performance.addEventListener");
  }
  removeEventListener(type, listener, options) {
    throw createNotImplementedError("Performance.removeEventListener");
  }
  dispatchEvent(event) {
    throw createNotImplementedError("Performance.dispatchEvent");
  }
  toJSON() {
    return this;
  }
};
__name(Performance, "Performance");
var PerformanceObserver = class {
  __unenv__ = true;
  _callback = null;
  constructor(callback) {
    this._callback = callback;
  }
  takeRecords() {
    return [];
  }
  disconnect() {
    throw createNotImplementedError("PerformanceObserver.disconnect");
  }
  observe(options) {
    throw createNotImplementedError("PerformanceObserver.observe");
  }
  bind(fn) {
    return fn;
  }
  runInAsyncScope(fn, thisArg, ...args) {
    return fn.call(thisArg, ...args);
  }
  asyncId() {
    return 0;
  }
  triggerAsyncId() {
    return 0;
  }
  emitDestroy() {
    return this;
  }
};
__name(PerformanceObserver, "PerformanceObserver");
__publicField(PerformanceObserver, "supportedEntryTypes", []);
var performance = globalThis.performance && "addEventListener" in globalThis.performance ? globalThis.performance : new Performance();

// ../../node_modules/.pnpm/@cloudflare+unenv-preset@2.0.2_unenv@2.0.0-rc.14_workerd@1.20250718.0/node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs
globalThis.performance = performance;
globalThis.Performance = Performance;
globalThis.PerformanceEntry = PerformanceEntry;
globalThis.PerformanceMark = PerformanceMark;
globalThis.PerformanceMeasure = PerformanceMeasure;
globalThis.PerformanceObserver = PerformanceObserver;
globalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;
globalThis.PerformanceResourceTiming = PerformanceResourceTiming;

// ../../node_modules/.pnpm/unenv@2.0.0-rc.14/node_modules/unenv/dist/runtime/node/console.mjs
import { Writable } from "node:stream";

// ../../node_modules/.pnpm/unenv@2.0.0-rc.14/node_modules/unenv/dist/runtime/mock/noop.mjs
var noop_default = Object.assign(() => {
}, { __unenv__: true });

// ../../node_modules/.pnpm/unenv@2.0.0-rc.14/node_modules/unenv/dist/runtime/node/console.mjs
var _console = globalThis.console;
var _ignoreErrors = true;
var _stderr = new Writable();
var _stdout = new Writable();
var log = _console?.log ?? noop_default;
var info = _console?.info ?? log;
var trace = _console?.trace ?? info;
var debug = _console?.debug ?? log;
var table = _console?.table ?? log;
var error = _console?.error ?? log;
var warn = _console?.warn ?? error;
var createTask = _console?.createTask ?? /* @__PURE__ */ notImplemented("console.createTask");
var clear = _console?.clear ?? noop_default;
var count = _console?.count ?? noop_default;
var countReset = _console?.countReset ?? noop_default;
var dir = _console?.dir ?? noop_default;
var dirxml = _console?.dirxml ?? noop_default;
var group = _console?.group ?? noop_default;
var groupEnd = _console?.groupEnd ?? noop_default;
var groupCollapsed = _console?.groupCollapsed ?? noop_default;
var profile = _console?.profile ?? noop_default;
var profileEnd = _console?.profileEnd ?? noop_default;
var time = _console?.time ?? noop_default;
var timeEnd = _console?.timeEnd ?? noop_default;
var timeLog = _console?.timeLog ?? noop_default;
var timeStamp = _console?.timeStamp ?? noop_default;
var Console = _console?.Console ?? /* @__PURE__ */ notImplementedClass("console.Console");
var _times = /* @__PURE__ */ new Map();
var _stdoutErrorHandler = noop_default;
var _stderrErrorHandler = noop_default;

// ../../node_modules/.pnpm/@cloudflare+unenv-preset@2.0.2_unenv@2.0.0-rc.14_workerd@1.20250718.0/node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs
var workerdConsole = globalThis["console"];
var {
  assert,
  clear: clear2,
  // @ts-expect-error undocumented public API
  context,
  count: count2,
  countReset: countReset2,
  // @ts-expect-error undocumented public API
  createTask: createTask2,
  debug: debug2,
  dir: dir2,
  dirxml: dirxml2,
  error: error2,
  group: group2,
  groupCollapsed: groupCollapsed2,
  groupEnd: groupEnd2,
  info: info2,
  log: log2,
  profile: profile2,
  profileEnd: profileEnd2,
  table: table2,
  time: time2,
  timeEnd: timeEnd2,
  timeLog: timeLog2,
  timeStamp: timeStamp2,
  trace: trace2,
  warn: warn2
} = workerdConsole;
Object.assign(workerdConsole, {
  Console,
  _ignoreErrors,
  _stderr,
  _stderrErrorHandler,
  _stdout,
  _stdoutErrorHandler,
  _times
});
var console_default = workerdConsole;

// ../../node_modules/.pnpm/wrangler@3.114.16_@cloudflare+workers-types@4.20260108.0/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console
globalThis.console = console_default;

// ../../node_modules/.pnpm/unenv@2.0.0-rc.14/node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs
var hrtime = /* @__PURE__ */ Object.assign(/* @__PURE__ */ __name(function hrtime2(startTime) {
  const now = Date.now();
  const seconds = Math.trunc(now / 1e3);
  const nanos = now % 1e3 * 1e6;
  if (startTime) {
    let diffSeconds = seconds - startTime[0];
    let diffNanos = nanos - startTime[0];
    if (diffNanos < 0) {
      diffSeconds = diffSeconds - 1;
      diffNanos = 1e9 + diffNanos;
    }
    return [diffSeconds, diffNanos];
  }
  return [seconds, nanos];
}, "hrtime"), { bigint: /* @__PURE__ */ __name(function bigint() {
  return BigInt(Date.now() * 1e6);
}, "bigint") });

// ../../node_modules/.pnpm/unenv@2.0.0-rc.14/node_modules/unenv/dist/runtime/node/internal/process/process.mjs
import { EventEmitter } from "node:events";

// ../../node_modules/.pnpm/unenv@2.0.0-rc.14/node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs
import { Socket } from "node:net";
var ReadStream = class extends Socket {
  fd;
  constructor(fd) {
    super();
    this.fd = fd;
  }
  isRaw = false;
  setRawMode(mode) {
    this.isRaw = mode;
    return this;
  }
  isTTY = false;
};
__name(ReadStream, "ReadStream");

// ../../node_modules/.pnpm/unenv@2.0.0-rc.14/node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs
import { Socket as Socket2 } from "node:net";
var WriteStream = class extends Socket2 {
  fd;
  constructor(fd) {
    super();
    this.fd = fd;
  }
  clearLine(dir3, callback) {
    callback && callback();
    return false;
  }
  clearScreenDown(callback) {
    callback && callback();
    return false;
  }
  cursorTo(x, y, callback) {
    callback && typeof callback === "function" && callback();
    return false;
  }
  moveCursor(dx, dy, callback) {
    callback && callback();
    return false;
  }
  getColorDepth(env2) {
    return 1;
  }
  hasColors(count3, env2) {
    return false;
  }
  getWindowSize() {
    return [this.columns, this.rows];
  }
  columns = 80;
  rows = 24;
  isTTY = false;
};
__name(WriteStream, "WriteStream");

// ../../node_modules/.pnpm/unenv@2.0.0-rc.14/node_modules/unenv/dist/runtime/node/internal/process/process.mjs
var Process = class extends EventEmitter {
  env;
  hrtime;
  nextTick;
  constructor(impl) {
    super();
    this.env = impl.env;
    this.hrtime = impl.hrtime;
    this.nextTick = impl.nextTick;
    for (const prop of [...Object.getOwnPropertyNames(Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {
      const value = this[prop];
      if (typeof value === "function") {
        this[prop] = value.bind(this);
      }
    }
  }
  emitWarning(warning, type, code) {
    console.warn(`${code ? `[${code}] ` : ""}${type ? `${type}: ` : ""}${warning}`);
  }
  emit(...args) {
    return super.emit(...args);
  }
  listeners(eventName) {
    return super.listeners(eventName);
  }
  #stdin;
  #stdout;
  #stderr;
  get stdin() {
    return this.#stdin ??= new ReadStream(0);
  }
  get stdout() {
    return this.#stdout ??= new WriteStream(1);
  }
  get stderr() {
    return this.#stderr ??= new WriteStream(2);
  }
  #cwd = "/";
  chdir(cwd2) {
    this.#cwd = cwd2;
  }
  cwd() {
    return this.#cwd;
  }
  arch = "";
  platform = "";
  argv = [];
  argv0 = "";
  execArgv = [];
  execPath = "";
  title = "";
  pid = 200;
  ppid = 100;
  get version() {
    return "";
  }
  get versions() {
    return {};
  }
  get allowedNodeEnvironmentFlags() {
    return /* @__PURE__ */ new Set();
  }
  get sourceMapsEnabled() {
    return false;
  }
  get debugPort() {
    return 0;
  }
  get throwDeprecation() {
    return false;
  }
  get traceDeprecation() {
    return false;
  }
  get features() {
    return {};
  }
  get release() {
    return {};
  }
  get connected() {
    return false;
  }
  get config() {
    return {};
  }
  get moduleLoadList() {
    return [];
  }
  constrainedMemory() {
    return 0;
  }
  availableMemory() {
    return 0;
  }
  uptime() {
    return 0;
  }
  resourceUsage() {
    return {};
  }
  ref() {
  }
  unref() {
  }
  umask() {
    throw createNotImplementedError("process.umask");
  }
  getBuiltinModule() {
    return void 0;
  }
  getActiveResourcesInfo() {
    throw createNotImplementedError("process.getActiveResourcesInfo");
  }
  exit() {
    throw createNotImplementedError("process.exit");
  }
  reallyExit() {
    throw createNotImplementedError("process.reallyExit");
  }
  kill() {
    throw createNotImplementedError("process.kill");
  }
  abort() {
    throw createNotImplementedError("process.abort");
  }
  dlopen() {
    throw createNotImplementedError("process.dlopen");
  }
  setSourceMapsEnabled() {
    throw createNotImplementedError("process.setSourceMapsEnabled");
  }
  loadEnvFile() {
    throw createNotImplementedError("process.loadEnvFile");
  }
  disconnect() {
    throw createNotImplementedError("process.disconnect");
  }
  cpuUsage() {
    throw createNotImplementedError("process.cpuUsage");
  }
  setUncaughtExceptionCaptureCallback() {
    throw createNotImplementedError("process.setUncaughtExceptionCaptureCallback");
  }
  hasUncaughtExceptionCaptureCallback() {
    throw createNotImplementedError("process.hasUncaughtExceptionCaptureCallback");
  }
  initgroups() {
    throw createNotImplementedError("process.initgroups");
  }
  openStdin() {
    throw createNotImplementedError("process.openStdin");
  }
  assert() {
    throw createNotImplementedError("process.assert");
  }
  binding() {
    throw createNotImplementedError("process.binding");
  }
  permission = { has: /* @__PURE__ */ notImplemented("process.permission.has") };
  report = {
    directory: "",
    filename: "",
    signal: "SIGUSR2",
    compact: false,
    reportOnFatalError: false,
    reportOnSignal: false,
    reportOnUncaughtException: false,
    getReport: /* @__PURE__ */ notImplemented("process.report.getReport"),
    writeReport: /* @__PURE__ */ notImplemented("process.report.writeReport")
  };
  finalization = {
    register: /* @__PURE__ */ notImplemented("process.finalization.register"),
    unregister: /* @__PURE__ */ notImplemented("process.finalization.unregister"),
    registerBeforeExit: /* @__PURE__ */ notImplemented("process.finalization.registerBeforeExit")
  };
  memoryUsage = Object.assign(() => ({
    arrayBuffers: 0,
    rss: 0,
    external: 0,
    heapTotal: 0,
    heapUsed: 0
  }), { rss: () => 0 });
  mainModule = void 0;
  domain = void 0;
  send = void 0;
  exitCode = void 0;
  channel = void 0;
  getegid = void 0;
  geteuid = void 0;
  getgid = void 0;
  getgroups = void 0;
  getuid = void 0;
  setegid = void 0;
  seteuid = void 0;
  setgid = void 0;
  setgroups = void 0;
  setuid = void 0;
  _events = void 0;
  _eventsCount = void 0;
  _exiting = void 0;
  _maxListeners = void 0;
  _debugEnd = void 0;
  _debugProcess = void 0;
  _fatalException = void 0;
  _getActiveHandles = void 0;
  _getActiveRequests = void 0;
  _kill = void 0;
  _preload_modules = void 0;
  _rawDebug = void 0;
  _startProfilerIdleNotifier = void 0;
  _stopProfilerIdleNotifier = void 0;
  _tickCallback = void 0;
  _disconnect = void 0;
  _handleQueue = void 0;
  _pendingMessage = void 0;
  _channel = void 0;
  _send = void 0;
  _linkedBinding = void 0;
};
__name(Process, "Process");

// ../../node_modules/.pnpm/@cloudflare+unenv-preset@2.0.2_unenv@2.0.0-rc.14_workerd@1.20250718.0/node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs
var globalProcess = globalThis["process"];
var getBuiltinModule = globalProcess.getBuiltinModule;
var { exit, platform, nextTick } = getBuiltinModule(
  "node:process"
);
var unenvProcess = new Process({
  env: globalProcess.env,
  hrtime,
  nextTick
});
var {
  abort,
  addListener,
  allowedNodeEnvironmentFlags,
  hasUncaughtExceptionCaptureCallback,
  setUncaughtExceptionCaptureCallback,
  loadEnvFile,
  sourceMapsEnabled,
  arch,
  argv,
  argv0,
  chdir,
  config,
  connected,
  constrainedMemory,
  availableMemory,
  cpuUsage,
  cwd,
  debugPort,
  dlopen,
  disconnect,
  emit,
  emitWarning,
  env,
  eventNames,
  execArgv,
  execPath,
  finalization,
  features,
  getActiveResourcesInfo,
  getMaxListeners,
  hrtime: hrtime3,
  kill,
  listeners,
  listenerCount,
  memoryUsage,
  on,
  off,
  once,
  pid,
  ppid,
  prependListener,
  prependOnceListener,
  rawListeners,
  release,
  removeAllListeners,
  removeListener,
  report,
  resourceUsage,
  setMaxListeners,
  setSourceMapsEnabled,
  stderr,
  stdin,
  stdout,
  title,
  throwDeprecation,
  traceDeprecation,
  umask,
  uptime,
  version,
  versions,
  domain,
  initgroups,
  moduleLoadList,
  reallyExit,
  openStdin,
  assert: assert2,
  binding,
  send,
  exitCode,
  channel,
  getegid,
  geteuid,
  getgid,
  getgroups,
  getuid,
  setegid,
  seteuid,
  setgid,
  setgroups,
  setuid,
  permission,
  mainModule,
  _events,
  _eventsCount,
  _exiting,
  _maxListeners,
  _debugEnd,
  _debugProcess,
  _fatalException,
  _getActiveHandles,
  _getActiveRequests,
  _kill,
  _preload_modules,
  _rawDebug,
  _startProfilerIdleNotifier,
  _stopProfilerIdleNotifier,
  _tickCallback,
  _disconnect,
  _handleQueue,
  _pendingMessage,
  _channel,
  _send,
  _linkedBinding
} = unenvProcess;
var _process = {
  abort,
  addListener,
  allowedNodeEnvironmentFlags,
  hasUncaughtExceptionCaptureCallback,
  setUncaughtExceptionCaptureCallback,
  loadEnvFile,
  sourceMapsEnabled,
  arch,
  argv,
  argv0,
  chdir,
  config,
  connected,
  constrainedMemory,
  availableMemory,
  cpuUsage,
  cwd,
  debugPort,
  dlopen,
  disconnect,
  emit,
  emitWarning,
  env,
  eventNames,
  execArgv,
  execPath,
  exit,
  finalization,
  features,
  getBuiltinModule,
  getActiveResourcesInfo,
  getMaxListeners,
  hrtime: hrtime3,
  kill,
  listeners,
  listenerCount,
  memoryUsage,
  nextTick,
  on,
  off,
  once,
  pid,
  platform,
  ppid,
  prependListener,
  prependOnceListener,
  rawListeners,
  release,
  removeAllListeners,
  removeListener,
  report,
  resourceUsage,
  setMaxListeners,
  setSourceMapsEnabled,
  stderr,
  stdin,
  stdout,
  title,
  throwDeprecation,
  traceDeprecation,
  umask,
  uptime,
  version,
  versions,
  // @ts-expect-error old API
  domain,
  initgroups,
  moduleLoadList,
  reallyExit,
  openStdin,
  assert: assert2,
  binding,
  send,
  exitCode,
  channel,
  getegid,
  geteuid,
  getgid,
  getgroups,
  getuid,
  setegid,
  seteuid,
  setgid,
  setgroups,
  setuid,
  permission,
  mainModule,
  _events,
  _eventsCount,
  _exiting,
  _maxListeners,
  _debugEnd,
  _debugProcess,
  _fatalException,
  _getActiveHandles,
  _getActiveRequests,
  _kill,
  _preload_modules,
  _rawDebug,
  _startProfilerIdleNotifier,
  _stopProfilerIdleNotifier,
  _tickCallback,
  _disconnect,
  _handleQueue,
  _pendingMessage,
  _channel,
  _send,
  _linkedBinding
};
var process_default = _process;

// ../../node_modules/.pnpm/wrangler@3.114.16_@cloudflare+workers-types@4.20260108.0/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process
globalThis.process = process_default;

// src/components/Layout.ts
function escapeHtml(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}
__name(escapeHtml, "escapeHtml");
function Header() {
  return `
    <header class="bg-white border-b border-gray-200">
      <div class="max-w-6xl mx-auto px-4 py-6">
        <a href="/" class="flex items-center gap-3 mb-4 no-underline">
          <div class="w-10 h-10 rounded-lg bg-gradient-to-br from-purple-500 to-blue-500 flex items-center justify-center">
            <span class="text-white font-bold text-lg">H</span>
          </div>
          <div>
            <h1 class="text-2xl font-bold text-gray-900">Hoogle-Effect</h1>
            <p class="text-sm text-gray-500">Search Effect-TS by type signature</p>
          </div>
        </a>
      </div>
    </header>
  `;
}
__name(Header, "Header");
function Footer() {
  return `
    <footer class="border-t border-gray-200 mt-12">
      <div class="max-w-6xl mx-auto px-4 py-6 text-center text-sm text-gray-500">
        <p>
          Inspired by
          <a href="https://hoogle.haskell.org" class="text-purple-600 hover:underline">Hoogle</a>
          &middot;
          Built for
          <a href="https://effect.website" class="text-purple-600 hover:underline">Effect-TS</a>
        </p>
      </div>
    </footer>
  `;
}
__name(Footer, "Footer");
function Layout({ title: title2, children }) {
  const childContent = Array.isArray(children) ? children.join("") : children;
  return `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>${escapeHtml(title2)}</title>
    <link rel="stylesheet" href="/styles.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet" />
  </head>
  <body class="min-h-screen bg-gray-50 font-sans">
    ${Header()}
    <main class="max-w-6xl mx-auto px-4 py-6">
      ${childContent}
    </main>
    ${Footer()}
    <script src="/enhance.js" defer><\/script>
  </body>
</html>`;
}
__name(Layout, "Layout");

// src/components/SearchBar.ts
function escapeHtml2(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}
__name(escapeHtml2, "escapeHtml");
function SearchBar({ value, placeholder }) {
  const defaultPlaceholder = "Search by name, type, or description... (e.g., map, Effect<A, E, R>, retry)";
  const escapedValue = escapeHtml2(value);
  const escapedPlaceholder = escapeHtml2(placeholder || defaultPlaceholder);
  return `
    <form action="/" method="GET" class="mb-0" id="search-form">
      <div class="relative">
        <div class="absolute inset-y-0 left-0 pl-4 flex items-center pointer-events-none">
          <svg class="h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
          </svg>
        </div>
        <input
          type="text"
          name="q"
          value="${escapedValue}"
          placeholder="${escapedPlaceholder}"
          class="w-full pl-12 pr-24 py-3 text-lg border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-purple-500 outline-none transition-shadow font-mono"
          autofocus
          id="search-input"
        />
        <button
          type="submit"
          class="absolute inset-y-0 right-0 px-4 flex items-center text-purple-600 hover:text-purple-800 font-medium"
        >
          Search
        </button>
      </div>
    </form>
  `;
}
__name(SearchBar, "SearchBar");

// src/components/SignatureDisplay.ts
function escapeHtml3(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}
__name(escapeHtml3, "escapeHtml");
function highlightSignature(sig) {
  const parts = [];
  let remaining = sig;
  remaining = remaining.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  const patterns = [
    // Effect types (blue)
    [/^(Effect|Stream|Option|Either|Cause|Exit|Layer|Schedule|Fiber|Ref|Queue|Chunk|Array|HashMap|HashSet|Context)(?=&lt;|[^a-zA-Z]|$)/g, "text-blue-400 font-medium"],
    // Primitive types (green)
    [/^(string|number|boolean|void|never|unknown|any|null|undefined)/g, "text-green-400"],
    // Arrows (purple)
    [/^(=&gt;)/g, "text-purple-400"],
    // Operators and brackets (gray)
    [/^(&lt;|&gt;|\||&amp;)/g, "text-gray-400"],
    [/^(\{|\}|\(|\)|\[|\]|,|;|:)/g, "text-gray-400"],
    // Type parameters like A, E, R (amber) - single capital letters or common type params
    [/^([A-Z][a-zA-Z0-9]*)/g, "text-amber-400"]
  ];
  while (remaining.length > 0) {
    let matched = false;
    for (const [pattern, className] of patterns) {
      pattern.lastIndex = 0;
      const match = remaining.match(pattern);
      if (match && match.index === 0) {
        parts.push(`<span class="${className}">${match[0]}</span>`);
        remaining = remaining.slice(match[0].length);
        matched = true;
        break;
      }
    }
    if (!matched) {
      const char = remaining[0];
      if (char === " " || char === "\n") {
        parts.push(char);
      } else {
        const nextSpecial = remaining.slice(1).search(/[&<>(){}[\],;:|=\s]/);
        const end = nextSpecial === -1 ? remaining.length : nextSpecial + 1;
        parts.push(`<span class="text-gray-300">${remaining.slice(0, end)}</span>`);
        remaining = remaining.slice(end);
        continue;
      }
      remaining = remaining.slice(1);
    }
  }
  return parts.join("");
}
__name(highlightSignature, "highlightSignature");
function simplifySignature(sig) {
  if (sig.startsWith("{ ")) {
    const firstOverload = sig.match(/\{ ([^;]+);/);
    if (firstOverload) {
      return firstOverload[1].trim() + " (+ overloads)";
    }
  }
  if (sig.length > 120) {
    return sig.slice(0, 117) + "...";
  }
  return sig;
}
__name(simplifySignature, "simplifySignature");
function SignatureDisplay({ signature, compact }) {
  const displaySig = compact ? simplifySignature(signature) : signature;
  if (compact) {
    return `<span class="text-gray-600">${escapeHtml3(displaySig)}</span>`;
  }
  const highlighted = highlightSignature(displaySig);
  return `<code class="text-sm text-gray-100 font-mono whitespace-pre-wrap break-all">${highlighted}</code>`;
}
__name(SignatureDisplay, "SignatureDisplay");

// src/components/ResultsList.ts
function escapeHtml4(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}
__name(escapeHtml4, "escapeHtml");
var GitHubIcon = /* @__PURE__ */ __name(() => `
  <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
    <path fill-rule="evenodd" clip-rule="evenodd" d="M12 2C6.477 2 2 6.477 2 12c0 4.42 2.865 8.17 6.839 9.49.5.092.682-.217.682-.482 0-.237-.008-.866-.013-1.7-2.782.604-3.369-1.34-3.369-1.34-.454-1.156-1.11-1.464-1.11-1.464-.908-.62.069-.608.069-.608 1.003.07 1.531 1.03 1.531 1.03.892 1.529 2.341 1.087 2.91.831.092-.646.35-1.086.636-1.336-2.22-.253-4.555-1.11-4.555-4.943 0-1.091.39-1.984 1.029-2.683-.103-.253-.446-1.27.098-2.647 0 0 .84-.269 2.75 1.025A9.578 9.578 0 0112 6.836c.85.004 1.705.114 2.504.336 1.909-1.294 2.747-1.025 2.747-1.025.546 1.377.203 2.394.1 2.647.64.699 1.028 1.592 1.028 2.683 0 3.842-2.339 4.687-4.566 4.935.359.309.678.919.678 1.852 0 1.336-.012 2.415-.012 2.743 0 .267.18.578.688.48C19.138 20.167 22 16.418 22 12c0-5.523-4.477-10-10-10z" />
  </svg>
`, "GitHubIcon");
function EmptyState() {
  const suggestions = ["map", "flatMap", "retry", "Effect", "forEach"];
  const suggestionLinks = suggestions.map(
    (term) => `<a href="/?q=${encodeURIComponent(term)}" class="px-2 py-1 bg-gray-100 rounded text-gray-600 hover:bg-purple-100 hover:text-purple-700 transition-colors no-underline">${escapeHtml4(term)}</a>`
  ).join("\n");
  return `
    <div class="bg-white rounded-lg border border-gray-200 p-8 text-center">
      <p class="text-gray-500 mb-4">Start typing to search Effect functions</p>
      <div class="text-sm text-gray-400 space-y-2">
        <p>Try searching for:</p>
        <div class="flex flex-wrap gap-2 justify-center">
          ${suggestionLinks}
        </div>
      </div>
    </div>
  `;
}
__name(EmptyState, "EmptyState");
function NoResults(query) {
  return `
    <div class="bg-white rounded-lg border border-gray-200 p-8 text-center text-gray-500">
      <p>No results found for "${escapeHtml4(query)}"</p>
      <p class="text-sm mt-2">Try a different search term</p>
    </div>
  `;
}
__name(NoResults, "NoResults");
function ResultItem(func) {
  const sinceTag = func.since ? `<span class="text-xs px-1.5 py-0.5 bg-gray-100 text-gray-500 rounded">v${escapeHtml4(func.since)}</span>` : "";
  const githubIcon = func.githubUrl ? `<span class="text-gray-400 hover:text-purple-600 transition-colors" title="View on GitHub">${GitHubIcon()}</span>` : "";
  const description = func.description ? `<p class="text-sm text-gray-500 line-clamp-2">${escapeHtml4(func.description)}</p>` : "";
  const tags = func.tags.length > 0 ? `<div class="flex flex-wrap gap-1">
          ${func.tags.slice(0, 2).map((tag) => `<span class="text-xs px-2 py-0.5 bg-purple-100 text-purple-700 rounded-full">${escapeHtml4(tag)}</span>`).join("\n")}
        </div>` : "";
  return `
    <a
      href="/function/${encodeURIComponent(func.id)}"
      class="block w-full text-left p-4 rounded-lg border bg-white border-gray-200 hover:border-purple-200 hover:bg-purple-50/50 transition-all no-underline"
    >
      <div class="flex items-start justify-between gap-2">
        <div class="flex-1 min-w-0">
          <div class="flex items-center gap-2 mb-1">
            <span class="font-semibold text-gray-900">${escapeHtml4(func.module)}</span>
            <span class="text-gray-400">.</span>
            <span class="font-semibold text-purple-600">${escapeHtml4(func.name)}</span>
            ${sinceTag}
            ${githubIcon}
          </div>

          <div class="text-sm text-gray-600 font-mono truncate mb-2">
            ${SignatureDisplay({ signature: func.signature, compact: true })}
          </div>

          ${description}
        </div>

        ${tags}
      </div>
    </a>
  `;
}
__name(ResultItem, "ResultItem");
function ResultsList({ results, query }) {
  if (!query) {
    return EmptyState();
  }
  if (results.length === 0) {
    return NoResults(query);
  }
  const resultItems = results.map((func) => ResultItem(func)).join("\n");
  return `
    <div class="space-y-2" id="results">
      <div class="text-sm text-gray-500 mb-3">
        ${results.length} result${results.length !== 1 ? "s" : ""}
      </div>
      ${resultItems}
    </div>
  `;
}
__name(ResultsList, "ResultsList");

// ../../node_modules/.pnpm/fuse.js@7.1.0/node_modules/fuse.js/dist/fuse.mjs
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
__name(isArray, "isArray");
var INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
__name(baseToString, "baseToString");
function toString(value) {
  return value == null ? "" : baseToString(value);
}
__name(toString, "toString");
function isString(value) {
  return typeof value === "string";
}
__name(isString, "isString");
function isNumber(value) {
  return typeof value === "number";
}
__name(isNumber, "isNumber");
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
__name(isBoolean, "isBoolean");
function isObject(value) {
  return typeof value === "object";
}
__name(isObject, "isObject");
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
__name(isObjectLike, "isObjectLike");
function isDefined(value) {
  return value !== void 0 && value !== null;
}
__name(isDefined, "isDefined");
function isBlank(value) {
  return !value.trim().length;
}
__name(isBlank, "isBlank");
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
__name(getTag, "getTag");
var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = /* @__PURE__ */ __name((key) => `Invalid value for key ${key}`, "LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY");
var PATTERN_LENGTH_TOO_LARGE = /* @__PURE__ */ __name((max) => `Pattern length exceeds max of ${max}.`, "PATTERN_LENGTH_TOO_LARGE");
var MISSING_KEY_PROPERTY = /* @__PURE__ */ __name((name) => `Missing ${name} property in key`, "MISSING_KEY_PROPERTY");
var INVALID_KEY_WEIGHT_VALUE = /* @__PURE__ */ __name((key) => `Property 'weight' in key '${key}' must be a positive integer`, "INVALID_KEY_WEIGHT_VALUE");
var hasOwn = Object.prototype.hasOwnProperty;
var KeyStore = class {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key) => {
      let obj = createKey(key);
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
};
__name(KeyStore, "KeyStore");
function createKey(key) {
  let path = null;
  let id = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id, weight, src, getFn };
}
__name(createKey, "createKey");
function createKeyPath(key) {
  return isArray(key) ? key : key.split(".");
}
__name(createKeyPath, "createKeyPath");
function createKeyId(key) {
  return isArray(key) ? key.join(".") : key;
}
__name(createKeyId, "createKeyId");
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = /* @__PURE__ */ __name((obj2, path2, index) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index]) {
      list.push(obj2);
    } else {
      let key = path2[index];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path2, index + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index + 1);
      }
    }
  }, "deepGet");
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
__name(get, "get");
var MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
var BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When `true`, the algorithm will ignore diacritics (accents) in comparisons
  ignoreDiacritics: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
var FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
var AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
var SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
}
__name(norm, "norm");
var FuseIndex = class {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
};
__name(FuseIndex, "FuseIndex");
function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
__name(createIndex, "createIndex");
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
__name(parseIndex, "parseIndex");
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
__name(computeScore$1, "computeScore$1");
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }
  return indices;
}
__name(convertMaskToIndices, "convertMaskToIndices");
var MAX_BITS = 32;
function search(text, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;
  while ((index = text.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish; j >= start; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
__name(search, "search");
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | 1 << len - i - 1;
  }
  return mask;
}
__name(createPatternAlphabet, "createPatternAlphabet");
var stripDiacritics = String.prototype.normalize ? (str) => str.normalize("NFD").replace(/[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]/g, "") : (str) => str;
var BitapSearch = class {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreDiacritics = Config.ignoreDiacritics,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreDiacritics,
      ignoreLocation
    };
    pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    pattern = ignoreDiacritics ? stripDiacritics(pattern) : pattern;
    this.pattern = pattern;
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = /* @__PURE__ */ __name((pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    }, "addChunk");
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text) {
    const { isCaseSensitive, ignoreDiacritics, includeMatches } = this.options;
    text = isCaseSensitive ? text : text.toLowerCase();
    text = ignoreDiacritics ? stripDiacritics(text) : text;
    if (this.pattern === text) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
};
__name(BitapSearch, "BitapSearch");
var BaseMatch = class {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
};
__name(BaseMatch, "BaseMatch");
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
__name(getMatch, "getMatch");
var ExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text) {
    const isMatch = text === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
__name(ExactMatch, "ExactMatch");
var InverseExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text) {
    const index = text.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
__name(InverseExactMatch, "InverseExactMatch");
var PrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text) {
    const isMatch = text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
__name(PrefixExactMatch, "PrefixExactMatch");
var InversePrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text) {
    const isMatch = !text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
__name(InversePrefixExactMatch, "InversePrefixExactMatch");
var SuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text) {
    const isMatch = text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text.length - this.pattern.length, text.length - 1]
    };
  }
};
__name(SuffixExactMatch, "SuffixExactMatch");
var InverseSuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text) {
    const isMatch = !text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
__name(InverseSuffixExactMatch, "InverseSuffixExactMatch");
var FuzzyMatch = class extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreDiacritics = Config.ignoreDiacritics,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreDiacritics,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text) {
    return this._bitapSearch.searchIn(text);
  }
};
__name(FuzzyMatch, "FuzzyMatch");
var IncludeMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text) {
    let location = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index = text.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
};
__name(IncludeMatch, "IncludeMatch");
var searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
var searchersLen = searchers.length;
var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
var OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
}
__name(parseQuery, "parseQuery");
var MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
var ExtendedSearch = class {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    ignoreDiacritics = Config.ignoreDiacritics,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      ignoreDiacritics,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    pattern = ignoreDiacritics ? stripDiacritics(pattern) : pattern;
    this.pattern = pattern;
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive, ignoreDiacritics } = this.options;
    text = isCaseSensitive ? text : text.toLowerCase();
    text = ignoreDiacritics ? stripDiacritics(text) : text;
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
};
__name(ExtendedSearch, "ExtendedSearch");
var registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
__name(register, "register");
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
__name(createSearcher, "createSearcher");
var LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
var KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
var isExpression = /* @__PURE__ */ __name((query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]), "isExpression");
var isPath = /* @__PURE__ */ __name((query) => !!query[KeyType.PATH], "isPath");
var isLeaf = /* @__PURE__ */ __name((query) => !isArray(query) && isObject(query) && !isExpression(query), "isLeaf");
var convertToExplicit = /* @__PURE__ */ __name((query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
}), "convertToExplicit");
function parse(query, options, { auto = true } = {}) {
  const next = /* @__PURE__ */ __name((query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key) => {
      const value = query2[key];
      if (isArray(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  }, "next");
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
__name(parse, "parse");
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
__name(computeScore, "computeScore");
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
__name(transformMatches, "transformMatches");
function transformScore(result, data) {
  data.score = result.score;
}
__name(transformScore, "transformScore");
function format(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
__name(format, "format");
var Fuse = class {
  constructor(docs, options = {}, index) {
    this.options = { ...Config, ...options };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text, i: idx, n: norm2 }) => {
      if (!isDefined(text)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        results.push({
          item: text,
          idx,
          matches: [{ score, value: text, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = /* @__PURE__ */ __name((node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    }, "evaluate");
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];
      keys.forEach((key, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key,
            value: item[keyIndex],
            searcher
          })
        );
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({ v: text, i: idx, n: norm2 }) => {
        if (!isDefined(text)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        matches.push({ score, key, value: text, norm: norm2, indices });
      }
    }
    return matches;
  }
};
__name(Fuse, "Fuse");
Fuse.version = "7.1.0";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}

// ../../data/index.json
var data_default = {
  version: "1.0.0",
  buildDate: "2026-01-08T06:50:39.215Z",
  effectVersion: "3.19.14",
  functions: [
    {
      id: "effect.EffectTypeId",
      name: "EffectTypeId",
      module: "effect",
      package: "effect",
      signature: "typeof EffectTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 56,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L56"
    },
    {
      id: "effect.isEffect",
      name: "isEffect",
      module: "effect",
      package: "effect",
      signature: "(u: unknown) => u is Effect<unknown, unknown, unknown>",
      description: "Checks if a given value is an `Effect` value.",
      documentation: "Checks if a given value is an `Effect` value.\n\n**When to Use**\n\nThis function can be useful for checking the type of a value before\nattempting to operate on it as an `Effect` value. For example, you could use\n`Effect.isEffect` to check the type of a value before using it as an argument\nto a function that expects an `Effect` value.",
      examples: [],
      tags: [
        "Guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 241,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L241"
    },
    {
      id: "effect.cachedWithTTL",
      name: "cachedWithTTL",
      module: "effect",
      package: "effect",
      signature: "{ (timeToLive: DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<A, E, never>, never, R>; <A, E, R>(self: Effect<A, E, R>, timeToLive: DurationInput): Effect<Effect<A, E, never>, never, R>; }",
      description: 'Returns an effect that caches its result for a specified `Duration`,\nknown as "timeToLive" (TTL).',
      documentation: 'Returns an effect that caches its result for a specified `Duration`,\nknown as "timeToLive" (TTL).\n\n**Details**\n\nThis function is used to cache the result of an effect for a specified amount\nof time. This means that the first time the effect is evaluated, its result\nis computed and stored.\n\nIf the effect is evaluated again within the specified `timeToLive`, the\ncached result will be used, avoiding recomputation.\n\nAfter the specified duration has passed, the cache expires, and the effect\nwill be recomputed upon the next evaluation.\n\n**When to Use**\n\nUse this function when you have an effect that involves costly operations or\ncomputations, and you want to avoid repeating them within a short time frame.\n\nIt\'s ideal for scenarios where the result of an effect doesn\'t change\nfrequently and can be reused for a specified duration.\n\nBy caching the result, you can improve efficiency and reduce unnecessary\ncomputations, especially in performance-critical applications.\n\n**Example**\n\n```ts\nimport { Effect, Console } from "effect"\n\nlet i = 1\nconst expensiveTask = Effect.promise<string>(() => {\n  console.log("expensive task...")\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(`result ${i++}`)\n    }, 100)\n  })\n})\n\nconst program = Effect.gen(function* () {\n  const cached = yield* Effect.cachedWithTTL(expensiveTask, "150 millis")\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* Effect.sleep("100 millis")\n  yield* cached.pipe(Effect.andThen(Console.log))\n})\n\nEffect.runFork(program)\n// Output:\n// expensive task...\n// result 1\n// result 1\n// expensive task...\n// result 2\n```',
      examples: [
        {
          code: 'import { Effect, Console } from "effect"\n\nlet i = 1\nconst expensiveTask = Effect.promise<string>(() => {\n  console.log("expensive task...")\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(`result ${i++}`)\n    }, 100)\n  })\n})\n\nconst program = Effect.gen(function* () {\n  const cached = yield* Effect.cachedWithTTL(expensiveTask, "150 millis")\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* Effect.sleep("100 millis")\n  yield* cached.pipe(Effect.andThen(Console.log))\n})\n\nEffect.runFork(program)\n// Output:\n// expensive task...\n// result 1\n// result 1\n// expensive task...\n// result 2'
        }
      ],
      tags: [
        "Caching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 309,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L309"
    },
    {
      id: "effect.cachedInvalidateWithTTL",
      name: "cachedInvalidateWithTTL",
      module: "effect",
      package: "effect",
      signature: "{ (timeToLive: DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<[Effect<A, E, never>, Effect<void, never, never>], never, R>; <A, E, R>(self: Effect<A, E, R>, timeToLive: DurationInput): Effect<[Effect<A, E, never>, Effect<void, never, never>], never, R>; }",
      description: "/\n * Caches an effect's result for a specified duration and allows manual\n * invalidation before expiration.\n *\n *",
      documentation: '/**\n * Caches an effect\'s result for a specified duration and allows manual\n * invalidation before expiration.\n *\n * **Details**\n *\n * This function behaves similarly to {@link cachedWithTTL}by caching the\n * result of an effect for a specified period of time. However, it introduces an\n * additional feature: it provides an effect that allows you to manually\n * invalidate the cached result before it naturally expires.\n *\n * This gives you more control over the cache, allowing you to refresh the\n * result when needed, even if the original cache has not yet expired.\n *\n * Once the cache is invalidated, the next time the effect is evaluated, the\n * result will be recomputed, and the cache will be refreshed.\n *\n * **When to Use**\n *\n * Use this function when you have an effect whose result needs to be cached for\n * a certain period, but you also want the option to refresh the cache manually\n * before the expiration time.\n *\n * This is useful when you need to ensure that the cached data remains valid for\n * a certain period but still want to invalidate it if the underlying data\n * changes or if you want to force a recomputation.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Console } from "effect"\n *\n * let i = 1\n * const expensiveTask = Effect.promise<string>(() => {\n *   console.log("expensive task...")\n *   return new Promise((resolve) => {\n *     setTimeout(() => {\n *       resolve(`result ${i++}`)\n *     }, 100)\n *   })\n * })\n *\n * const program = Effect.gen(function* () {\n *   const [cached, invalidate] = yield* Effect.cachedInvalidateWithTTL(\n *     expensiveTask,\n *     "1 hour"\n *   )\n *   yield* cached.pipe(Effect.andThen(Console.log))\n *   yield* cached.pipe(Effect.andThen(Console.log))\n *   yield* invalidate\n *   yield* cached.pipe(Effect.andThen(Console.log))\n * })\n *\n * Effect.runFork(program)\n * // Output:\n * // expensive task...\n * // result 1\n * // result 1\n * // expensive task...\n * // result 2\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect, Console } from "effect"\n *\n * let i = 1\n * const expensiveTask = Effect.promise<string>(() => {\n *   console.log("expensive task...")\n *   return new Promise((resolve) => {\n *     setTimeout(() => {\n *       resolve(`result ${i++}`)\n *     }, 100)\n *   })\n * })\n *\n * const program = Effect.gen(function* () {\n *   const [cached, invalidate] = yield* Effect.cachedInvalidateWithTTL(\n *     expensiveTask,\n *     "1 hour"\n *   )\n *   yield* cached.pipe(Effect.andThen(Console.log))\n *   yield* cached.pipe(Effect.andThen(Console.log))\n *   yield* invalidate\n *   yield* cached.pipe(Effect.andThen(Console.log))\n * })\n *\n * Effect.runFork(program)\n * // Output:\n * // expensive task...\n * // result 1\n * // result 1\n * // expensive task...\n * // result 2\n *'
        }
      ],
      tags: [
        "Caching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 517,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L517"
    },
    {
      id: "effect.cached",
      name: "cached",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<Effect<A, E, R>, never, never>",
      description: "Returns an effect that lazily computes a result and caches it for subsequent\nevaluations.",
      documentation: 'Returns an effect that lazily computes a result and caches it for subsequent\nevaluations.\n\n**Details**\n\nThis function wraps an effect and ensures that its result is computed only\nonce. Once the result is computed, it is cached, meaning that subsequent\nevaluations of the same effect will return the cached result without\nre-executing the logic.\n\n**When to Use**\n\nUse this function when you have an expensive or time-consuming operation that\nyou want to avoid repeating. The first evaluation will compute the result,\nand all following evaluations will immediately return the cached value,\nimproving performance and reducing unnecessary work.\n\n**Example**\n\n```ts\nimport { Effect, Console } from "effect"\n\nlet i = 1\nconst expensiveTask = Effect.promise<string>(() => {\n  console.log("expensive task...")\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(`result ${i++}`)\n    }, 100)\n  })\n})\n\nconst program = Effect.gen(function* () {\n  console.log("non-cached version:")\n  yield* expensiveTask.pipe(Effect.andThen(Console.log))\n  yield* expensiveTask.pipe(Effect.andThen(Console.log))\n  console.log("cached version:")\n  const cached = yield* Effect.cached(expensiveTask)\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* cached.pipe(Effect.andThen(Console.log))\n})\n\nEffect.runFork(program)\n// Output:\n// non-cached version:\n// expensive task...\n// result 1\n// expensive task...\n// result 2\n// cached version:\n// expensive task...\n// result 3\n// result 3\n```',
      examples: [
        {
          code: 'import { Effect, Console } from "effect"\n\nlet i = 1\nconst expensiveTask = Effect.promise<string>(() => {\n  console.log("expensive task...")\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(`result ${i++}`)\n    }, 100)\n  })\n})\n\nconst program = Effect.gen(function* () {\n  console.log("non-cached version:")\n  yield* expensiveTask.pipe(Effect.andThen(Console.log))\n  yield* expensiveTask.pipe(Effect.andThen(Console.log))\n  console.log("cached version:")\n  const cached = yield* Effect.cached(expensiveTask)\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* cached.pipe(Effect.andThen(Console.log))\n})\n\nEffect.runFork(program)\n// Output:\n// non-cached version:\n// expensive task...\n// result 1\n// expensive task...\n// result 2\n// cached version:\n// expensive task...\n// result 3\n// result 3'
        }
      ],
      tags: [
        "Caching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 725,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L725"
    },
    {
      id: "effect.cachedFunction",
      name: "cachedFunction",
      module: "effect",
      package: "effect",
      signature: "<A, B, E, R>(f: (a: A) => Effect<B, E, R>, eq?: Equivalence<A>) => Effect<(a: A) => Effect<B, E, R>, never, never>",
      description: "Returns a memoized version of a function with effects, reusing results for\nthe same inputs.",
      documentation: 'Returns a memoized version of a function with effects, reusing results for\nthe same inputs.\n\n**Details**\n\nThis function creates a memoized version of a given function that performs an\neffect. Memoization ensures that once a result is computed for a specific\ninput, it is stored and reused for subsequent calls with the same input,\nreducing the need to recompute the result.\n\nThe function can optionally take an `Equivalence` parameter to\ndetermine how inputs are compared for caching purposes.\n\n**When to Use**\n\nUse this function when you have a function that performs an effect and you\nwant to avoid recomputing the result for the same input multiple times.\n\nIt\'s ideal for functions that produce deterministic results based on their\ninputs, and you want to improve performance by caching the output.\n\nThis is particularly useful in scenarios where the function involves\nexpensive calculations or operations that should be avoided after the first\nexecution with the same parameters.\n\n**Example**\n\n```ts\nimport { Effect, Random } from "effect"\n\nconst program = Effect.gen(function* () {\n  const randomNumber = (n: number) => Random.nextIntBetween(1, n)\n  console.log("non-memoized version:")\n  console.log(yield* randomNumber(10))\n  console.log(yield* randomNumber(10))\n\n  console.log("memoized version:")\n  const memoized = yield* Effect.cachedFunction(randomNumber)\n  console.log(yield* memoized(10))\n  console.log(yield* memoized(10))\n})\n\nEffect.runFork(program)\n// Example Output:\n// non-memoized version:\n// 2\n// 8\n// memoized version:\n// 5\n// 5\n```',
      examples: [
        {
          code: 'import { Effect, Random } from "effect"\n\nconst program = Effect.gen(function* () {\n  const randomNumber = (n: number) => Random.nextIntBetween(1, n)\n  console.log("non-memoized version:")\n  console.log(yield* randomNumber(10))\n  console.log(yield* randomNumber(10))\n\n  console.log("memoized version:")\n  const memoized = yield* Effect.cachedFunction(randomNumber)\n  console.log(yield* memoized(10))\n  console.log(yield* memoized(10))\n})\n\nEffect.runFork(program)\n// Example Output:\n// non-memoized version:\n// 2\n// 8\n// memoized version:\n// 5\n// 5'
        }
      ],
      tags: [
        "Caching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 782,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L782"
    },
    {
      id: "effect.once",
      name: "once",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<Effect<void, E, R>, never, never>",
      description: "Returns an effect that executes only once, regardless of how many times it's\ncalled.",
      documentation: 'Returns an effect that executes only once, regardless of how many times it\'s\ncalled.\n\n**Details**\n\nThis function ensures that a specific effect is executed only a single time,\nno matter how many times it is invoked. The result of the effect will be\ncached, and subsequent calls to the effect will immediately return the cached\nresult without re-executing the original logic.\n\n**When to Use**\n\nUse this function when you need to perform a task only once, regardless of\nhow many times the effect is triggered. It\'s particularly useful when you\nhave initialization tasks, logging, or other one-time actions that should not\nbe repeated. This can help optimize performance and avoid redundant actions.\n\n**Example**\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst program = Effect.gen(function* () {\n  const task1 = Console.log("task1")\n  yield* Effect.repeatN(task1, 2)\n  const task2 = yield* Effect.once(Console.log("task2"))\n  yield* Effect.repeatN(task2, 2)\n})\n\nEffect.runFork(program)\n// Output:\n// task1\n// task1\n// task1\n// task2\n```',
      examples: [
        {
          code: 'import { Effect, Console } from "effect"\n\nconst program = Effect.gen(function* () {\n  const task1 = Console.log("task1")\n  yield* Effect.repeatN(task1, 2)\n  const task2 = yield* Effect.once(Console.log("task2"))\n  yield* Effect.repeatN(task2, 2)\n})\n\nEffect.runFork(program)\n// Output:\n// task1\n// task1\n// task1\n// task2'
        }
      ],
      tags: [
        "Caching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 824,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L824"
    },
    {
      id: "effect.all",
      name: "all",
      module: "effect",
      package: "effect",
      signature: '<const Arg extends Iterable<Effect<any, any, any>> | Record<string, Effect<any, any, any>>, O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard?: boolean | undefined; readonly mode?: "default" | "validate" | "either" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, O>>(arg: Arg, options?: O) => All.Return<Arg, O>',
      description: "Combines multiple effects into one, returning results based on the input\nstructure.",
      documentation: "Combines multiple effects into one, returning results based on the input\nstructure.\n\n**Details**\n\nUse this function when you need to run multiple effects and combine their\nresults into a single output. It supports tuples, iterables, structs, and\nrecords, making it flexible for different input types.\n\nFor instance, if the input is a tuple:\n\n```ts skip-type-checking\n//         \u250C\u2500\u2500\u2500 a tuple of effects\n//         \u25BC\nEffect.all([effect1, effect2, ...])\n```\n\nthe effects are executed sequentially, and the result is a new effect\ncontaining the results as a tuple. The results in the tuple match the order\nof the effects passed to `Effect.all`.\n\n**Concurrency**\n\nYou can control the execution order (e.g., sequential vs. concurrent) using\nthe `concurrency` option.\n\n**Short-Circuiting Behavior**\n\nThis function stops execution on the first error it encounters, this is\ncalled \"short-circuiting\". If any effect in the collection fails, the\nremaining effects will not run, and the error will be propagated. To change\nthis behavior, you can use the `mode` option, which allows all effects to run\nand collect results as `Either` or `Option`.\n\n**The `mode` option**\n\nThe `{ mode: \"either\" }` option changes the behavior of `Effect.all` to\nensure all effects run, even if some fail. Instead of stopping on the first\nfailure, this mode collects both successes and failures, returning an array\nof `Either` instances where each result is either a `Right` (success) or a\n`Left` (failure).\n\nSimilarly, the `{ mode: \"validate\" }` option uses `Option` to indicate\nsuccess or failure. Each effect returns `None` for success and `Some` with\nthe error for failure.\n\n**Example** (Combining Effects in Tuples)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst tupleOfEffects = [\n  Effect.succeed(42).pipe(Effect.tap(Console.log)),\n  Effect.succeed(\"Hello\").pipe(Effect.tap(Console.log))\n] as const\n\n//      \u250C\u2500\u2500\u2500 Effect<[number, string], never, never>\n//      \u25BC\nconst resultsAsTuple = Effect.all(tupleOfEffects)\n\nEffect.runPromise(resultsAsTuple).then(console.log)\n// Output:\n// 42\n// Hello\n// [ 42, 'Hello' ]\n```\n\n**Example** (Combining Effects in Iterables)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst iterableOfEffects: Iterable<Effect.Effect<number>> = [1, 2, 3].map(\n  (n) => Effect.succeed(n).pipe(Effect.tap(Console.log))\n)\n\n//      \u250C\u2500\u2500\u2500 Effect<number[], never, never>\n//      \u25BC\nconst resultsAsArray = Effect.all(iterableOfEffects)\n\nEffect.runPromise(resultsAsArray).then(console.log)\n// Output:\n// 1\n// 2\n// 3\n// [ 1, 2, 3 ]\n```\n\n**Example** (Combining Effects in Structs)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst structOfEffects = {\n  a: Effect.succeed(42).pipe(Effect.tap(Console.log)),\n  b: Effect.succeed(\"Hello\").pipe(Effect.tap(Console.log))\n}\n\n//      \u250C\u2500\u2500\u2500 Effect<{ a: number; b: string; }, never, never>\n//      \u25BC\nconst resultsAsStruct = Effect.all(structOfEffects)\n\nEffect.runPromise(resultsAsStruct).then(console.log)\n// Output:\n// 42\n// Hello\n// { a: 42, b: 'Hello' }\n```\n\n**Example** (Combining Effects in Records)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst recordOfEffects: Record<string, Effect.Effect<number>> = {\n  key1: Effect.succeed(1).pipe(Effect.tap(Console.log)),\n  key2: Effect.succeed(2).pipe(Effect.tap(Console.log))\n}\n\n//      \u250C\u2500\u2500\u2500 Effect<{ [x: string]: number; }, never, never>\n//      \u25BC\nconst resultsAsRecord = Effect.all(recordOfEffects)\n\nEffect.runPromise(resultsAsRecord).then(console.log)\n// Output:\n// 1\n// 2\n// { key1: 1, key2: 2 }\n```\n\n**Example** (Short-Circuiting Behavior)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst program = Effect.all([\n  Effect.succeed(\"Task1\").pipe(Effect.tap(Console.log)),\n  Effect.fail(\"Task2: Oh no!\").pipe(Effect.tap(Console.log)),\n  // Won't execute due to earlier failure\n  Effect.succeed(\"Task3\").pipe(Effect.tap(Console.log))\n])\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// Task1\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Task2: Oh no!' }\n// }\n```\n\n**Example** (Collecting Results with `mode: \"either\"`)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst effects = [\n  Effect.succeed(\"Task1\").pipe(Effect.tap(Console.log)),\n  Effect.fail(\"Task2: Oh no!\").pipe(Effect.tap(Console.log)),\n  Effect.succeed(\"Task3\").pipe(Effect.tap(Console.log))\n]\n\nconst program = Effect.all(effects, { mode: \"either\" })\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// Task1\n// Task3\n// {\n//   _id: 'Exit',\n//   _tag: 'Success',\n//   value: [\n//     { _id: 'Either', _tag: 'Right', right: 'Task1' },\n//     { _id: 'Either', _tag: 'Left', left: 'Task2: Oh no!' },\n//     { _id: 'Either', _tag: 'Right', right: 'Task3' }\n//   ]\n// }\n```\n\n**Example** (Collecting Results with `mode: \"validate\"`)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst effects = [\n  Effect.succeed(\"Task1\").pipe(Effect.tap(Console.log)),\n  Effect.fail(\"Task2: Oh no!\").pipe(Effect.tap(Console.log)),\n  Effect.succeed(\"Task3\").pipe(Effect.tap(Console.log))\n]\n\nconst program = Effect.all(effects, { mode: \"validate\" })\n\nEffect.runPromiseExit(program).then((result) => console.log(\"%o\", result))\n// Output:\n// Task1\n// Task3\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Fail',\n//     failure: [\n//       { _id: 'Option', _tag: 'None' },\n//       { _id: 'Option', _tag: 'Some', value: 'Task2: Oh no!' },\n//       { _id: 'Option', _tag: 'None' }\n//     ]\n//   }\n// }\n```",
      examples: [
        {
          title: "Combining Effects in Tuples",
          code: `import { Effect, Console } from "effect"

const tupleOfEffects = [
  Effect.succeed(42).pipe(Effect.tap(Console.log)),
  Effect.succeed("Hello").pipe(Effect.tap(Console.log))
] as const

//      \u250C\u2500\u2500\u2500 Effect<[number, string], never, never>
//      \u25BC
const resultsAsTuple = Effect.all(tupleOfEffects)

Effect.runPromise(resultsAsTuple).then(console.log)
// Output:
// 42
// Hello
// [ 42, 'Hello' ]`
        },
        {
          title: "Combining Effects in Iterables",
          code: 'import { Effect, Console } from "effect"\n\nconst iterableOfEffects: Iterable<Effect.Effect<number>> = [1, 2, 3].map(\n  (n) => Effect.succeed(n).pipe(Effect.tap(Console.log))\n)\n\n//      \u250C\u2500\u2500\u2500 Effect<number[], never, never>\n//      \u25BC\nconst resultsAsArray = Effect.all(iterableOfEffects)\n\nEffect.runPromise(resultsAsArray).then(console.log)\n// Output:\n// 1\n// 2\n// 3\n// [ 1, 2, 3 ]'
        },
        {
          title: "Combining Effects in Structs",
          code: `import { Effect, Console } from "effect"

const structOfEffects = {
  a: Effect.succeed(42).pipe(Effect.tap(Console.log)),
  b: Effect.succeed("Hello").pipe(Effect.tap(Console.log))
}

//      \u250C\u2500\u2500\u2500 Effect<{ a: number; b: string; }, never, never>
//      \u25BC
const resultsAsStruct = Effect.all(structOfEffects)

Effect.runPromise(resultsAsStruct).then(console.log)
// Output:
// 42
// Hello
// { a: 42, b: 'Hello' }`
        },
        {
          title: "Combining Effects in Records",
          code: 'import { Effect, Console } from "effect"\n\nconst recordOfEffects: Record<string, Effect.Effect<number>> = {\n  key1: Effect.succeed(1).pipe(Effect.tap(Console.log)),\n  key2: Effect.succeed(2).pipe(Effect.tap(Console.log))\n}\n\n//      \u250C\u2500\u2500\u2500 Effect<{ [x: string]: number; }, never, never>\n//      \u25BC\nconst resultsAsRecord = Effect.all(recordOfEffects)\n\nEffect.runPromise(resultsAsRecord).then(console.log)\n// Output:\n// 1\n// 2\n// { key1: 1, key2: 2 }'
        },
        {
          title: "Short-Circuiting Behavior",
          code: `import { Effect, Console } from "effect"

const program = Effect.all([
  Effect.succeed("Task1").pipe(Effect.tap(Console.log)),
  Effect.fail("Task2: Oh no!").pipe(Effect.tap(Console.log)),
  // Won't execute due to earlier failure
  Effect.succeed("Task3").pipe(Effect.tap(Console.log))
])

Effect.runPromiseExit(program).then(console.log)
// Output:
// Task1
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Task2: Oh no!' }
// }`
        },
        {
          title: 'Collecting Results with `mode: "either"`',
          code: `import { Effect, Console } from "effect"

const effects = [
  Effect.succeed("Task1").pipe(Effect.tap(Console.log)),
  Effect.fail("Task2: Oh no!").pipe(Effect.tap(Console.log)),
  Effect.succeed("Task3").pipe(Effect.tap(Console.log))
]

const program = Effect.all(effects, { mode: "either" })

Effect.runPromiseExit(program).then(console.log)
// Output:
// Task1
// Task3
// {
//   _id: 'Exit',
//   _tag: 'Success',
//   value: [
//     { _id: 'Either', _tag: 'Right', right: 'Task1' },
//     { _id: 'Either', _tag: 'Left', left: 'Task2: Oh no!' },
//     { _id: 'Either', _tag: 'Right', right: 'Task3' }
//   ]
// }`
        },
        {
          title: 'Collecting Results with `mode: "validate"`',
          code: `import { Effect, Console } from "effect"

const effects = [
  Effect.succeed("Task1").pipe(Effect.tap(Console.log)),
  Effect.fail("Task2: Oh no!").pipe(Effect.tap(Console.log)),
  Effect.succeed("Task3").pipe(Effect.tap(Console.log))
]

const program = Effect.all(effects, { mode: "validate" })

Effect.runPromiseExit(program).then((result) => console.log("%o", result))
// Output:
// Task1
// Task3
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: [
//       { _id: 'Option', _tag: 'None' },
//       { _id: 'Option', _tag: 'Some', value: 'Task2: Oh no!' },
//       { _id: 'Option', _tag: 'None' }
//     ]
//   }
// }`
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 1044,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L1044"
    },
    {
      id: "effect.allWith",
      name: "allWith",
      module: "effect",
      package: "effect",
      signature: '<O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard?: boolean | undefined; readonly mode?: "default" | "validate" | "either" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, O>>(options?: O) => <const Arg extends Iterable<Effect<any, any, any>> | Record<string, Effect<any, any, any>>>(arg: Arg) => All.Return<Arg, O>',
      description: "/\n * A data-last version of {@link all}, designed for use in pipelines.\n *\n *",
      documentation: '/**\n * A data-last version of {@link all}, designed for use in pipelines.\n *\n * **When to Use**\n *\n * This function enables you to combine multiple effects and customize execution\n * options such as concurrency levels. This version is useful in functional\n * pipelines where you first define your data and then apply operations to it.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, pipe } from "effect"\n *\n * const task1 = Effect.succeed(1).pipe(\n *   Effect.delay("200 millis"),\n *   Effect.tap(Effect.log("task1 done"))\n * )\n *\n * const task2 = Effect.succeed("hello").pipe(\n *   Effect.delay("100 millis"),\n *   Effect.tap(Effect.log("task2 done"))\n * )\n *\n * const program = pipe(\n *   [task1, task2],\n *   // Run both effects concurrently using the concurrent option\n *   Effect.allWith({ concurrency: 2 })\n * )\n *\n * Effect.runPromise(program).then(console.log)\n * // Output:\n * // timestamp=... level=INFO fiber=#3 message="task2 done"\n * // timestamp=... level=INFO fiber=#2 message="task1 done"\n * // [ 1, \'hello\' ]\n * ```\n *\n *',
      examples: [
        {
          code: `* import { Effect, pipe } from "effect"
 *
 * const task1 = Effect.succeed(1).pipe(
 *   Effect.delay("200 millis"),
 *   Effect.tap(Effect.log("task1 done"))
 * )
 *
 * const task2 = Effect.succeed("hello").pipe(
 *   Effect.delay("100 millis"),
 *   Effect.tap(Effect.log("task2 done"))
 * )
 *
 * const program = pipe(
 *   [task1, task2],
 *   // Run both effects concurrently using the concurrent option
 *   Effect.allWith({ concurrency: 2 })
 * )
 *
 * Effect.runPromise(program).then(console.log)
 * // Output:
 * // timestamp=... level=INFO fiber=#3 message="task2 done"
 * // timestamp=... level=INFO fiber=#2 message="task1 done"
 * // [ 1, 'hello' ]
 *`
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 1091,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L1091"
    },
    {
      id: "effect.allSuccesses",
      name: "allSuccesses",
      module: "effect",
      package: "effect",
      signature: '<X extends Effect<any, any, any>>(elements: Iterable<X>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }) => Effect<Effect.Success<X>[], never, Effect.Context<X>>',
      description: "Evaluates and runs each effect in the iterable, collecting only the\nsuccessful results while discarding failures.",
      documentation: 'Evaluates and runs each effect in the iterable, collecting only the\nsuccessful results while discarding failures.\n\n**Details**\n\nThis function function processes an iterable of effects and runs each one. If\nan effect is successful, its result is collected; if it fails, the result is\ndiscarded. This ensures that only successful outcomes are kept.\n\n**Options**\n\nThe function also allows you to customize how the effects are handled by\nspecifying options such as concurrency, batching, and how finalizers behave.\nThese options provide flexibility in running the effects concurrently or\nadjusting other execution details.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst tasks = [\n  Effect.succeed(1),\n  Effect.fail("Error 1"),\n  Effect.succeed(2),\n  Effect.fail("Error 2")\n]\n\nconst program = Effect.gen(function*() {\n  const successfulResults = yield* Effect.allSuccesses(tasks)\n  console.log(successfulResults)\n})\n\nEffect.runFork(program)\n// Output: [1, 2]\n\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst tasks = [\n  Effect.succeed(1),\n  Effect.fail("Error 1"),\n  Effect.succeed(2),\n  Effect.fail("Error 2")\n]\n\nconst program = Effect.gen(function*() {\n  const successfulResults = yield* Effect.allSuccesses(tasks)\n  console.log(successfulResults)\n})\n\nEffect.runFork(program)\n// Output: [1, 2]'
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 1215,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L1215"
    },
    {
      id: "effect.dropUntil",
      name: "dropUntil",
      module: "effect",
      package: "effect",
      signature: "{ <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<A[], E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>): Effect<A[], E, R>; }",
      description: "Drops elements until the effectful predicate returns `true`.",
      documentation: 'Drops elements until the effectful predicate returns `true`.\n\n**Details**\n\nThis function processes a collection of elements and uses an effectful\npredicate to determine when to stop dropping elements. It drops elements from\nthe beginning of the collection until the predicate returns `true`.\n\nThe predicate is a function that takes an element and its index in the\ncollection and returns an effect that evaluates to a boolean.\n\nOnce the predicate returns `true`, the remaining elements of the collection\nare returned.\n\n**Note**: The first element for which the predicate returns `true` is also\ndropped.\n\n**When to Use**\n\nThis function allows you to conditionally skip over a part of the collection\nbased on some criteria defined in the predicate.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.dropUntil(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [5, 6]\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.dropUntil(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [5, 6]'
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 1266,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L1266"
    },
    {
      id: "effect.dropWhile",
      name: "dropWhile",
      module: "effect",
      package: "effect",
      signature: "{ <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<A[], E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>): Effect<A[], E, R>; }",
      description: "Drops elements as long as the predicate returns `true`.",
      documentation: 'Drops elements as long as the predicate returns `true`.\n\n**Details**\n\nThis function processes a collection of elements and uses a predicate to\ndecide whether to drop an element.\n\nThe predicate is a function that takes an element and its index, and it\nreturns an effect that evaluates to a boolean.\n\nAs long as the predicate returns `true`, elements will continue to be dropped\nfrom the collection.\n\nOnce the predicate returns `false`, the remaining elements are kept.\n\n**When to Use**\n\nThis function allows you to discard elements from the start of a collection\nbased on a condition, and only keep the rest when the condition no longer\nholds.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n <= 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.dropWhile(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [4, 5, 6]\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n <= 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.dropWhile(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [4, 5, 6]'
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 1407,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L1407"
    },
    {
      id: "effect.takeUntil",
      name: "takeUntil",
      module: "effect",
      package: "effect",
      signature: "{ <A, R, E>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<A[], E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): Effect<A[], E, R>; }",
      description: "Takes elements from a collection until the effectful predicate returns\n`true`.",
      documentation: 'Takes elements from a collection until the effectful predicate returns\n`true`.\n\n**Details**\n\nThis function processes a collection of elements and uses an effectful\npredicate to decide when to stop taking elements. The elements are taken from\nthe beginning of the collection until the predicate returns `true`.\n\nThe predicate is a function that takes an element and its index in the\ncollection, and returns an effect that resolves to a boolean.\n\nOnce the predicate returns `true`, the remaining elements of the collection\nare discarded, and the function stops taking more elements.\n\n**Note**: The first element for which the predicate returns `true` is also\nincluded in the result.\n\n**When to Use**\n\nUse this function when you want to conditionally take elements from a\ncollection based on a dynamic condition. For example, you may want to collect\nnumbers from a list until a certain threshold is reached, or gather items\nuntil a specific condition is met.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.takeUntil(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [ 1, 2, 3, 4 ]\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.takeUntil(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [ 1, 2, 3, 4 ]'
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 1550,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L1550"
    },
    {
      id: "effect.takeWhile",
      name: "takeWhile",
      module: "effect",
      package: "effect",
      signature: "{ <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<A[], E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): Effect<A[], E, R>; }",
      description: "Takes elements as long as the predicate returns `true`.",
      documentation: 'Takes elements as long as the predicate returns `true`.\n\n**Details**\n\nThis function processes a collection of elements and uses a predicate to\ndecide whether to take an element.\n\nThe predicate is a function that takes an element and its index, and it\nreturns an effect that evaluates to a boolean.\n\nAs long as the predicate returns `true`, elements will continue to be taken\nfrom the collection.\n\nOnce the predicate returns `false`, the remaining elements are discarded.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n <= 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.takeWhile(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [1, 2, 3]\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n <= 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.takeWhile(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [1, 2, 3]'
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 1690,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L1690"
    },
    {
      id: "effect.every",
      name: "every",
      module: "effect",
      package: "effect",
      signature: "{ <A, E, R>(predicate: (a: A, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<boolean, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>): Effect<boolean, E, R>; }",
      description: "Determines whether all elements of the iterable satisfy the effectful\npredicate.",
      documentation: 'Determines whether all elements of the iterable satisfy the effectful\npredicate.\n\n**Details**\n\nThis function checks whether every element in a given collection (an\niterable) satisfies a condition defined by an effectful predicate.\n\nThe predicate is a function that takes an element and its index, and it\nreturns an effect that evaluates to a boolean.\n\nThe function will process each element and return `true` if all elements\nsatisfy the predicate; otherwise, it returns `false`.\n\n**When to Use**\n\nThis function is useful when you need to verify that all items in a\ncollection meet certain criteria, even when the evaluation of each item\ninvolves effects, such as asynchronous checks or complex computations.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst numbers = [2, 4, 6, 8]\nconst predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)\n\nconst program = Effect.gen(function*() {\n  const allEven = yield* Effect.every(numbers, predicate)\n  console.log(allEven)\n})\n\nEffect.runFork(program)\n// Output: true\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst numbers = [2, 4, 6, 8]\nconst predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)\n\nconst program = Effect.gen(function*() {\n  const allEven = yield* Effect.every(numbers, predicate)\n  console.log(allEven)\n})\n\nEffect.runFork(program)\n// Output: true'
        }
      ],
      tags: [
        "Condition Checking"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 1814,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L1814"
    },
    {
      id: "effect.exists",
      name: "exists",
      module: "effect",
      package: "effect",
      signature: '{ <A, E, R>(predicate: (a: A, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): (elements: Iterable<A>) => Effect<boolean, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): Effect<boolean, E, R>; }',
      description: "Determines whether any element of the iterable satisfies the effectual\npredicate.",
      documentation: 'Determines whether any element of the iterable satisfies the effectual\npredicate.\n\n**Details**\n\nThis function checks whether any element in a given collection (an iterable)\nsatisfies a condition defined by an effectful predicate.\n\nThe predicate is a function that takes an element and its index, and it\nreturns an effect that evaluates to a boolean.\n\nThe function will process each element, and if any element satisfies the\npredicate (returns `true`), the function will immediately return `true`.\n\nIf none of the elements satisfy the condition, it will return `false`.\n\n**When to Use**\n\nThis function allows you to quickly check for a condition in a collection\nwithout having to manually iterate over it.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst numbers = [1, 2, 3, 4]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 2)\n\nconst program = Effect.gen(function*() {\n  const hasLargeNumber = yield* Effect.exists(numbers, predicate)\n  console.log(hasLargeNumber)\n})\n\nEffect.runFork(program)\n// Output: true\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst numbers = [1, 2, 3, 4]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 2)\n\nconst program = Effect.gen(function*() {\n  const hasLargeNumber = yield* Effect.exists(numbers, predicate)\n  console.log(hasLargeNumber)\n})\n\nEffect.runFork(program)\n// Output: true'
        }
      ],
      tags: [
        "Condition Checking"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 1951,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L1951"
    },
    {
      id: "effect.filter",
      name: "filter",
      module: "effect",
      package: "effect",
      signature: '{ <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly negate?: boolean; readonly concurrentFinalizers?: boolean; }): (elements: Iterable<A>) => Effect<A[], E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly negate?: boolean; readonly concurrentFinalizers?: boolean; }): Effect<A[], E, R>; }',
      description: "Filters an iterable using the specified effectful predicate.",
      documentation: 'Filters an iterable using the specified effectful predicate.\n\n**Details**\n\nThis function filters a collection (an iterable) by applying an effectful\npredicate.\n\nThe predicate is a function that takes an element and its index, and it\nreturns an effect that evaluates to a boolean.\n\nThe function processes each element in the collection and keeps only those\nthat satisfy the condition defined by the predicate.\n\n**Options**\n\nYou can also adjust the behavior with options such as concurrency, batching,\nor whether to negate the condition.\n\n**When to Use**\n\nThis function allows you to selectively keep or remove elements based on a\ncondition that may involve asynchronous or side-effect-causing operations.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst numbers = [1, 2, 3, 4, 5]\nconst predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.filter(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [2, 4]\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst numbers = [1, 2, 3, 4, 5]\nconst predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.filter(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [2, 4]'
        }
      ],
      tags: [
        "Filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 2097,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L2097"
    },
    {
      id: "effect.filterMap",
      name: "filterMap",
      module: "effect",
      package: "effect",
      signature: "{ <Eff extends Effect<any, any, any>, B>(pf: (a: Effect.Success<Eff>) => Option<B>): (elements: Iterable<Eff>) => Effect<B[], Effect.Error<Eff>, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>, B>(elements: Iterable<Eff>, pf: (a: Effect.Success<Eff>) => Option<B>): Effect<B[], Effect.Error<Eff>, Effect.Context<Eff>>; }",
      description: "Filters and maps elements sequentially in one operation. This function processes each element one by one. It applies a function that\nreturns an `Option` to each element. If the function returns `Some`, the\nelement is kept; if it returns `None`, the element is removed. The operation\nis done sequentially for each element.",
      documentation: 'Filters and maps elements sequentially in one operation.\n\nThis function processes each element one by one. It applies a function that\nreturns an `Option` to each element. If the function returns `Some`, the\nelement is kept; if it returns `None`, the element is removed. The operation\nis done sequentially for each element.\n\n**Example**\n\n```ts\nimport { Console, Effect, Option } from "effect"\n\nconst task = (n: number) =>\n  Effect.succeed(n).pipe(\n    Effect.delay(1000 - (n * 100)),\n    Effect.tap(Console.log(`task${n} done`))\n  )\n\nconst program = Effect.filterMap(\n  [task(1), task(2), task(3), task(4)],\n  (n) => n % 2 === 0 ? Option.some(n) : Option.none()\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// task1 done\n// task2 done\n// task3 done\n// task4 done\n// [ 2, 4 ]\n```',
      examples: [
        {
          code: 'import { Console, Effect, Option } from "effect"\n\nconst task = (n: number) =>\n  Effect.succeed(n).pipe(\n    Effect.delay(1000 - (n * 100)),\n    Effect.tap(Console.log(`task${n} done`))\n  )\n\nconst program = Effect.filterMap(\n  [task(1), task(2), task(3), task(4)],\n  (n) => n % 2 === 0 ? Option.some(n) : Option.none()\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// task1 done\n// task2 done\n// task3 done\n// task4 done\n// [ 2, 4 ]'
        }
      ],
      tags: [
        "Filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 2235,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L2235"
    },
    {
      id: "effect.findFirst",
      name: "findFirst",
      module: "effect",
      package: "effect",
      signature: "{ <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Option<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): Effect<Option<A>, E, R>; }",
      description: "Returns the first element that satisfies the effectful predicate.",
      documentation: "Returns the first element that satisfies the effectful predicate.\n\n**Details**\n\nThis function processes a collection of elements and applies an effectful\npredicate to each element.\n\nThe predicate is a function that takes an element and its index in the\ncollection, and it returns an effect that evaluates to a boolean.\n\nThe function stops as soon as it finds the first element for which the\npredicate returns `true` and returns that element wrapped in an `Option`.\n\nIf no element satisfies the predicate, the result will be `None`.\n\n**When to Use**\n\nThis function allows you to efficiently find an element that meets a specific\ncondition, even when the evaluation involves effects like asynchronous\noperations or side effects.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.findFirst(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: { _id: 'Option', _tag: 'Some', value: 4 }\n```",
      examples: [
        {
          code: `import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5]
const predicate = (n: number, i: number) => Effect.succeed(n > 3)

const program = Effect.gen(function*() {
  const result = yield* Effect.findFirst(numbers, predicate)
  console.log(result)
})

Effect.runFork(program)
// Output: { _id: 'Option', _tag: 'Some', value: 4 }`
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 2353,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L2353"
    },
    {
      id: "effect.forEach",
      name: "forEach",
      module: "effect",
      package: "effect",
      signature: '{ <B, E, R, S extends Iterable<any>>(f: (a: ReadonlyArray.Infer<S>, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly discard?: false; readonly concurrentFinalizers?: boolean; }): (self: S) => Effect<ReadonlyArray.With<S, B>, E, R>; <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly discard: true; readonly concurrentFinalizers?: boolean; }): (self: Iterable<A>) => Effect<void, E, R>; <B, E, R, S extends Iterable<any>>(self: S, f: (a: ReadonlyArray.Infer<S>, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly discard?: false; readonly concurrentFinalizers?: boolean; }): Effect<ReadonlyArray.With<S, B>, E, R>; <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly discard: true; readonly concurrentFinalizers?: boolean; }): Effect<void, E, R>; }',
      description: "Executes an effectful operation for each element in an `Iterable`.",
      documentation: 'Executes an effectful operation for each element in an `Iterable`.\n\n**Details**\n\nThis function applies a provided operation to each element in the iterable,\nproducing a new effect that returns an array of results.\n\nIf any effect fails, the iteration stops immediately (short-circuiting), and\nthe error is propagated.\n\n**Concurrency**\n\nThe `concurrency` option controls how many operations are performed\nconcurrently. By default, the operations are performed sequentially.\n\n**Discarding Results**\n\nIf the `discard` option is set to `true`, the intermediate results are not\ncollected, and the final result of the operation is `void`.\n\n**Example** (Applying Effects to Iterable Elements)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst result = Effect.forEach([1, 2, 3, 4, 5], (n, index) =>\n  Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2))\n)\n\nEffect.runPromise(result).then(console.log)\n// Output:\n// Currently at index 0\n// Currently at index 1\n// Currently at index 2\n// Currently at index 3\n// Currently at index 4\n// [ 2, 4, 6, 8, 10 ]\n```\n\n**Example** (Discarding Results)\n\n```ts\nimport { Effect, Console } from "effect"\n\n// Apply effects but discard the results\nconst result = Effect.forEach(\n  [1, 2, 3, 4, 5],\n  (n, index) =>\n    Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2)),\n  { discard: true }\n)\n\nEffect.runPromise(result).then(console.log)\n// Output:\n// Currently at index 0\n// Currently at index 1\n// Currently at index 2\n// Currently at index 3\n// Currently at index 4\n// undefined\n```',
      examples: [
        {
          title: "Applying Effects to Iterable Elements",
          code: 'import { Effect, Console } from "effect"\n\nconst result = Effect.forEach([1, 2, 3, 4, 5], (n, index) =>\n  Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2))\n)\n\nEffect.runPromise(result).then(console.log)\n// Output:\n// Currently at index 0\n// Currently at index 1\n// Currently at index 2\n// Currently at index 3\n// Currently at index 4\n// [ 2, 4, 6, 8, 10 ]'
        },
        {
          title: "Discarding Results",
          code: 'import { Effect, Console } from "effect"\n\n// Apply effects but discard the results\nconst result = Effect.forEach(\n  [1, 2, 3, 4, 5],\n  (n, index) =>\n    Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2)),\n  { discard: true }\n)\n\nEffect.runPromise(result).then(console.log)\n// Output:\n// Currently at index 0\n// Currently at index 1\n// Currently at index 2\n// Currently at index 3\n// Currently at index 4\n// undefined'
        }
      ],
      tags: [
        "Looping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 2509,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L2509"
    },
    {
      id: "effect.head",
      name: "head",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<Iterable<A>, E, R>) => Effect<A, E | NoSuchElementException, R>",
      description: "Returns the first element of the iterable if the collection is non-empty, or\nfails with the error `NoSuchElementException` if the collection is empty.",
      documentation: 'Returns the first element of the iterable if the collection is non-empty, or\nfails with the error `NoSuchElementException` if the collection is empty.\n\n**When to Use**\n\nThis function is useful when you need to retrieve the first item from a\ncollection and want to handle the case where the collection might be empty\nwithout causing an unhandled exception.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\n// Simulate an async operation\nconst fetchNumbers = Effect.succeed([1, 2, 3]).pipe(Effect.delay("100 millis"))\n\nconst program = Effect.gen(function*() {\n  const firstElement = yield* Effect.head(fetchNumbers)\n  console.log(firstElement)\n})\n\nEffect.runFork(program)\n// Output: 1\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\n// Simulate an async operation\nconst fetchNumbers = Effect.succeed([1, 2, 3]).pipe(Effect.delay("100 millis"))\n\nconst program = Effect.gen(function*() {\n  const firstElement = yield* Effect.head(fetchNumbers)\n  console.log(firstElement)\n})\n\nEffect.runFork(program)\n// Output: 1'
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 2837,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L2837"
    },
    {
      id: "effect.mergeAll",
      name: "mergeAll",
      module: "effect",
      package: "effect",
      signature: '{ <Z, Eff extends Effect<any, any, any>>(zero: Z, f: (z: Z, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): (elements: Iterable<Eff>) => Effect<Z, Effect.Error<Eff>, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>, Z>(elements: Iterable<Eff>, zero: Z, f: (z: Z, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): Effect<Z, Effect.Error<Eff>, Effect.Context<Eff>>; }',
      description: "Merges an `Iterable<Effect<A, E, R>>` to a single effect.",
      documentation: 'Merges an `Iterable<Effect<A, E, R>>` to a single effect.\n\n**Details**\n\nThis function takes an iterable of effects and combines them into a single\neffect. It does this by iterating over each effect in the collection and\napplying a function that accumulates results into a "zero" value, which\nstarts with an initial value and is updated with each effect\'s success.\n\nThe provided function `f` is called for each element in the iterable,\nallowing you to specify how to combine the results.\n\n**Options**\n\nThe function also allows you to customize how the effects are handled by\nspecifying options such as concurrency, batching, and how finalizers behave.\nThese options provide flexibility in running the effects concurrently or\nadjusting other execution details.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst numbers = [Effect.succeed(1), Effect.succeed(2), Effect.succeed(3)]\nconst add = (sum: number, value: number, i: number) => sum + value\nconst zero = 0\n\nconst program = Effect.gen(function*() {\n  const total = yield* Effect.mergeAll(numbers, zero, add)\n  console.log(total)\n})\n\nEffect.runFork(program)\n// Output: 6\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst numbers = [Effect.succeed(1), Effect.succeed(2), Effect.succeed(3)]\nconst add = (sum: number, value: number, i: number) => sum + value\nconst zero = 0\n\nconst program = Effect.gen(function*() {\n  const total = yield* Effect.mergeAll(numbers, zero, add)\n  console.log(total)\n})\n\nEffect.runFork(program)\n// Output: 6'
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 2879,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L2879"
    },
    {
      id: "effect.partition",
      name: "partition",
      module: "effect",
      package: "effect",
      signature: '{ <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): (elements: Iterable<A>) => Effect<[excluded: E[], satisfying: B[]], never, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): Effect<[excluded: E[], satisfying: B[]], never, R>; }',
      description: "Processes an iterable and applies an effectful function to each element,\ncategorizing the results into successes and failures.",
      documentation: "Processes an iterable and applies an effectful function to each element,\ncategorizing the results into successes and failures.\n\n**Details**\n\nThis function processes each element in the provided iterable by applying an\neffectful function to it. The results are then categorized into two separate\nlists: one for failures and another for successes. This separation allows you\nto handle the two categories differently. Failures are collected in a list\nwithout interrupting the processing of the remaining elements, so the\noperation continues even if some elements fail. This is particularly useful\nwhen you need to handle both successful and failed results separately,\nwithout stopping the entire process on encountering a failure.\n\n**When to Use**\n\nUse this function when you want to process a collection of items and handle\nerrors or failures without interrupting the processing of other items. It's\nuseful when you need to distinguish between successful and failed results and\nprocess them separately, for example, when logging errors while continuing to\nwork with valid data. The function ensures that failures are captured, while\nsuccesses are processed normally.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\n//      \u250C\u2500\u2500\u2500 Effect<[string[], number[]], never, never>\n//      \u25BC\nconst program = Effect.partition([0, 1, 2, 3, 4], (n) => {\n  if (n % 2 === 0) {\n    return Effect.succeed(n)\n  } else {\n    return Effect.fail(`${n} is not even`)\n  }\n})\n\nEffect.runPromise(program).then(console.log, console.error)\n// Output:\n// [ [ '1 is not even', '3 is not even' ], [ 0, 2, 4 ] ]\n```",
      examples: [
        {
          code: "import { Effect } from \"effect\"\n\n//      \u250C\u2500\u2500\u2500 Effect<[string[], number[]], never, never>\n//      \u25BC\nconst program = Effect.partition([0, 1, 2, 3, 4], (n) => {\n  if (n % 2 === 0) {\n    return Effect.succeed(n)\n  } else {\n    return Effect.fail(`${n} is not even`)\n  }\n})\n\nEffect.runPromise(program).then(console.log, console.error)\n// Output:\n// [ [ '1 is not even', '3 is not even' ], [ 0, 2, 4 ] ]"
        }
      ],
      tags: [
        "Error Accumulation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 3023,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L3023"
    },
    {
      id: "effect.reduce",
      name: "reduce",
      module: "effect",
      package: "effect",
      signature: "{ <Z, A, E, R>(zero: Z, f: (z: Z, a: A, i: number) => Effect<Z, E, R>): (elements: Iterable<A>) => Effect<Z, E, R>; <A, Z, E, R>(elements: Iterable<A>, zero: Z, f: (z: Z, a: A, i: number) => Effect<Z, E, R>): Effect<Z, E, R>; }",
      description: "Reduces an `Iterable<A>` using an effectual function `f`, working\nsequentially from left to right.",
      documentation: 'Reduces an `Iterable<A>` using an effectual function `f`, working\nsequentially from left to right.\n\n**Details**\n\nThis function takes an iterable and applies a function `f` to each element in\nthe iterable. The function works sequentially, starting with an initial value\n`zero` and then combining it with each element in the collection. The\nprovided function `f` is called for each element in the iterable, allowing\nyou to accumulate a result based on the current value and the element being\nprocessed.\n\n**When to Use**\n\nThe function is often used for operations like summing a collection of\nnumbers or combining results from multiple tasks. It ensures that operations\nare performed one after the other, maintaining the order of the elements.\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduce(\n  [1, 2, 3, 4],\n  0,\n  (acc, id, i) =>\n    processOrder(id)\n      .pipe(Effect.map((order) => acc + order.price))\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Order 1 processed\n// Order 2 processed\n// Order 3 processed\n// Order 4 processed\n// 1000\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduce(\n  [1, 2, 3, 4],\n  0,\n  (acc, id, i) =>\n    processOrder(id)\n      .pipe(Effect.map((order) => acc + order.price))\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Order 1 processed\n// Order 2 processed\n// Order 3 processed\n// Order 4 processed\n// 1000'
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 3186,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L3186"
    },
    {
      id: "effect.reduceWhile",
      name: "reduceWhile",
      module: "effect",
      package: "effect",
      signature: "{ <Z, A, E, R>(zero: Z, options: { readonly while: Predicate<Z>; readonly body: (s: Z, a: A, i: number) => Effect<Z, E, R>; }): (elements: Iterable<A>) => Effect<Z, E, R>; <A, Z, E, R>(elements: Iterable<A>, zero: Z, options: { readonly while: Predicate<Z>; readonly body: (s: Z, a: A, i: number) => Effect<Z, E, R>; }): Effect<Z, E, R>; }",
      description: "Reduces an `Iterable<A>` using an effectual function `body`, working\nsequentially from left to right, stopping the process early when the\npredicate `while` is not satisfied.",
      documentation: 'Reduces an `Iterable<A>` using an effectual function `body`, working\nsequentially from left to right, stopping the process early when the\npredicate `while` is not satisfied.\n\n**Details**\n\nThis function processes a collection of elements, applying a function `body`\nto reduce them to a single value, starting from the first element. It checks\nthe value of the accumulator against a predicate (`while`). If at any point\nthe predicate returns `false`, the reduction stops, and the accumulated\nresult is returned.\n\n**When to Use**\n\nUse this function when you need to reduce a collection of elements, but only\ncontinue the process as long as a certain condition holds true. For example,\nif you want to sum values in a list but stop as soon as the sum exceeds a\ncertain threshold, you can use this function.\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduceWhile(\n  [1, 2, 3, 4],\n  0,\n  {\n    body: (acc, id, i) =>\n      processOrder(id)\n        .pipe(Effect.map((order) => acc + order.price)),\n    while: (acc) => acc < 500\n  }\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Order 1 processed\n// Order 2 processed\n// Order 3 processed\n// 600\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduceWhile(\n  [1, 2, 3, 4],\n  0,\n  {\n    body: (acc, id, i) =>\n      processOrder(id)\n        .pipe(Effect.map((order) => acc + order.price)),\n    while: (acc) => acc < 500\n  }\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Order 1 processed\n// Order 2 processed\n// Order 3 processed\n// 600'
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 3343,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L3343"
    },
    {
      id: "effect.reduceRight",
      name: "reduceRight",
      module: "effect",
      package: "effect",
      signature: "{ <A, Z, R, E>(zero: Z, f: (a: A, z: Z, i: number) => Effect<Z, E, R>): (elements: Iterable<A>) => Effect<Z, E, R>; <A, Z, R, E>(elements: Iterable<A>, zero: Z, f: (a: A, z: Z, i: number) => Effect<Z, E, R>): Effect<Z, E, R>; }",
      description: "Reduces an `Iterable<A>` using an effectual function `f`, working\nsequentially from right to left.",
      documentation: 'Reduces an `Iterable<A>` using an effectual function `f`, working\nsequentially from right to left.\n\n**Details**\n\nThis function takes an iterable and applies a function `f` to each element in\nthe iterable. The function works sequentially, starting with an initial value\n`zero` and then combining it with each element in the collection. The\nprovided function `f` is called for each element in the iterable, allowing\nyou to accumulate a result based on the current value and the element being\nprocessed.\n\n**When to Use**\n\nThe function is often used for operations like summing a collection of\nnumbers or combining results from multiple tasks. It ensures that operations\nare performed one after the other, maintaining the order of the elements.\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduceRight(\n  [1, 2, 3, 4],\n  0,\n  (id, acc, i) =>\n    processOrder(id)\n      .pipe(Effect.map((order) => acc + order.price))\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Order 4 processed\n// Order 3 processed\n// Order 2 processed\n// Order 1 processed\n// 1000\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduceRight(\n  [1, 2, 3, 4],\n  0,\n  (id, acc, i) =>\n    processOrder(id)\n      .pipe(Effect.map((order) => acc + order.price))\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Order 4 processed\n// Order 3 processed\n// Order 2 processed\n// Order 1 processed\n// 1000'
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 3505,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L3505"
    },
    {
      id: "effect.reduceEffect",
      name: "reduceEffect",
      module: "effect",
      package: "effect",
      signature: '{ <Z, E, R, Eff extends Effect<any, any, any>>(zero: Effect<Z, E, R>, f: (z: NoInfer<Z>, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): (elements: Iterable<Eff>) => Effect<Z, E | Effect.Error<Eff>, R | Effect.Context<Eff>>; <Eff extends Effect<any, any, any>, Z, E, R>(elements: Iterable<Eff>, zero: Effect<Z, E, R>, f: (z: NoInfer<Z>, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): Effect<Z, E | Effect.Error<Eff>, R | Effect.Context<Eff>>; }',
      description: "Reduces an `Iterable<Effect<A, E, R>>` to a single effect.",
      documentation: 'Reduces an `Iterable<Effect<A, E, R>>` to a single effect.\n\n**Details**\n\nThis function processes a collection of effects and combines them into one\nsingle effect. It starts with an initial effect (`zero`) and applies a\nfunction `f` to each element in the collection.\n\n**Options**\n\nThe function also allows you to customize how the effects are handled by\nspecifying options such as concurrency, batching, and how finalizers behave.\nThese options provide flexibility in running the effects concurrently or\nadjusting other execution details.\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduceEffect(\n  [processOrder(1), processOrder(2), processOrder(3), processOrder(4)],\n  Effect.succeed(0),\n  (acc, order, i) => acc + order.price\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Order 1 processed\n// Order 2 processed\n// Order 3 processed\n// Order 4 processed\n// 1000\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduceEffect(\n  [processOrder(1), processOrder(2), processOrder(3), processOrder(4)],\n  Effect.succeed(0),\n  (acc, order, i) => acc + order.price\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Order 1 processed\n// Order 2 processed\n// Order 3 processed\n// Order 4 processed\n// 1000'
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 3652,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L3652"
    },
    {
      id: "effect.replicate",
      name: "replicate",
      module: "effect",
      package: "effect",
      signature: "{ (n: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>[]; <A, E, R>(self: Effect<A, E, R>, n: number): Effect<A, E, R>[]; }",
      description: "Replicates the given effect `n` times.",
      documentation: 'Replicates the given effect `n` times.\n\n**Details**\n\nThis function takes an effect and replicates it a specified number of times\n(`n`). The result is an array of `n` effects, each of which is identical to\nthe original effect.\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\nconst task = Effect.succeed("Hello, World!").pipe(\n  Effect.tap(Console.log)\n)\n\nconst program = Effect.gen(function*() {\n  // Replicate the task 3 times\n  const tasks = Effect.replicate(task, 3)\n  for (const t of tasks) {\n    // Run each task\n    yield* t\n  }\n})\n\nEffect.runFork(program)\n// Output:\n// Hello, World!\n// Hello, World!\n// Hello, World!\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\nconst task = Effect.succeed("Hello, World!").pipe(\n  Effect.tap(Console.log)\n)\n\nconst program = Effect.gen(function*() {\n  // Replicate the task 3 times\n  const tasks = Effect.replicate(task, 3)\n  for (const t of tasks) {\n    // Run each task\n    yield* t\n  }\n})\n\nEffect.runFork(program)\n// Output:\n// Hello, World!\n// Hello, World!\n// Hello, World!'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 3786,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L3786"
    },
    {
      id: "effect.replicateEffect",
      name: "replicateEffect",
      module: "effect",
      package: "effect",
      signature: '{ (n: number, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly discard?: false; readonly concurrentFinalizers?: boolean; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A[], E, R>; (n: number, options: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly discard: true; readonly concurrentFinalizers?: boolean; }): <A, E, R>(self: Effect<A, E, R>) => Effect<void, E, R>; <A, E, R>(self: Effect<A, E, R>, n: number, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly discard?: false; readonly concurrentFinalizers?: boolean; }): Effect<A[], E, R>; <A, E, R>(self: Effect<A, E, R>, n: number, options: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly discard: true; readonly concurrentFinalizers?: boolean; }): Effect<void, E, R>; }',
      description: "Performs this effect the specified number of times and collects the results.",
      documentation: 'Performs this effect the specified number of times and collects the results.\n\n**Details**\n\nThis function repeats an effect multiple times and collects the results into\nan array. You specify how many times to execute the effect, and it runs that\nmany times, either in sequence or concurrently depending on the provided\noptions.\n\n**Options**\n\nIf the `discard` option is set to `true`, the intermediate results are not\ncollected, and the final result of the operation is `void`.\n\nThe function also allows you to customize how the effects are handled by\nspecifying options such as concurrency, batching, and how finalizers behave.\nThese options provide flexibility in running the effects concurrently or\nadjusting other execution details.\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\nlet counter = 0\n\nconst task = Effect.sync(() => ++counter).pipe(\n  Effect.tap(() => Console.log(`Task completed`))\n)\n\nconst program = Effect.gen(function*() {\n  // Replicate the task 3 times and collect the results\n  const results = yield* Effect.replicateEffect(task, 3)\n  yield* Console.log(`Results: ${results.join(", ")}`)\n})\n\nEffect.runFork(program)\n// Output:\n// Task completed\n// Task completed\n// Task completed\n// Results: 1, 2, 3\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\nlet counter = 0\n\nconst task = Effect.sync(() => ++counter).pipe(\n  Effect.tap(() => Console.log(`Task completed`))\n)\n\nconst program = Effect.gen(function*() {\n  // Replicate the task 3 times and collect the results\n  const results = yield* Effect.replicateEffect(task, 3)\n  yield* Console.log(`Results: ${results.join(", ")}`)\n})\n\nEffect.runFork(program)\n// Output:\n// Task completed\n// Task completed\n// Task completed\n// Results: 1, 2, 3'
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 3910,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L3910"
    },
    {
      id: "effect.validateAll",
      name: "validateAll",
      module: "effect",
      package: "effect",
      signature: '{ <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly discard?: false; readonly concurrentFinalizers?: boolean; }): (elements: Iterable<A>) => Effect<B[], [E, ...E[]], R>; <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly discard: true; readonly concurrentFinalizers?: boolean; }): (elements: Iterable<A>) => Effect<void, [E, ...E[]], R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly discard?: false; readonly concurrentFinalizers?: boolean; }): Effect<B[], [E, ...E[]], R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly discard: true; readonly concurrentFinalizers?: boolean; }): Effect<void, [E, ...E[]], R>; }',
      description: "/\n * Applies an effectful operation to each element in a collection while\n * collecting both successes and failures.\n *\n *",
      documentation: "/**\n * Applies an effectful operation to each element in a collection while\n * collecting both successes and failures.\n *\n * **Details**\n *\n * This function allows you to apply an effectful operation to every item in a\n * collection.\n *\n * Unlike {@link forEach}, which would stop at the first error, this function\n * continues processing all elements, accumulating both successes and failures.\n *\n * **When to Use**\n *\n * Use this function when you want to process every item in a collection, even\n * if some items fail. This is particularly useful when you need to perform\n * operations on all elements without halting due to an error.\n *\n * Keep in mind that if there are any failures, **all successes will be lost**,\n * so this function is not suitable when you need to keep the successful results\n * in case of errors.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * //      \u250C\u2500\u2500\u2500 Effect<number[], [string, ...string[]], never>\n * //      \u25BC\n * const program = Effect.validateAll([1, 2, 3, 4, 5], (n) => {\n *   if (n < 4) {\n *     return Console.log(`item ${n}`).pipe(Effect.as(n))\n *   } else {\n *     return Effect.fail(`${n} is not less that 4`)\n *   }\n * })\n *\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // item 1\n * // item 2\n * // item 3\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: {\n * //     _id: 'Cause',\n * //     _tag: 'Fail',\n * //     failure: [ '4 is not less that 4', '5 is not less that 4' ]\n * //   }\n * // }\n * ```\n *\n *",
      examples: [
        {
          code: "* import { Effect, Console } from \"effect\"\n *\n * //      \u250C\u2500\u2500\u2500 Effect<number[], [string, ...string[]], never>\n * //      \u25BC\n * const program = Effect.validateAll([1, 2, 3, 4, 5], (n) => {\n *   if (n < 4) {\n *     return Console.log(`item ${n}`).pipe(Effect.as(n))\n *   } else {\n *     return Effect.fail(`${n} is not less that 4`)\n *   }\n * })\n *\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // item 1\n * // item 2\n * // item 3\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: {\n * //     _id: 'Cause',\n * //     _tag: 'Fail',\n * //     failure: [ '4 is not less that 4', '5 is not less that 4' ]\n * //   }\n * // }\n *"
        }
      ],
      tags: [
        "Error Accumulation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4188,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4188"
    },
    {
      id: "effect.validateFirst",
      name: "validateFirst",
      module: "effect",
      package: "effect",
      signature: '{ <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): (elements: Iterable<A>) => Effect<B, E[], R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): Effect<B, E[], R>; }',
      description: "/\n * This function is similar to {@link validateAll}but with a key difference: it\n * returns the first successful result or all errors if none of the operations\n * succeed.\n *\n *",
      documentation: '/**\n * This function is similar to {@link validateAll}but with a key difference: it\n * returns the first successful result or all errors if none of the operations\n * succeed.\n *\n * **Details**\n *\n * This function processes a collection of elements and applies an effectful\n * operation to each. Unlike {@link validateAll}, which accumulates both\n * successes and failures, `Effect.validateFirst` stops and returns the first\n * success it encounters. If no success occurs, it returns all accumulated\n * errors. This can be useful when you are interested in the first successful\n * result and want to avoid processing further once a valid result is found.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Console } from "effect"\n *\n * //      \u250C\u2500\u2500\u2500 Effect<number, string[], never>\n * //      \u25BC\n * const program = Effect.validateFirst([1, 2, 3, 4, 5], (n) => {\n *   if (n < 4) {\n *     return Effect.fail(`${n} is not less that 4`)\n *   } else {\n *     return Console.log(`item ${n}`).pipe(Effect.as(n))\n *   }\n * })\n *\n * Effect.runPromise(program).then(console.log, console.error)\n * // Output:\n * // item 4\n * // 4\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect, Console } from "effect"\n *\n * //      \u250C\u2500\u2500\u2500 Effect<number, string[], never>\n * //      \u25BC\n * const program = Effect.validateFirst([1, 2, 3, 4, 5], (n) => {\n *   if (n < 4) {\n *     return Effect.fail(`${n} is not less that 4`)\n *   } else {\n *     return Console.log(`item ${n}`).pipe(Effect.as(n))\n *   }\n * })\n *\n * Effect.runPromise(program).then(console.log, console.error)\n * // Output:\n * // item 4\n * // 4\n *'
        }
      ],
      tags: [
        "Error Accumulation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4496,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4496"
    },
    {
      id: "effect.async",
      name: "async",
      module: "effect",
      package: "effect",
      signature: "<A, E = never, R = never>(resume: (callback: (_: Effect<A, E, R>) => void, signal: AbortSignal) => void | Effect<void, never, R>, blockingOn?: FiberId) => Effect<A, E, R>",
      description: "Creates an `Effect` from a callback-based asynchronous function.",
      documentation: 'Creates an `Effect` from a callback-based asynchronous function.\n\n**Details**\n\nThe `resume` function:\n- Must be called exactly once. Any additional calls will be ignored.\n- Can return an optional `Effect` that will be run if the `Fiber` executing\n  this `Effect` is interrupted. This can be useful in scenarios where you\n  need to handle resource cleanup if the operation is interrupted.\n- Can receive an `AbortSignal` to handle interruption if needed.\n\nThe `FiberId` of the fiber that may complete the async callback may also be\nspecified using the `blockingOn` argument. This is called the "blocking\nfiber" because it suspends the fiber executing the `async` effect (i.e.\nsemantically blocks the fiber from making progress). Specifying this fiber id\nin cases where it is known will improve diagnostics, but not affect the\nbehavior of the returned effect.\n\n**When to Use**\n\nUse `Effect.async` when dealing with APIs that use callback-style instead of\n`async/await` or `Promise`.\n\n**Example** (Wrapping a Callback API)\n\n```ts\nimport { Effect } from "effect"\nimport * as NodeFS from "node:fs"\n\nconst readFile = (filename: string) =>\n  Effect.async<Buffer, Error>((resume) => {\n    NodeFS.readFile(filename, (error, data) => {\n      if (error) {\n        // Resume with a failed Effect if an error occurs\n        resume(Effect.fail(error))\n      } else {\n        // Resume with a succeeded Effect if successful\n        resume(Effect.succeed(data))\n      }\n    })\n  })\n\n//      \u250C\u2500\u2500\u2500 Effect<Buffer, Error, never>\n//      \u25BC\nconst program = readFile("example.txt")\n```\n\n**Example** (Handling Interruption with Cleanup)\n\n```ts\nimport { Effect, Fiber } from "effect"\nimport * as NodeFS from "node:fs"\n\n// Simulates a long-running operation to write to a file\nconst writeFileWithCleanup = (filename: string, data: string) =>\n  Effect.async<void, Error>((resume) => {\n    const writeStream = NodeFS.createWriteStream(filename)\n\n    // Start writing data to the file\n    writeStream.write(data)\n\n    // When the stream is finished, resume with success\n    writeStream.on("finish", () => resume(Effect.void))\n\n    // In case of an error during writing, resume with failure\n    writeStream.on("error", (err) => resume(Effect.fail(err)))\n\n    // Handle interruption by returning a cleanup effect\n    return Effect.sync(() => {\n      console.log(`Cleaning up ${filename}`)\n      NodeFS.unlinkSync(filename)\n    })\n  })\n\nconst program = Effect.gen(function* () {\n  const fiber = yield* Effect.fork(\n    writeFileWithCleanup("example.txt", "Some long data...")\n  )\n  // Simulate interrupting the fiber after 1 second\n  yield* Effect.sleep("1 second")\n  yield* Fiber.interrupt(fiber) // This will trigger the cleanup\n})\n\n// Run the program\nEffect.runPromise(program)\n// Output:\n// Cleaning up example.txt\n```\n\n**Example** (Handling Interruption with AbortSignal)\n\n```ts\nimport { Effect, Fiber } from "effect"\n\n// A task that supports interruption using AbortSignal\nconst interruptibleTask = Effect.async<void, Error>((resume, signal) => {\n  // Handle interruption\n  signal.addEventListener("abort", () => {\n    console.log("Abort signal received")\n    clearTimeout(timeoutId)\n  })\n\n  // Simulate a long-running task\n  const timeoutId = setTimeout(() => {\n    console.log("Operation completed")\n    resume(Effect.void)\n  }, 2000)\n})\n\nconst program = Effect.gen(function* () {\n  const fiber = yield* Effect.fork(interruptibleTask)\n  // Simulate interrupting the fiber after 1 second\n  yield* Effect.sleep("1 second")\n  yield* Fiber.interrupt(fiber)\n})\n\n// Run the program\nEffect.runPromise(program)\n// Output:\n// Abort signal received\n```',
      examples: [
        {
          title: "Wrapping a Callback API",
          code: 'import { Effect } from "effect"\nimport * as NodeFS from "node:fs"\n\nconst readFile = (filename: string) =>\n  Effect.async<Buffer, Error>((resume) => {\n    NodeFS.readFile(filename, (error, data) => {\n      if (error) {\n        // Resume with a failed Effect if an error occurs\n        resume(Effect.fail(error))\n      } else {\n        // Resume with a succeeded Effect if successful\n        resume(Effect.succeed(data))\n      }\n    })\n  })\n\n//      \u250C\u2500\u2500\u2500 Effect<Buffer, Error, never>\n//      \u25BC\nconst program = readFile("example.txt")'
        },
        {
          title: "Handling Interruption with Cleanup",
          code: 'import { Effect, Fiber } from "effect"\nimport * as NodeFS from "node:fs"\n\n// Simulates a long-running operation to write to a file\nconst writeFileWithCleanup = (filename: string, data: string) =>\n  Effect.async<void, Error>((resume) => {\n    const writeStream = NodeFS.createWriteStream(filename)\n\n    // Start writing data to the file\n    writeStream.write(data)\n\n    // When the stream is finished, resume with success\n    writeStream.on("finish", () => resume(Effect.void))\n\n    // In case of an error during writing, resume with failure\n    writeStream.on("error", (err) => resume(Effect.fail(err)))\n\n    // Handle interruption by returning a cleanup effect\n    return Effect.sync(() => {\n      console.log(`Cleaning up ${filename}`)\n      NodeFS.unlinkSync(filename)\n    })\n  })\n\nconst program = Effect.gen(function* () {\n  const fiber = yield* Effect.fork(\n    writeFileWithCleanup("example.txt", "Some long data...")\n  )\n  // Simulate interrupting the fiber after 1 second\n  yield* Effect.sleep("1 second")\n  yield* Fiber.interrupt(fiber) // This will trigger the cleanup\n})\n\n// Run the program\nEffect.runPromise(program)\n// Output:\n// Cleaning up example.txt'
        },
        {
          title: "Handling Interruption with AbortSignal",
          code: 'import { Effect, Fiber } from "effect"\n\n// A task that supports interruption using AbortSignal\nconst interruptibleTask = Effect.async<void, Error>((resume, signal) => {\n  // Handle interruption\n  signal.addEventListener("abort", () => {\n    console.log("Abort signal received")\n    clearTimeout(timeoutId)\n  })\n\n  // Simulate a long-running task\n  const timeoutId = setTimeout(() => {\n    console.log("Operation completed")\n    resume(Effect.void)\n  }, 2000)\n})\n\nconst program = Effect.gen(function* () {\n  const fiber = yield* Effect.fork(interruptibleTask)\n  // Simulate interrupting the fiber after 1 second\n  yield* Effect.sleep("1 second")\n  yield* Fiber.interrupt(fiber)\n})\n\n// Run the program\nEffect.runPromise(program)\n// Output:\n// Abort signal received'
        }
      ],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4718,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4718"
    },
    {
      id: "effect.asyncEffect",
      name: "asyncEffect",
      module: "effect",
      package: "effect",
      signature: "<A, E, R, R3, E2, R2>(register: (callback: (_: Effect<A, E, R>) => void) => Effect<void | Effect<void, never, R3>, E2, R2>) => Effect<A, E | E2, R | R3 | R2>",
      description: "/\n * A variant of {@link async}where the registration function may return an `Effect`.\n *\n *",
      documentation: "/**\n * A variant of {@link async}where the registration function may return an `Effect`.\n *\n *",
      examples: [],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4725,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4725"
    },
    {
      id: "effect.custom",
      name: "custom",
      module: "effect",
      package: "effect",
      signature: "{ <X, A, E, R>(i0: X, body: (this: { effect_instruction_i0: X; }) => Effect<A, E, R>): Effect<A, E, R>; <X, Y, A, E, R>(i0: X, i1: Y, body: (this: { effect_instruction_i0: X; effect_instruction_i1: Y; }) => Effect<A, E, R>): Effect<A, E, R>; <X, Y, Z, A, E, R>(i0: X, i1: Y, i2: Z, body: (this: { effect_instruction_i0: X; effect_instruction_i1: Y; effect_instruction_i2: Z; }) => Effect<A, E, R>): Effect<A, E, R>; }",
      description: 'Low level constructor that enables for custom stack tracing cutpoints. It is meant to be called with a bag of instructions that become available in\nthe "this" of the effect.',
      documentation: 'Low level constructor that enables for custom stack tracing cutpoints.\n\nIt is meant to be called with a bag of instructions that become available in\nthe "this" of the effect.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst throwingFunction = () => { throw new Error() }\nconst blowUp = Effect.custom(throwingFunction, function() {\n  return Effect.succeed(this.effect_instruction_i0())\n})\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst throwingFunction = () => { throw new Error() }\nconst blowUp = Effect.custom(throwingFunction, function() {\n  return Effect.succeed(this.effect_instruction_i0())\n})'
        }
      ],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4746,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4746"
    },
    {
      id: "effect.withFiberRuntime",
      name: "withFiberRuntime",
      module: "effect",
      package: "effect",
      signature: "<A, E = never, R = never>(withRuntime: (fiber: RuntimeFiber<A, E>, status: Running) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4824,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4824"
    },
    {
      id: "effect.fail",
      name: "fail",
      module: "effect",
      package: "effect",
      signature: "<E>(error: E) => Effect<never, E, never>",
      description: "/\n * Creates an `Effect` that represents a recoverable error.\n *\n *",
      documentation: '/**\n * Creates an `Effect` that represents a recoverable error.\n *\n * **When to Use**\n *\n * Use this function to explicitly signal an error in an `Effect`. The error\n * will keep propagating unless it is handled. You can handle the error with\n * functions like {@link catchAll}or {@link catchTag}.\n *\n * **Example** (Creating a Failed Effect)\n *\n * ```ts\n * import { Effect } from "effect"\n *\n * //      \u250C\u2500\u2500\u2500 Effect<never, Error, never>\n * //      \u25BC\n * const failure = Effect.fail(\n *   new Error("Operation failed due to network error")\n * )\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect } from "effect"\n *\n * //      \u250C\u2500\u2500\u2500 Effect<never, Error, never>\n * //      \u25BC\n * const failure = Effect.fail(\n *   new Error("Operation failed due to network error")\n * )\n *'
        }
      ],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4851,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4851"
    },
    {
      id: "effect.failSync",
      name: "failSync",
      module: "effect",
      package: "effect",
      signature: "<E>(evaluate: LazyArg<E>) => Effect<never, E, never>",
      description: "Creates an `Effect` that fails with the specified error, evaluated lazily.",
      documentation: "Creates an `Effect` that fails with the specified error, evaluated lazily.",
      examples: [],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4858,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4858"
    },
    {
      id: "effect.failCause",
      name: "failCause",
      module: "effect",
      package: "effect",
      signature: "<E>(cause: Cause<E>) => Effect<never, E, never>",
      description: "Creates an `Effect` that fails with the specified `Cause`.",
      documentation: "Creates an `Effect` that fails with the specified `Cause`.",
      examples: [],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4865,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4865"
    },
    {
      id: "effect.failCauseSync",
      name: "failCauseSync",
      module: "effect",
      package: "effect",
      signature: "<E>(evaluate: LazyArg<Cause<E>>) => Effect<never, E, never>",
      description: "Creates an `Effect` that fails with the specified `Cause`, evaluated lazily.",
      documentation: "Creates an `Effect` that fails with the specified `Cause`, evaluated lazily.",
      examples: [],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4872,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4872"
    },
    {
      id: "effect.die",
      name: "die",
      module: "effect",
      package: "effect",
      signature: "(defect: unknown) => Effect<never, never, never>",
      description: "Creates an effect that terminates a fiber with a specified error.",
      documentation: 'Creates an effect that terminates a fiber with a specified error.\n\n**Details**\n\nThis function is used to signal a defect, which represents a critical and\nunexpected error in the code. When invoked, it produces an effect that does\nnot handle the error and instead terminates the fiber.\n\nThe error channel of the resulting effect is of type `never`, indicating that\nit cannot recover from this failure.\n\n**When to Use**\n\nUse this function when encountering unexpected conditions in your code that\nshould not be handled as regular errors but instead represent unrecoverable\ndefects.\n\n**Example** (Terminating on Division by Zero with a Specified Error)\n\n```ts\nimport { Effect } from "effect"\n\nconst divide = (a: number, b: number) =>\n  b === 0\n    ? Effect.die(new Error("Cannot divide by zero"))\n    : Effect.succeed(a / b)\n\n//      \u250C\u2500\u2500\u2500 Effect<number, never, never>\n//      \u25BC\nconst program = divide(1, 0)\n\nEffect.runPromise(program).catch(console.error)\n// Output:\n// (FiberFailure) Error: Cannot divide by zero\n//   ...stack trace...\n```',
      examples: [
        {
          title: "Terminating on Division by Zero with a Specified Error",
          code: 'import { Effect } from "effect"\n\nconst divide = (a: number, b: number) =>\n  b === 0\n    ? Effect.die(new Error("Cannot divide by zero"))\n    : Effect.succeed(a / b)\n\n//      \u250C\u2500\u2500\u2500 Effect<number, never, never>\n//      \u25BC\nconst program = divide(1, 0)\n\nEffect.runPromise(program).catch(console.error)\n// Output:\n// (FiberFailure) Error: Cannot divide by zero\n//   ...stack trace...'
        }
      ],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4919,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4919"
    },
    {
      id: "effect.dieMessage",
      name: "dieMessage",
      module: "effect",
      package: "effect",
      signature: "(message: string) => Effect<never, never, never>",
      description: "Creates an effect that terminates a fiber with a `RuntimeException`\ncontaining the specified message.",
      documentation: 'Creates an effect that terminates a fiber with a `RuntimeException`\ncontaining the specified message.\n\n**Details**\n\nThis function is used to signal a defect, representing a critical and\nunexpected error in the code. When invoked, it produces an effect that\nterminates the fiber with a `RuntimeException` carrying the given message.\n\nThe resulting effect has an error channel of type `never`, indicating it does\nnot handle or recover from the error.\n\n**When to Use**\n\nUse this function when you want to terminate a fiber due to an unrecoverable\ndefect and include a clear explanation in the message.\n\n**Example** (Terminating on Division by Zero with a Specified Message)\n\n```ts\nimport { Effect } from "effect"\n\nconst divide = (a: number, b: number) =>\n  b === 0\n    ? Effect.dieMessage("Cannot divide by zero")\n    : Effect.succeed(a / b)\n\n//      \u250C\u2500\u2500\u2500 Effect<number, never, never>\n//      \u25BC\nconst program = divide(1, 0)\n\nEffect.runPromise(program).catch(console.error)\n// Output:\n// (FiberFailure) RuntimeException: Cannot divide by zero\n//   ...stack trace...\n```',
      examples: [
        {
          title: "Terminating on Division by Zero with a Specified Message",
          code: 'import { Effect } from "effect"\n\nconst divide = (a: number, b: number) =>\n  b === 0\n    ? Effect.dieMessage("Cannot divide by zero")\n    : Effect.succeed(a / b)\n\n//      \u250C\u2500\u2500\u2500 Effect<number, never, never>\n//      \u25BC\nconst program = divide(1, 0)\n\nEffect.runPromise(program).catch(console.error)\n// Output:\n// (FiberFailure) RuntimeException: Cannot divide by zero\n//   ...stack trace...'
        }
      ],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4965,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4965"
    },
    {
      id: "effect.dieSync",
      name: "dieSync",
      module: "effect",
      package: "effect",
      signature: "(evaluate: LazyArg<unknown>) => Effect<never, never, never>",
      description: "Creates an effect that dies with the specified error, evaluated lazily.",
      documentation: "Creates an effect that dies with the specified error, evaluated lazily.\n\n**Details**\n\nThis function allows you to create an effect that will terminate with a fatal error.\nThe error is provided as a lazy argument, meaning it will only be evaluated when the effect runs.",
      examples: [],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4979,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4979"
    },
    {
      id: "effect.gen",
      name: "gen",
      module: "effect",
      package: "effect",
      signature: "{ <Eff extends YieldWrap<Effect<any, any, any>>, AEff>(f: (resume: Adapter) => Generator<Eff, AEff, never>): Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never>; <Self, Eff extends YieldWrap<Effect<any, any, any>>, AEff>(self: Self, f: (this: Self, resume: Adapter) => Generator<Eff, AEff, never>): Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never>; }",
      description: "Provides a way to write effectful code using generator functions, simplifying\ncontrol flow and error handling.",
      documentation: 'Provides a way to write effectful code using generator functions, simplifying\ncontrol flow and error handling.\n\n**When to Use**\n\n`Effect.gen` allows you to write code that looks and behaves like synchronous\ncode, but it can handle asynchronous tasks, errors, and complex control flow\n(like loops and conditions). It helps make asynchronous code more readable\nand easier to manage.\n\nThe generator functions work similarly to `async/await` but with more\nexplicit control over the execution of effects. You can `yield*` values from\neffects and return the final result at the end.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst addServiceCharge = (amount: number) => amount + 1\n\nconst applyDiscount = (\n  total: number,\n  discountRate: number\n): Effect.Effect<number, Error> =>\n  discountRate === 0\n    ? Effect.fail(new Error("Discount rate cannot be zero"))\n    : Effect.succeed(total - (total * discountRate) / 100)\n\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\nconst fetchDiscountRate = Effect.promise(() => Promise.resolve(5))\n\nexport const program = Effect.gen(function* () {\n  const transactionAmount = yield* fetchTransactionAmount\n  const discountRate = yield* fetchDiscountRate\n  const discountedAmount = yield* applyDiscount(\n    transactionAmount,\n    discountRate\n  )\n  const finalAmount = addServiceCharge(discountedAmount)\n  return `Final amount to charge: ${finalAmount}`\n})\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst addServiceCharge = (amount: number) => amount + 1\n\nconst applyDiscount = (\n  total: number,\n  discountRate: number\n): Effect.Effect<number, Error> =>\n  discountRate === 0\n    ? Effect.fail(new Error("Discount rate cannot be zero"))\n    : Effect.succeed(total - (total * discountRate) / 100)\n\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\nconst fetchDiscountRate = Effect.promise(() => Promise.resolve(5))\n\nexport const program = Effect.gen(function* () {\n  const transactionAmount = yield* fetchTransactionAmount\n  const discountRate = yield* fetchDiscountRate\n  const discountedAmount = yield* applyDiscount(\n    transactionAmount,\n    discountRate\n  )\n  const finalAmount = addServiceCharge(discountedAmount)\n  return `Final amount to charge: ${finalAmount}`\n})'
        }
      ],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5029,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5029"
    },
    {
      id: "effect.never",
      name: "never",
      module: "effect",
      package: "effect",
      signature: "Effect<never, never, never>",
      description: "An effect that that runs indefinitely and never produces any result. The\nmoral equivalent of `while(true) {}`, only without the wasted CPU cycles.",
      documentation: "An effect that that runs indefinitely and never produces any result. The\nmoral equivalent of `while(true) {}`, only without the wasted CPU cycles.\n\n**When to Use**\n\nIt could be useful for long-running background tasks or to simulate waiting\nbehavior without actually consuming resources. This effect is ideal for cases\nwhere you want to keep the program alive or in a certain state without\nperforming any active work.",
      examples: [],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5180,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5180"
    },
    {
      id: "effect.none",
      name: "none",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<Option<A>, E, R>) => Effect<void, NoSuchElementException | E, R>",
      description: "Ensures the `Option` is `None`, returning `void`. Otherwise, raises a\n`NoSuchElementException`.",
      documentation: "Ensures the `Option` is `None`, returning `void`. Otherwise, raises a\n`NoSuchElementException`.\n\n**Details**\n\nThis function checks if the provided `Option` is `None`. If it is, it returns\nan effect that produces no result (i.e., `void`). If the `Option` is not\n`None` (i.e., it contains a value), the function will raise a\n`NoSuchElementException` error.\n\n**When to Use**\n\nThis is useful when you want to ensure that a certain value is absent (i.e.,\n`None`) before continuing execution, and to handle cases where the value is\nunexpectedly present.",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5200,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5200"
    },
    {
      id: "effect.promise",
      name: "promise",
      module: "effect",
      package: "effect",
      signature: "<A>(evaluate: (signal: AbortSignal) => PromiseLike<A>) => Effect<A, never, never>",
      description: "/\n * Creates an `Effect` that represents an asynchronous computation guaranteed to\n * succeed.\n *\n *",
      documentation: '/**\n * Creates an `Effect` that represents an asynchronous computation guaranteed to\n * succeed.\n *\n * **Details**\n *\n * The provided function (`thunk`) returns a `Promise` that should never reject; if it does, the error\n * will be treated as a "defect".\n *\n * This defect is not a standard error but indicates a flaw in the logic that\n * was expected to be error-free. You can think of it similar to an unexpected\n * crash in the program, which can be further managed or logged using tools like\n * {@link catchAllDefect}.\n *\n * **Interruptions**\n *\n * An optional `AbortSignal` can be provided to allow for interruption of the\n * wrapped `Promise` API.\n *\n * **When to Use**\n *\n * Use this function when you are sure the operation will not reject.\n *\n * **Example** (Delayed Message)\n *\n * ```ts\n * import { Effect } from "effect"\n *\n * const delay = (message: string) =>\n *   Effect.promise<string>(\n *     () =>\n *       new Promise((resolve) => {\n *         setTimeout(() => {\n *           resolve(message)\n *         }, 2000)\n *       })\n *   )\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, never, never>\n * //      \u25BC\n * const program = delay("Async operation completed successfully!")\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect } from "effect"\n *\n * const delay = (message: string) =>\n *   Effect.promise<string>(\n *     () =>\n *       new Promise((resolve) => {\n *         setTimeout(() => {\n *           resolve(message)\n *         }, 2000)\n *       })\n *   )\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, never, never>\n * //      \u25BC\n * const program = delay("Async operation completed successfully!")\n *'
        }
      ],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5249,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5249"
    },
    {
      id: "effect.succeed",
      name: "succeed",
      module: "effect",
      package: "effect",
      signature: "<A>(value: A) => Effect<A, never, never>",
      description: "Creates an `Effect` that always succeeds with a given value.",
      documentation: 'Creates an `Effect` that always succeeds with a given value.\n\n**When to Use**\n\nUse this function when you need an effect that completes successfully with a\nspecific value without any errors or external dependencies.\n\n**Example** (Creating a Successful Effect)\n\n```ts\nimport { Effect } from "effect"\n\n// Creating an effect that represents a successful scenario\n//\n//      \u250C\u2500\u2500\u2500 Effect<number, never, never>\n//      \u25BC\nconst success = Effect.succeed(42)\n```',
      examples: [
        {
          title: "Creating a Successful Effect",
          code: 'import { Effect } from "effect"\n\n// Creating an effect that represents a successful scenario\n//\n//      \u250C\u2500\u2500\u2500 Effect<number, never, never>\n//      \u25BC\nconst success = Effect.succeed(42)'
        }
      ],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5275,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5275"
    },
    {
      id: "effect.succeedNone",
      name: "succeedNone",
      module: "effect",
      package: "effect",
      signature: "Effect<Option<never>, never, never>",
      description: "Returns an effect which succeeds with `None`.",
      documentation: "Returns an effect which succeeds with `None`.\n\n**When to Use**\n\nUse this function when you need to represent the absence of a value in your\ncode, especially when working with optional data. This can be helpful when\nyou want to indicate that no result is available without throwing an error or\nperforming additional logic.",
      examples: [],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5291,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5291"
    },
    {
      id: "effect.succeedSome",
      name: "succeedSome",
      module: "effect",
      package: "effect",
      signature: "<A>(value: A) => Effect<Option<A>, never, never>",
      description: "Returns an effect which succeeds with the value wrapped in a `Some`.",
      documentation: "Returns an effect which succeeds with the value wrapped in a `Some`.",
      examples: [],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5300,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5300"
    },
    {
      id: "effect.suspend",
      name: "suspend",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(effect: LazyArg<Effect<A, E, R>>) => Effect<A, E, R>",
      description: "Delays the creation of an `Effect` until it is actually needed.",
      documentation: 'Delays the creation of an `Effect` until it is actually needed.\n\n**Details**\n\nThe `Effect.suspend` function takes a thunk that represents the effect and\nwraps it in a suspended effect. This means the effect will not be created\nuntil it is explicitly needed, which is helpful in various scenarios:\n- **Lazy Evaluation**: Helps optimize performance by deferring computations,\n  especially when the effect might not be needed, or when its computation is\n  expensive. This also ensures that any side effects or scoped captures are\n  re-executed on each invocation.\n- **Handling Circular Dependencies**: Useful in managing circular\n  dependencies, such as recursive functions that need to avoid eager\n  evaluation to prevent stack overflow.\n- **Unifying Return Types**: Can help TypeScript unify return types in\n  situations where multiple branches of logic return different effects,\n  simplifying type inference.\n\n**When to Use**\n\nUse this function when you need to defer the evaluation of an effect until it\nis required. This is particularly useful for optimizing expensive\ncomputations, managing circular dependencies, or resolving type inference\nissues.\n\n**Example** (Lazy Evaluation with Side Effects)\n\n```ts\nimport { Effect } from "effect"\n\nlet i = 0\n\nconst bad = Effect.succeed(i++)\n\nconst good = Effect.suspend(() => Effect.succeed(i++))\n\nconsole.log(Effect.runSync(bad)) // Output: 0\nconsole.log(Effect.runSync(bad)) // Output: 0\n\nconsole.log(Effect.runSync(good)) // Output: 1\nconsole.log(Effect.runSync(good)) // Output: 2\n```\n\n**Example** (Recursive Fibonacci)\n\n```ts\nimport { Effect } from "effect"\n\nconst blowsUp = (n: number): Effect.Effect<number> =>\n  n < 2\n    ? Effect.succeed(1)\n    : Effect.zipWith(blowsUp(n - 1), blowsUp(n - 2), (a, b) => a + b)\n\nconsole.log(Effect.runSync(blowsUp(32)))\n// crash: JavaScript heap out of memory\n\nconst allGood = (n: number): Effect.Effect<number> =>\n  n < 2\n    ? Effect.succeed(1)\n    : Effect.zipWith(\n        Effect.suspend(() => allGood(n - 1)),\n        Effect.suspend(() => allGood(n - 2)),\n        (a, b) => a + b\n      )\n\nconsole.log(Effect.runSync(allGood(32)))\n// Output: 3524578\n```\n\n**Example** (Using Effect.suspend to Help TypeScript Infer Types)\n\n```ts\nimport { Effect } from "effect"\n\n//   Without suspend, TypeScript may struggle with type inference.\n//   Inferred type:\n//     (a: number, b: number) =>\n//       Effect<never, Error, never> | Effect<number, never, never>\nconst withoutSuspend = (a: number, b: number) =>\n  b === 0\n    ? Effect.fail(new Error("Cannot divide by zero"))\n    : Effect.succeed(a / b)\n\n//   Using suspend to unify return types.\n//   Inferred type:\n//     (a: number, b: number) => Effect<number, Error, never>\nconst withSuspend = (a: number, b: number) =>\n  Effect.suspend(() =>\n    b === 0\n      ? Effect.fail(new Error("Cannot divide by zero"))\n      : Effect.succeed(a / b)\n  )\n```',
      examples: [
        {
          title: "Lazy Evaluation with Side Effects",
          code: 'import { Effect } from "effect"\n\nlet i = 0\n\nconst bad = Effect.succeed(i++)\n\nconst good = Effect.suspend(() => Effect.succeed(i++))\n\nconsole.log(Effect.runSync(bad)) // Output: 0\nconsole.log(Effect.runSync(bad)) // Output: 0\n\nconsole.log(Effect.runSync(good)) // Output: 1\nconsole.log(Effect.runSync(good)) // Output: 2'
        },
        {
          title: "Recursive Fibonacci",
          code: 'import { Effect } from "effect"\n\nconst blowsUp = (n: number): Effect.Effect<number> =>\n  n < 2\n    ? Effect.succeed(1)\n    : Effect.zipWith(blowsUp(n - 1), blowsUp(n - 2), (a, b) => a + b)\n\nconsole.log(Effect.runSync(blowsUp(32)))\n// crash: JavaScript heap out of memory\n\nconst allGood = (n: number): Effect.Effect<number> =>\n  n < 2\n    ? Effect.succeed(1)\n    : Effect.zipWith(\n        Effect.suspend(() => allGood(n - 1)),\n        Effect.suspend(() => allGood(n - 2)),\n        (a, b) => a + b\n      )\n\nconsole.log(Effect.runSync(allGood(32)))\n// Output: 3524578'
        },
        {
          title: "Using Effect.suspend to Help TypeScript Infer Types",
          code: 'import { Effect } from "effect"\n\n//   Without suspend, TypeScript may struggle with type inference.\n//   Inferred type:\n//     (a: number, b: number) =>\n//       Effect<never, Error, never> | Effect<number, never, never>\nconst withoutSuspend = (a: number, b: number) =>\n  b === 0\n    ? Effect.fail(new Error("Cannot divide by zero"))\n    : Effect.succeed(a / b)\n\n//   Using suspend to unify return types.\n//   Inferred type:\n//     (a: number, b: number) => Effect<number, Error, never>\nconst withSuspend = (a: number, b: number) =>\n  Effect.suspend(() =>\n    b === 0\n      ? Effect.fail(new Error("Cannot divide by zero"))\n      : Effect.succeed(a / b)\n  )'
        }
      ],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5399,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5399"
    },
    {
      id: "effect.sync",
      name: "sync",
      module: "effect",
      package: "effect",
      signature: "<A>(thunk: LazyArg<A>) => Effect<A, never, never>",
      description: "/\n * Creates an `Effect` that represents a synchronous side-effectful computation.\n *\n *",
      documentation: '/**\n * Creates an `Effect` that represents a synchronous side-effectful computation.\n *\n * **Details**\n *\n * The provided function (`thunk`) must not throw errors; if it does, the error\n * will be treated as a "defect".\n *\n * This defect is not a standard error but indicates a flaw in the logic that\n * was expected to be error-free. You can think of it similar to an unexpected\n * crash in the program, which can be further managed or logged using tools like\n * {@link catchAllDefect}.\n *\n * **When to Use**\n *\n * Use this function when you are sure the operation will not fail.\n *\n * **Example** (Logging a Message)\n *\n * ```ts\n * import { Effect } from "effect"\n *\n * const log = (message: string) =>\n *   Effect.sync(() => {\n *     console.log(message) // side effect\n *   })\n *\n * //      \u250C\u2500\u2500\u2500 Effect<void, never, never>\n * //      \u25BC\n * const program = log("Hello, World!")\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect } from "effect"\n *\n * const log = (message: string) =>\n *   Effect.sync(() => {\n *     console.log(message) // side effect\n *   })\n *\n * //      \u250C\u2500\u2500\u2500 Effect<void, never, never>\n * //      \u25BC\n * const program = log("Hello, World!")\n *'
        }
      ],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5437,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5437"
    },
    {
      id: "effect.yieldNow",
      name: "yieldNow",
      module: "effect",
      package: "effect",
      signature: "(options?: { readonly priority?: number; }) => Effect<void, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5459,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5459"
    },
    {
      id: "effect.catchAll",
      name: "catchAll",
      module: "effect",
      package: "effect",
      signature: "{ <E, A2, E2, R2>(f: (e: E) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (e: E) => Effect<A2, E2, R2>): Effect<A | A2, E2, R | R2>; }",
      description: "Handles all errors in an effect by providing a fallback effect.",
      documentation: 'Handles all errors in an effect by providing a fallback effect.\n\n**Details**\n\nThis function catches any errors that may occur during the execution of an\neffect and allows you to handle them by specifying a fallback effect. This\nensures that the program continues without failing by recovering from errors\nusing the provided fallback logic.\n\n**Note**: This function only handles recoverable errors. It will not recover\nfrom unrecoverable defects.\n\n**Example** (Providing Recovery Logic for Recoverable Errors)\n\n```ts\nimport { Effect, Random } from "effect"\n\nclass HttpError {\n  readonly _tag = "HttpError"\n}\n\nclass ValidationError {\n  readonly _tag = "ValidationError"\n}\n\n//      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return "some result"\n})\n\n//      \u250C\u2500\u2500\u2500 Effect<string, never, never>\n//      \u25BC\nconst recovered = program.pipe(\n  Effect.catchAll((error) =>\n    Effect.succeed(`Recovering from ${error._tag}`)\n  )\n)\n```',
      examples: [
        {
          title: "Providing Recovery Logic for Recoverable Errors",
          code: 'import { Effect, Random } from "effect"\n\nclass HttpError {\n  readonly _tag = "HttpError"\n}\n\nclass ValidationError {\n  readonly _tag = "ValidationError"\n}\n\n//      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return "some result"\n})\n\n//      \u250C\u2500\u2500\u2500 Effect<string, never, never>\n//      \u25BC\nconst recovered = program.pipe(\n  Effect.catchAll((error) =>\n    Effect.succeed(`Recovering from ${error._tag}`)\n  )\n)'
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5582,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5582"
    },
    {
      id: "effect.catchAllCause",
      name: "catchAllCause",
      module: "effect",
      package: "effect",
      signature: "{ <E, A2, E2, R2>(f: (cause: Cause<E>) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause<E>) => Effect<A2, E2, R2>): Effect<A | A2, E2, R | R2>; }",
      description: "Handles both recoverable and unrecoverable errors by providing a recovery\neffect.",
      documentation: 'Handles both recoverable and unrecoverable errors by providing a recovery\neffect.\n\n**When to Use**\n\nThe `catchAllCause` function allows you to handle all errors, including\nunrecoverable defects, by providing a recovery effect. The recovery logic is\nbased on the `Cause` of the error, which provides detailed information about\nthe failure.\n\n**When to Recover from Defects**\n\nDefects are unexpected errors that typically shouldn\'t be recovered from, as\nthey often indicate serious issues. However, in some cases, such as\ndynamically loaded plugins, controlled recovery might be needed.\n\n**Example** (Recovering from All Errors)\n\n```ts\nimport { Cause, Effect } from "effect"\n\n// Define an effect that may fail with a recoverable or unrecoverable error\nconst program = Effect.fail("Something went wrong!")\n\n// Recover from all errors by examining the cause\nconst recovered = program.pipe(\n  Effect.catchAllCause((cause) =>\n    Cause.isFailure(cause)\n      ? Effect.succeed("Recovered from a regular error")\n      : Effect.succeed("Recovered from a defect")\n  )\n)\n\nEffect.runPromise(recovered).then(console.log)\n// Output: "Recovered from a regular error"\n```',
      examples: [
        {
          title: "Recovering from All Errors",
          code: 'import { Cause, Effect } from "effect"\n\n// Define an effect that may fail with a recoverable or unrecoverable error\nconst program = Effect.fail("Something went wrong!")\n\n// Recover from all errors by examining the cause\nconst recovered = program.pipe(\n  Effect.catchAllCause((cause) =>\n    Cause.isFailure(cause)\n      ? Effect.succeed("Recovered from a regular error")\n      : Effect.succeed("Recovered from a defect")\n  )\n)\n\nEffect.runPromise(recovered).then(console.log)\n// Output: "Recovered from a regular error"'
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5737,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5737"
    },
    {
      id: "effect.catchAllDefect",
      name: "catchAllDefect",
      module: "effect",
      package: "effect",
      signature: "{ <A2, E2, R2>(f: (defect: unknown) => Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (defect: unknown) => Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }",
      description: "/\n * Recovers from all defects using a provided recovery function.\n *\n *",
      documentation: '/**\n * Recovers from all defects using a provided recovery function.\n *\n * **When to Use**\n *\n * There is no sensible way to recover from defects. This method should be used\n * only at the boundary between Effect and an external system, to transmit\n * information on a defect for diagnostic or explanatory purposes.\n *\n * **Details**\n *\n * `catchAllDefect` allows you to handle defects, which are unexpected errors\n * that usually cause the program to terminate. This function lets you recover\n * from these defects by providing a function that handles the error. However,\n * it does not handle expected errors (like those from {@link fail}) or\n * execution interruptions (like those from {@link interrupt}).\n *\n * **When to Recover from Defects**\n *\n * Defects are unexpected errors that typically shouldn\'t be recovered from, as\n * they often indicate serious issues. However, in some cases, such as\n * dynamically loaded plugins, controlled recovery might be needed.\n *\n * **Example** (Handling All Defects)\n *\n * ```ts\n * import { Effect, Cause, Console } from "effect"\n *\n * // Simulating a runtime error\n * const task = Effect.dieMessage("Boom!")\n *\n * const program = Effect.catchAllDefect(task, (defect) => {\n *   if (Cause.isRuntimeException(defect)) {\n *     return Console.log(\n *       `RuntimeException defect caught: ${defect.message}`\n *     )\n *   }\n *   return Console.log("Unknown defect caught.")\n * })\n *\n * // We get an Exit.Success because we caught all defects\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // RuntimeException defect caught: Boom!\n * // {\n * //   _id: "Exit",\n * //   _tag: "Success",\n * //   value: undefined\n * // }\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect, Cause, Console } from "effect"\n *\n * // Simulating a runtime error\n * const task = Effect.dieMessage("Boom!")\n *\n * const program = Effect.catchAllDefect(task, (defect) => {\n *   if (Cause.isRuntimeException(defect)) {\n *     return Console.log(\n *       `RuntimeException defect caught: ${defect.message}`\n *     )\n *   }\n *   return Console.log("Unknown defect caught.")\n * })\n *\n * // We get an Exit.Success because we caught all defects\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // RuntimeException defect caught: Boom!\n * // {\n * //   _id: "Exit",\n * //   _tag: "Success",\n * //   value: undefined\n * // }\n *'
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5877,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5877"
    },
    {
      id: "effect.catchIf",
      name: "catchIf",
      module: "effect",
      package: "effect",
      signature: "{ <E, EB extends E, A2, E2, R2>(refinement: Refinement<NoInfer<E>, EB>, f: (e: EB) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | Exclude<E, EB>, R2 | R>; <E, A2, E2, R2>(predicate: Predicate<NoInfer<E>>, f: (e: NoInfer<E>) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>; <A, E, R, EB extends E, A2, E2, R2>(self: Effect<A, E, R>, refinement: Refinement<E, EB>, f: (e: EB) => Effect<A2, E2, R2>): Effect<A | A2, E2 | Exclude<E, EB>, R | R2>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, predicate: Predicate<E>, f: (e: E) => Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }",
      description: "/\n * Recovers from specific errors based on a predicate.\n *\n *",
      documentation: '/**\n * Recovers from specific errors based on a predicate.\n *\n * **When to Use**\n *\n * `catchIf` works similarly to {@link catchSome}, but it allows you to\n * recover from errors by providing a predicate function. If the predicate\n * matches the error, the recovery effect is applied. This function doesn\'t\n * alter the error type, so the resulting effect still carries the original\n * error type unless a user-defined type guard is used to narrow the type.\n *\n * **Example** (Catching Specific Errors with a Predicate)\n *\n * ```ts\n * import { Effect, Random } from "effect"\n *\n * class HttpError {\n *   readonly _tag = "HttpError"\n * }\n *\n * class ValidationError {\n *   readonly _tag = "ValidationError"\n * }\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n * //      \u25BC\n * const program = Effect.gen(function* () {\n *   const n1 = yield* Random.next\n *   const n2 = yield* Random.next\n *   if (n1 < 0.5) {\n *     yield* Effect.fail(new HttpError())\n *   }\n *   if (n2 < 0.5) {\n *     yield* Effect.fail(new ValidationError())\n *   }\n *   return "some result"\n * })\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, ValidationError, never>\n * //      \u25BC\n * const recovered = program.pipe(\n *   Effect.catchIf(\n *     // Only handle HttpError errors\n *     (error) => error._tag === "HttpError",\n *     () => Effect.succeed("Recovering from HttpError")\n *   )\n * )\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect, Random } from "effect"\n *\n * class HttpError {\n *   readonly _tag = "HttpError"\n * }\n *\n * class ValidationError {\n *   readonly _tag = "ValidationError"\n * }\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n * //      \u25BC\n * const program = Effect.gen(function* () {\n *   const n1 = yield* Random.next\n *   const n2 = yield* Random.next\n *   if (n1 < 0.5) {\n *     yield* Effect.fail(new HttpError())\n *   }\n *   if (n2 < 0.5) {\n *     yield* Effect.fail(new ValidationError())\n *   }\n *   return "some result"\n * })\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, ValidationError, never>\n * //      \u25BC\n * const recovered = program.pipe(\n *   Effect.catchIf(\n *     // Only handle HttpError errors\n *     (error) => error._tag === "HttpError",\n *     () => Effect.succeed("Recovering from HttpError")\n *   )\n * )\n *'
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 6041,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L6041"
    },
    {
      id: "effect.catchSome",
      name: "catchSome",
      module: "effect",
      package: "effect",
      signature: "{ <E, A2, E2, R2>(pf: (e: NoInfer<E>) => Option<Effect<A2, E2, R2>>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, pf: (e: NoInfer<E>) => Option<Effect<A2, E2, R2>>): Effect<A | A2, E | E2, R | R2>; }",
      description: "Catches and recovers from specific types of errors, allowing you to attempt\nrecovery only for certain errors.",
      documentation: 'Catches and recovers from specific types of errors, allowing you to attempt\nrecovery only for certain errors.\n\n**Details**\n\n`catchSome` lets you selectively catch and handle errors of certain\ntypes by providing a recovery effect for specific errors. If the error\nmatches a condition, recovery is attempted; if not, it doesn\'t affect the\nprogram. This function doesn\'t alter the error type, meaning the error type\nremains the same as in the original effect.\n\n**Example** (Handling Specific Errors with Effect.catchSome)\n\n```ts\nimport { Effect, Random, Option } from "effect"\n\nclass HttpError {\n  readonly _tag = "HttpError"\n}\n\nclass ValidationError {\n  readonly _tag = "ValidationError"\n}\n\n//      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return "some result"\n})\n\n//      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n//      \u25BC\nconst recovered = program.pipe(\n  Effect.catchSome((error) => {\n    // Only handle HttpError errors\n    if (error._tag === "HttpError") {\n      return Option.some(Effect.succeed("Recovering from HttpError"))\n    } else {\n      return Option.none()\n    }\n  })\n)\n```',
      examples: [
        {
          title: "Handling Specific Errors with Effect.catchSome",
          code: 'import { Effect, Random, Option } from "effect"\n\nclass HttpError {\n  readonly _tag = "HttpError"\n}\n\nclass ValidationError {\n  readonly _tag = "ValidationError"\n}\n\n//      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return "some result"\n})\n\n//      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n//      \u25BC\nconst recovered = program.pipe(\n  Effect.catchSome((error) => {\n    // Only handle HttpError errors\n    if (error._tag === "HttpError") {\n      return Option.some(Effect.succeed("Recovering from HttpError"))\n    } else {\n      return Option.none()\n    }\n  })\n)'
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 6313,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L6313"
    },
    {
      id: "effect.catchSomeCause",
      name: "catchSomeCause",
      module: "effect",
      package: "effect",
      signature: "{ <E, A2, E2, R2>(f: (cause: Cause<NoInfer<E>>) => Option<Effect<A2, E2, R2>>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause<NoInfer<E>>) => Option<Effect<A2, E2, R2>>): Effect<A | A2, E | E2, R | R2>; }",
      description: "Recovers from specific causes using a provided partial function.",
      documentation: "Recovers from specific causes using a provided partial function.",
      examples: [],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 6442,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L6442"
    },
    {
      id: "effect.catchSomeDefect",
      name: "catchSomeDefect",
      module: "effect",
      package: "effect",
      signature: "{ <A2, E2, R2>(pf: (defect: unknown) => Option<Effect<A2, E2, R2>>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, pf: (defect: unknown) => Option<Effect<A2, E2, R2>>): Effect<A | A2, E | E2, R | R2>; }",
      description: "/\n * Recovers from specific defects using a provided partial function.\n *\n *",
      documentation: "/**\n * Recovers from specific defects using a provided partial function.\n *\n * **Details**\n *\n * `catchSomeDefect` allows you to handle specific defects, which are\n * unexpected errors that can cause the program to stop. It uses a partial\n * function to catch only certain defects and ignores others. The function does\n * not handle expected errors (such as those caused by {@link fail}) or\n * interruptions in execution (like those caused by {@link interrupt}).\n *\n * This function provides a way to handle certain types of defects while\n * allowing others to propagate and cause failure in the program.\n *\n * **Note**: There is no sensible way to recover from defects. This method\n * should be used only at the boundary between Effect and an external system, to\n * transmit information on a defect for diagnostic or explanatory purposes.\n *\n * **How the Partial Function Works**\n *\n * The function provided to `catchSomeDefect` acts as a filter and a handler for defects:\n * - It receives the defect as an input.\n * - If the defect matches a specific condition (e.g., a certain error type), the function returns\n *   an `Option.some` containing the recovery logic.\n * - If the defect does not match, the function returns `Option.none`, allowing the defect to propagate.\n *\n * **Example** (Handling Specific Defects)\n *\n * ```ts\n * import { Effect, Cause, Option, Console } from \"effect\"\n *\n * // Simulating a runtime error\n * const task = Effect.dieMessage(\"Boom!\")\n *\n * const program = Effect.catchSomeDefect(task, (defect) => {\n *   if (Cause.isIllegalArgumentException(defect)) {\n *     return Option.some(\n *       Console.log(\n *         `Caught an IllegalArgumentException defect: ${defect.message}`\n *       )\n *     )\n *   }\n *   return Option.none()\n * })\n *\n * // Since we are only catching IllegalArgumentException\n * // we will get an Exit.Failure because we simulated a runtime error.\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: {\n * //     _id: 'Cause',\n * //     _tag: 'Die',\n * //     defect: { _tag: 'RuntimeException' }\n * //   }\n * // }\n * ```\n *\n *",
      examples: [
        {
          code: `* import { Effect, Cause, Option, Console } from "effect"
 *
 * // Simulating a runtime error
 * const task = Effect.dieMessage("Boom!")
 *
 * const program = Effect.catchSomeDefect(task, (defect) => {
 *   if (Cause.isIllegalArgumentException(defect)) {
 *     return Option.some(
 *       Console.log(
 *         \`Caught an IllegalArgumentException defect: \${defect.message}\`
 *       )
 *     )
 *   }
 *   return Option.none()
 * })
 *
 * // Since we are only catching IllegalArgumentException
 * // we will get an Exit.Failure because we simulated a runtime error.
 * Effect.runPromiseExit(program).then(console.log)
 * // Output:
 * // {
 * //   _id: 'Exit',
 * //   _tag: 'Failure',
 * //   cause: {
 * //     _id: 'Cause',
 * //     _tag: 'Die',
 * //     defect: { _tag: 'RuntimeException' }
 * //   }
 * // }
 *`
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 6527,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L6527"
    },
    {
      id: "effect.catchTag",
      name: "catchTag",
      module: "effect",
      package: "effect",
      signature: '{ <E, const K extends RA.NonEmptyReadonlyArray<E extends { _tag: string; } ? E["_tag"] : never>, A1, E1, R1>(...args: [...tags: K, f: (e: Extract<NoInfer<E>, { _tag: K[number]; }>) => Effect<A1, E1, R1>]): <A, R>(self: Effect<A, E, R>) => Effect<A1 | A, E1 | Exclude<E, { _tag: K[number]; }>, R1 | R>; <A, E, R, const K extends RA.NonEmptyReadonlyArray<E extends { _tag: string; } ? E["_tag"] : never>, A1, E1, R1>(self: Effect<A, E, R>, ...args: [...tags: K, f: (e: Extract<NoInfer<E>, { _tag: K[number]; }>) => Effect<A1, E1, R1>]): Effect<A | A1, E1 | Exclude<E, { _tag: K[number]; }>, R | R1>; }',
      description: "Catches and handles specific errors by their `_tag` field, which is used as a\ndiscriminator.",
      documentation: 'Catches and handles specific errors by their `_tag` field, which is used as a\ndiscriminator.\n\n**When to Use**\n\n`catchTag` is useful when your errors are tagged with a readonly `_tag` field\nthat identifies the error type. You can use this function to handle specific\nerror types by matching the `_tag` value. This allows for precise error\nhandling, ensuring that only specific errors are caught and handled.\n\nThe error type must have a readonly `_tag` field to use `catchTag`. This\nfield is used to identify and match errors.\n\n**Example** (Handling Errors by Tag)\n\n```ts\nimport { Effect, Random } from "effect"\n\nclass HttpError {\n  readonly _tag = "HttpError"\n}\n\nclass ValidationError {\n  readonly _tag = "ValidationError"\n}\n\n//      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return "some result"\n})\n\n//      \u250C\u2500\u2500\u2500 Effect<string, ValidationError, never>\n//      \u25BC\nconst recovered = program.pipe(\n  // Only handle HttpError errors\n  Effect.catchTag("HttpError", (_HttpError) =>\n    Effect.succeed("Recovering from HttpError")\n  )\n)\n```',
      examples: [
        {
          title: "Handling Errors by Tag",
          code: 'import { Effect, Random } from "effect"\n\nclass HttpError {\n  readonly _tag = "HttpError"\n}\n\nclass ValidationError {\n  readonly _tag = "ValidationError"\n}\n\n//      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return "some result"\n})\n\n//      \u250C\u2500\u2500\u2500 Effect<string, ValidationError, never>\n//      \u25BC\nconst recovered = program.pipe(\n  // Only handle HttpError errors\n  Effect.catchTag("HttpError", (_HttpError) =>\n    Effect.succeed("Recovering from HttpError")\n  )\n)'
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 6714,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L6714"
    },
    {
      id: "effect.catchTags",
      name: "catchTags",
      module: "effect",
      package: "effect",
      signature: '{ <E, Cases extends { [K in Extract<E, { _tag: string; }>["_tag"]]+?: ((error: Extract<E, { _tag: K; }>) => Effect<any, any, any>); } & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string; }>["_tag"]>]: never; })>(cases: Cases): <A, R>(self: Effect<A, E, R>) => Effect<A | { [K in keyof Cases]: Cases[K] extends (...args: any[]) => Effect<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: any[]) => Effect<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: any[]) => Effect<any, any, infer R> ? R : never; }[keyof Cases]>; <R, E, A, Cases extends { [K in Extract<E, { _tag: string; }>["_tag"]]+?: ((error: Extract<E, { _tag: K; }>) => Effect<any, any, any>); } & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string; }>["_tag"]>]: never; })>(self: Effect<A, E, R>, cases: Cases): Effect<A | { [K in keyof Cases]: Cases[K] extends (...args: any[]) => Effect<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: any[]) => Effect<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: any[]) => Effect<any, any, infer R> ? R : never; }[keyof Cases]>; }',
      description: "/\n * Handles multiple errors in a single block of code using their `_tag` field.\n *\n *",
      documentation: '/**\n * Handles multiple errors in a single block of code using their `_tag` field.\n *\n * **When to Use**\n *\n * `catchTags` is a convenient way to handle multiple error types at\n * once. Instead of using {@link catchTag}multiple times, you can pass an\n * object where each key is an error type\'s `_tag`, and the value is the handler\n * for that specific error. This allows you to catch and recover from multiple\n * error types in a single call.\n *\n * The error type must have a readonly `_tag` field to use `catchTag`. This\n * field is used to identify and match errors.\n *\n * **Example** (Handling Multiple Tagged Error Types at Once)\n *\n * ```ts\n * import { Effect, Random } from "effect"\n *\n * class HttpError {\n *   readonly _tag = "HttpError"\n * }\n *\n * class ValidationError {\n *   readonly _tag = "ValidationError"\n * }\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n * //      \u25BC\n * const program = Effect.gen(function* () {\n *   const n1 = yield* Random.next\n *   const n2 = yield* Random.next\n *   if (n1 < 0.5) {\n *     yield* Effect.fail(new HttpError())\n *   }\n *   if (n2 < 0.5) {\n *     yield* Effect.fail(new ValidationError())\n *   }\n *   return "some result"\n * })\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, never, never>\n * //      \u25BC\n * const recovered = program.pipe(\n *   Effect.catchTags({\n *     HttpError: (_HttpError) =>\n *       Effect.succeed(`Recovering from HttpError`),\n *     ValidationError: (_ValidationError) =>\n *       Effect.succeed(`Recovering from ValidationError`)\n *   })\n * )\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect, Random } from "effect"\n *\n * class HttpError {\n *   readonly _tag = "HttpError"\n * }\n *\n * class ValidationError {\n *   readonly _tag = "ValidationError"\n * }\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n * //      \u25BC\n * const program = Effect.gen(function* () {\n *   const n1 = yield* Random.next\n *   const n2 = yield* Random.next\n *   if (n1 < 0.5) {\n *     yield* Effect.fail(new HttpError())\n *   }\n *   if (n2 < 0.5) {\n *     yield* Effect.fail(new ValidationError())\n *   }\n *   return "some result"\n * })\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, never, never>\n * //      \u25BC\n * const recovered = program.pipe(\n *   Effect.catchTags({\n *     HttpError: (_HttpError) =>\n *       Effect.succeed(`Recovering from HttpError`),\n *     ValidationError: (_ValidationError) =>\n *       Effect.succeed(`Recovering from ValidationError`)\n *   })\n * )\n *'
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 6900,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L6900"
    },
    {
      id: "effect.cause",
      name: "cause",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<Cause<E>, never, R>",
      description: "Retrieves the cause of a failure in an effect.",
      documentation: 'Retrieves the cause of a failure in an effect.\n\n**Details**\n\nThis function allows you to expose the detailed cause of an effect, which\nincludes a more precise representation of failures, such as error messages\nand defects.\n\n**When to Use**\n\nThis function is helpful when you need to inspect the cause of a failure in\nan effect, giving you more information than just the error message. It can be\nused to log, handle, or analyze failures in more detail, including\ndistinguishing between different types of defects (e.g., runtime exceptions,\ninterruptions, etc.).\n\n**Example**\n\n```ts\nimport { Effect, Console } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, string, never>\n//      \u25BC\nconst program = Effect.fail("Oh uh!").pipe(Effect.as(2))\n\n//      \u250C\u2500\u2500\u2500 Effect<void, never, never>\n//      \u25BC\nconst recovered = Effect.gen(function* () {\n  const cause = yield* Effect.cause(program)\n  yield* Console.log(cause)\n})\n```',
      examples: [
        {
          code: 'import { Effect, Console } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, string, never>\n//      \u25BC\nconst program = Effect.fail("Oh uh!").pipe(Effect.as(2))\n\n//      \u250C\u2500\u2500\u2500 Effect<void, never, never>\n//      \u25BC\nconst recovered = Effect.gen(function* () {\n  const cause = yield* Effect.cause(program)\n  yield* Console.log(cause)\n})'
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 7089,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L7089"
    },
    {
      id: "effect.eventually",
      name: "eventually",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, never, R>",
      description: "Runs an effect repeatedly until it succeeds, ignoring errors.",
      documentation: 'Runs an effect repeatedly until it succeeds, ignoring errors.\n\n**Details**\n\nThis function takes an effect and runs it repeatedly until the effect\nsuccessfully completes. If the effect fails, it will ignore the error and\nretry the operation. This is useful when you need to perform a task that may\nfail occasionally, but you want to keep trying until it eventually succeeds.\nIt works by repeatedly executing the effect until it no longer throws an\nerror.\n\n**When to Use**\n\nUse this function when you want to retry an operation multiple times until it\nsucceeds. It is helpful in cases where the operation may fail temporarily\n(e.g., a network request), and you want to keep trying without handling or\nworrying about the errors.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nlet counter = 0\n\nconst effect = Effect.try(() => {\n  counter++\n  if (counter < 3) {\n    console.log("running effect")\n    throw new Error("error")\n  } else {\n    console.log("effect done")\n    return "some result"\n  }\n})\n\nconst program = Effect.eventually(effect)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// running effect\n// running effect\n// effect done\n// some result\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nlet counter = 0\n\nconst effect = Effect.try(() => {\n  counter++\n  if (counter < 3) {\n    console.log("running effect")\n    throw new Error("error")\n  } else {\n    console.log("effect done")\n    return "some result"\n  }\n})\n\nconst program = Effect.eventually(effect)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// running effect\n// running effect\n// effect done\n// some result'
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 7140,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L7140"
    },
    {
      id: "effect.ignore",
      name: "ignore",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<void, never, R>",
      description: "Discards both the success and failure values of an effect.",
      documentation: 'Discards both the success and failure values of an effect.\n\n**When to Use**\n\n`ignore` allows you to run an effect without caring about its result, whether\nit succeeds or fails. This is useful when you only care about the side\neffects of the effect and do not need to handle or process its outcome.\n\n**Example** (Using Effect.ignore to Discard Values)\n\n```ts\nimport { Effect } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, string, never>\n//      \u25BC\nconst task = Effect.fail("Uh oh!").pipe(Effect.as(5))\n\n//      \u250C\u2500\u2500\u2500 Effect<void, never, never>\n//      \u25BC\nconst program = Effect.ignore(task)\n```',
      examples: [
        {
          title: "Using Effect.ignore to Discard Values",
          code: 'import { Effect } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, string, never>\n//      \u25BC\nconst task = Effect.fail("Uh oh!").pipe(Effect.as(5))\n\n//      \u250C\u2500\u2500\u2500 Effect<void, never, never>\n//      \u25BC\nconst program = Effect.ignore(task)'
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 7169,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L7169"
    },
    {
      id: "effect.ignoreLogged",
      name: "ignoreLogged",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<void, never, R>",
      description: "Ignores the result of an effect but logs any failures.",
      documentation: "Ignores the result of an effect but logs any failures.\n\n**Details**\n\nThis function takes an effect and returns a new effect that ignores whether\nthe original effect succeeds or fails. However, if the effect fails, it will\nlog the failure at the Debug level, so you can keep track of any issues that\narise.\n\n**When to Use**\n\nThis is useful in scenarios where you want to continue with your program\nregardless of the result of the effect, but you still want to be aware of\npotential failures that may need attention later.",
      examples: [],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 7189,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L7189"
    },
    {
      id: "effect.parallelErrors",
      name: "parallelErrors",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, E[], R>",
      description: "Combines all errors from concurrent operations into a single error.",
      documentation: `Combines all errors from concurrent operations into a single error.

**Details**

This function is used when you have multiple operations running at the same
time, and you want to capture all the errors that occur across those
operations. Instead of handling each error separately, it combines all the
errors into one unified error.

**When to Use**

When using this function, any errors that occur in the concurrently running
operations will be grouped together into a single error. This helps simplify
error handling in cases where you don't need to differentiate between each
failure, but simply want to know that multiple failures occurred.

**Example**

\`\`\`ts
import { Effect } from "effect"

const fail1 = Effect.fail("Oh uh!")
const fail2 = Effect.fail("Oh no!")
const die = Effect.dieMessage("Boom!")

// Run all effects concurrently and capture all errors
const program = Effect.all([fail1, fail2, die], {
  concurrency: "unbounded"
}).pipe(Effect.asVoid, Effect.parallelErrors)

Effect.runPromiseExit(program).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: [ 'Oh uh!', 'Oh no!' ] }
// }
\`\`\``,
      examples: [
        {
          code: `import { Effect } from "effect"

const fail1 = Effect.fail("Oh uh!")
const fail2 = Effect.fail("Oh no!")
const die = Effect.dieMessage("Boom!")

// Run all effects concurrently and capture all errors
const program = Effect.all([fail1, fail2, die], {
  concurrency: "unbounded"
}).pipe(Effect.asVoid, Effect.parallelErrors)

Effect.runPromiseExit(program).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: [ 'Oh uh!', 'Oh no!' ] }
// }`
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 7233,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L7233"
    },
    {
      id: "effect.sandbox",
      name: "sandbox",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, Cause<E>, R>",
      description: "/\n * Transforms an effect to expose detailed error causes.\n *\n *",
      documentation: '/**\n * Transforms an effect to expose detailed error causes.\n *\n * **Details**\n *\n * This function enhances an effect by providing detailed information about any\n * error, defect, or interruption that may occur during its execution. It\n * modifies the error channel of the effect so that it includes a full cause of\n * the failure, wrapped in a `Cause<E>` type.\n *\n * After applying this function, you can use operators like {@link catchAll}and\n * {@link catchTags}to handle specific types of errors.\n *\n * If you no longer need the detailed cause information, you can revert the\n * changes using {@link unsandbox}to return to the original error-handling\n * behavior.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Console } from "effect"\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, Error, never>\n * //      \u25BC\n * const task = Effect.fail(new Error("Oh uh!")).pipe(\n *   Effect.as("primary result")\n * )\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, Cause<Error>, never>\n * //      \u25BC\n * const sandboxed = Effect.sandbox(task)\n *\n * const program = Effect.catchTags(sandboxed, {\n *   Die: (cause) =>\n *     Console.log(`Caught a defect: ${cause.defect}`).pipe(\n *       Effect.as("fallback result on defect")\n *     ),\n *   Interrupt: (cause) =>\n *     Console.log(`Caught a defect: ${cause.fiberId}`).pipe(\n *       Effect.as("fallback result on fiber interruption")\n *     ),\n *   Fail: (cause) =>\n *     Console.log(`Caught a defect: ${cause.error}`).pipe(\n *       Effect.as("fallback result on failure")\n *     )\n * })\n *\n * // Restore the original error handling with unsandbox\n * const main = Effect.unsandbox(program)\n *\n * Effect.runPromise(main).then(console.log)\n * // Output:\n * // Caught a defect: Oh uh!\n * // fallback result on failure\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect, Console } from "effect"\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, Error, never>\n * //      \u25BC\n * const task = Effect.fail(new Error("Oh uh!")).pipe(\n *   Effect.as("primary result")\n * )\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, Cause<Error>, never>\n * //      \u25BC\n * const sandboxed = Effect.sandbox(task)\n *\n * const program = Effect.catchTags(sandboxed, {\n *   Die: (cause) =>\n *     Console.log(`Caught a defect: ${cause.defect}`).pipe(\n *       Effect.as("fallback result on defect")\n *     ),\n *   Interrupt: (cause) =>\n *     Console.log(`Caught a defect: ${cause.fiberId}`).pipe(\n *       Effect.as("fallback result on fiber interruption")\n *     ),\n *   Fail: (cause) =>\n *     Console.log(`Caught a defect: ${cause.error}`).pipe(\n *       Effect.as("fallback result on failure")\n *     )\n * })\n *\n * // Restore the original error handling with unsandbox\n * const main = Effect.unsandbox(program)\n *\n * Effect.runPromise(main).then(console.log)\n * // Output:\n * // Caught a defect: Oh uh!\n * // fallback result on failure\n *'
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 7295,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L7295"
    },
    {
      id: "effect.retry",
      name: "retry",
      module: "effect",
      package: "effect",
      signature: "{ <E, O extends NoExcessProperties<Retry.Options<E>, O>>(options: O): <A, R>(self: Effect<A, E, R>) => Effect<A, (O extends { schedule: Schedule<infer _O, infer _I, infer _R>; } ? E : O extends { until: Refinement<E, infer E2 extends E>; } ? E2 : E) | (O extends { while: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never), R | (O extends { schedule: Schedule<infer _O, infer _I, infer R>; } ? R : never) | (O extends { while: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never)>; <B, E, R1>(policy: Schedule<B, NoInfer<E>, R1>): <A, R>(self: Effect<A, E, R>) => Effect<A, E, R1 | R>; <A, E, R, O extends NoExcessProperties<Retry.Options<E>, O>>(self: Effect<A, E, R>, options: O): Effect<A, (O extends { schedule: Schedule<infer _O, infer _I, infer _R>; } ? E : O extends { until: Refinement<E, infer E2 extends E>; } ? E2 : E) | (O extends { while: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never), R | (O extends { schedule: Schedule<infer _O, infer _I, infer R>; } ? R : never) | (O extends { while: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never)>; <A, E, R, B, R1>(self: Effect<A, E, R>, policy: Schedule<B, NoInfer<E>, R1>): Effect<A, E, R | R1>; }",
      description: "/\n * Retries a failing effect based on a defined retry policy.\n *\n *",
      documentation: '/**\n * Retries a failing effect based on a defined retry policy.\n *\n * **Details**\n *\n * The `Effect.retry` function takes an effect and a {@link Schedule}policy,\n * and will automatically retry the effect if it fails, following the rules of\n * the policy.\n *\n * If the effect ultimately succeeds, the result will be returned.\n *\n * If the maximum retries are exhausted and the effect still fails, the failure\n * is propagated.\n *\n * **When to Use**\n *\n * This can be useful when dealing with intermittent failures, such as network\n * issues or temporary resource unavailability. By defining a retry policy, you\n * can control the number of retries, the delay between them, and when to stop\n * retrying.\n *\n * **Example** (Retrying with a Fixed Delay)\n *\n * ```ts\n * import { Effect, Schedule } from "effect"\n *\n * let count = 0\n *\n * // Simulates an effect with possible failures\n * const task = Effect.async<string, Error>((resume) => {\n *   if (count <= 2) {\n *     count++\n *     console.log("failure")\n *     resume(Effect.fail(new Error()))\n *   } else {\n *     console.log("success")\n *     resume(Effect.succeed("yay!"))\n *   }\n * })\n *\n * // Define a repetition policy using a fixed delay between retries\n * const policy = Schedule.fixed("100 millis")\n *\n * const repeated = Effect.retry(task, policy)\n *\n * Effect.runPromise(repeated).then(console.log)\n * // Output:\n * // failure\n * // failure\n * // failure\n * // success\n * // yay!\n * ```\n *\n * **Example** (Retrying a Task up to 5 times)\n *\n * ```ts\n * import { Effect } from "effect"\n *\n * let count = 0\n *\n * // Simulates an effect with possible failures\n * const task = Effect.async<string, Error>((resume) => {\n *   if (count <= 2) {\n *     count++\n *     console.log("failure")\n *     resume(Effect.fail(new Error()))\n *   } else {\n *     console.log("success")\n *     resume(Effect.succeed("yay!"))\n *   }\n * })\n *\n * // Retry the task up to 5 times\n * Effect.runPromise(Effect.retry(task, { times: 5 })).then(console.log)\n * // Output:\n * // failure\n * // failure\n * // failure\n * // success\n * ```\n *\n * **Example** (Retrying Until a Specific Condition is Met)\n *\n * ```ts\n * import { Effect } from "effect"\n *\n * let count = 0\n *\n * // Define an effect that simulates varying error on each invocation\n * const action = Effect.failSync(() => {\n *   console.log(`Action called ${++count} time(s)`)\n *   return `Error ${count}`\n * })\n *\n * // Retry the action until a specific condition is met\n * const program = Effect.retry(action, {\n *   until: (err) => err === "Error 3"\n * })\n *\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // Action called 1 time(s)\n * // Action called 2 time(s)\n * // Action called 3 time(s)\n * // {\n * //   _id: \'Exit\',\n * //   _tag: \'Failure\',\n * //   cause: { _id: \'Cause\', _tag: \'Fail\', failure: \'Error 3\' }\n * // }\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect, Schedule } from "effect"\n *\n * let count = 0\n *\n * // Simulates an effect with possible failures\n * const task = Effect.async<string, Error>((resume) => {\n *   if (count <= 2) {\n *     count++\n *     console.log("failure")\n *     resume(Effect.fail(new Error()))\n *   } else {\n *     console.log("success")\n *     resume(Effect.succeed("yay!"))\n *   }\n * })\n *\n * // Define a repetition policy using a fixed delay between retries\n * const policy = Schedule.fixed("100 millis")\n *\n * const repeated = Effect.retry(task, policy)\n *\n * Effect.runPromise(repeated).then(console.log)\n * // Output:\n * // failure\n * // failure\n * // failure\n * // success\n * // yay!\n *'
        },
        {
          code: '* import { Effect } from "effect"\n *\n * let count = 0\n *\n * // Simulates an effect with possible failures\n * const task = Effect.async<string, Error>((resume) => {\n *   if (count <= 2) {\n *     count++\n *     console.log("failure")\n *     resume(Effect.fail(new Error()))\n *   } else {\n *     console.log("success")\n *     resume(Effect.succeed("yay!"))\n *   }\n * })\n *\n * // Retry the task up to 5 times\n * Effect.runPromise(Effect.retry(task, { times: 5 })).then(console.log)\n * // Output:\n * // failure\n * // failure\n * // failure\n * // success\n *'
        },
        {
          code: "* import { Effect } from \"effect\"\n *\n * let count = 0\n *\n * // Define an effect that simulates varying error on each invocation\n * const action = Effect.failSync(() => {\n *   console.log(`Action called ${++count} time(s)`)\n *   return `Error ${count}`\n * })\n *\n * // Retry the action until a specific condition is met\n * const program = Effect.retry(action, {\n *   until: (err) => err === \"Error 3\"\n * })\n *\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // Action called 1 time(s)\n * // Action called 2 time(s)\n * // Action called 3 time(s)\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Error 3' }\n * // }\n *"
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 7449,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L7449"
    },
    {
      id: "effect.withExecutionPlan",
      name: "withExecutionPlan",
      module: "effect",
      package: "effect",
      signature: "{ <Input, Provides, PlanE, PlanR>(plan: ExecutionPlan<{ provides: Provides; input: Input; error: PlanE; requirements: PlanR; }>): <A, E extends Input, R>(effect: Effect<A, E, R>) => Effect<A, PlanE | E, PlanR | Exclude<R, Provides>>; <A, E extends Input, R, Provides, Input, PlanE, PlanR>(effect: Effect<A, E, R>, plan: ExecutionPlan<{ provides: Provides; input: Input; error: PlanE; requirements: PlanR; }>): Effect<A, E | PlanE, PlanR | Exclude<R, Provides>>; }",
      description: "Apply an `ExecutionPlan` to the effect, which allows you to fallback to\ndifferent resources in case of failure.",
      documentation: "Apply an `ExecutionPlan` to the effect, which allows you to fallback to\ndifferent resources in case of failure.",
      examples: [],
      tags: [
        "Error handling"
      ],
      since: "3.16.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 7935,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L7935"
    },
    {
      id: "effect.retryOrElse",
      name: "retryOrElse",
      module: "effect",
      package: "effect",
      signature: "{ <A1, E, R1, A2, E2, R2>(policy: Schedule<A1, NoInfer<E>, R1>, orElse: (e: NoInfer<E>, out: A1) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R1 | R2 | R>; <A, E, R, A1, R1, A2, E2, R2>(self: Effect<A, E, R>, policy: Schedule<A1, NoInfer<E>, R1>, orElse: (e: NoInfer<E>, out: A1) => Effect<A2, E2, R2>): Effect<A | A2, E2, R | R1 | R2>; }",
      description: "/\n * Retries a failing effect and runs a fallback effect if retries are exhausted.\n *\n *",
      documentation: '/**\n * Retries a failing effect and runs a fallback effect if retries are exhausted.\n *\n * **Details**\n *\n * The `Effect.retryOrElse` function attempts to retry a failing effect multiple\n * times according to a defined {@link Schedule}policy.\n *\n * If the retries are exhausted and the effect still fails, it runs a fallback\n * effect instead.\n *\n * **When to Use**\n *\n * This function is useful when you want to handle failures gracefully by\n * specifying an alternative action after repeated failures.\n *\n * **Example** (Retrying with Fallback)\n *\n * ```ts\n * import { Effect, Schedule, Console } from "effect"\n *\n * let count = 0\n *\n * // Simulates an effect with possible failures\n * const task = Effect.async<string, Error>((resume) => {\n *   if (count <= 2) {\n *     count++\n *     console.log("failure")\n *     resume(Effect.fail(new Error()))\n *   } else {\n *     console.log("success")\n *     resume(Effect.succeed("yay!"))\n *   }\n * })\n *\n * // Retry the task with a delay between retries and a maximum of 2 retries\n * const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")\n *\n * // If all retries fail, run the fallback effect\n * const repeated = Effect.retryOrElse(\n *   task,\n *   policy,\n *   // fallback\n *   () => Console.log("orElse").pipe(Effect.as("default value"))\n * )\n *\n * Effect.runPromise(repeated).then(console.log)\n * // Output:\n * // failure\n * // failure\n * // failure\n * // orElse\n * // default value\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect, Schedule, Console } from "effect"\n *\n * let count = 0\n *\n * // Simulates an effect with possible failures\n * const task = Effect.async<string, Error>((resume) => {\n *   if (count <= 2) {\n *     count++\n *     console.log("failure")\n *     resume(Effect.fail(new Error()))\n *   } else {\n *     console.log("success")\n *     resume(Effect.succeed("yay!"))\n *   }\n * })\n *\n * // Retry the task with a delay between retries and a maximum of 2 retries\n * const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")\n *\n * // If all retries fail, run the fallback effect\n * const repeated = Effect.retryOrElse(\n *   task,\n *   policy,\n *   // fallback\n *   () => Console.log("orElse").pipe(Effect.as("default value"))\n * )\n *\n * Effect.runPromise(repeated).then(console.log)\n * // Output:\n * // failure\n * // failure\n * // failure\n * // orElse\n * // default value\n *'
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8025,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8025"
    },
    {
      id: "effect.tryMap",
      name: "tryMap",
      module: "effect",
      package: "effect",
      signature: "{ <A, B, E1>(options: { readonly try: (a: A) => B; readonly catch: (error: unknown) => E1; }): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R>; <A, E, R, B, E1>(self: Effect<A, E, R>, options: { readonly try: (a: A) => B; readonly catch: (error: unknown) => E1; }): Effect<B, E | E1, R>; }",
      description: "Returns an effect that maps its success using the specified side-effecting\n`try` function, converting any errors into typed failed effects using the\n`catch` function.",
      documentation: "Returns an effect that maps its success using the specified side-effecting\n`try` function, converting any errors into typed failed effects using the\n`catch` function.",
      examples: [],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8227,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8227"
    },
    {
      id: "effect.tryMapPromise",
      name: "tryMapPromise",
      module: "effect",
      package: "effect",
      signature: "{ <A, B, E1>(options: { readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>; readonly catch: (error: unknown) => E1; }): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R>; <A, E, R, B, E1>(self: Effect<A, E, R>, options: { readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>; readonly catch: (error: unknown) => E1; }): Effect<B, E | E1, R>; }",
      description: "Returns an effect that maps its success using the specified side-effecting\n`try` function, converting any promise rejections into typed failed effects\nusing the `catch` function. An optional `AbortSignal` can be provided to allow for interruption of the\nwrapped `Promise` API.",
      documentation: "Returns an effect that maps its success using the specified side-effecting\n`try` function, converting any promise rejections into typed failed effects\nusing the `catch` function.\n\nAn optional `AbortSignal` can be provided to allow for interruption of the\nwrapped `Promise` API.",
      examples: [],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8270,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8270"
    },
    {
      id: "effect.tryPromise",
      name: "tryPromise",
      module: "effect",
      package: "effect",
      signature: "{ <A, E>(options: { readonly try: (signal: AbortSignal) => PromiseLike<A>; readonly catch: (error: unknown) => E; }): Effect<A, E, never>; <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>): Effect<A, UnknownException, never>; }",
      description: "Creates an `Effect` that represents an asynchronous computation that might\nfail.",
      documentation: 'Creates an `Effect` that represents an asynchronous computation that might\nfail.\n\n**When to Use**\n\nIn situations where you need to perform asynchronous operations that might\nfail, such as fetching data from an API, you can use the `tryPromise`\nconstructor. This constructor is designed to handle operations that could\nthrow exceptions by capturing those exceptions and transforming them into\nmanageable errors.\n\n**Error Handling**\n\nThere are two ways to handle errors with `tryPromise`:\n\n1. If you don\'t provide a `catch` function, the error is caught and the\n   effect fails with an `UnknownException`.\n2. If you provide a `catch` function, the error is caught and the `catch`\n   function maps it to an error of type `E`.\n\n**Interruptions**\n\nAn optional `AbortSignal` can be provided to allow for interruption of the\nwrapped `Promise` API.\n\n**Example** (Fetching a TODO Item)\n\n```ts\nimport { Effect } from "effect"\n\nconst getTodo = (id: number) =>\n  // Will catch any errors and propagate them as UnknownException\n  Effect.tryPromise(() =>\n    fetch(`https://jsonplaceholder.typicode.com/todos/${id}`)\n  )\n\n//      \u250C\u2500\u2500\u2500 Effect<Response, UnknownException, never>\n//      \u25BC\nconst program = getTodo(1)\n```\n\n**Example** (Custom Error Handling)\n\n```ts\nimport { Effect } from "effect"\n\nconst getTodo = (id: number) =>\n  Effect.tryPromise({\n    try: () => fetch(`https://jsonplaceholder.typicode.com/todos/${id}`),\n    // remap the error\n    catch: (unknown) => new Error(`something went wrong ${unknown}`)\n  })\n\n//      \u250C\u2500\u2500\u2500 Effect<Response, Error, never>\n//      \u25BC\nconst program = getTodo(1)\n```',
      examples: [
        {
          title: "Fetching a TODO Item",
          code: 'import { Effect } from "effect"\n\nconst getTodo = (id: number) =>\n  // Will catch any errors and propagate them as UnknownException\n  Effect.tryPromise(() =>\n    fetch(`https://jsonplaceholder.typicode.com/todos/${id}`)\n  )\n\n//      \u250C\u2500\u2500\u2500 Effect<Response, UnknownException, never>\n//      \u25BC\nconst program = getTodo(1)'
        },
        {
          title: "Custom Error Handling",
          code: 'import { Effect } from "effect"\n\nconst getTodo = (id: number) =>\n  Effect.tryPromise({\n    try: () => fetch(`https://jsonplaceholder.typicode.com/todos/${id}`),\n    // remap the error\n    catch: (unknown) => new Error(`something went wrong ${unknown}`)\n  })\n\n//      \u250C\u2500\u2500\u2500 Effect<Response, Error, never>\n//      \u25BC\nconst program = getTodo(1)'
        }
      ],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8370,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8370"
    },
    {
      id: "effect.unsandbox",
      name: "unsandbox",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, Cause<E>, R>) => Effect<A, E, R>",
      description: "/\n * The `unsandbox` function is used to revert an effect that has been\n * sandboxed by {@link sandbox}. When you apply `unsandbox`, the\n * effect's error channel is restored to its original state, without the\n * detailed `Cause<E>` information. This means that any underlying causes of\n * errors, defects, or fiber interruptions are no longer exposed in the error\n * channel.\n *\n * This function is useful when you want to remove the detailed error tracking\n * provided by `sandbox` and return to the standard error handling for\n * your effect. Once unsandboxed, the effect behaves as if `sandbox` was\n * never applied.\n *\n *",
      documentation: "/**\n * The `unsandbox` function is used to revert an effect that has been\n * sandboxed by {@link sandbox}. When you apply `unsandbox`, the\n * effect's error channel is restored to its original state, without the\n * detailed `Cause<E>` information. This means that any underlying causes of\n * errors, defects, or fiber interruptions are no longer exposed in the error\n * channel.\n *\n * This function is useful when you want to remove the detailed error tracking\n * provided by `sandbox` and return to the standard error handling for\n * your effect. Once unsandboxed, the effect behaves as if `sandbox` was\n * never applied.\n *\n *",
      examples: [],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8523,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8523"
    },
    {
      id: "effect.allowInterrupt",
      name: "allowInterrupt",
      module: "effect",
      package: "effect",
      signature: "Effect<void, never, never>",
      description: "Allows interruption of the current fiber, even in uninterruptible regions.",
      documentation: "Allows interruption of the current fiber, even in uninterruptible regions.\n\n**Details**\n\nThis effect checks whether any other fibers are attempting to interrupt the\ncurrent fiber. If so, it allows the current fiber to perform a\nself-interruption.\n\n**When to Use**\n\nThis is useful in situations where you want to allow interruption to happen\neven in regions of the code that are normally uninterruptible.",
      examples: [],
      tags: [
        "Interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8541,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8541"
    },
    {
      id: "effect.checkInterruptible",
      name: "checkInterruptible",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(f: (isInterruptible: boolean) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "Checks if interruption is allowed and executes a callback accordingly.",
      documentation: 'Checks if interruption is allowed and executes a callback accordingly.\n\n**Details**\n\nThis function checks the current interrupt status of the running fiber. It\nthen calls the provided callback, passing a boolean indicating whether\ninterruption is allowed.\n\n**When to Use**\n\nThis is useful for handling specific logic based on whether the current\noperation can be interrupted, such as when performing asynchronous operations\nor handling cancellation.\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.checkInterruptible((isInterruptible) => {\n    if (isInterruptible) {\n      return Console.log("You can interrupt this operation.")\n    } else {\n      return Console.log("This operation cannot be interrupted.")\n    }\n  })\n})\n\nEffect.runPromise(program)\n// Output: You can interrupt this operation.\n\nEffect.runPromise(program.pipe(Effect.uninterruptible))\n// Output: This operation cannot be interrupted.\n\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.checkInterruptible((isInterruptible) => {\n    if (isInterruptible) {\n      return Console.log("You can interrupt this operation.")\n    } else {\n      return Console.log("This operation cannot be interrupted.")\n    }\n  })\n})\n\nEffect.runPromise(program)\n// Output: You can interrupt this operation.\n\nEffect.runPromise(program.pipe(Effect.uninterruptible))\n// Output: This operation cannot be interrupted.'
        }
      ],
      tags: [
        "Interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8583,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8583"
    },
    {
      id: "effect.disconnect",
      name: "disconnect",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>",
      description: "Provides a way to handle timeouts in uninterruptible effects, allowing them\nto continue in the background while the main control flow proceeds with the\ntimeout error.",
      documentation: 'Provides a way to handle timeouts in uninterruptible effects, allowing them\nto continue in the background while the main control flow proceeds with the\ntimeout error.\n\n**Details**\n\nThe `disconnect` function allows an uninterruptible effect to continue\nrunning in the background, while enabling the main control flow to\nimmediately recognize a timeout condition. This is useful when you want to\navoid blocking the program due to long-running tasks, especially when those\ntasks do not need to affect the flow of the rest of the program.\n\nWithout `disconnect`, an uninterruptible effect will ignore the\ntimeout and continue executing until it completes. The timeout error will\nonly be assessed after the effect finishes, which can cause delays in\nrecognizing a timeout.\n\nWith `disconnect`, the uninterruptible effect proceeds in the\nbackground while the main program flow can immediately handle the timeout\nerror or trigger alternative logic. This enables faster timeout handling\nwithout waiting for the completion of the long-running task.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst longRunningTask = Effect.gen(function* () {\n  console.log("Start heavy processing...")\n  yield* Effect.sleep("5 seconds") // Simulate a long process\n  console.log("Heavy processing done.")\n  return "Data processed"\n})\n\nconst timedEffect = longRunningTask.pipe(\n  Effect.uninterruptible,\n  // Allows the task to finish in the background if it times out\n  Effect.disconnect,\n  Effect.timeout("1 second")\n)\n\nEffect.runPromiseExit(timedEffect).then(console.log)\n// Output:\n// Start heavy processing...\n// {\n//   _id: \'Exit\',\n//   _tag: \'Failure\',\n//   cause: {\n//     _id: \'Cause\',\n//     _tag: \'Fail\',\n//     failure: { _tag: \'TimeoutException\' }\n//   }\n// }\n// Heavy processing done.\n```',
      examples: [
        {
          code: `import { Effect } from "effect"

const longRunningTask = Effect.gen(function* () {
  console.log("Start heavy processing...")
  yield* Effect.sleep("5 seconds") // Simulate a long process
  console.log("Heavy processing done.")
  return "Data processed"
})

const timedEffect = longRunningTask.pipe(
  Effect.uninterruptible,
  // Allows the task to finish in the background if it times out
  Effect.disconnect,
  Effect.timeout("1 second")
)

Effect.runPromiseExit(timedEffect).then(console.log)
// Output:
// Start heavy processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: { _tag: 'TimeoutException' }
//   }
// }
// Heavy processing done.`
        }
      ],
      tags: [
        "Interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8647,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8647"
    },
    {
      id: "effect.interrupt",
      name: "interrupt",
      module: "effect",
      package: "effect",
      signature: "Effect<never, never, never>",
      description: "/\n * Represents an effect that interrupts the current fiber.\n *\n *",
      documentation: `/**
 * Represents an effect that interrupts the current fiber.
 *
 * **Details**
 *
 * This effect models the explicit interruption of the fiber in which it runs.
 * When executed, it causes the fiber to stop its operation immediately,
 * capturing the interruption details such as the fiber's ID and its start time.
 * The resulting interruption can be observed in the \`Exit\` type if the effect
 * is run with functions like {@link runPromiseExit}.
 *
 * **Example**
 *
 * \`\`\`ts
 * import { Effect } from "effect"
 *
 * const program = Effect.gen(function* () {
 *   console.log("start")
 *   yield* Effect.sleep("2 seconds")
 *   yield* Effect.interrupt
 *   console.log("done")
 *   return "some result"
 * })
 *
 * Effect.runPromiseExit(program).then(console.log)
 * // Output:
 * // start
 * // {
 * //   _id: 'Exit',
 * //   _tag: 'Failure',
 * //   cause: {
 * //     _id: 'Cause',
 * //     _tag: 'Interrupt',
 * //     fiberId: {
 * //       _id: 'FiberId',
 * //       _tag: 'Runtime',
 * //       id: 0,
 * //       startTimeMillis: ...
 * //     }
 * //   }
 * // }
 * \`\`\`
 *
 *`,
      examples: [
        {
          code: `* import { Effect } from "effect"
 *
 * const program = Effect.gen(function* () {
 *   console.log("start")
 *   yield* Effect.sleep("2 seconds")
 *   yield* Effect.interrupt
 *   console.log("done")
 *   return "some result"
 * })
 *
 * Effect.runPromiseExit(program).then(console.log)
 * // Output:
 * // start
 * // {
 * //   _id: 'Exit',
 * //   _tag: 'Failure',
 * //   cause: {
 * //     _id: 'Cause',
 * //     _tag: 'Interrupt',
 * //     fiberId: {
 * //       _id: 'FiberId',
 * //       _tag: 'Runtime',
 * //       id: 0,
 * //       startTimeMillis: ...
 * //     }
 * //   }
 * // }
 *`
        }
      ],
      tags: [
        "Interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8694,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8694"
    },
    {
      id: "effect.interruptWith",
      name: "interruptWith",
      module: "effect",
      package: "effect",
      signature: "(fiberId: FiberId) => Effect<never, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8699,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8699"
    },
    {
      id: "effect.interruptible",
      name: "interruptible",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>",
      description: "Marks an effect as interruptible.",
      documentation: "Marks an effect as interruptible.",
      examples: [],
      tags: [
        "Interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8706,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8706"
    },
    {
      id: "effect.interruptibleMask",
      name: "interruptibleMask",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(f: (restore: <AX, EX, RX>(effect: Effect<AX, EX, RX>) => Effect<AX, EX, RX>) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "/\n * This function behaves like {@link interruptible}, but it also provides a\n * `restore` function. This function can be used to restore the interruptibility\n * of any specific region of code.\n *\n *",
      documentation: "/**\n * This function behaves like {@link interruptible}, but it also provides a\n * `restore` function. This function can be used to restore the interruptibility\n * of any specific region of code.\n *\n *",
      examples: [],
      tags: [
        "Interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8715,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8715"
    },
    {
      id: "effect.onInterrupt",
      name: "onInterrupt",
      module: "effect",
      package: "effect",
      signature: "{ <X, R2>(cleanup: (interruptors: HashSet<FiberId>) => Effect<X, never, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, cleanup: (interruptors: HashSet<FiberId>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }",
      description: "Registers a cleanup effect to run when an effect is interrupted.",
      documentation: 'Registers a cleanup effect to run when an effect is interrupted.\n\n**Details**\n\nThis function allows you to specify an effect to run when the fiber is\ninterrupted. This effect will be executed when the fiber is interrupted,\nallowing you to perform cleanup or other actions.\n\n**Example** (Running a Cleanup Action on Interruption)\n\n```ts\nimport { Console, Effect } from "effect"\n\n// This handler is executed when the fiber is interrupted\nconst handler = Effect.onInterrupt((_fibers) => Console.log("Cleanup completed"))\n\nconst success = Console.log("Task completed").pipe(Effect.as("some result"), handler)\n\nEffect.runFork(success)\n// Output:\n// Task completed\n\nconst failure = Console.log("Task failed").pipe(Effect.andThen(Effect.fail("some error")), handler)\n\nEffect.runFork(failure)\n// Output:\n// Task failed\n\nconst interruption = Console.log("Task interrupted").pipe(Effect.andThen(Effect.interrupt), handler)\n\nEffect.runFork(interruption)\n// Output:\n// Task interrupted\n// Cleanup completed\n```',
      examples: [
        {
          title: "Running a Cleanup Action on Interruption",
          code: 'import { Console, Effect } from "effect"\n\n// This handler is executed when the fiber is interrupted\nconst handler = Effect.onInterrupt((_fibers) => Console.log("Cleanup completed"))\n\nconst success = Console.log("Task completed").pipe(Effect.as("some result"), handler)\n\nEffect.runFork(success)\n// Output:\n// Task completed\n\nconst failure = Console.log("Task failed").pipe(Effect.andThen(Effect.fail("some error")), handler)\n\nEffect.runFork(failure)\n// Output:\n// Task failed\n\nconst interruption = Console.log("Task interrupted").pipe(Effect.andThen(Effect.interrupt), handler)\n\nEffect.runFork(interruption)\n// Output:\n// Task interrupted\n// Cleanup completed'
        }
      ],
      tags: [
        "Interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8756,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8756"
    },
    {
      id: "effect.uninterruptible",
      name: "uninterruptible",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>",
      description: "Marks an effect as uninterruptible.",
      documentation: "Marks an effect as uninterruptible.",
      examples: [],
      tags: [
        "Interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8846,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8846"
    },
    {
      id: "effect.uninterruptibleMask",
      name: "uninterruptibleMask",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(f: (restore: <AX, EX, RX>(effect: Effect<AX, EX, RX>) => Effect<AX, EX, RX>) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "/\n * This function behaves like {@link uninterruptible}, but it also provides a\n * `restore` function. This function can be used to restore the interruptibility\n * of any specific region of code.\n *\n *",
      documentation: "/**\n * This function behaves like {@link uninterruptible}, but it also provides a\n * `restore` function. This function can be used to restore the interruptibility\n * of any specific region of code.\n *\n *",
      examples: [],
      tags: [
        "Interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8855,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8855"
    },
    {
      id: "effect.liftPredicate",
      name: "liftPredicate",
      module: "effect",
      package: "effect",
      signature: "{ <T extends A, E, B extends T = T, A = T>(predicate: Refinement<T, B> | Predicate<T>, orFailWith: (a: EqualsWith<T, B, A, Exclude<A, B>>) => E): (a: A) => Effect<EqualsWith<T, B, A, B>, E, never>; <A, E, B extends A = A>(self: A, predicate: Refinement<A, B> | Predicate<A>, orFailWith: (a: EqualsWith<A, B, A, Exclude<A, B>>) => E): Effect<B, E, never>; }",
      description: "Transforms a `Predicate` function into an `Effect` returning the input value if the predicate returns `true`\nor failing with specified error if the predicate fails",
      documentation: 'Transforms a `Predicate` function into an `Effect` returning the input value if the predicate returns `true`\nor failing with specified error if the predicate fails\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst isPositive = (n: number): boolean => n > 0\n\n// succeeds with `1`\nEffect.liftPredicate(1, isPositive, n => `${n} is not positive`)\n\n// fails with `"0 is not positive"`\nEffect.liftPredicate(0, isPositive, n => `${n} is not positive`)\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst isPositive = (n: number): boolean => n > 0\n\n// succeeds with `1`\nEffect.liftPredicate(1, isPositive, n => `${n} is not positive`)\n\n// fails with `"0 is not positive"`\nEffect.liftPredicate(0, isPositive, n => `${n} is not positive`)'
        }
      ],
      tags: [
        "Condition Checking"
      ],
      since: "3.4.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8877,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8877"
    },
    {
      id: "effect.as",
      name: "as",
      module: "effect",
      package: "effect",
      signature: "{ <B>(value: B): <A, E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A, E, R, B>(self: Effect<A, E, R>, value: B): Effect<B, E, R>; }",
      description: "Replaces the value inside an effect with a constant value.",
      documentation: 'Replaces the value inside an effect with a constant value.\n\n**Details**\n\nThis function allows you to ignore the original value inside an effect and\nreplace it with a constant value.\n\n**When to Use**\n\nIt is useful when you no longer need the value produced by an effect but want\nto ensure that the effect completes successfully with a specific constant\nresult instead. For instance, you can replace the value produced by a\ncomputation with a predefined value, ignoring what was calculated before.\n\n**Example** (Replacing a Value)\n\n```ts\nimport { pipe, Effect } from "effect"\n\n// Replaces the value 5 with the constant "new value"\nconst program = pipe(Effect.succeed(5), Effect.as("new value"))\n\nEffect.runPromise(program).then(console.log)\n// Output: "new value"\n```',
      examples: [
        {
          title: "Replacing a Value",
          code: 'import { pipe, Effect } from "effect"\n\n// Replaces the value 5 with the constant "new value"\nconst program = pipe(Effect.succeed(5), Effect.as("new value"))\n\nEffect.runPromise(program).then(console.log)\n// Output: "new value"'
        }
      ],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8953,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8953"
    },
    {
      id: "effect.asSome",
      name: "asSome",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<Option<A>, E, R>",
      description: "This function maps the success value of an `Effect` value to a `Some` value\nin an `Option` value. If the original `Effect` value fails, the returned\n`Effect` value will also fail.",
      documentation: "This function maps the success value of an `Effect` value to a `Some` value\nin an `Option` value. If the original `Effect` value fails, the returned\n`Effect` value will also fail.",
      examples: [],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9025,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9025"
    },
    {
      id: "effect.asSomeError",
      name: "asSomeError",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, Option<E>, R>",
      description: "This function maps the error value of an `Effect` value to a `Some` value\nin an `Option` value. If the original `Effect` value succeeds, the returned\n`Effect` value will also succeed.",
      documentation: "This function maps the error value of an `Effect` value to a `Some` value\nin an `Option` value. If the original `Effect` value succeeds, the returned\n`Effect` value will also succeed.",
      examples: [],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9034,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9034"
    },
    {
      id: "effect.asVoid",
      name: "asVoid",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<void, E, R>",
      description: "This function maps the success value of an `Effect` value to `void`. If the\noriginal `Effect` value succeeds, the returned `Effect` value will also\nsucceed. If the original `Effect` value fails, the returned `Effect` value\nwill fail with the same error.",
      documentation: "This function maps the success value of an `Effect` value to `void`. If the\noriginal `Effect` value succeeds, the returned `Effect` value will also\nsucceed. If the original `Effect` value fails, the returned `Effect` value\nwill fail with the same error.",
      examples: [],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9044,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9044"
    },
    {
      id: "effect.flip",
      name: "flip",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<E, A, R>",
      description: "Swaps the success and error channels of an effect.",
      documentation: 'Swaps the success and error channels of an effect.\n\n**Details**\n\nThis function reverses the flow of an effect by swapping its success and\nerror channels. The success value becomes an error, and the error value\nbecomes a success.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, string, never>\n//      \u25BC\nconst program = Effect.fail("Oh uh!").pipe(Effect.as(2))\n\n//      \u250C\u2500\u2500\u2500 Effect<string, number, never>\n//      \u25BC\nconst flipped = Effect.flip(program)\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, string, never>\n//      \u25BC\nconst program = Effect.fail("Oh uh!").pipe(Effect.as(2))\n\n//      \u250C\u2500\u2500\u2500 Effect<string, number, never>\n//      \u25BC\nconst flipped = Effect.flip(program)'
        }
      ],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9071,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9071"
    },
    {
      id: "effect.flipWith",
      name: "flipWith",
      module: "effect",
      package: "effect",
      signature: "{ <E, A, R, E2, A2, R2>(f: (effect: Effect<E, A, R>) => Effect<E2, A2, R2>): (self: Effect<A, E, R>) => Effect<A2, E2, R2>; <A, E, R, E2, A2, R2>(self: Effect<A, E, R>, f: (effect: Effect<E, A, R>) => Effect<E2, A2, R2>): Effect<A2, E2, R2>; }",
      description: "Swaps the error/value parameters, applies the function `f` and flips the\nparameters back",
      documentation: "Swaps the error/value parameters, applies the function `f` and flips the\nparameters back",
      examples: [],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9079,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9079"
    },
    {
      id: "effect.map",
      name: "map",
      module: "effect",
      package: "effect",
      signature: "{ <A, B>(f: (a: A) => B): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A, E, R, B>(self: Effect<A, E, R>, f: (a: A) => B): Effect<B, E, R>; }",
      description: "Transforms the value inside an effect by applying a function to it.",
      documentation: 'Transforms the value inside an effect by applying a function to it.\n\n**Syntax**\n\n```ts skip-type-checking\nconst mappedEffect = pipe(myEffect, Effect.map(transformation))\n// or\nconst mappedEffect = Effect.map(myEffect, transformation)\n// or\nconst mappedEffect = myEffect.pipe(Effect.map(transformation))\n```\n\n**Details**\n\n`map` takes a function and applies it to the value contained within an\neffect, creating a new effect with the transformed value.\n\nIt\'s important to note that effects are immutable, meaning that the original\neffect is not modified. Instead, a new effect is returned with the updated\nvalue.\n\n**Example** (Adding a Service Charge)\n\n```ts\nimport { pipe, Effect } from "effect"\n\nconst addServiceCharge = (amount: number) => amount + 1\n\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\nconst finalAmount = pipe(\n  fetchTransactionAmount,\n  Effect.map(addServiceCharge)\n)\n\nEffect.runPromise(finalAmount).then(console.log)\n// Output: 101\n```',
      examples: [
        {
          title: "Adding a Service Charge",
          code: 'import { pipe, Effect } from "effect"\n\nconst addServiceCharge = (amount: number) => amount + 1\n\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\nconst finalAmount = pipe(\n  fetchTransactionAmount,\n  Effect.map(addServiceCharge)\n)\n\nEffect.runPromise(finalAmount).then(console.log)\n// Output: 101'
        }
      ],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9144,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9144"
    },
    {
      id: "effect.mapAccum",
      name: "mapAccum",
      module: "effect",
      package: "effect",
      signature: "{ <S, A, B, E, R, I extends Iterable<A> = Iterable<A>>(initial: S, f: (state: S, a: ReadonlyArray.Infer<I>, i: number) => Effect<readonly [S, B], E, R>): (elements: I) => Effect<[S, ReadonlyArray.With<I, B>], E, R>; <A, S, B, E, R, I extends Iterable<A> = Iterable<A>>(elements: I, initial: S, f: (state: S, a: ReadonlyArray.Infer<I>, i: number) => Effect<readonly [S, B], E, R>): Effect<[S, ReadonlyArray.With<I, B>], E, R>; }",
      description: "Applies a stateful transformation to each element of a collection, producing\nnew elements along with an updated state.",
      documentation: 'Applies a stateful transformation to each element of a collection, producing\nnew elements along with an updated state.\n\n**When to Use**\n\nUse `mapAccum` when you need to process each element of a collection while\nkeeping track of some state across iterations.\n\n**Details**\n\n`mapAccum` takes an initial state (`initial`) and a function (`f`) that is\napplied to each element. This function returns a new state and a transformed\nelement. The final effect produces both the accumulated state and the\ntransformed collection.\n\nIf the input collection is a non-empty array, the return type will match the\ninput collection type.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\n// Define an initial state and a transformation function\nconst initialState = 0\n\nconst transformation = (state: number, element: string) =>\n  Effect.succeed<[number, string]>([state + element.length, element.toUpperCase()])\n\n// Apply mapAccum to transform an array of strings\nconst program = Effect.mapAccum(["a", "bb", "ccc"], initialState, transformation)\n\nEffect.runPromise(program).then(([finalState, transformedCollection]) => {\n  console.log(finalState)\n  console.log(transformedCollection)\n})\n// Output:\n// 6\n// [ \'A\', \'BB\', \'CCC\' ]\n```',
      examples: [
        {
          code: `import { Effect } from "effect"

// Define an initial state and a transformation function
const initialState = 0

const transformation = (state: number, element: string) =>
  Effect.succeed<[number, string]>([state + element.length, element.toUpperCase()])

// Apply mapAccum to transform an array of strings
const program = Effect.mapAccum(["a", "bb", "ccc"], initialState, transformation)

Effect.runPromise(program).then(([finalState, transformedCollection]) => {
  console.log(finalState)
  console.log(transformedCollection)
})
// Output:
// 6
// [ 'A', 'BB', 'CCC' ]`
        }
      ],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9287,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9287"
    },
    {
      id: "effect.mapBoth",
      name: "mapBoth",
      module: "effect",
      package: "effect",
      signature: "{ <E, E2, A, A2>(options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): <R>(self: Effect<A, E, R>) => Effect<A2, E2, R>; <A, E, R, E2, A2>(self: Effect<A, E, R>, options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): Effect<A2, E2, R>; }",
      description: "Applies transformations to both the success and error channels of an effect.",
      documentation: 'Applies transformations to both the success and error channels of an effect.\n\n**Details**\n\nThis function takes two map functions as arguments: one for the error channel\nand one for the success channel. You can use it when you want to modify both\nthe error and the success values without altering the overall success or\nfailure status of the effect.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, string, never>\n//      \u25BC\nconst simulatedTask = Effect.fail("Oh no!").pipe(Effect.as(1))\n\n//      \u250C\u2500\u2500\u2500 Effect<boolean, Error, never>\n//      \u25BC\nconst modified = Effect.mapBoth(simulatedTask, {\n  onFailure: (message) => new Error(message),\n  onSuccess: (n) => n > 0\n})\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, string, never>\n//      \u25BC\nconst simulatedTask = Effect.fail("Oh no!").pipe(Effect.as(1))\n\n//      \u250C\u2500\u2500\u2500 Effect<boolean, Error, never>\n//      \u25BC\nconst modified = Effect.mapBoth(simulatedTask, {\n  onFailure: (message) => new Error(message),\n  onSuccess: (n) => n > 0\n})'
        }
      ],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9414,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9414"
    },
    {
      id: "effect.mapError",
      name: "mapError",
      module: "effect",
      package: "effect",
      signature: "{ <E, E2>(f: (e: E) => E2): <A, R>(self: Effect<A, E, R>) => Effect<A, E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, f: (e: E) => E2): Effect<A, E2, R>; }",
      description: "Transforms or modifies the error produced by an effect without affecting its\nsuccess value.",
      documentation: 'Transforms or modifies the error produced by an effect without affecting its\nsuccess value.\n\n**When to Use**\n\nThis function is helpful when you want to enhance the error with additional\ninformation, change the error type, or apply custom error handling while\nkeeping the original behavior of the effect\'s success values intact. It only\noperates on the error channel and leaves the success channel unchanged.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, string, never>\n//      \u25BC\nconst simulatedTask = Effect.fail("Oh no!").pipe(Effect.as(1))\n\n//      \u250C\u2500\u2500\u2500 Effect<number, Error, never>\n//      \u25BC\nconst mapped = Effect.mapError(\n  simulatedTask,\n  (message) => new Error(message)\n)\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, string, never>\n//      \u25BC\nconst simulatedTask = Effect.fail("Oh no!").pipe(Effect.as(1))\n\n//      \u250C\u2500\u2500\u2500 Effect<number, Error, never>\n//      \u25BC\nconst mapped = Effect.mapError(\n  simulatedTask,\n  (message) => new Error(message)\n)'
        }
      ],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9525,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9525"
    },
    {
      id: "effect.mapErrorCause",
      name: "mapErrorCause",
      module: "effect",
      package: "effect",
      signature: "{ <E, E2>(f: (cause: Cause<E>) => Cause<E2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, f: (cause: Cause<E>) => Cause<E2>): Effect<A, E2, R>; }",
      description: "Maps the cause of failure of an effect using a specified function.",
      documentation: "Maps the cause of failure of an effect using a specified function.",
      examples: [],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9608,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9608"
    },
    {
      id: "effect.merge",
      name: "merge",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A | E, never, R>",
      description: "Combines both success and error channels of an effect into a single outcome.",
      documentation: 'Combines both success and error channels of an effect into a single outcome.\n\n**Details**\n\nThis function transforms an effect that may fail into one that always returns\na value, where both success and failure outcomes are handled as values in the\nsuccess channel.\n\n**When to Use**\n\nThis can be useful when you want to continue execution regardless of the\nerror type and still capture both successful results and errors as part of\nthe outcome.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, string, never>\n//      \u25BC\nconst program = Effect.fail("Oh uh!").pipe(Effect.as(2))\n\n//      \u250C\u2500\u2500\u2500 Effect<number | string, never, never>\n//      \u25BC\nconst recovered = Effect.merge(program)\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, string, never>\n//      \u25BC\nconst program = Effect.fail("Oh uh!").pipe(Effect.as(2))\n\n//      \u250C\u2500\u2500\u2500 Effect<number | string, never, never>\n//      \u25BC\nconst recovered = Effect.merge(program)'
        }
      ],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9662,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9662"
    },
    {
      id: "effect.negate",
      name: "negate",
      module: "effect",
      package: "effect",
      signature: "<E, R>(self: Effect<boolean, E, R>) => Effect<boolean, E, R>",
      description: "Returns a new effect with the boolean value of this effect negated.",
      documentation: "Returns a new effect with the boolean value of this effect negated.",
      examples: [],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9669,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9669"
    },
    {
      id: "effect.acquireRelease",
      name: "acquireRelease",
      module: "effect",
      package: "effect",
      signature: "{ <A, X, R2>(release: (a: A, exit: Exit<unknown, unknown>) => Effect<X, never, R2>): <E, R>(acquire: Effect<A, E, R>) => Effect<A, E, R2 | R | Scope>; <A, E, R, X, R2>(acquire: Effect<A, E, R>, release: (a: A, exit: Exit<unknown, unknown>) => Effect<X, never, R2>): Effect<A, E, R | R2 | Scope>; }",
      description: "Creates a scoped resource using an `acquire` and `release` effect.",
      documentation: 'Creates a scoped resource using an `acquire` and `release` effect.\n\n**Details**\n\nThis function helps manage resources by combining two `Effect` values: one\nfor acquiring the resource and one for releasing it.\n\n`acquireRelease` does the following:\n\n  1. Ensures that the effect that acquires the resource will not be\n     interrupted. Note that acquisition may still fail due to internal\n     reasons (such as an uncaught exception).\n  2. Ensures that the `release` effect will not be interrupted, and will be\n     executed as long as the acquisition effect successfully acquires the\n     resource.\n\nIf the `acquire` function succeeds, the `release` function is added to the\nlist of finalizers for the scope. This ensures that the release will happen\nautomatically when the scope is closed.\n\nBoth `acquire` and `release` run uninterruptibly, meaning they cannot be\ninterrupted while they are executing.\n\nAdditionally, the `release` function can be influenced by the exit value when\nthe scope closes, allowing for custom handling of how the resource is\nreleased based on the execution outcome.\n\n**When to Use**\n\nThis function is used to ensure that an effect that represents the\nacquisition of a resource (for example, opening a file, launching a thread,\netc.) will not be interrupted, and that the resource will always be released\nwhen the `Effect` completes execution.\n\n**Example** (Defining a Simple Resource)\n\n```ts\nimport { Effect } from "effect"\n\n// Define an interface for a resource\ninterface MyResource {\n  readonly contents: string\n  readonly close: () => Promise<void>\n}\n\n// Simulate resource acquisition\nconst getMyResource = (): Promise<MyResource> =>\n  Promise.resolve({\n    contents: "lorem ipsum",\n    close: () =>\n      new Promise((resolve) => {\n        console.log("Resource released")\n        resolve()\n      })\n  })\n\n// Define how the resource is acquired\nconst acquire = Effect.tryPromise({\n  try: () =>\n    getMyResource().then((res) => {\n      console.log("Resource acquired")\n      return res\n    }),\n  catch: () => new Error("getMyResourceError")\n})\n\n// Define how the resource is released\nconst release = (res: MyResource) => Effect.promise(() => res.close())\n\n// Create the resource management workflow\n//\n//      \u250C\u2500\u2500\u2500 Effect<MyResource, Error, Scope>\n//      \u25BC\nconst resource = Effect.acquireRelease(acquire, release)\n```',
      examples: [
        {
          title: "Defining a Simple Resource",
          code: 'import { Effect } from "effect"\n\n// Define an interface for a resource\ninterface MyResource {\n  readonly contents: string\n  readonly close: () => Promise<void>\n}\n\n// Simulate resource acquisition\nconst getMyResource = (): Promise<MyResource> =>\n  Promise.resolve({\n    contents: "lorem ipsum",\n    close: () =>\n      new Promise((resolve) => {\n        console.log("Resource released")\n        resolve()\n      })\n  })\n\n// Define how the resource is acquired\nconst acquire = Effect.tryPromise({\n  try: () =>\n    getMyResource().then((res) => {\n      console.log("Resource acquired")\n      return res\n    }),\n  catch: () => new Error("getMyResourceError")\n})\n\n// Define how the resource is released\nconst release = (res: MyResource) => Effect.promise(() => res.close())\n\n// Create the resource management workflow\n//\n//      \u250C\u2500\u2500\u2500 Effect<MyResource, Error, Scope>\n//      \u25BC\nconst resource = Effect.acquireRelease(acquire, release)'
        }
      ],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9752,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9752"
    },
    {
      id: "effect.acquireReleaseInterruptible",
      name: "acquireReleaseInterruptible",
      module: "effect",
      package: "effect",
      signature: "{ <X, R2>(release: (exit: Exit<unknown, unknown>) => Effect<X, never, R2>): <A, E, R>(acquire: Effect<A, E, R>) => Effect<A, E, Scope | R2 | R>; <A, E, R, X, R2>(acquire: Effect<A, E, R>, release: (exit: Exit<unknown, unknown>) => Effect<X, never, R2>): Effect<A, E, Scope | R | R2>; }",
      description: "/\n * Creates a scoped resource with an interruptible acquire action.\n *\n *",
      documentation: "/**\n * Creates a scoped resource with an interruptible acquire action.\n *\n * **Details**\n *\n * This function is similar to {@link acquireRelease}, but it allows the\n * acquisition of the resource to be interrupted. The `acquire` effect, which\n * represents the process of obtaining the resource, can be interrupted if\n * necessary.\n *\n *",
      examples: [],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9933,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9933"
    },
    {
      id: "effect.acquireUseRelease",
      name: "acquireUseRelease",
      module: "effect",
      package: "effect",
      signature: "{ <A2, E2, R2, A, X, R3>(use: (a: A) => Effect<A2, E2, R2>, release: (a: A, exit: Exit<A2, E2>) => Effect<X, never, R3>): <E, R>(acquire: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | R3 | R>; <A, E, R, A2, E2, R2, X, R3>(acquire: Effect<A, E, R>, use: (a: A) => Effect<A2, E2, R2>, release: (a: A, exit: Exit<A2, E2>) => Effect<X, never, R3>): Effect<A2, E | E2, R | R2 | R3>; }",
      description: "Many real-world operations involve working with resources that must be released when no longer needed, such as: - Database connections\n- File handles\n- Network requests This function ensures that a resource is: 1. Acquired properly.\n2. Used for its intended purpose.\n3. Released even if an error occurs.",
      documentation: 'Many real-world operations involve working with resources that must be released when no longer needed, such as:\n\n- Database connections\n- File handles\n- Network requests\n\nThis function ensures that a resource is:\n\n1. **Acquired** properly.\n2. **Used** for its intended purpose.\n3. **Released** even if an error occurs.\n\n**Example** (Automatically Managing Resource Lifetime)\n\n```ts\nimport { Effect, Console } from "effect"\n\n// Define an interface for a resource\ninterface MyResource {\n  readonly contents: string\n  readonly close: () => Promise<void>\n}\n\n// Simulate resource acquisition\nconst getMyResource = (): Promise<MyResource> =>\n  Promise.resolve({\n    contents: "lorem ipsum",\n    close: () =>\n      new Promise((resolve) => {\n        console.log("Resource released")\n        resolve()\n      })\n  })\n\n// Define how the resource is acquired\nconst acquire = Effect.tryPromise({\n  try: () =>\n    getMyResource().then((res) => {\n      console.log("Resource acquired")\n      return res\n    }),\n  catch: () => new Error("getMyResourceError")\n})\n\n// Define how the resource is released\nconst release = (res: MyResource) => Effect.promise(() => res.close())\n\nconst use = (res: MyResource) => Console.log(`content is ${res.contents}`)\n\n//      \u250C\u2500\u2500\u2500 Effect<void, Error, never>\n//      \u25BC\nconst program = Effect.acquireUseRelease(acquire, use, release)\n\nEffect.runPromise(program)\n// Output:\n// Resource acquired\n// content is lorem ipsum\n// Resource released\n```',
      examples: [
        {
          title: "Automatically Managing Resource Lifetime",
          code: 'import { Effect, Console } from "effect"\n\n// Define an interface for a resource\ninterface MyResource {\n  readonly contents: string\n  readonly close: () => Promise<void>\n}\n\n// Simulate resource acquisition\nconst getMyResource = (): Promise<MyResource> =>\n  Promise.resolve({\n    contents: "lorem ipsum",\n    close: () =>\n      new Promise((resolve) => {\n        console.log("Resource released")\n        resolve()\n      })\n  })\n\n// Define how the resource is acquired\nconst acquire = Effect.tryPromise({\n  try: () =>\n    getMyResource().then((res) => {\n      console.log("Resource acquired")\n      return res\n    }),\n  catch: () => new Error("getMyResourceError")\n})\n\n// Define how the resource is released\nconst release = (res: MyResource) => Effect.promise(() => res.close())\n\nconst use = (res: MyResource) => Console.log(`content is ${res.contents}`)\n\n//      \u250C\u2500\u2500\u2500 Effect<void, Error, never>\n//      \u25BC\nconst program = Effect.acquireUseRelease(acquire, use, release)\n\nEffect.runPromise(program)\n// Output:\n// Resource acquired\n// content is lorem ipsum\n// Resource released'
        }
      ],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 10027,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L10027"
    },
    {
      id: "effect.addFinalizer",
      name: "addFinalizer",
      module: "effect",
      package: "effect",
      signature: "<X, R>(finalizer: (exit: Exit<unknown, unknown>) => Effect<X, never, R>) => Effect<void, never, Scope | R>",
      description: "Ensures a finalizer is added to the scope of the calling effect, guaranteeing\nit runs when the scope is closed.",
      documentation: "Ensures a finalizer is added to the scope of the calling effect, guaranteeing\nit runs when the scope is closed.\n\n**Details**\n\nThis function adds a finalizer that will execute whenever the scope of the\neffect is closed, regardless of whether the effect succeeds, fails, or is\ninterrupted. The finalizer receives the `Exit` value of the effect's scope,\nallowing it to react differently depending on how the effect concludes.\n\nFinalizers are a reliable way to manage resource cleanup, ensuring that\nresources such as file handles, network connections, or database transactions\nare properly closed even in the event of an unexpected interruption or error.\n\nFinalizers operate in conjunction with Effect's scoped resources. If an\neffect with a finalizer is wrapped in a scope, the finalizer will execute\nautomatically when the scope ends.\n\n**Example** (Adding a Finalizer on Success)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\n//      \u250C\u2500\u2500\u2500 Effect<string, never, Scope>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  yield* Effect.addFinalizer((exit) =>\n    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)\n  )\n  return \"some result\"\n})\n\n// Wrapping the effect in a scope\n//\n//      \u250C\u2500\u2500\u2500 Effect<string, never, never>\n//      \u25BC\nconst runnable = Effect.scoped(program)\n\nEffect.runPromiseExit(runnable).then(console.log)\n// Output:\n// Finalizer executed. Exit status: Success\n// { _id: 'Exit', _tag: 'Success', value: 'some result' }\n```\n\n**Example** (Adding a Finalizer on Failure)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\n//      \u250C\u2500\u2500\u2500 Effect<never, string, Scope>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  yield* Effect.addFinalizer((exit) =>\n    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)\n  )\n  return yield* Effect.fail(\"Uh oh!\")\n})\n\n// Wrapping the effect in a scope\n//\n//      \u250C\u2500\u2500\u2500 Effect<never, string, never>\n//      \u25BC\nconst runnable = Effect.scoped(program)\n\nEffect.runPromiseExit(runnable).then(console.log)\n// Output:\n// Finalizer executed. Exit status: Failure\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Uh oh!' }\n// }\n```\n\n**Example** (Adding a Finalizer on Interruption)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\n//      \u250C\u2500\u2500\u2500 Effect<never, never, Scope>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  yield* Effect.addFinalizer((exit) =>\n    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)\n  )\n  return yield* Effect.interrupt\n})\n\n// Wrapping the effect in a scope\n//\n//      \u250C\u2500\u2500\u2500 Effect<never, never, never>\n//      \u25BC\nconst runnable = Effect.scoped(program)\n\nEffect.runPromiseExit(runnable).then(console.log)\n// Output:\n// Finalizer executed. Exit status: Failure\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Interrupt',\n//     fiberId: {\n//       _id: 'FiberId',\n//       _tag: 'Runtime',\n//       id: 0,\n//       startTimeMillis: ...\n//     }\n//   }\n// }\n```",
      examples: [
        {
          title: "Adding a Finalizer on Success",
          code: `import { Effect, Console } from "effect"

//      \u250C\u2500\u2500\u2500 Effect<string, never, Scope>
//      \u25BC
const program = Effect.gen(function* () {
  yield* Effect.addFinalizer((exit) =>
    Console.log(\`Finalizer executed. Exit status: \${exit._tag}\`)
  )
  return "some result"
})

// Wrapping the effect in a scope
//
//      \u250C\u2500\u2500\u2500 Effect<string, never, never>
//      \u25BC
const runnable = Effect.scoped(program)

Effect.runPromiseExit(runnable).then(console.log)
// Output:
// Finalizer executed. Exit status: Success
// { _id: 'Exit', _tag: 'Success', value: 'some result' }`
        },
        {
          title: "Adding a Finalizer on Failure",
          code: `import { Effect, Console } from "effect"

//      \u250C\u2500\u2500\u2500 Effect<never, string, Scope>
//      \u25BC
const program = Effect.gen(function* () {
  yield* Effect.addFinalizer((exit) =>
    Console.log(\`Finalizer executed. Exit status: \${exit._tag}\`)
  )
  return yield* Effect.fail("Uh oh!")
})

// Wrapping the effect in a scope
//
//      \u250C\u2500\u2500\u2500 Effect<never, string, never>
//      \u25BC
const runnable = Effect.scoped(program)

Effect.runPromiseExit(runnable).then(console.log)
// Output:
// Finalizer executed. Exit status: Failure
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Uh oh!' }
// }`
        },
        {
          title: "Adding a Finalizer on Interruption",
          code: "import { Effect, Console } from \"effect\"\n\n//      \u250C\u2500\u2500\u2500 Effect<never, never, Scope>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  yield* Effect.addFinalizer((exit) =>\n    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)\n  )\n  return yield* Effect.interrupt\n})\n\n// Wrapping the effect in a scope\n//\n//      \u250C\u2500\u2500\u2500 Effect<never, never, never>\n//      \u25BC\nconst runnable = Effect.scoped(program)\n\nEffect.runPromiseExit(runnable).then(console.log)\n// Output:\n// Finalizer executed. Exit status: Failure\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Interrupt',\n//     fiberId: {\n//       _id: 'FiberId',\n//       _tag: 'Runtime',\n//       id: 0,\n//       startTimeMillis: ...\n//     }\n//   }\n// }"
        }
      ],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 10278,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L10278"
    },
    {
      id: "effect.ensuring",
      name: "ensuring",
      module: "effect",
      package: "effect",
      signature: "{ <X, R1>(finalizer: Effect<X, never, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R1 | R>; <A, E, R, X, R1>(self: Effect<A, E, R>, finalizer: Effect<X, never, R1>): Effect<A, E, R | R1>; }",
      description: "/\n * Guarantees the execution of a finalizer when an effect starts execution.\n *\n *",
      documentation: '/**\n * Guarantees the execution of a finalizer when an effect starts execution.\n *\n * **Details**\n *\n * This function allows you to specify a `finalizer` effect that will always be\n * run once the effect starts execution, regardless of whether the effect\n * succeeds, fails, or is interrupted.\n *\n * **When to Use**\n *\n * This is useful when you need to ensure that certain cleanup or final steps\n * are executed in all cases, such as releasing resources or performing\n * necessary logging.\n *\n * While this function provides strong guarantees about executing the finalizer,\n * it is considered a low-level tool, which may not be ideal for more complex\n * resource management. For higher-level resource management with automatic\n * acquisition and release, see the {@link acquireRelease}family of functions.\n * For use cases where you need access to the result of an effect, consider\n * using {@link onExit}.\n *\n * **Example** (Running a Finalizer in All Outcomes)\n *\n * ```ts\n * import { Console, Effect } from "effect"\n *\n * // Define a cleanup effect\n * const handler = Effect.ensuring(Console.log("Cleanup completed"))\n *\n * // Define a successful effect\n * const success = Console.log("Task completed").pipe(\n *   Effect.as("some result"),\n *   handler\n * )\n *\n * Effect.runFork(success)\n * // Output:\n * // Task completed\n * // Cleanup completed\n *\n * // Define a failing effect\n * const failure = Console.log("Task failed").pipe(\n *   Effect.andThen(Effect.fail("some error")),\n *   handler\n * )\n *\n * Effect.runFork(failure)\n * // Output:\n * // Task failed\n * // Cleanup completed\n *\n * // Define an interrupted effect\n * const interruption = Console.log("Task interrupted").pipe(\n *   Effect.andThen(Effect.interrupt),\n *   handler\n * )\n *\n * Effect.runFork(interruption)\n * // Output:\n * // Task interrupted\n * // Cleanup completed\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Console, Effect } from "effect"\n *\n * // Define a cleanup effect\n * const handler = Effect.ensuring(Console.log("Cleanup completed"))\n *\n * // Define a successful effect\n * const success = Console.log("Task completed").pipe(\n *   Effect.as("some result"),\n *   handler\n * )\n *\n * Effect.runFork(success)\n * // Output:\n * // Task completed\n * // Cleanup completed\n *\n * // Define a failing effect\n * const failure = Console.log("Task failed").pipe(\n *   Effect.andThen(Effect.fail("some error")),\n *   handler\n * )\n *\n * Effect.runFork(failure)\n * // Output:\n * // Task failed\n * // Cleanup completed\n *\n * // Define an interrupted effect\n * const interruption = Console.log("Task interrupted").pipe(\n *   Effect.andThen(Effect.interrupt),\n *   handler\n * )\n *\n * Effect.runFork(interruption)\n * // Output:\n * // Task interrupted\n * // Cleanup completed\n *'
        }
      ],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 10349,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L10349"
    },
    {
      id: "effect.onError",
      name: "onError",
      module: "effect",
      package: "effect",
      signature: "{ <E, X, R2>(cleanup: (cause: Cause<E>) => Effect<X, never, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, cleanup: (cause: Cause<E>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }",
      description: "Ensures a cleanup effect runs whenever the calling effect fails, providing\nthe failure cause to the cleanup effect.",
      documentation: 'Ensures a cleanup effect runs whenever the calling effect fails, providing\nthe failure cause to the cleanup effect.\n\n**Details**\n\nThis function allows you to attach a cleanup effect that runs whenever the\ncalling effect fails. The cleanup effect receives the cause of the failure,\nallowing you to perform actions such as logging, releasing resources, or\nexecuting additional recovery logic based on the error. The cleanup effect\nwill execute even if the failure is due to interruption.\n\nImportantly, the cleanup effect itself is uninterruptible, ensuring that it\ncompletes regardless of external interruptions.\n\n**Example** (Running Cleanup Only on Failure)\n\n```ts\nimport { Console, Effect } from "effect"\n\n// This handler logs the failure cause when the effect fails\nconst handler = Effect.onError((cause) =>\n  Console.log(`Cleanup completed: ${cause}`)\n)\n\n// Define a successful effect\nconst success = Console.log("Task completed").pipe(\n  Effect.as("some result"),\n  handler\n)\n\nEffect.runFork(success)\n// Output:\n// Task completed\n\n// Define a failing effect\nconst failure = Console.log("Task failed").pipe(\n  Effect.andThen(Effect.fail("some error")),\n  handler\n)\n\nEffect.runFork(failure)\n// Output:\n// Task failed\n// Cleanup completed: Error: some error\n\n// Define a failing effect\nconst defect = Console.log("Task failed with defect").pipe(\n  Effect.andThen(Effect.die("Boom!")),\n  handler\n)\n\nEffect.runFork(defect)\n// Output:\n// Task failed with defect\n// Cleanup completed: Error: Boom!\n\n// Define an interrupted effect\nconst interruption = Console.log("Task interrupted").pipe(\n  Effect.andThen(Effect.interrupt),\n  handler\n)\n\nEffect.runFork(interruption)\n// Output:\n// Task interrupted\n// Cleanup completed: All fibers interrupted without errors.\n```',
      examples: [
        {
          title: "Running Cleanup Only on Failure",
          code: 'import { Console, Effect } from "effect"\n\n// This handler logs the failure cause when the effect fails\nconst handler = Effect.onError((cause) =>\n  Console.log(`Cleanup completed: ${cause}`)\n)\n\n// Define a successful effect\nconst success = Console.log("Task completed").pipe(\n  Effect.as("some result"),\n  handler\n)\n\nEffect.runFork(success)\n// Output:\n// Task completed\n\n// Define a failing effect\nconst failure = Console.log("Task failed").pipe(\n  Effect.andThen(Effect.fail("some error")),\n  handler\n)\n\nEffect.runFork(failure)\n// Output:\n// Task failed\n// Cleanup completed: Error: some error\n\n// Define a failing effect\nconst defect = Console.log("Task failed with defect").pipe(\n  Effect.andThen(Effect.die("Boom!")),\n  handler\n)\n\nEffect.runFork(defect)\n// Output:\n// Task failed with defect\n// Cleanup completed: Error: Boom!\n\n// Define an interrupted effect\nconst interruption = Console.log("Task interrupted").pipe(\n  Effect.andThen(Effect.interrupt),\n  handler\n)\n\nEffect.runFork(interruption)\n// Output:\n// Task interrupted\n// Cleanup completed: All fibers interrupted without errors.'
        }
      ],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 10568,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L10568"
    },
    {
      id: "effect.onExit",
      name: "onExit",
      module: "effect",
      package: "effect",
      signature: "{ <A, E, X, R2>(cleanup: (exit: Exit<A, E>) => Effect<X, never, R2>): <R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, cleanup: (exit: Exit<A, E>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }",
      description: "Guarantees that a cleanup function runs regardless of whether the effect\nsucceeds, fails, or is interrupted.",
      documentation: 'Guarantees that a cleanup function runs regardless of whether the effect\nsucceeds, fails, or is interrupted.\n\n**Details**\n\nThis function ensures that a provided cleanup function is executed after the\neffect completes, regardless of the outcome. The cleanup function is given\nthe `Exit` value of the effect, which provides detailed information about the\nresult:\n- If the effect succeeds, the `Exit` contains the success value.\n- If the effect fails, the `Exit` contains the error or failure cause.\n- If the effect is interrupted, the `Exit` reflects the interruption.\n\nThe cleanup function is guaranteed to run uninterruptibly, ensuring reliable\nresource management even in complex or high-concurrency scenarios.\n\n**Example** (Running a Cleanup Function with the Effect\u2019s Result)\n\n```ts\nimport { Console, Effect, Exit } from "effect"\n\n// Define a cleanup effect that logs the result\nconst handler = Effect.onExit((exit) =>\n  Console.log(`Cleanup completed: ${Exit.getOrElse(exit, String)}`)\n)\n\n// Define a successful effect\nconst success = Console.log("Task completed").pipe(\n  Effect.as("some result"),\n  handler\n)\n\nEffect.runFork(success)\n// Output:\n// Task completed\n// Cleanup completed: some result\n\n// Define a failing effect\nconst failure = Console.log("Task failed").pipe(\n  Effect.andThen(Effect.fail("some error")),\n  handler\n)\n\nEffect.runFork(failure)\n// Output:\n// Task failed\n// Cleanup completed: Error: some error\n\n// Define an interrupted effect\nconst interruption = Console.log("Task interrupted").pipe(\n  Effect.andThen(Effect.interrupt),\n  handler\n)\n\nEffect.runFork(interruption)\n// Output:\n// Task interrupted\n// Cleanup completed: All fibers interrupted without errors.\n```',
      examples: [
        {
          title: "Running a Cleanup Function with the Effect\u2019s Result",
          code: 'import { Console, Effect, Exit } from "effect"\n\n// Define a cleanup effect that logs the result\nconst handler = Effect.onExit((exit) =>\n  Console.log(`Cleanup completed: ${Exit.getOrElse(exit, String)}`)\n)\n\n// Define a successful effect\nconst success = Console.log("Task completed").pipe(\n  Effect.as("some result"),\n  handler\n)\n\nEffect.runFork(success)\n// Output:\n// Task completed\n// Cleanup completed: some result\n\n// Define a failing effect\nconst failure = Console.log("Task failed").pipe(\n  Effect.andThen(Effect.fail("some error")),\n  handler\n)\n\nEffect.runFork(failure)\n// Output:\n// Task failed\n// Cleanup completed: Error: some error\n\n// Define an interrupted effect\nconst interruption = Console.log("Task interrupted").pipe(\n  Effect.andThen(Effect.interrupt),\n  handler\n)\n\nEffect.runFork(interruption)\n// Output:\n// Task interrupted\n// Cleanup completed: All fibers interrupted without errors.'
        }
      ],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 10786,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L10786"
    },
    {
      id: "effect.parallelFinalizers",
      name: "parallelFinalizers",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>",
      description: "Ensures that finalizers are run concurrently when the scope of an effect is\nclosed.",
      documentation: 'Ensures that finalizers are run concurrently when the scope of an effect is\nclosed.\n\n**Details**\n\nThis function modifies the behavior of finalizers within a scoped workflow to\nallow them to run concurrently when the scope is closed.\n\nBy default, finalizers are executed sequentially in reverse order of their\naddition, but this function changes that behavior to execute all finalizers\nconcurrently.\n\n**When to Use**\n\nRunning finalizers concurrently can improve performance when multiple\nindependent cleanup tasks need to be performed. However, it requires that\nthese tasks do not depend on the order of execution or introduce race\nconditions.\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\n// Define a program that adds multiple finalizers\nconst program = Effect.gen(function*() {\n  yield* Effect.addFinalizer(() => Console.log("Finalizer 1 executed").pipe(Effect.delay("300 millis")))\n  yield* Effect.addFinalizer(() => Console.log("Finalizer 2 executed").pipe(Effect.delay("100 millis")))\n  yield* Effect.addFinalizer(() => Console.log("Finalizer 3 executed").pipe(Effect.delay("200 millis")))\n  return "some result"\n})\n\n// Modify the program to ensure finalizers run in parallel\nconst modified = program.pipe(Effect.parallelFinalizers)\n\nconst runnable = Effect.scoped(modified)\n\nEffect.runFork(runnable)\n// Output:\n// Finalizer 2 executed\n// Finalizer 3 executed\n// Finalizer 1 executed\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\n// Define a program that adds multiple finalizers\nconst program = Effect.gen(function*() {\n  yield* Effect.addFinalizer(() => Console.log("Finalizer 1 executed").pipe(Effect.delay("300 millis")))\n  yield* Effect.addFinalizer(() => Console.log("Finalizer 2 executed").pipe(Effect.delay("100 millis")))\n  yield* Effect.addFinalizer(() => Console.log("Finalizer 3 executed").pipe(Effect.delay("200 millis")))\n  return "some result"\n})\n\n// Modify the program to ensure finalizers run in parallel\nconst modified = program.pipe(Effect.parallelFinalizers)\n\nconst runnable = Effect.scoped(modified)\n\nEffect.runFork(runnable)\n// Output:\n// Finalizer 2 executed\n// Finalizer 3 executed\n// Finalizer 1 executed'
        }
      ],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 10968,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L10968"
    },
    {
      id: "effect.sequentialFinalizers",
      name: "sequentialFinalizers",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>",
      description: "Ensures that finalizers are run sequentially in reverse order of their\naddition.",
      documentation: "Ensures that finalizers are run sequentially in reverse order of their\naddition.\n\n**Details**\n\nThis function modifies the behavior of finalizers within a scoped workflow to\nensure they are run sequentially in reverse order when the scope is closed.\n\nBy default, finalizers are executed sequentially, so this only changes the\nbehavior if the scope is configured to run finalizers concurrently.",
      examples: [],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 10986,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L10986"
    },
    {
      id: "effect.finalizersMask",
      name: "finalizersMask",
      module: "effect",
      package: "effect",
      signature: "(strategy: ExecutionStrategy) => <A, E, R>(self: (restore: <A1, E1, R1>(self: Effect<A1, E1, R1>) => Effect<A1, E1, R1>) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "Applies a custom execution strategy to finalizers within a scoped workflow.",
      documentation: "Applies a custom execution strategy to finalizers within a scoped workflow.\n\n**Details**\n\nThis function allows you to control how finalizers are executed in a scope by\napplying a specified `ExecutionStrategy`. The `strategy` can dictate whether\nfinalizers run (e.g., sequentially or in parallel).\n\nAdditionally, the function provides a `restore` operation, which ensures that\nthe effect passed to it is executed under the default execution strategy.",
      examples: [],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11002,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11002"
    },
    {
      id: "effect.scope",
      name: "scope",
      module: "effect",
      package: "effect",
      signature: "Effect<Scope, never, Scope>",
      description: "Provides access to the current scope in a scoped workflow.",
      documentation: "Provides access to the current scope in a scoped workflow.",
      examples: [],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11009,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11009"
    },
    {
      id: "effect.scopeWith",
      name: "scopeWith",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(f: (scope: Scope) => Effect<A, E, R>) => Effect<A, E, Scope | R>",
      description: "Accesses the current scope and uses it to perform the specified effect.",
      documentation: "Accesses the current scope and uses it to perform the specified effect.",
      examples: [],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11016,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11016"
    },
    {
      id: "effect.scopedWith",
      name: "scopedWith",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(f: (scope: Scope) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "Creates a `Scope`, passes it to the specified effectful function, and closes\nthe scope when the effect completes (whether through success, failure, or\ninterruption).",
      documentation: "Creates a `Scope`, passes it to the specified effectful function, and closes\nthe scope when the effect completes (whether through success, failure, or\ninterruption).",
      examples: [],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "3.11.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11025,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11025"
    },
    {
      id: "effect.scoped",
      name: "scoped",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, Exclude<R, Scope>>",
      description: "Scopes all resources used in an effect to the lifetime of the effect.",
      documentation: "Scopes all resources used in an effect to the lifetime of the effect.\n\n**Details**\n\nThis function ensures that all resources used within an effect are tied to\nits lifetime. Finalizers for these resources are executed automatically when\nthe effect completes, whether through success, failure, or interruption. This\nguarantees proper resource cleanup without requiring explicit management.",
      examples: [],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11039,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11039"
    },
    {
      id: "effect.using",
      name: "using",
      module: "effect",
      package: "effect",
      signature: "{ <A, A2, E2, R2>(use: (a: A) => Effect<A2, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | Exclude<R, Scope>>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, use: (a: A) => Effect<A2, E2, R2>): Effect<A2, E | E2, R2 | Exclude<R, Scope>>; }",
      description: "Scopes all resources acquired by one effect to the lifetime of another\neffect.",
      documentation: 'Scopes all resources acquired by one effect to the lifetime of another\neffect.\n\n**Details**\n\nThis function allows you to scope the resources acquired by one effect\n(`self`) to the lifetime of another effect (`use`). This ensures that the\nresources are cleaned up as soon as the `use` effect completes, regardless of\nhow the `use` effect ends (success, failure, or interruption).\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\nconst acquire = Console.log("Acquiring resource").pipe(\n  Effect.as(1),\n  Effect.tap(Effect.addFinalizer(() => Console.log("Releasing resource")))\n)\nconst use = (resource: number) => Console.log(`Using resource: ${resource}`)\n\nconst program = acquire.pipe(Effect.using(use))\n\nEffect.runFork(program)\n// Output:\n// Acquiring resource\n// Using resource: 1\n// Releasing resource\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\nconst acquire = Console.log("Acquiring resource").pipe(\n  Effect.as(1),\n  Effect.tap(Effect.addFinalizer(() => Console.log("Releasing resource")))\n)\nconst use = (resource: number) => Console.log(`Using resource: ${resource}`)\n\nconst program = acquire.pipe(Effect.using(use))\n\nEffect.runFork(program)\n// Output:\n// Acquiring resource\n// Using resource: 1\n// Releasing resource'
        }
      ],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11076,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11076"
    },
    {
      id: "effect.withEarlyRelease",
      name: "withEarlyRelease",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<[finalizer: Effect<void, never, never>, result: A], E, Scope | R>",
      description: "Returns the result of the effect and a finalizer to close its scope.",
      documentation: 'Returns the result of the effect and a finalizer to close its scope.\n\n**Details**\n\nThis function allows you to retrieve both the result of an effect and a\nfinalizer that can be used to manually close its scope. This is useful for\nworkflows where you need early access to the result while retaining control\nover the resource cleanup process.\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\nconst acquire = Console.log("Acquiring resource").pipe(\n  Effect.as(1),\n  Effect.tap(Effect.addFinalizer(() => Console.log("Releasing resource")))\n)\nconst program = Effect.gen(function*() {\n  const [finalizer, resource] = yield* Effect.withEarlyRelease(acquire)\n  console.log(`Using resource: ${resource}`)\n  yield* Effect.sleep("1 second")\n  yield* finalizer\n})\n\nEffect.runFork(program.pipe(Effect.scoped))\n// Output:\n// Acquiring resource\n// Using resource: 1\n// Releasing resource\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\nconst acquire = Console.log("Acquiring resource").pipe(\n  Effect.as(1),\n  Effect.tap(Effect.addFinalizer(() => Console.log("Releasing resource")))\n)\nconst program = Effect.gen(function*() {\n  const [finalizer, resource] = yield* Effect.withEarlyRelease(acquire)\n  console.log(`Using resource: ${resource}`)\n  yield* Effect.sleep("1 second")\n  yield* finalizer\n})\n\nEffect.runFork(program.pipe(Effect.scoped))\n// Output:\n// Acquiring resource\n// Using resource: 1\n// Releasing resource'
        }
      ],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11188,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11188"
    },
    {
      id: "effect.awaitAllChildren",
      name: "awaitAllChildren",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>",
      description: "Returns a new effect that will not succeed with its value before first\nwaiting for the end of all child fibers forked by the effect.",
      documentation: "Returns a new effect that will not succeed with its value before first\nwaiting for the end of all child fibers forked by the effect.",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11196,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11196"
    },
    {
      id: "effect.daemonChildren",
      name: "daemonChildren",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>",
      description: "Returns a new workflow that will not supervise any fibers forked by this\nworkflow.",
      documentation: "Returns a new workflow that will not supervise any fibers forked by this\nworkflow.",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11204,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11204"
    },
    {
      id: "effect.descriptor",
      name: "descriptor",
      module: "effect",
      package: "effect",
      signature: "Effect<Fiber.Descriptor, never, never>",
      description: "Constructs an effect with information about the current `Fiber`.",
      documentation: "Constructs an effect with information about the current `Fiber`.",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11211,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11211"
    },
    {
      id: "effect.descriptorWith",
      name: "descriptorWith",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(f: (descriptor: Fiber.Descriptor) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "Constructs an effect based on information about the current `Fiber`.",
      documentation: "Constructs an effect based on information about the current `Fiber`.",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11218,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11218"
    },
    {
      id: "effect.diffFiberRefs",
      name: "diffFiberRefs",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<[FiberRefsPatch, A], E, R>",
      description: "Returns a new workflow that executes this one and captures the changes in\n`FiberRef` values.",
      documentation: "Returns a new workflow that executes this one and captures the changes in\n`FiberRef` values.",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11226,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11226"
    },
    {
      id: "effect.ensuringChild",
      name: "ensuringChild",
      module: "effect",
      package: "effect",
      signature: "{ <X, R2>(f: (fiber: Fiber<readonly unknown[], any>) => Effect<X, never, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, f: (fiber: Fiber<readonly unknown[], any>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }",
      description: "Acts on the children of this fiber (collected into a single fiber),\nguaranteeing the specified callback will be invoked, whether or not this\neffect succeeds.",
      documentation: "Acts on the children of this fiber (collected into a single fiber),\nguaranteeing the specified callback will be invoked, whether or not this\neffect succeeds.",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11235,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11235"
    },
    {
      id: "effect.ensuringChildren",
      name: "ensuringChildren",
      module: "effect",
      package: "effect",
      signature: "{ <X, R2>(children: (fibers: readonly RuntimeFiber<any, any>[]) => Effect<X, never, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, children: (fibers: readonly RuntimeFiber<any, any>[]) => Effect<X, never, R2>): Effect<A, E, R | R2>; }",
      description: "Acts on the children of this fiber, guaranteeing the specified callback\nwill be invoked, whether or not this effect succeeds.",
      documentation: "Acts on the children of this fiber, guaranteeing the specified callback\nwill be invoked, whether or not this effect succeeds.",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11262,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11262"
    },
    {
      id: "effect.fiberId",
      name: "fiberId",
      module: "effect",
      package: "effect",
      signature: "Effect<FiberId, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11284,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11284"
    },
    {
      id: "effect.fiberIdWith",
      name: "fiberIdWith",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(f: (descriptor: Runtime) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11289,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11289"
    },
    {
      id: "effect.fork",
      name: "fork",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<RuntimeFiber<A, E>, never, R>",
      description: "/\n * Creates a new fiber to run an effect concurrently.\n *\n *",
      documentation: '/**\n * Creates a new fiber to run an effect concurrently.\n *\n * **Details**\n *\n * This function takes an effect and forks it into a separate fiber, allowing it\n * to run concurrently without blocking the original effect. The new fiber\n * starts execution immediately after being created, and the fiber object is\n * returned immediately without waiting for the effect to begin. This is useful\n * when you want to run tasks concurrently while continuing other tasks in the\n * parent fiber.\n *\n * The forked fiber is attached to the parent fiber\'s scope. This means that\n * when the parent fiber terminates, the child fiber will also be terminated\n * automatically. This feature, known as "auto supervision," ensures that no\n * fibers are left running unintentionally. If you prefer not to have this auto\n * supervision behavior, you can use {@link forkDaemon}or {@link forkIn}.\n *\n * **When to Use**\n *\n * Use this function when you need to run an effect concurrently without\n * blocking the current execution flow. For example, you might use it to launch\n * background tasks or concurrent computations. However, working with fibers can\n * be complex, so before using this function directly, you might want to explore\n * higher-level functions like {@link raceWith}, {@link zip}, or others that can\n * manage concurrency for you.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from "effect"\n *\n * const fib = (n: number): Effect.Effect<number> =>\n *   n < 2\n *     ? Effect.succeed(n)\n *     : Effect.zipWith(fib(n - 1), fib(n - 2), (a, b) => a + b)\n *\n * //      \u250C\u2500\u2500\u2500 Effect<RuntimeFiber<number, never>, never, never>\n * //      \u25BC\n * const fib10Fiber = Effect.fork(fib(10))\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect } from "effect"\n *\n * const fib = (n: number): Effect.Effect<number> =>\n *   n < 2\n *     ? Effect.succeed(n)\n *     : Effect.zipWith(fib(n - 1), fib(n - 2), (a, b) => a + b)\n *\n * //      \u250C\u2500\u2500\u2500 Effect<RuntimeFiber<number, never>, never, never>\n * //      \u25BC\n * const fib10Fiber = Effect.fork(fib(10))\n *'
        }
      ],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11337,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11337"
    },
    {
      id: "effect.forkDaemon",
      name: "forkDaemon",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<RuntimeFiber<A, E>, never, R>",
      description: "Creates a long-running background fiber that is independent of its parent.",
      documentation: 'Creates a long-running background fiber that is independent of its parent.\n\n**Details**\n\nThis function creates a "daemon" fiber that runs in the background and is not\ntied to the lifecycle of its parent fiber. Unlike normal fibers that stop\nwhen the parent fiber terminates, a daemon fiber will continue running until\nthe global scope closes or the fiber completes naturally. This makes it\nuseful for tasks that need to run in the background independently, such as\nperiodic logging, monitoring, or background data processing.\n\n**Example** (Creating a Daemon Fiber)\n\n```ts\nimport { Effect, Console, Schedule } from "effect"\n\n// Daemon fiber that logs a message repeatedly every second\nconst daemon = Effect.repeat(\n  Console.log("daemon: still running!"),\n  Schedule.fixed("1 second")\n)\n\nconst parent = Effect.gen(function* () {\n  console.log("parent: started!")\n  // Daemon fiber running independently\n  yield* Effect.forkDaemon(daemon)\n  yield* Effect.sleep("3 seconds")\n  console.log("parent: finished!")\n})\n\nEffect.runFork(parent)\n// Output:\n// parent: started!\n// daemon: still running!\n// daemon: still running!\n// daemon: still running!\n// parent: finished!\n// daemon: still running!\n// daemon: still running!\n// daemon: still running!\n// daemon: still running!\n// daemon: still running!\n// ...etc...\n```',
      examples: [
        {
          title: "Creating a Daemon Fiber",
          code: 'import { Effect, Console, Schedule } from "effect"\n\n// Daemon fiber that logs a message repeatedly every second\nconst daemon = Effect.repeat(\n  Console.log("daemon: still running!"),\n  Schedule.fixed("1 second")\n)\n\nconst parent = Effect.gen(function* () {\n  console.log("parent: started!")\n  // Daemon fiber running independently\n  yield* Effect.forkDaemon(daemon)\n  yield* Effect.sleep("3 seconds")\n  console.log("parent: finished!")\n})\n\nEffect.runFork(parent)\n// Output:\n// parent: started!\n// daemon: still running!\n// daemon: still running!\n// daemon: still running!\n// parent: finished!\n// daemon: still running!\n// daemon: still running!\n// daemon: still running!\n// daemon: still running!\n// daemon: still running!\n// ...etc...'
        }
      ],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11387,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11387"
    },
    {
      id: "effect.forkAll",
      name: "forkAll",
      module: "effect",
      package: "effect",
      signature: "{ (options?: { readonly discard?: false; }): <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>) => Effect<Fiber<Effect.Success<Eff>[], Effect.Error<Eff>>, never, Effect.Context<Eff>>; (options: { readonly discard: true; }): <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>) => Effect<void, never, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>, options?: { readonly discard?: false; }): Effect<Fiber<Effect.Success<Eff>[], Effect.Error<Eff>>, never, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>, options: { readonly discard: true; }): Effect<void, never, Effect.Context<Eff>>; }",
      description: "Returns an effect that forks all of the specified values, and returns a\ncomposite fiber that produces a list of their results, in order.",
      documentation: "Returns an effect that forks all of the specified values, and returns a\ncomposite fiber that produces a list of their results, in order.",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11395,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11395"
    },
    {
      id: "effect.forkIn",
      name: "forkIn",
      module: "effect",
      package: "effect",
      signature: "{ (scope: Scope): <A, E, R>(self: Effect<A, E, R>) => Effect<RuntimeFiber<A, E>, never, R>; <A, E, R>(self: Effect<A, E, R>, scope: Scope): Effect<RuntimeFiber<A, E>, never, R>; }",
      description: "Forks an effect in a specific scope, allowing finer control over its\nexecution.",
      documentation: 'Forks an effect in a specific scope, allowing finer control over its\nexecution.\n\n**Details**\n\nThere are some cases where we need more fine-grained control, so we want to\nfork a fiber in a specific scope. We can use the `Effect.forkIn` operator\nwhich takes the target scope as an argument.\n\nThe fiber will be interrupted when the scope is closed.\n\n**Example** (Forking a Fiber in a Specific Scope)\n\nIn this example, the child fiber is forked into the outerScope,\nallowing it to outlive the inner scope but still be terminated\nwhen the outerScope is closed.\n\n```ts\nimport { Console, Effect, Schedule } from "effect"\n\n// Child fiber that logs a message repeatedly every second\nconst child = Effect.repeat(\n  Console.log("child: still running!"),\n  Schedule.fixed("1 second")\n)\n\nconst program = Effect.scoped(\n  Effect.gen(function* () {\n    yield* Effect.addFinalizer(() =>\n      Console.log("The outer scope is about to be closed!")\n    )\n\n    // Capture the outer scope\n    const outerScope = yield* Effect.scope\n\n    // Create an inner scope\n    yield* Effect.scoped(\n      Effect.gen(function* () {\n        yield* Effect.addFinalizer(() =>\n          Console.log("The inner scope is about to be closed!")\n        )\n        // Fork the child fiber in the outer scope\n        yield* Effect.forkIn(child, outerScope)\n        yield* Effect.sleep("3 seconds")\n      })\n    )\n\n    yield* Effect.sleep("5 seconds")\n  })\n)\n\nEffect.runFork(program)\n// Output:\n// child: still running!\n// child: still running!\n// child: still running!\n// The inner scope is about to be closed!\n// child: still running!\n// child: still running!\n// child: still running!\n// child: still running!\n// child: still running!\n// child: still running!\n// The outer scope is about to be closed!\n```',
      examples: [
        {
          code: 'import { Console, Effect, Schedule } from "effect"\n\n// Child fiber that logs a message repeatedly every second\nconst child = Effect.repeat(\n  Console.log("child: still running!"),\n  Schedule.fixed("1 second")\n)\n\nconst program = Effect.scoped(\n  Effect.gen(function* () {\n    yield* Effect.addFinalizer(() =>\n      Console.log("The outer scope is about to be closed!")\n    )\n\n    // Capture the outer scope\n    const outerScope = yield* Effect.scope\n\n    // Create an inner scope\n    yield* Effect.scoped(\n      Effect.gen(function* () {\n        yield* Effect.addFinalizer(() =>\n          Console.log("The inner scope is about to be closed!")\n        )\n        // Fork the child fiber in the outer scope\n        yield* Effect.forkIn(child, outerScope)\n        yield* Effect.sleep("3 seconds")\n      })\n    )\n\n    yield* Effect.sleep("5 seconds")\n  })\n)\n\nEffect.runFork(program)\n// Output:\n// child: still running!\n// child: still running!\n// child: still running!\n// The inner scope is about to be closed!\n// child: still running!\n// child: still running!\n// child: still running!\n// child: still running!\n// child: still running!\n// child: still running!\n// The outer scope is about to be closed!'
        }
      ],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11507,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11507"
    },
    {
      id: "effect.forkScoped",
      name: "forkScoped",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<RuntimeFiber<A, E>, never, Scope | R>",
      description: "/\n * Forks a fiber in a local scope, ensuring it outlives its parent.\n *\n *",
      documentation: '/**\n * Forks a fiber in a local scope, ensuring it outlives its parent.\n *\n * **Details**\n *\n * This function is used to create fibers that are tied to a local scope,\n * meaning they are not dependent on their parent fiber\'s lifecycle. Instead,\n * they will continue running until the scope they were created in is closed.\n * This is particularly useful when you need a fiber to run independently of the\n * parent fiber, but still want it to be terminated when the scope ends.\n *\n * Fibers created with this function are isolated from the parent fiber\u2019s\n * termination, so they can run for a longer period. This behavior is different\n * from fibers created with {@link fork}, which are terminated when the parent fiber\n * terminates. With `forkScoped`, the child fiber will keep running until the\n * local scope ends, regardless of the state of the parent fiber.\n *\n * **Example** (Forking a Fiber in a Local Scope)\n *\n * In this example, the child fiber continues to run beyond the lifetime of the parent fiber.\n * The child fiber is tied to the local scope and will be terminated only when the scope ends.\n *\n * ```ts\n * import { Effect, Console, Schedule } from "effect"\n *\n * // Child fiber that logs a message repeatedly every second\n * const child = Effect.repeat(\n *   Console.log("child: still running!"),\n *   Schedule.fixed("1 second")\n * )\n *\n * //      \u250C\u2500\u2500\u2500 Effect<void, never, Scope>\n * //      \u25BC\n * const parent = Effect.gen(function* () {\n *   console.log("parent: started!")\n *   // Child fiber attached to local scope\n *   yield* Effect.forkScoped(child)\n *   yield* Effect.sleep("3 seconds")\n *   console.log("parent: finished!")\n * })\n *\n * // Program runs within a local scope\n * const program = Effect.scoped(\n *   Effect.gen(function* () {\n *     console.log("Local scope started!")\n *     yield* Effect.fork(parent)\n *     // Scope lasts for 5 seconds\n *     yield* Effect.sleep("5 seconds")\n *     console.log("Leaving the local scope!")\n *   })\n * )\n *\n * Effect.runFork(program)\n * // Output:\n * // Local scope started!\n * // parent: started!\n * // child: still running!\n * // child: still running!\n * // child: still running!\n * // parent: finished!\n * // child: still running!\n * // child: still running!\n * // Leaving the local scope!\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect, Console, Schedule } from "effect"\n *\n * // Child fiber that logs a message repeatedly every second\n * const child = Effect.repeat(\n *   Console.log("child: still running!"),\n *   Schedule.fixed("1 second")\n * )\n *\n * //      \u250C\u2500\u2500\u2500 Effect<void, never, Scope>\n * //      \u25BC\n * const parent = Effect.gen(function* () {\n *   console.log("parent: started!")\n *   // Child fiber attached to local scope\n *   yield* Effect.forkScoped(child)\n *   yield* Effect.sleep("3 seconds")\n *   console.log("parent: finished!")\n * })\n *\n * // Program runs within a local scope\n * const program = Effect.scoped(\n *   Effect.gen(function* () {\n *     console.log("Local scope started!")\n *     yield* Effect.fork(parent)\n *     // Scope lasts for 5 seconds\n *     yield* Effect.sleep("5 seconds")\n *     console.log("Leaving the local scope!")\n *   })\n * )\n *\n * Effect.runFork(program)\n * // Output:\n * // Local scope started!\n * // parent: started!\n * // child: still running!\n * // child: still running!\n * // child: still running!\n * // parent: finished!\n * // child: still running!\n * // child: still running!\n * // Leaving the local scope!\n *'
        }
      ],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11719,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11719"
    },
    {
      id: "effect.forkWithErrorHandler",
      name: "forkWithErrorHandler",
      module: "effect",
      package: "effect",
      signature: "{ <E, X>(handler: (e: E) => Effect<X, never, never>): <A, R>(self: Effect<A, E, R>) => Effect<RuntimeFiber<A, E>, never, R>; <A, E, R, X>(self: Effect<A, E, R>, handler: (e: E) => Effect<X, never, never>): Effect<RuntimeFiber<A, E>, never, R>; }",
      description: "/\n * Like {@link fork}but handles an error with the provided handler.\n *\n *",
      documentation: "/**\n * Like {@link fork}but handles an error with the provided handler.\n *\n *",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11726,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11726"
    },
    {
      id: "effect.fromFiber",
      name: "fromFiber",
      module: "effect",
      package: "effect",
      signature: "<A, E>(fiber: Fiber<A, E>) => Effect<A, E, never>",
      description: "Creates an `Effect` value that represents the exit value of the specified\nfiber.",
      documentation: "Creates an `Effect` value that represents the exit value of the specified\nfiber.",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11751,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11751"
    },
    {
      id: "effect.fromFiberEffect",
      name: "fromFiberEffect",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(fiber: Effect<Fiber<A, E>, E, R>) => Effect<A, E, R>",
      description: "Creates an `Effect` value that represents the exit value of a fiber obtained\nfrom an effect.",
      documentation: "Creates an `Effect` value that represents the exit value of a fiber obtained\nfrom an effect.",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11761,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11761"
    },
    {
      id: "effect.supervised",
      name: "supervised",
      module: "effect",
      package: "effect",
      signature: "{ <X>(supervisor: Supervisor<X>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, X>(self: Effect<A, E, R>, supervisor: Supervisor<X>): Effect<A, E, R>; }",
      description: "Supervises child fibers by reporting them to a specified supervisor.",
      documentation: 'Supervises child fibers by reporting them to a specified supervisor.\n\n**Details**\n\nThis function takes a supervisor as an argument and returns an effect where\nall child fibers forked within it are supervised by the provided supervisor.\nThis enables you to capture detailed information about these child fibers,\nsuch as their status, through the supervisor.\n\n**Example** (Monitoring Fiber Count)\n\n```ts\nimport { Effect, Supervisor, Schedule, Fiber, FiberStatus } from "effect"\n\n// Main program that monitors fibers while calculating a Fibonacci number\nconst program = Effect.gen(function* () {\n  // Create a supervisor to track child fibers\n  const supervisor = yield* Supervisor.track\n\n  // Start a Fibonacci calculation, supervised by the supervisor\n  const fibFiber = yield* fib(20).pipe(\n    Effect.supervised(supervisor),\n    // Fork the Fibonacci effect into a fiber\n    Effect.fork\n  )\n\n  // Define a schedule to periodically monitor the fiber count every 500ms\n  const policy = Schedule.spaced("500 millis").pipe(\n    Schedule.whileInputEffect((_) =>\n      Fiber.status(fibFiber).pipe(\n        // Continue while the Fibonacci fiber is not done\n        Effect.andThen((status) => status !== FiberStatus.done)\n      )\n    )\n  )\n\n  // Start monitoring the fibers, using the supervisor to track the count\n  const monitorFiber = yield* monitorFibers(supervisor).pipe(\n    // Repeat the monitoring according to the schedule\n    Effect.repeat(policy),\n    // Fork the monitoring into its own fiber\n    Effect.fork\n  )\n\n  // Join the monitor and Fibonacci fibers to ensure they complete\n  yield* Fiber.join(monitorFiber)\n  const result = yield* Fiber.join(fibFiber)\n\n  console.log(`fibonacci result: ${result}`)\n})\n\n// Function to monitor and log the number of active fibers\nconst monitorFibers = (\n  supervisor: Supervisor.Supervisor<Array<Fiber.RuntimeFiber<any, any>>>\n): Effect.Effect<void> =>\n  Effect.gen(function* () {\n    const fibers = yield* supervisor.value // Get the current set of fibers\n    console.log(`number of fibers: ${fibers.length}`)\n  })\n\n// Recursive Fibonacci calculation, spawning fibers for each recursive step\nconst fib = (n: number): Effect.Effect<number> =>\n  Effect.gen(function* () {\n    if (n <= 1) {\n      return 1\n    }\n    yield* Effect.sleep("500 millis") // Simulate work by delaying\n\n    // Fork two fibers for the recursive Fibonacci calls\n    const fiber1 = yield* Effect.fork(fib(n - 2))\n    const fiber2 = yield* Effect.fork(fib(n - 1))\n\n    // Join the fibers to retrieve their results\n    const v1 = yield* Fiber.join(fiber1)\n    const v2 = yield* Fiber.join(fiber2)\n\n    return v1 + v2 // Combine the results\n  })\n\nEffect.runPromise(program)\n// Output:\n// number of fibers: 0\n// number of fibers: 2\n// number of fibers: 6\n// number of fibers: 14\n// number of fibers: 30\n// number of fibers: 62\n// number of fibers: 126\n// number of fibers: 254\n// number of fibers: 510\n// number of fibers: 1022\n// number of fibers: 2034\n// number of fibers: 3795\n// number of fibers: 5810\n// number of fibers: 6474\n// number of fibers: 4942\n// number of fibers: 2515\n// number of fibers: 832\n// number of fibers: 170\n// number of fibers: 18\n// number of fibers: 0\n// fibonacci result: 10946\n```',
      examples: [
        {
          title: "Monitoring Fiber Count",
          code: 'import { Effect, Supervisor, Schedule, Fiber, FiberStatus } from "effect"\n\n// Main program that monitors fibers while calculating a Fibonacci number\nconst program = Effect.gen(function* () {\n  // Create a supervisor to track child fibers\n  const supervisor = yield* Supervisor.track\n\n  // Start a Fibonacci calculation, supervised by the supervisor\n  const fibFiber = yield* fib(20).pipe(\n    Effect.supervised(supervisor),\n    // Fork the Fibonacci effect into a fiber\n    Effect.fork\n  )\n\n  // Define a schedule to periodically monitor the fiber count every 500ms\n  const policy = Schedule.spaced("500 millis").pipe(\n    Schedule.whileInputEffect((_) =>\n      Fiber.status(fibFiber).pipe(\n        // Continue while the Fibonacci fiber is not done\n        Effect.andThen((status) => status !== FiberStatus.done)\n      )\n    )\n  )\n\n  // Start monitoring the fibers, using the supervisor to track the count\n  const monitorFiber = yield* monitorFibers(supervisor).pipe(\n    // Repeat the monitoring according to the schedule\n    Effect.repeat(policy),\n    // Fork the monitoring into its own fiber\n    Effect.fork\n  )\n\n  // Join the monitor and Fibonacci fibers to ensure they complete\n  yield* Fiber.join(monitorFiber)\n  const result = yield* Fiber.join(fibFiber)\n\n  console.log(`fibonacci result: ${result}`)\n})\n\n// Function to monitor and log the number of active fibers\nconst monitorFibers = (\n  supervisor: Supervisor.Supervisor<Array<Fiber.RuntimeFiber<any, any>>>\n): Effect.Effect<void> =>\n  Effect.gen(function* () {\n    const fibers = yield* supervisor.value // Get the current set of fibers\n    console.log(`number of fibers: ${fibers.length}`)\n  })\n\n// Recursive Fibonacci calculation, spawning fibers for each recursive step\nconst fib = (n: number): Effect.Effect<number> =>\n  Effect.gen(function* () {\n    if (n <= 1) {\n      return 1\n    }\n    yield* Effect.sleep("500 millis") // Simulate work by delaying\n\n    // Fork two fibers for the recursive Fibonacci calls\n    const fiber1 = yield* Effect.fork(fib(n - 2))\n    const fiber2 = yield* Effect.fork(fib(n - 1))\n\n    // Join the fibers to retrieve their results\n    const v1 = yield* Fiber.join(fiber1)\n    const v2 = yield* Fiber.join(fiber2)\n\n    return v1 + v2 // Combine the results\n  })\n\nEffect.runPromise(program)\n// Output:\n// number of fibers: 0\n// number of fibers: 2\n// number of fibers: 6\n// number of fibers: 14\n// number of fibers: 30\n// number of fibers: 62\n// number of fibers: 126\n// number of fibers: 254\n// number of fibers: 510\n// number of fibers: 1022\n// number of fibers: 2034\n// number of fibers: 3795\n// number of fibers: 5810\n// number of fibers: 6474\n// number of fibers: 4942\n// number of fibers: 2515\n// number of fibers: 832\n// number of fibers: 170\n// number of fibers: 18\n// number of fibers: 0\n// fibonacci result: 10946'
        }
      ],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11870,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11870"
    },
    {
      id: "effect.transplant",
      name: "transplant",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(f: (grafter: <A2, E2, R2>(effect: Effect<A2, E2, R2>) => Effect<A2, E2, R2>) => Effect<A, E, R>) => Effect<A, E, R>",
      description: 'Transplants specified effects so that when those effects fork other\neffects, the forked effects will be governed by the scope of the fiber that\nexecutes this effect. This can be used to "graft" deep grandchildren onto a higher-level scope,\neffectively extending their lifespans into the parent scope.',
      documentation: 'Transplants specified effects so that when those effects fork other\neffects, the forked effects will be governed by the scope of the fiber that\nexecutes this effect.\n\nThis can be used to "graft" deep grandchildren onto a higher-level scope,\neffectively extending their lifespans into the parent scope.',
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12101,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12101"
    },
    {
      id: "effect.withConcurrency",
      name: "withConcurrency",
      module: "effect",
      package: "effect",
      signature: '{ (concurrency: number | "unbounded"): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, concurrency: number | "unbounded"): Effect<A, E, R>; }',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12106,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12106"
    },
    {
      id: "effect.withScheduler",
      name: "withScheduler",
      module: "effect",
      package: "effect",
      signature: "{ (scheduler: Scheduler): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, scheduler: Scheduler): Effect<A, E, R>; }",
      description: "Sets the provided scheduler for usage in the wrapped effect",
      documentation: "Sets the provided scheduler for usage in the wrapped effect",
      examples: [],
      tags: [
        "Scheduler"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12124,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12124"
    },
    {
      id: "effect.withSchedulingPriority",
      name: "withSchedulingPriority",
      module: "effect",
      package: "effect",
      signature: "{ (priority: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, priority: number): Effect<A, E, R>; }",
      description: "Sets the scheduling priority used when yielding",
      documentation: "Sets the scheduling priority used when yielding",
      examples: [],
      tags: [
        "Scheduler"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12146,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12146"
    },
    {
      id: "effect.withMaxOpsBeforeYield",
      name: "withMaxOpsBeforeYield",
      module: "effect",
      package: "effect",
      signature: "{ (priority: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, priority: number): Effect<A, E, R>; }",
      description: "Sets the maximum number of operations before yield by the default schedulers",
      documentation: "Sets the maximum number of operations before yield by the default schedulers",
      examples: [],
      tags: [
        "Scheduler"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12168,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12168"
    },
    {
      id: "effect.clock",
      name: "clock",
      module: "effect",
      package: "effect",
      signature: "Effect<Clock, never, never>",
      description: "Retrieves the `Clock` service from the context.",
      documentation: 'Retrieves the `Clock` service from the context.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  const clock = yield* Effect.clock\n  const currentTime = yield* clock.currentTimeMillis\n  console.log(`Current time in milliseconds: ${currentTime}`)\n})\n\nEffect.runFork(program)\n// Example Output:\n// Current time in milliseconds: 1735484796134\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  const clock = yield* Effect.clock\n  const currentTime = yield* clock.currentTimeMillis\n  console.log(`Current time in milliseconds: ${currentTime}`)\n})\n\nEffect.runFork(program)\n// Example Output:\n// Current time in milliseconds: 1735484796134'
        }
      ],
      tags: [
        "Clock"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12206,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12206"
    },
    {
      id: "effect.clockWith",
      name: "clockWith",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(f: (clock: Clock) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "Retrieves the `Clock` service from the context and provides it to the\nspecified effectful function.",
      documentation: 'Retrieves the `Clock` service from the context and provides it to the\nspecified effectful function.\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\nconst program = Effect.clockWith((clock) =>\n  clock.currentTimeMillis.pipe(\n    Effect.map((currentTime) => `Current time is: ${currentTime}`),\n    Effect.tap(Console.log)\n  )\n)\n\nEffect.runFork(program)\n// Example Output:\n// Current time is: 1735484929744\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\nconst program = Effect.clockWith((clock) =>\n  clock.currentTimeMillis.pipe(\n    Effect.map((currentTime) => `Current time is: ${currentTime}`),\n    Effect.tap(Console.log)\n  )\n)\n\nEffect.runFork(program)\n// Example Output:\n// Current time is: 1735484929744'
        }
      ],
      tags: [
        "Clock"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12231,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12231"
    },
    {
      id: "effect.withClockScoped",
      name: "withClockScoped",
      module: "effect",
      package: "effect",
      signature: "<C extends Clock.Clock>(clock: C) => Effect<void, never, Scope>",
      description: "Sets the implementation of the `Clock` service to the specified value and\nrestores it to its original value when the scope is closed.",
      documentation: "Sets the implementation of the `Clock` service to the specified value and\nrestores it to its original value when the scope is closed.",
      examples: [],
      tags: [
        "Clock"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12239,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12239"
    },
    {
      id: "effect.withClock",
      name: "withClock",
      module: "effect",
      package: "effect",
      signature: "{ <C extends Clock.Clock>(clock: C): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <C extends Clock.Clock, A, E, R>(effect: Effect<A, E, R>, clock: C): Effect<A, E, R>; }",
      description: "Executes the specified workflow with the specified implementation of the\n`Clock` service.",
      documentation: "Executes the specified workflow with the specified implementation of the\n`Clock` service.",
      examples: [],
      tags: [
        "Clock"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12247,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12247"
    },
    {
      id: "effect.console",
      name: "console",
      module: "effect",
      package: "effect",
      signature: "Effect<Console, never, never>",
      description: "Retreives the `Console` service from the context",
      documentation: "Retreives the `Console` service from the context",
      examples: [],
      tags: [
        "Console"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12271,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12271"
    },
    {
      id: "effect.consoleWith",
      name: "consoleWith",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(f: (console: Console) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "Retreives the `Console` service from the context and provides it to the\nspecified effectful function.",
      documentation: "Retreives the `Console` service from the context and provides it to the\nspecified effectful function.",
      examples: [],
      tags: [
        "Console"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12279,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12279"
    },
    {
      id: "effect.withConsoleScoped",
      name: "withConsoleScoped",
      module: "effect",
      package: "effect",
      signature: "<A extends Console>(console: A) => Effect<void, never, Scope>",
      description: "Sets the implementation of the console service to the specified value and\nrestores it to its original value when the scope is closed.",
      documentation: "Sets the implementation of the console service to the specified value and\nrestores it to its original value when the scope is closed.",
      examples: [],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12287,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12287"
    },
    {
      id: "effect.withConsole",
      name: "withConsole",
      module: "effect",
      package: "effect",
      signature: "{ <C extends Console>(console: C): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, C extends Console>(effect: Effect<A, E, R>, console: C): Effect<A, E, R>; }",
      description: "Executes the specified workflow with the specified implementation of the\nconsole service.",
      documentation: "Executes the specified workflow with the specified implementation of the\nconsole service.",
      examples: [],
      tags: [
        "Console"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12295,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12295"
    },
    {
      id: "effect.delay",
      name: "delay",
      module: "effect",
      package: "effect",
      signature: "{ (duration: DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, duration: DurationInput): Effect<A, E, R>; }",
      description: "Delays the execution of an effect by a specified `Duration`. Details This function postpones the execution of the provided effect by the specified\nduration. The duration can be provided in various formats supported by the\n`Duration` module. Internally, this function does not block the thread; instead, it uses an\nefficient, non-blocking mechanism to introduce the delay.",
      documentation: 'Delays the execution of an effect by a specified `Duration`.\n\n**Details\n\nThis function postpones the execution of the provided effect by the specified\nduration. The duration can be provided in various formats supported by the\n`Duration` module.\n\nInternally, this function does not block the thread; instead, it uses an\nefficient, non-blocking mechanism to introduce the delay.\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\nconst task = Console.log("Task executed")\n\nconst program = Console.log("start").pipe(\n  Effect.andThen(\n    // Delays the log message by 2 seconds\n    task.pipe(Effect.delay("2 seconds"))\n  )\n)\n\nEffect.runFork(program)\n// Output:\n// start\n// Task executed\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\nconst task = Console.log("Task executed")\n\nconst program = Console.log("start").pipe(\n  Effect.andThen(\n    // Delays the log message by 2 seconds\n    task.pipe(Effect.delay("2 seconds"))\n  )\n)\n\nEffect.runFork(program)\n// Output:\n// start\n// Task executed'
        }
      ],
      tags: [
        "Delays & Timeouts"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12348,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12348"
    },
    {
      id: "effect.sleep",
      name: "sleep",
      module: "effect",
      package: "effect",
      signature: "(duration: DurationInput) => Effect<void, never, never>",
      description: "Suspends the execution of an effect for a specified `Duration`.",
      documentation: 'Suspends the execution of an effect for a specified `Duration`.\n\n**Details**\n\nThis function pauses the execution of an effect for a given duration. It is\nasynchronous, meaning that it does not block the fiber executing the effect.\nInstead, the fiber is suspended during the delay period and can resume once\nthe specified time has passed.\n\nThe duration can be specified using various formats supported by the\n`Duration` module, such as a string (`"2 seconds"`) or numeric value\nrepresenting milliseconds.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  console.log("Starting task...")\n  yield* Effect.sleep("3 seconds") // Waits for 3 seconds\n  console.log("Task completed!")\n})\n\nEffect.runFork(program)\n// Output:\n// Starting task...\n// Task completed!\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  console.log("Starting task...")\n  yield* Effect.sleep("3 seconds") // Waits for 3 seconds\n  console.log("Task completed!")\n})\n\nEffect.runFork(program)\n// Output:\n// Starting task...\n// Task completed!'
        }
      ],
      tags: [
        "Delays & Timeouts"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12456,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12456"
    },
    {
      id: "effect.timed",
      name: "timed",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<[duration: Duration, result: A], E, R>",
      description: "Executes an effect and measures the time it takes to complete.",
      documentation: 'Executes an effect and measures the time it takes to complete.\n\n**Details**\n\nThis function wraps the provided effect and returns a new effect that, when\nexecuted, performs the original effect and calculates its execution duration.\n\nThe result of the new effect includes both the execution time (as a\n`Duration`) and the original effect\'s result. This is useful for monitoring\nperformance or gaining insights into the time taken by specific operations.\n\nThe original effect\'s behavior (success, failure, or interruption) remains\nunchanged, and the timing information is provided alongside the result in a\ntuple.\n\n**Example**\n\n```ts\nimport { Duration, Effect } from "effect"\n\nconst task = Effect.gen(function*() {\n  yield* Effect.sleep("2 seconds") // Simulates some work\n  return "some result"\n})\n\nconst timedTask = task.pipe(Effect.timed)\n\nconst program = Effect.gen(function*() {\n  const [duration, result] = yield* timedTask\n  console.log(`Task completed in ${Duration.toMillis(duration)} ms with result: ${result}`)\n})\n\nEffect.runFork(program)\n// Output: Task completed in 2003.749125 ms with result: some result\n```',
      examples: [
        {
          code: 'import { Duration, Effect } from "effect"\n\nconst task = Effect.gen(function*() {\n  yield* Effect.sleep("2 seconds") // Simulates some work\n  return "some result"\n})\n\nconst timedTask = task.pipe(Effect.timed)\n\nconst program = Effect.gen(function*() {\n  const [duration, result] = yield* timedTask\n  console.log(`Task completed in ${Duration.toMillis(duration)} ms with result: ${result}`)\n})\n\nEffect.runFork(program)\n// Output: Task completed in 2003.749125 ms with result: some result'
        }
      ],
      tags: [
        "Delays & Timeouts"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12497,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12497"
    },
    {
      id: "effect.timedWith",
      name: "timedWith",
      module: "effect",
      package: "effect",
      signature: "{ <E1, R1>(nanoseconds: Effect<bigint, E1, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<[Duration, A], E1 | E, R1 | R>; <A, E, R, E1, R1>(self: Effect<A, E, R>, nanoseconds: Effect<bigint, E1, R1>): Effect<[Duration, A], E | E1, R | R1>; }",
      description: "/\n * Executes an effect and measures its execution time using a custom clock.\n *\n *",
      documentation: "/**\n * Executes an effect and measures its execution time using a custom clock.\n *\n * **Details**\n *\n * This function extends the functionality of {@link timed}by allowing you to\n * specify a custom clock for measuring the execution duration. The provided\n * effect (`nanoseconds`) represents the clock and should return the current\n * time in nanoseconds. The timing information is computed using this custom\n * clock instead of the default system clock.\n *\n *",
      examples: [],
      tags: [
        "Delays & Timeouts"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12512,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12512"
    },
    {
      id: "effect.timeout",
      name: "timeout",
      module: "effect",
      package: "effect",
      signature: "{ (duration: DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | TimeoutException, R>; <A, E, R>(self: Effect<A, E, R>, duration: DurationInput): Effect<A, E | TimeoutException, R>; }",
      description: "Adds a time limit to an effect, triggering a timeout if the effect exceeds\nthe duration.",
      documentation: `Adds a time limit to an effect, triggering a timeout if the effect exceeds
the duration.

**Details**

This function allows you to enforce a time limit on the execution of an
effect. If the effect does not complete within the given duration, it fails
with a \`TimeoutException\`. This is useful for preventing tasks from hanging
indefinitely, especially in scenarios where responsiveness or resource limits
are critical.

The returned effect will either:
- Succeed with the original effect's result if it completes within the
  specified duration.
- Fail with a \`TimeoutException\` if the time limit is exceeded.

**Example**

\`\`\`ts
import { Effect } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

// Output will show a TimeoutException as the task takes longer
// than the specified timeout duration
const timedEffect = task.pipe(Effect.timeout("1 second"))

Effect.runPromiseExit(timedEffect).then(console.log)
// Output:
// Start processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: { _tag: 'TimeoutException' }
//   }
// }
\`\`\``,
      examples: [
        {
          code: `import { Effect } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

// Output will show a TimeoutException as the task takes longer
// than the specified timeout duration
const timedEffect = task.pipe(Effect.timeout("1 second"))

Effect.runPromiseExit(timedEffect).then(console.log)
// Output:
// Start processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: { _tag: 'TimeoutException' }
//   }
// }`
        }
      ],
      tags: [
        "Delays & Timeouts"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12599,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12599"
    },
    {
      id: "effect.timeoutOption",
      name: "timeoutOption",
      module: "effect",
      package: "effect",
      signature: "{ (duration: DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, duration: DurationInput): Effect<Option<A>, E, R>; }",
      description: "Gracefully handles timeouts by returning an `Option` that represents either\nthe result or a timeout.",
      documentation: 'Gracefully handles timeouts by returning an `Option` that represents either\nthe result or a timeout.\n\n**Details**\n\nThis function wraps the outcome of an effect in an `Option` type. If the\neffect completes within the specified duration, it returns a `Some`\ncontaining the result. If the effect times out, it returns a `None`. Unlike\nother timeout methods, this approach does not raise errors or exceptions;\ninstead, it allows you to treat timeouts as a regular outcome, simplifying\nthe logic for handling delays.\n\n**When to Use**\n\nThis is useful when you want to handle timeouts without causing the program\nto fail, making it easier to manage situations where you expect tasks might\ntake too long but want to continue executing other tasks.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst task = Effect.gen(function* () {\n  console.log("Start processing...")\n  yield* Effect.sleep("2 seconds") // Simulates a delay in processing\n  console.log("Processing complete.")\n  return "Result"\n})\n\nconst timedOutEffect = Effect.all([\n  task.pipe(Effect.timeoutOption("3 seconds")),\n  task.pipe(Effect.timeoutOption("1 second"))\n])\n\nEffect.runPromise(timedOutEffect).then(console.log)\n// Output:\n// Start processing...\n// Processing complete.\n// Start processing...\n// [\n//   { _id: \'Option\', _tag: \'Some\', value: \'Result\' },\n//   { _id: \'Option\', _tag: \'None\' }\n// ]\n```',
      examples: [
        {
          code: `import { Effect } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

const timedOutEffect = Effect.all([
  task.pipe(Effect.timeoutOption("3 seconds")),
  task.pipe(Effect.timeoutOption("1 second"))
])

Effect.runPromise(timedOutEffect).then(console.log)
// Output:
// Start processing...
// Processing complete.
// Start processing...
// [
//   { _id: 'Option', _tag: 'Some', value: 'Result' },
//   { _id: 'Option', _tag: 'None' }
// ]`
        }
      ],
      tags: [
        "Delays & Timeouts"
      ],
      since: "3.1.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12769,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12769"
    },
    {
      id: "effect.timeoutFail",
      name: "timeoutFail",
      module: "effect",
      package: "effect",
      signature: "{ <E1>(options: { readonly onTimeout: LazyArg<E1>; readonly duration: DurationInput; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R>; <A, E, R, E1>(self: Effect<A, E, R>, options: { readonly onTimeout: LazyArg<E1>; readonly duration: DurationInput; }): Effect<A, E | E1, R>; }",
      description: "Specifies a custom error to be produced when a timeout occurs.",
      documentation: 'Specifies a custom error to be produced when a timeout occurs.\n\n**Details**\n\nThis function allows you to handle timeouts in a customized way by defining a\nspecific error to be raised when an effect exceeds the given duration. Unlike\ndefault timeout behaviors that use generic exceptions, this function gives\nyou the flexibility to specify a meaningful error type that aligns with your\napplication\'s needs.\n\nWhen you apply this function, you provide:\n- A `duration`: The time limit for the effect.\n- An `onTimeout` function: A lazy evaluation function that generates the\n  custom error if the timeout occurs.\n\nIf the effect completes within the time limit, its result is returned\nnormally. Otherwise, the `onTimeout` function is triggered, and its output is\nused as the error for the effect.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst task = Effect.gen(function* () {\n  console.log("Start processing...")\n  yield* Effect.sleep("2 seconds") // Simulates a delay in processing\n  console.log("Processing complete.")\n  return "Result"\n})\n\nclass MyTimeoutError {\n  readonly _tag = "MyTimeoutError"\n}\n\nconst program = task.pipe(\n  Effect.timeoutFail({\n    duration: "1 second",\n    onTimeout: () => new MyTimeoutError() // Custom timeout error\n  })\n)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// Start processing...\n// {\n//   _id: \'Exit\',\n//   _tag: \'Failure\',\n//   cause: {\n//     _id: \'Cause\',\n//     _tag: \'Fail\',\n//     failure: MyTimeoutError { _tag: \'MyTimeoutError\' }\n//   }\n// }\n```',
      examples: [
        {
          code: `import { Effect } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

class MyTimeoutError {
  readonly _tag = "MyTimeoutError"
}

const program = task.pipe(
  Effect.timeoutFail({
    duration: "1 second",
    onTimeout: () => new MyTimeoutError() // Custom timeout error
  })
)

Effect.runPromiseExit(program).then(console.log)
// Output:
// Start processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: MyTimeoutError { _tag: 'MyTimeoutError' }
//   }
// }`
        }
      ],
      tags: [
        "Delays & Timeouts"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12950,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12950"
    },
    {
      id: "effect.timeoutFailCause",
      name: "timeoutFailCause",
      module: "effect",
      package: "effect",
      signature: "{ <E1>(options: { readonly onTimeout: LazyArg<Cause<E1>>; readonly duration: DurationInput; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R>; <A, E, R, E1>(self: Effect<A, E, R>, options: { readonly onTimeout: LazyArg<Cause<E1>>; readonly duration: DurationInput; }): Effect<A, E | E1, R>; }",
      description: "Specifies a custom defect to be thrown when a timeout occurs.",
      documentation: 'Specifies a custom defect to be thrown when a timeout occurs.\n\n**Details**\n\nThis function allows you to handle timeouts as exceptional cases by\ngenerating a custom defect when an effect exceeds the specified duration. You\nprovide:\n- A `duration`: The time limit for the effect.\n- An `onTimeout` function: A lazy evaluation function that generates the\n  custom defect (typically created using `Cause.die`).\n\nIf the effect completes within the time limit, its result is returned\nnormally. Otherwise, the custom defect is triggered, and the effect fails\nwith that defect.\n\n**When to Use**\n\nThis is especially useful when you need to treat timeouts as critical\nfailures in your application and wish to include meaningful information in\nthe defect.\n\n**Example**\n\n```ts\nimport { Effect, Cause } from "effect"\n\nconst task = Effect.gen(function* () {\n  console.log("Start processing...")\n  yield* Effect.sleep("2 seconds") // Simulates a delay in processing\n  console.log("Processing complete.")\n  return "Result"\n})\n\nconst program = task.pipe(\n  Effect.timeoutFailCause({\n    duration: "1 second",\n    onTimeout: () => Cause.die("Timed out!") // Custom defect for timeout\n  })\n)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// Start processing...\n// {\n//   _id: \'Exit\',\n//   _tag: \'Failure\',\n//   cause: { _id: \'Cause\', _tag: \'Die\', defect: \'Timed out!\' }\n// }\n```',
      examples: [
        {
          code: `import { Effect, Cause } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

const program = task.pipe(
  Effect.timeoutFailCause({
    duration: "1 second",
    onTimeout: () => Cause.die("Timed out!") // Custom defect for timeout
  })
)

Effect.runPromiseExit(program).then(console.log)
// Output:
// Start processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Die', defect: 'Timed out!' }
// }`
        }
      ],
      tags: [
        "Delays & Timeouts"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 13149,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L13149"
    },
    {
      id: "effect.timeoutTo",
      name: "timeoutTo",
      module: "effect",
      package: "effect",
      signature: "{ <A, B, B1>(options: { readonly onTimeout: LazyArg<B1>; readonly onSuccess: (a: A) => B; readonly duration: DurationInput; }): <E, R>(self: Effect<A, E, R>) => Effect<B | B1, E, R>; <A, E, R, B1, B>(self: Effect<A, E, R>, options: { readonly onTimeout: LazyArg<B1>; readonly onSuccess: (a: A) => B; readonly duration: DurationInput; }): Effect<B1 | B, E, R>; }",
      description: "/\n * Provides custom behavior for successful and timed-out operations.\n *\n *",
      documentation: '/**\n * Provides custom behavior for successful and timed-out operations.\n *\n * **Details**\n *\n * This function allows you to define distinct outcomes for an effect depending\n * on whether it completes within a specified time frame or exceeds the timeout\n * duration. You can provide:\n * - `onSuccess`: A handler for processing the result of the effect if it\n *   completes successfully within the time limit.\n * - `onTimeout`: A handler for generating a result when the effect times out.\n * - `duration`: The maximum allowed time for the effect to complete.\n *\n * **When to Use**\n *\n * Unlike {@link timeout}, which raises an exception for timeouts, this function\n * gives you full control over the behavior for both success and timeout\n * scenarios. It is particularly useful when you want to encapsulate timeouts\n * and successes into a specific data structure, like an `Either` type, to\n * represent these outcomes in a meaningful way.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Either } from "effect"\n *\n * const task = Effect.gen(function* () {\n *   console.log("Start processing...")\n *   yield* Effect.sleep("2 seconds") // Simulates a delay in processing\n *   console.log("Processing complete.")\n *   return "Result"\n * })\n *\n * const program = task.pipe(\n *   Effect.timeoutTo({\n *     duration: "1 second",\n *     onSuccess: (result): Either.Either<string, string> =>\n *       Either.right(result),\n *     onTimeout: (): Either.Either<string, string> =>\n *       Either.left("Timed out!")\n *   })\n * )\n *\n * Effect.runPromise(program).then(console.log)\n * // Output:\n * // Start processing...\n * // {\n * //   _id: "Either",\n * //   _tag: "Left",\n * //   left: "Timed out!"\n * // }\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect, Either } from "effect"\n *\n * const task = Effect.gen(function* () {\n *   console.log("Start processing...")\n *   yield* Effect.sleep("2 seconds") // Simulates a delay in processing\n *   console.log("Processing complete.")\n *   return "Result"\n * })\n *\n * const program = task.pipe(\n *   Effect.timeoutTo({\n *     duration: "1 second",\n *     onSuccess: (result): Either.Either<string, string> =>\n *       Either.right(result),\n *     onTimeout: (): Either.Either<string, string> =>\n *       Either.left("Timed out!")\n *   })\n * )\n *\n * Effect.runPromise(program).then(console.log)\n * // Output:\n * // Start processing...\n * // {\n * //   _id: "Either",\n * //   _tag: "Left",\n * //   left: "Timed out!"\n * // }\n *'
        }
      ],
      tags: [
        "Delays & Timeouts"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 13337,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L13337"
    },
    {
      id: "effect.configProviderWith",
      name: "configProviderWith",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(f: (provider: ConfigProvider) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "Allows working with the default configuration provider.",
      documentation: "Allows working with the default configuration provider.\n\n**Details**\n\nThis function retrieves the default configuration provider and passes it to\nthe provided function, which can use it to perform computations or retrieve\nconfiguration values. The function can return an effect that leverages the\nconfiguration provider for its operations.",
      examples: [],
      tags: [
        "Config"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 13482,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L13482"
    },
    {
      id: "effect.withConfigProvider",
      name: "withConfigProvider",
      module: "effect",
      package: "effect",
      signature: "{ (provider: ConfigProvider): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, provider: ConfigProvider): Effect<A, E, R>; }",
      description: "Executes an effect using a specific configuration provider.",
      documentation: 'Executes an effect using a specific configuration provider.\n\n**Details**\n\nThis function lets you run an effect with a specified configuration provider.\nThe custom provider will override the default configuration provider for the\nduration of the effect\'s execution.\n\n**When to Use**\n\nThis is particularly useful when you need to use a different set of\nconfiguration values or sources for specific parts of your application.\n\n**Example**\n\n```ts\nimport { Config, ConfigProvider, Effect } from "effect"\n\nconst customProvider: ConfigProvider.ConfigProvider = ConfigProvider.fromMap(\n  new Map([["custom-key", "custom-value"]])\n)\n\nconst program = Effect.withConfigProvider(customProvider)(\n  Effect.gen(function*() {\n    const value = yield* Config.string("custom-key")\n    console.log(`Config value: ${value}`)\n  })\n)\n\nEffect.runPromise(program)\n// Output:\n// Config value: custom-value\n```',
      examples: [
        {
          code: 'import { Config, ConfigProvider, Effect } from "effect"\n\nconst customProvider: ConfigProvider.ConfigProvider = ConfigProvider.fromMap(\n  new Map([["custom-key", "custom-value"]])\n)\n\nconst program = Effect.withConfigProvider(customProvider)(\n  Effect.gen(function*() {\n    const value = yield* Config.string("custom-key")\n    console.log(`Config value: ${value}`)\n  })\n)\n\nEffect.runPromise(program)\n// Output:\n// Config value: custom-value'
        }
      ],
      tags: [
        "Config"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 13521,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L13521"
    },
    {
      id: "effect.withConfigProviderScoped",
      name: "withConfigProviderScoped",
      module: "effect",
      package: "effect",
      signature: "(provider: ConfigProvider) => Effect<void, never, Scope>",
      description: "Sets a configuration provider within a scope.",
      documentation: "Sets a configuration provider within a scope.\n\n**Details**\n\nThis function sets the configuration provider to a specified value and\nensures that it is restored to its original value when the scope is closed.",
      examples: [],
      tags: [
        "Config"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 13612,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L13612"
    },
    {
      id: "effect.context",
      name: "context",
      module: "effect",
      package: "effect",
      signature: "<R>() => Effect<Context<R>, never, R>",
      description: "Accesses the full context of the effect.",
      documentation: "Accesses the full context of the effect.\n\n**Details**\n\nThis function provides the ability to access the entire context required by\nan effect. The context is a container that holds dependencies or environment\nvalues needed by an effect to run. By using this function, you can retrieve\nand work with the context directly within an effect.",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 13626,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L13626"
    },
    {
      id: "effect.contextWith",
      name: "contextWith",
      module: "effect",
      package: "effect",
      signature: "<R, A>(f: (context: Context<R>) => A) => Effect<A, never, R>",
      description: "Accesses the context and applies a transformation function.",
      documentation: "Accesses the context and applies a transformation function.\n\n**Details**\n\nThis function retrieves the context of the effect and applies a pure\ntransformation function to it. The result of the transformation is then\nreturned within the effect.",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 13641,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L13641"
    },
    {
      id: "effect.contextWithEffect",
      name: "contextWithEffect",
      module: "effect",
      package: "effect",
      signature: "<R2, A, E, R>(f: (context: Context<R2>) => Effect<A, E, R>) => Effect<A, E, R2 | R>",
      description: "Accesses the context and performs an effectful transformation.",
      documentation: "Accesses the context and performs an effectful transformation.\n\n**Details**\n\nThis function retrieves the context and allows you to transform it\neffectually using another effect. It is useful when the transformation\ninvolves asynchronous or effectful operations.",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 13656,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L13656"
    },
    {
      id: "effect.mapInputContext",
      name: "mapInputContext",
      module: "effect",
      package: "effect",
      signature: "{ <R2, R>(f: (context: Context<R2>) => Context<R>): <A, E>(self: Effect<A, E, R>) => Effect<A, E, R2>; <A, E, R, R2>(self: Effect<A, E, R>, f: (context: Context<R2>) => Context<R>): Effect<A, E, R2>; }",
      description: "Provides part of the required context while leaving the rest unchanged.",
      documentation: 'Provides part of the required context while leaving the rest unchanged.\n\n**Details**\n\nThis function allows you to transform the context required by an effect,\nproviding part of the context and leaving the rest to be fulfilled later.\n\n**Example**\n\n```ts\nimport { Context, Effect } from "effect"\n\nclass Service1 extends Context.Tag("Service1")<Service1, { readonly port: number }>() {}\nclass Service2 extends Context.Tag("Service2")<Service2, { readonly connection: string }>() {}\n\nconst program = Effect.gen(function*() {\n  const service1 = yield* Service1\n  console.log(service1.port)\n  const service2 = yield* Service2\n  console.log(service2.connection)\n  return "some result"\n})\n\n//      \u250C\u2500\u2500\u2500 Effect<string, never, Service2>\n//      \u25BC\nconst programWithService1 = Effect.mapInputContext(\n  program,\n  (ctx: Context.Context<Service2>) => Context.add(ctx, Service1, { port: 3000 })\n)\n\nconst runnable = programWithService1.pipe(\n  Effect.provideService(Service2, { connection: "localhost" }),\n  Effect.provideService(Service1, { port: 3001 })\n)\n\nEffect.runPromise(runnable)\n// Output:\n// 3000\n// localhost\n```',
      examples: [
        {
          code: 'import { Context, Effect } from "effect"\n\nclass Service1 extends Context.Tag("Service1")<Service1, { readonly port: number }>() {}\nclass Service2 extends Context.Tag("Service2")<Service2, { readonly connection: string }>() {}\n\nconst program = Effect.gen(function*() {\n  const service1 = yield* Service1\n  console.log(service1.port)\n  const service2 = yield* Service2\n  console.log(service2.connection)\n  return "some result"\n})\n\n//      \u250C\u2500\u2500\u2500 Effect<string, never, Service2>\n//      \u25BC\nconst programWithService1 = Effect.mapInputContext(\n  program,\n  (ctx: Context.Context<Service2>) => Context.add(ctx, Service1, { port: 3000 })\n)\n\nconst runnable = programWithService1.pipe(\n  Effect.provideService(Service2, { connection: "localhost" }),\n  Effect.provideService(Service1, { port: 3001 })\n)\n\nEffect.runPromise(runnable)\n// Output:\n// 3000\n// localhost'
        }
      ],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 13702,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L13702"
    },
    {
      id: "effect.provide",
      name: "provide",
      module: "effect",
      package: "effect",
      signature: "{ <const Layers extends readonly [Layer.Layer.Any, ...Array<Layer.Layer.Any>]>(layers: Layers): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | { [k in keyof Layers]: Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Success<Layers[k]>; }[number]>>; <ROut, E2, RIn>(layer: Layer<ROut, E2, RIn>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, RIn | Exclude<R, ROut>>; <R2>(context: Context<R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, R2>>; <R2>(runtime: Runtime<R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, R2>>; <E2, R2>(managedRuntime: ManagedRuntime<R2, E2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, Exclude<R, R2>>; <A, E, R, const Layers extends readonly [Layer.Layer.Any, ...Array<Layer.Layer.Any>]>(self: Effect<A, E, R>, layers: Layers): Effect<A, E | { [k in keyof Layers]: Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Success<Layers[k]>; }[number]>>; <A, E, R, ROut, E2, RIn>(self: Effect<A, E, R>, layer: Layer<ROut, E2, RIn>): Effect<A, E | E2, RIn | Exclude<R, ROut>>; <A, E, R, R2>(self: Effect<A, E, R>, context: Context<R2>): Effect<A, E, Exclude<R, R2>>; <A, E, R, R2>(self: Effect<A, E, R>, runtime: Runtime<R2>): Effect<A, E, Exclude<R, R2>>; <A, E, E2, R, R2>(self: Effect<A, E, R>, runtime: ManagedRuntime<R2, E2>): Effect<A, E | E2, Exclude<R, R2>>; }",
      description: "Provides necessary dependencies to an effect, removing its environmental\nrequirements.",
      documentation: 'Provides necessary dependencies to an effect, removing its environmental\nrequirements.\n\n**Details**\n\nThis function allows you to supply the required environment for an effect.\nThe environment can be provided in the form of one or more `Layer`s, a\n`Context`, a `Runtime`, or a `ManagedRuntime`. Once the environment is\nprovided, the effect can run without requiring external dependencies.\n\nYou can compose layers to create a modular and reusable way of setting up the\nenvironment for effects. For example, layers can be used to configure\ndatabases, logging services, or any other required dependencies.\n\n**Example**\n\n```ts\nimport { Context, Effect, Layer } from "effect"\n\nclass Database extends Context.Tag("Database")<\n  Database,\n  { readonly query: (sql: string) => Effect.Effect<Array<unknown>> }\n>() {}\n\nconst DatabaseLive = Layer.succeed(\n  Database,\n  {\n    // Simulate a database query\n    query: (sql: string) => Effect.log(`Executing query: ${sql}`).pipe(Effect.as([]))\n  }\n)\n\n//      \u250C\u2500\u2500\u2500 Effect<unknown[], never, Database>\n//      \u25BC\nconst program = Effect.gen(function*() {\n  const database = yield* Database\n  const result = yield* database.query("SELECT * FROM users")\n  return result\n})\n\n//      \u250C\u2500\u2500\u2500 Effect<unknown[], never, never>\n//      \u25BC\nconst runnable = Effect.provide(program, DatabaseLive)\n\nEffect.runPromise(runnable).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message="Executing query: SELECT * FROM users"\n// []\n```',
      examples: [
        {
          code: 'import { Context, Effect, Layer } from "effect"\n\nclass Database extends Context.Tag("Database")<\n  Database,\n  { readonly query: (sql: string) => Effect.Effect<Array<unknown>> }\n>() {}\n\nconst DatabaseLive = Layer.succeed(\n  Database,\n  {\n    // Simulate a database query\n    query: (sql: string) => Effect.log(`Executing query: ${sql}`).pipe(Effect.as([]))\n  }\n)\n\n//      \u250C\u2500\u2500\u2500 Effect<unknown[], never, Database>\n//      \u25BC\nconst program = Effect.gen(function*() {\n  const database = yield* Database\n  const result = yield* database.query("SELECT * FROM users")\n  return result\n})\n\n//      \u250C\u2500\u2500\u2500 Effect<unknown[], never, never>\n//      \u25BC\nconst runnable = Effect.provide(program, DatabaseLive)\n\nEffect.runPromise(runnable).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message="Executing query: SELECT * FROM users"\n// []'
        }
      ],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 13852,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L13852"
    },
    {
      id: "effect.provideService",
      name: "provideService",
      module: "effect",
      package: "effect",
      signature: "{ <I, S>(tag: Tag<I, S>, service: NoInfer<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, I>>; <A, E, R, I, S>(self: Effect<A, E, R>, tag: Tag<I, S>, service: NoInfer<S>): Effect<A, E, Exclude<R, I>>; }",
      description: "Provides an implementation for a service in the context of an effect.",
      documentation: 'Provides an implementation for a service in the context of an effect.\n\n**Details**\n\nThis function allows you to supply a specific implementation for a service\nrequired by an effect. Services are typically defined using `Context.Tag`,\nwhich acts as a unique identifier for the service. By using this function,\nyou link the service to its concrete implementation, enabling the effect to\nexecute successfully without additional requirements.\n\nFor example, you can use this function to provide a random number generator,\na logger, or any other service your effect depends on. Once the service is\nprovided, all parts of the effect that rely on the service will automatically\nuse the implementation you supplied.\n\n**Example**\n\n```ts\nimport { Effect, Context } from "effect"\n\n// Declaring a tag for a service that generates random numbers\nclass Random extends Context.Tag("MyRandomService")<\n  Random,\n  { readonly next: Effect.Effect<number> }\n>() {}\n\n// Using the service\nconst program = Effect.gen(function* () {\n  const random = yield* Random\n  const randomNumber = yield* random.next\n  console.log(`random number: ${randomNumber}`)\n})\n\n// Providing the implementation\n//\n//      \u250C\u2500\u2500\u2500 Effect<void, never, never>\n//      \u25BC\nconst runnable = Effect.provideService(program, Random, {\n  next: Effect.sync(() => Math.random())\n})\n\n// Run successfully\nEffect.runPromise(runnable)\n// Example Output:\n// random number: 0.8241872233134417\n```',
      examples: [
        {
          code: 'import { Effect, Context } from "effect"\n\n// Declaring a tag for a service that generates random numbers\nclass Random extends Context.Tag("MyRandomService")<\n  Random,\n  { readonly next: Effect.Effect<number> }\n>() {}\n\n// Using the service\nconst program = Effect.gen(function* () {\n  const random = yield* Random\n  const randomNumber = yield* random.next\n  console.log(`random number: ${randomNumber}`)\n})\n\n// Providing the implementation\n//\n//      \u250C\u2500\u2500\u2500 Effect<void, never, never>\n//      \u25BC\nconst runnable = Effect.provideService(program, Random, {\n  next: Effect.sync(() => Math.random())\n})\n\n// Run successfully\nEffect.runPromise(runnable)\n// Example Output:\n// random number: 0.8241872233134417'
        }
      ],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14489,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14489"
    },
    {
      id: "effect.provideServiceEffect",
      name: "provideServiceEffect",
      module: "effect",
      package: "effect",
      signature: "{ <I, S, E1, R1>(tag: Tag<I, S>, effect: Effect<NoInfer<S>, E1, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R1 | Exclude<R, I>>; <A, E, R, I, S, E1, R1>(self: Effect<A, E, R>, tag: Tag<I, S>, effect: Effect<NoInfer<S>, E1, R1>): Effect<A, E | E1, R1 | Exclude<R, I>>; }",
      description: "Dynamically provides an implementation for a service using an effect.",
      documentation: "Dynamically provides an implementation for a service using an effect.\n\n**Details**\n\nThis function allows you to provide an implementation for a service\ndynamically by using another effect. The provided effect is executed to\nproduce the service implementation, which is then made available to the\nconsuming effect. This is particularly useful when the service implementation\nitself requires asynchronous or resource-intensive initialization.\n\nFor example, you can use this function to lazily initialize a database\nconnection or fetch configuration values from an external source before\nmaking the service available to your effect.",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14617,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14617"
    },
    {
      id: "effect.serviceFunction",
      name: "serviceFunction",
      module: "effect",
      package: "effect",
      signature: "<T extends Effect<any, any, any>, Args extends Array<any>, A>(getService: T, f: (_: Effect.Success<T>) => (...args: Args) => A) => (...args: Args) => Effect<A, Effect.Error<T>, Effect.Context<T>>",
      description: "Creates a function that uses a service from the context to produce a value.",
      documentation: "Creates a function that uses a service from the context to produce a value.",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14665,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14665"
    },
    {
      id: "effect.serviceFunctionEffect",
      name: "serviceFunctionEffect",
      module: "effect",
      package: "effect",
      signature: "<T extends Effect<any, any, any>, Args extends Array<any>, A, E, R>(getService: T, f: (_: Effect.Success<T>) => (...args: Args) => Effect<A, E, R>) => (...args: Args) => Effect<A, E | Effect.Error<T>, R | Effect.Context<T>>",
      description: "Creates a function that uses a service from the context to produce an effect.",
      documentation: "Creates a function that uses a service from the context to produce an effect.",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14674,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14674"
    },
    {
      id: "effect.serviceFunctions",
      name: "serviceFunctions",
      module: "effect",
      package: "effect",
      signature: "<S, SE, SR>(getService: Effect<S, SE, SR>) => { [k in keyof S as S[k] extends (...args: any[]) => Effect<any, any, any> ? k : never]: S[k] extends (...args: infer Args) => Effect<infer A, infer E, infer R> ? (...args: Args) => Effect<A, SE | E, SR | R> : never; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14679,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14679"
    },
    {
      id: "effect.serviceConstants",
      name: "serviceConstants",
      module: "effect",
      package: "effect",
      signature: "<S, SE, SR>(getService: Effect<S, SE, SR>) => { [k in { [k in keyof S]: k; }[keyof S]]: S[k] extends Effect<infer A, infer E, infer R> ? Effect<A, SE | E, SR | R> : Effect<S[k], SE, SR>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14686,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14686"
    },
    {
      id: "effect.serviceMembers",
      name: "serviceMembers",
      module: "effect",
      package: "effect",
      signature: "<S, SE, SR>(getService: Effect<S, SE, SR>) => { functions: { [k in keyof S as S[k] extends (...args: any[]) => Effect<any, any, any> ? k : never]: S[k] extends (...args: infer Args) => Effect<infer A, infer E, infer R> ? (...args: Args) => Effect<A, SE | E, SR | R> : never; }; constants: { [k in { [k in keyof S]: k; }[keyof S]]: S[k] extends Effect<infer A, infer E, infer R> ? Effect<A, SE | E, SR | R> : Effect<S[k], SE, SR>; }; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14695,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14695"
    },
    {
      id: "effect.serviceOption",
      name: "serviceOption",
      module: "effect",
      package: "effect",
      signature: "<I, S>(tag: Tag<I, S>) => Effect<Option<S>, never, never>",
      description: "Retrieves an optional service from the context as an `Option`.",
      documentation: "Retrieves an optional service from the context as an `Option`.\n\n**Details**\n\nThis function retrieves a service from the context and wraps it in an\n`Option`. If the service is available, it returns a `Some` containing the\nservice. If the service is not found, it returns a `None`. This approach is\nuseful when you want to handle the absence of a service gracefully without\ncausing an error.\n\n**When to Use**\n\nUse this function when:\n- You need to access a service that may or may not be present in the context.\n- You want to handle the absence of a service using the `Option` type instead\n  of throwing an error.",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14728,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14728"
    },
    {
      id: "effect.serviceOptional",
      name: "serviceOptional",
      module: "effect",
      package: "effect",
      signature: "<I, S>(tag: Tag<I, S>) => Effect<S, NoSuchElementException, never>",
      description: "Retrieves a service from the context, throwing an error if it is missing.",
      documentation: "Retrieves a service from the context, throwing an error if it is missing.\n\n**Details**\n\nThis function retrieves a required service from the context. If the service\nis available, it returns the service. If the service is missing, it throws a\n`NoSuchElementException`, which can be handled using Effect's error-handling\nmechanisms. This is useful for services that are critical to the execution of\nyour effect.",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14745,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14745"
    },
    {
      id: "effect.updateService",
      name: "updateService",
      module: "effect",
      package: "effect",
      signature: "{ <I, S>(tag: Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, I | R>; <A, E, R, I, S>(self: Effect<A, E, R>, tag: Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): Effect<A, E, R | I>; }",
      description: "Updates a service in the context with a new implementation.",
      documentation: "Updates a service in the context with a new implementation.\n\n**Details**\n\nThis function modifies the existing implementation of a service in the\ncontext. It retrieves the current service, applies the provided\ntransformation function `f`, and replaces the old service with the\ntransformed one.\n\n**When to Use**\n\nThis is useful for adapting or extending a service's behavior during the\nexecution of an effect.",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14764,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14764"
    },
    {
      id: "effect.Do",
      name: "Do",
      module: "effect",
      package: "effect",
      signature: "Effect<{}, never, never>",
      description: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`. Here\'s how the do simulation works: 1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values',
      documentation: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere\'s how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n\n**Example**\n\n```ts\nimport * as assert from "node:assert"\nimport { Effect, pipe } from "effect"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind("x", () => Effect.succeed(2)),\n  Effect.bind("y", () => Effect.succeed(3)),\n  Effect.let("sum", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })\n```',
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Effect, pipe } from "effect"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind("x", () => Effect.succeed(2)),\n  Effect.bind("y", () => Effect.succeed(3)),\n  Effect.let("sum", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })'
        }
      ],
      tags: [
        "Do notation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14836,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14836"
    },
    {
      id: "effect.bind",
      name: "bind",
      module: "effect",
      package: "effect",
      signature: "{ <N extends string, A extends object, B, E2, R2>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Effect<B, E2, R2>): <E1, R1>(self: Effect<A, E1, R1>) => Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E2 | E1, R2 | R1>; <A extends object, N extends string, E1, R1, B, E2, R2>(self: Effect<A, E1, R1>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Effect<B, E2, R2>): Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E1 | E2, R1 | R2>; }",
      description: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`. Here\'s how the do simulation works: 1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values',
      documentation: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere\'s how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n\n**Example**\n\n```ts\nimport * as assert from "node:assert"\nimport { Effect, pipe } from "effect"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind("x", () => Effect.succeed(2)),\n  Effect.bind("y", () => Effect.succeed(3)),\n  Effect.let("sum", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })\n```',
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Effect, pipe } from "effect"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind("x", () => Effect.succeed(2)),\n  Effect.bind("y", () => Effect.succeed(3)),\n  Effect.let("sum", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })'
        }
      ],
      tags: [
        "Do notation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14869,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14869"
    },
    {
      id: "effect.bindAll",
      name: "bindAll",
      module: "effect",
      package: "effect",
      signature: '{ <A extends object, X extends Record<string, Effect<any, any, any>>, O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly mode?: "default" | "validate" | "either" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, O>>(f: (a: NoInfer<A>) => [Extract<keyof X, keyof A>] extends [never] ? X : "Duplicate keys", options?: O): <E1, R1>(self: Effect<A, E1, R1>) => [All.ReturnObject<X, false, All.ExtractMode<O>>] extends [Effect<infer Success, infer Error, infer Context>] ? Effect<{ [K in keyof A | keyof Success]: K extends keyof A ? A[K] : K extends keyof Success ? Success[K] : never; }, E1 | Error, R1 | Context> : never; <A extends object, X extends Record<string, Effect<any, any, any>>, O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly mode?: "default" | "validate" | "either" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, O>, E1, R1>(self: Effect<A, E1, R1>, f: (a: NoInfer<A>) => [Extract<keyof X, keyof A>] extends [never] ? X : "Duplicate keys", options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly mode?: "default" | "validate" | "either"; readonly concurrentFinalizers?: boolean; }): [All.ReturnObject<X, false, All.ExtractMode<O>>] extends [Effect<infer Success, infer Error, infer Context>] ? Effect<{ [K in keyof A | keyof Success]: K extends keyof A ? A[K] : K extends keyof Success ? Success[K] : never; }, E1 | Error, R1 | Context> : never; }',
      description: "`bindAll` combines `all` with `bind`. It is useful\nwhen you want to concurrently run multiple effects and then combine their\nresults in a Do notation pipeline.",
      documentation: '`bindAll` combines `all` with `bind`. It is useful\nwhen you want to concurrently run multiple effects and then combine their\nresults in a Do notation pipeline.\n\n**Example**\n\n```ts\nimport * as assert from "node:assert"\nimport { Effect, Either, pipe } from "effect"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind("x", () => Effect.succeed(2)),\n  Effect.bindAll(({ x }) => ({\n    a: Effect.succeed(x),\n    b: Effect.fail("oops"),\n  }), { concurrency: 2, mode: "either" })\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, a: Either.right(2), b: Either.left("oops") })\n```',
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Effect, Either, pipe } from "effect"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind("x", () => Effect.succeed(2)),\n  Effect.bindAll(({ x }) => ({\n    a: Effect.succeed(x),\n    b: Effect.fail("oops"),\n  }), { concurrency: 2, mode: "either" })\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, a: Either.right(2), b: Either.left("oops") })'
        }
      ],
      tags: [
        "Do notation"
      ],
      since: "3.7.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14966,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14966"
    },
    {
      id: "effect.bindTo",
      name: "bindTo",
      module: "effect",
      package: "effect",
      signature: "{ <N extends string>(name: N): <A, E, R>(self: Effect<A, E, R>) => Effect<{ [K in N]: A; }, E, R>; <A, E, R, N extends string>(self: Effect<A, E, R>, name: N): Effect<{ [K in N]: A; }, E, R>; }",
      description: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`. Here\'s how the do simulation works: 1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values',
      documentation: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere\'s how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n\n**Example**\n\n```ts\nimport * as assert from "node:assert"\nimport { Effect, pipe } from "effect"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind("x", () => Effect.succeed(2)),\n  Effect.bind("y", () => Effect.succeed(3)),\n  Effect.let("sum", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })\n```',
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Effect, pipe } from "effect"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind("x", () => Effect.succeed(2)),\n  Effect.bind("y", () => Effect.succeed(3)),\n  Effect.let("sum", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })'
        }
      ],
      tags: [
        "Do notation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 15071,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L15071"
    },
    {
      id: "effect.option",
      name: "option",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<Option<A>, never, R>",
      description: "Encapsulates the result of an effect in an `Option`.",
      documentation: "Encapsulates the result of an effect in an `Option`.\n\n**Details**\n\nThis function wraps the outcome of an effect in an `Option` type. If the\noriginal effect succeeds, the success value is wrapped in `Option.some`. If\nthe effect fails, the failure is converted to `Option.none`.\n\nThis is particularly useful for scenarios where you want to represent the\nabsence of a value explicitly, without causing the resulting effect to fail.\nThe resulting effect has an error type of `never`, meaning it cannot fail\ndirectly. However, unrecoverable errors, also referred to as defects, are\nnot captured and will still result in failure.\n\n**Example** (Using Effect.option to Handle Errors)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst maybe1 = Effect.option(Effect.succeed(1))\n\nEffect.runPromiseExit(maybe1).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Success',\n//   value: { _id: 'Option', _tag: 'Some', value: 1 }\n// }\n\nconst maybe2 = Effect.option(Effect.fail(\"Uh oh!\"))\n\nEffect.runPromiseExit(maybe2).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Success',\n//   value: { _id: 'Option', _tag: 'None' }\n// }\n\nconst maybe3 = Effect.option(Effect.die(\"Boom!\"))\n\nEffect.runPromiseExit(maybe3).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Die', defect: 'Boom!' }\n// }\n```",
      examples: [
        {
          title: "Using Effect.option to Handle Errors",
          code: `import { Effect } from "effect"

const maybe1 = Effect.option(Effect.succeed(1))

Effect.runPromiseExit(maybe1).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Success',
//   value: { _id: 'Option', _tag: 'Some', value: 1 }
// }

const maybe2 = Effect.option(Effect.fail("Uh oh!"))

Effect.runPromiseExit(maybe2).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Success',
//   value: { _id: 'Option', _tag: 'None' }
// }

const maybe3 = Effect.option(Effect.die("Boom!"))

Effect.runPromiseExit(maybe3).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Die', defect: 'Boom!' }
// }`
        }
      ],
      tags: [
        "Outcome Encapsulation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 15243,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L15243"
    },
    {
      id: "effect.either",
      name: "either",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<Either<A, E>, never, R>",
      description: "Encapsulates both success and failure of an `Effect` into an `Either` type.",
      documentation: 'Encapsulates both success and failure of an `Effect` into an `Either` type.\n\n**Details**\n\nThis function converts an effect that may fail into an effect that always\nsucceeds, wrapping the outcome in an `Either` type. The result will be\n`Either.Left` if the effect fails, containing the recoverable error, or\n`Either.Right` if it succeeds, containing the result.\n\nUsing this function, you can handle recoverable errors explicitly without\ncausing the effect to fail. This is particularly useful in scenarios where\nyou want to chain effects and manage both success and failure in the same\nlogical flow.\n\nIt\'s important to note that unrecoverable errors, often referred to as\n"defects," are still thrown and not captured within the `Either` type. Only\nfailures that are explicitly represented as recoverable errors in the effect\nare encapsulated.\n\nThe resulting effect cannot fail directly because all recoverable failures\nare represented inside the `Either` type.\n\n**Example**\n\n```ts\nimport { Effect, Either, Random } from "effect"\n\nclass HttpError {\n  readonly _tag = "HttpError"\n}\n\nclass ValidationError {\n  readonly _tag = "ValidationError"\n}\n\n//      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return "some result"\n})\n\n//      \u250C\u2500\u2500\u2500 Effect<string, never, never>\n//      \u25BC\nconst recovered = Effect.gen(function* () {\n  //      \u250C\u2500\u2500\u2500 Either<string, HttpError | ValidationError>\n  //      \u25BC\n  const failureOrSuccess = yield* Effect.either(program)\n  return Either.match(failureOrSuccess, {\n    onLeft: (error) => `Recovering from ${error._tag}`,\n    onRight: (value) => value // Do nothing in case of success\n  })\n})\n```',
      examples: [
        {
          code: 'import { Effect, Either, Random } from "effect"\n\nclass HttpError {\n  readonly _tag = "HttpError"\n}\n\nclass ValidationError {\n  readonly _tag = "ValidationError"\n}\n\n//      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return "some result"\n})\n\n//      \u250C\u2500\u2500\u2500 Effect<string, never, never>\n//      \u25BC\nconst recovered = Effect.gen(function* () {\n  //      \u250C\u2500\u2500\u2500 Either<string, HttpError | ValidationError>\n  //      \u25BC\n  const failureOrSuccess = yield* Effect.either(program)\n  return Either.match(failureOrSuccess, {\n    onLeft: (error) => `Recovering from ${error._tag}`,\n    onRight: (value) => value // Do nothing in case of success\n  })\n})'
        }
      ],
      tags: [
        "Outcome Encapsulation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 15313,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L15313"
    },
    {
      id: "effect.exit",
      name: "exit",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<Exit<A, E>, never, R>",
      description: "/\n * Encapsulates both success and failure of an `Effect` using the `Exit` type.\n *\n *",
      documentation: '/**\n * Encapsulates both success and failure of an `Effect` using the `Exit` type.\n *\n * **Details**\n *\n * This function converts an effect into one that always succeeds, wrapping its\n * outcome in the `Exit` type. The `Exit` type provides explicit handling of\n * both success (`Exit.Success`) and failure (`Exit.Failure`) cases, including\n * defects (unrecoverable errors).\n *\n * Unlike {@link either}or {@link option}, this function also encapsulates\n * defects, which are typically unrecoverable and would otherwise terminate the\n * effect. With the `Exit` type, defects are represented in `Exit.Failure`,\n * allowing for detailed introspection and structured error handling.\n *\n * This makes the resulting effect robust and incapable of direct failure (its\n * error type is `never`). It is particularly useful for workflows where all\n * outcomes, including unexpected defects, must be managed and analyzed.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Cause, Console, Exit } from "effect"\n *\n * // Simulating a runtime error\n * const task = Effect.dieMessage("Boom!")\n *\n * const program = Effect.gen(function* () {\n *   const exit = yield* Effect.exit(task)\n *   if (Exit.isFailure(exit)) {\n *     const cause = exit.cause\n *     if (\n *       Cause.isDieType(cause) &&\n *       Cause.isRuntimeException(cause.defect)\n *     ) {\n *       yield* Console.log(\n *         `RuntimeException defect caught: ${cause.defect.message}`\n *       )\n *     } else {\n *       yield* Console.log("Unknown failure caught.")\n *     }\n *   }\n * })\n *\n * // We get an Exit.Success because we caught all failures\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // RuntimeException defect caught: Boom!\n * // {\n * //   _id: "Exit",\n * //   _tag: "Success",\n * //   value: undefined\n * // }\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect, Cause, Console, Exit } from "effect"\n *\n * // Simulating a runtime error\n * const task = Effect.dieMessage("Boom!")\n *\n * const program = Effect.gen(function* () {\n *   const exit = yield* Effect.exit(task)\n *   if (Exit.isFailure(exit)) {\n *     const cause = exit.cause\n *     if (\n *       Cause.isDieType(cause) &&\n *       Cause.isRuntimeException(cause.defect)\n *     ) {\n *       yield* Console.log(\n *         `RuntimeException defect caught: ${cause.defect.message}`\n *       )\n *     } else {\n *       yield* Console.log("Unknown failure caught.")\n *     }\n *   }\n * })\n *\n * // We get an Exit.Success because we caught all failures\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // RuntimeException defect caught: Boom!\n * // {\n * //   _id: "Exit",\n * //   _tag: "Success",\n * //   value: undefined\n * // }\n *'
        }
      ],
      tags: [
        "Outcome Encapsulation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 15375,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L15375"
    },
    {
      id: "effect.intoDeferred",
      name: "intoDeferred",
      module: "effect",
      package: "effect",
      signature: "{ <A, E>(deferred: Deferred<A, E>): <R>(self: Effect<A, E, R>) => Effect<boolean, never, R>; <A, E, R>(self: Effect<A, E, R>, deferred: Deferred<A, E>): Effect<boolean, never, R>; }",
      description: "Converts an `Effect` into an operation that completes a `Deferred` with its result.",
      documentation: 'Converts an `Effect` into an operation that completes a `Deferred` with its result.\n\n**Details**\n\nThe `intoDeferred` function takes an effect and a `Deferred` and ensures that the `Deferred`\nis completed based on the outcome of the effect. If the effect succeeds, the `Deferred` is\ncompleted with the success value. If the effect fails, the `Deferred` is completed with the\nfailure. Additionally, if the effect is interrupted, the `Deferred` will also be interrupted.\n\n**Example**\n\n```ts\nimport { Deferred, Effect } from "effect"\n\n// Define an effect that succeeds\nconst successEffect = Effect.succeed(42)\n\nconst program = Effect.gen(function*() {\n  // Create a deferred\n  const deferred = yield* Deferred.make<number, string>()\n\n  // Complete the deferred using the successEffect\n  const isCompleted = yield* Effect.intoDeferred(successEffect, deferred)\n\n  // Access the value of the deferred\n  const value = yield* Deferred.await(deferred)\n  console.log(value)\n\n  return isCompleted\n})\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// 42\n// true\n```',
      examples: [
        {
          code: 'import { Deferred, Effect } from "effect"\n\n// Define an effect that succeeds\nconst successEffect = Effect.succeed(42)\n\nconst program = Effect.gen(function*() {\n  // Create a deferred\n  const deferred = yield* Deferred.make<number, string>()\n\n  // Complete the deferred using the successEffect\n  const isCompleted = yield* Effect.intoDeferred(successEffect, deferred)\n\n  // Access the value of the deferred\n  const value = yield* Deferred.await(deferred)\n  console.log(value)\n\n  return isCompleted\n})\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// 42\n// true'
        }
      ],
      tags: [
        "Synchronization Utilities"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 15417,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L15417"
    },
    {
      id: "effect.filterOrDie",
      name: "filterOrDie",
      module: "effect",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, orDieWith: (a: EqualsWith<A, B, A, Exclude<A, B>>) => unknown): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>, orDieWith: (a: NoInfer<A>) => unknown): <E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>, orDieWith: (a: EqualsWith<A, B, A, Exclude<A, B>>) => unknown): Effect<B, E, R>; <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>, orDieWith: (a: A) => unknown): Effect<A, E, R>; }",
      description: "Filters an effect, dying with a custom defect if the predicate fails.",
      documentation: "Filters an effect, dying with a custom defect if the predicate fails.\n\n**Details**\n\nThis function applies a predicate to the result of an effect. If the\npredicate evaluates to `false`, the effect dies with a custom defect\ngenerated by the `orDieWith` function.\n\n**When to Use**\n\nThis is useful for enforcing constraints on values and treating violations as\nfatal program errors.",
      examples: [],
      tags: [
        "Filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 15555,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L15555"
    },
    {
      id: "effect.filterOrDieMessage",
      name: "filterOrDieMessage",
      module: "effect",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, message: string): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>, message: string): <E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>, message: string): Effect<B, E, R>; <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>, message: string): Effect<A, E, R>; }",
      description: "/\n * Filters an effect, dying with a custom message if the predicate fails.\n *\n *",
      documentation: "/**\n * Filters an effect, dying with a custom message if the predicate fails.\n *\n * **Details**\n *\n * This function works like {@link filterOrDie}but allows you to specify a\n * custom error message to describe the reason for the failure. The message is\n * included in the defect when the predicate evaluates to `false`.\n *\n *",
      examples: [],
      tags: [
        "Filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 15641,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L15641"
    },
    {
      id: "effect.filterOrElse",
      name: "filterOrElse",
      module: "effect",
      package: "effect",
      signature: "{ <A, C, E2, R2, B extends A>(refinement: Refinement<NoInfer<A>, B>, orElse: (a: EqualsWith<A, B, NoInfer<A>, Exclude<NoInfer<A>, B>>) => Effect<C, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<C | B, E2 | E, R2 | R>; <A, C, E2, R2>(predicate: Predicate<NoInfer<A>>, orElse: (a: NoInfer<A>) => Effect<C, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<A | C, E2 | E, R2 | R>; <A, E, R, C, E2, R2, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>, orElse: (a: EqualsWith<A, B, A, Exclude<A, B>>) => Effect<C, E2, R2>): Effect<C | B, E | E2, R | R2>; <A, E, R, C, E2, R2>(self: Effect<A, E, R>, predicate: Predicate<A>, orElse: (a: A) => Effect<C, E2, R2>): Effect<A | C, E | E2, R | R2>; }",
      description: "Filters an effect, providing an alternative effect if the predicate fails.",
      documentation: "Filters an effect, providing an alternative effect if the predicate fails.\n\n**Details**\n\nThis function applies a predicate to the result of an effect. If the\npredicate evaluates to `false`, it executes the `orElse` effect instead. The\n`orElse` effect can produce an alternative value or perform additional\ncomputations.",
      examples: [],
      tags: [
        "Filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 15708,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L15708"
    },
    {
      id: "effect.filterOrFail",
      name: "filterOrFail",
      module: "effect",
      package: "effect",
      signature: "{ <A, E2, B extends A>(refinement: Refinement<NoInfer<A>, B>, orFailWith: (a: EqualsWith<A, B, NoInfer<A>, Exclude<NoInfer<A>, B>>) => E2): <E, R>(self: Effect<A, E, R>) => Effect<NoInfer<B>, E2 | E, R>; <A, E2>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R>; <A, E, R, E2, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>, orFailWith: (a: EqualsWith<A, B, A, Exclude<A, B>>) => E2): Effect<NoInfer<B>, E | E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => E2): Effect<A, E | E2, R>; <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Effect<A, E, R>) => Effect<NoInfer<B>, NoSuchElementException | E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Effect<A, E, R>) => Effect<A, NoSuchElementException | E, R>; <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>): Effect<NoInfer<B>, NoSuchElementException | E, R>; <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>): Effect<A, NoSuchElementException | E, R>; }",
      description: "Filters an effect, failing with a custom error if the predicate fails.",
      documentation: 'Filters an effect, failing with a custom error if the predicate fails.\n\n**Details**\n\nThis function applies a predicate to the result of an effect. If the\npredicate evaluates to `false`, the effect fails with a custom error\ngenerated by the `orFailWith` function.\n\n**When to Use**\n\nThis is useful for enforcing constraints and treating violations as\nrecoverable errors.\n\n**Providing a Guard**\n\nIn addition to the filtering capabilities discussed earlier, you have the\noption to further refine and narrow down the type of the success channel by\nproviding a [user-defined type\nguard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates).\nLet\'s explore this concept through an example:\n\n**Example**\n\n```ts\nimport { Effect, pipe } from "effect"\n\n// Define a user interface\ninterface User {\n  readonly name: string\n}\n\n// Simulate an asynchronous authentication function\ndeclare const auth: () => Promise<User | null>\n\nconst program = pipe(\n  Effect.promise(() => auth()),\n  // Use filterOrFail with a custom type guard to ensure user is not null\n  Effect.filterOrFail(\n    (user): user is User => user !== null, // Type guard\n    () => new Error("Unauthorized")\n  ),\n  // \'user\' now has the type `User` (not `User | null`)\n  Effect.andThen((user) => user.name)\n)\n```',
      examples: [
        {
          code: 'import { Effect, pipe } from "effect"\n\n// Define a user interface\ninterface User {\n  readonly name: string\n}\n\n// Simulate an asynchronous authentication function\ndeclare const auth: () => Promise<User | null>\n\nconst program = pipe(\n  Effect.promise(() => auth()),\n  // Use filterOrFail with a custom type guard to ensure user is not null\n  Effect.filterOrFail(\n    (user): user is User => user !== null, // Type guard\n    () => new Error("Unauthorized")\n  ),\n  // \'user\' now has the type `User` (not `User | null`)\n  Effect.andThen((user) => user.name)\n)'
        }
      ],
      tags: [
        "Filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 15816,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L15816"
    },
    {
      id: "effect.filterEffectOrElse",
      name: "filterEffectOrElse",
      module: "effect",
      package: "effect",
      signature: "{ <A, E2, R2, A2, E3, R3>(options: { readonly predicate: (a: NoInfer<A>) => Effect<boolean, E2, R2>; readonly orElse: (a: NoInfer<A>) => Effect<A2, E3, R3>; }): <E, R>(self: Effect<A, E, R>) => Effect<A | A2, E2 | E3 | E, R2 | R3 | R>; <A, E, R, E2, R2, A2, E3, R3>(self: Effect<A, E, R>, options: { readonly predicate: (a: A) => Effect<boolean, E2, R2>; readonly orElse: (a: A) => Effect<A2, E3, R3>; }): Effect<A | A2, E | E2 | E3, R | R2 | R3>; }",
      description: "Filters an effect with an effectful predicate, falling back to an alternative\neffect if the predicate fails.",
      documentation: 'Filters an effect with an effectful predicate, falling back to an alternative\neffect if the predicate fails.\n\n**Details**\n\nThis function applies a predicate to the result of an effect. If the\npredicate evaluates to `false`, the effect falls back to the `orElse`\neffect. The `orElse` effect can produce an alternative value or perform\nadditional computations.\n\n**Example**\n\n```ts\nimport { Effect, pipe } from "effect"\n\n// Define a user interface\ninterface User {\n  readonly name: string\n}\n\n// Simulate an asynchronous authentication function\ndeclare const auth: () => Promise<User | null>\n\nconst program = pipe(\n  Effect.promise(() => auth()),\n  // Use filterEffectOrElse with an effectful predicate\n  Effect.filterEffectOrElse({\n    predicate: (user) => Effect.succeed(user !== null),\n    orElse: (user) => Effect.fail(new Error(`Unauthorized user: ${user}`))\n  }),\n)\n```',
      examples: [
        {
          code: 'import { Effect, pipe } from "effect"\n\n// Define a user interface\ninterface User {\n  readonly name: string\n}\n\n// Simulate an asynchronous authentication function\ndeclare const auth: () => Promise<User | null>\n\nconst program = pipe(\n  Effect.promise(() => auth()),\n  // Use filterEffectOrElse with an effectful predicate\n  Effect.filterEffectOrElse({\n    predicate: (user) => Effect.succeed(user !== null),\n    orElse: (user) => Effect.fail(new Error(`Unauthorized user: ${user}`))\n  }),\n)'
        }
      ],
      tags: [
        "Filtering"
      ],
      since: "3.13.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 16263,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L16263"
    },
    {
      id: "effect.filterEffectOrFail",
      name: "filterEffectOrFail",
      module: "effect",
      package: "effect",
      signature: "{ <A, E2, R2, E3>(options: { readonly predicate: (a: NoInfer<A>) => Effect<boolean, E2, R2>; readonly orFailWith: (a: NoInfer<A>) => E3; }): <E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E3 | E, R2 | R>; <A, E, R, E2, R2, E3>(self: Effect<A, E, R>, options: { readonly predicate: (a: A) => Effect<boolean, E2, R2>; readonly orFailWith: (a: A) => E3; }): Effect<A, E | E2 | E3, R | R2>; }",
      description: "Filters an effect with an effectful predicate, failing with a custom error if the predicate fails.",
      documentation: 'Filters an effect with an effectful predicate, failing with a custom error if the predicate fails.\n\n**Details**\n\nThis function applies a predicate to the result of an effect. If the\npredicate evaluates to `false`, the effect fails with a custom error\ngenerated by the `orFailWith` function.\n\n**When to Use**\n\nThis is useful for enforcing constraints and treating violations as\nrecoverable errors.\n\n**Example**\n\n```ts\nimport { Effect, pipe } from "effect"\n\n// Define a user interface\ninterface User {\n  readonly name: string\n}\n\n// Simulate an asynchronous authentication function\ndeclare const auth: () => Promise<User | null>\n\nconst program = pipe(\n  Effect.promise(() => auth()),\n  // Use filterEffectOrFail with an effectful predicate\n  Effect.filterEffectOrFail({\n    predicate: (user) => Effect.succeed(user !== null),\n    orFailWith: () => new Error("Unauthorized")\n  }),\n)\n```',
      examples: [
        {
          code: 'import { Effect, pipe } from "effect"\n\n// Define a user interface\ninterface User {\n  readonly name: string\n}\n\n// Simulate an asynchronous authentication function\ndeclare const auth: () => Promise<User | null>\n\nconst program = pipe(\n  Effect.promise(() => auth()),\n  // Use filterEffectOrFail with an effectful predicate\n  Effect.filterEffectOrFail({\n    predicate: (user) => Effect.succeed(user !== null),\n    orFailWith: () => new Error("Unauthorized")\n  }),\n)'
        }
      ],
      tags: [
        "Filtering"
      ],
      since: "3.13.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 16387,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L16387"
    },
    {
      id: "effect.unless",
      name: "unless",
      module: "effect",
      package: "effect",
      signature: "{ (condition: LazyArg<boolean>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, condition: LazyArg<boolean>): Effect<Option<A>, E, R>; }",
      description: "Executes an effect only if the condition is `false`.",
      documentation: "Executes an effect only if the condition is `false`.",
      examples: [],
      tags: [
        "Conditional Operators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 16486,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L16486"
    },
    {
      id: "effect.unlessEffect",
      name: "unlessEffect",
      module: "effect",
      package: "effect",
      signature: "{ <E2, R2>(condition: Effect<boolean, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option<A>, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Effect<A, E, R>, condition: Effect<boolean, E2, R2>): Effect<Option<A>, E | E2, R | R2>; }",
      description: "Conditionally execute an effect based on the result of another effect.",
      documentation: "Conditionally execute an effect based on the result of another effect.",
      examples: [],
      tags: [
        "Conditional Operators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 16517,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L16517"
    },
    {
      id: "effect.when",
      name: "when",
      module: "effect",
      package: "effect",
      signature: "{ (condition: LazyArg<boolean>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, condition: LazyArg<boolean>): Effect<Option<A>, E, R>; }",
      description: "Conditionally executes an effect based on a boolean condition.",
      documentation: 'Conditionally executes an effect based on a boolean condition.\n\n**Details**\n\nThis function allows you to run an effect only if a given condition evaluates\nto `true`. If the condition is `true`, the effect is executed, and its result\nis wrapped in an `Option.some`. If the condition is `false`, the effect is\nskipped, and the result is `Option.none`.\n\n**When to Use**\n\nThis function is useful for scenarios where you need to dynamically decide\nwhether to execute an effect based on runtime logic, while also representing\nthe skipped case explicitly.\n\n**Example** (Conditional Effect Execution)\n\n```ts\nimport { Effect, Option } from "effect"\n\nconst validateWeightOption = (\n  weight: number\n): Effect.Effect<Option.Option<number>> =>\n  // Conditionally execute the effect if the weight is non-negative\n  Effect.succeed(weight).pipe(Effect.when(() => weight >= 0))\n\n// Run with a valid weight\nEffect.runPromise(validateWeightOption(100)).then(console.log)\n// Output:\n// {\n//   _id: "Option",\n//   _tag: "Some",\n//   value: 100\n// }\n\n// Run with an invalid weight\nEffect.runPromise(validateWeightOption(-5)).then(console.log)\n// Output:\n// {\n//   _id: "Option",\n//   _tag: "None"\n// }\n```',
      examples: [
        {
          title: "Conditional Effect Execution",
          code: 'import { Effect, Option } from "effect"\n\nconst validateWeightOption = (\n  weight: number\n): Effect.Effect<Option.Option<number>> =>\n  // Conditionally execute the effect if the weight is non-negative\n  Effect.succeed(weight).pipe(Effect.when(() => weight >= 0))\n\n// Run with a valid weight\nEffect.runPromise(validateWeightOption(100)).then(console.log)\n// Output:\n// {\n//   _id: "Option",\n//   _tag: "Some",\n//   value: 100\n// }\n\n// Run with an invalid weight\nEffect.runPromise(validateWeightOption(-5)).then(console.log)\n// Output:\n// {\n//   _id: "Option",\n//   _tag: "None"\n// }'
        }
      ],
      tags: [
        "Conditional Operators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 16590,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L16590"
    },
    {
      id: "effect.whenEffect",
      name: "whenEffect",
      module: "effect",
      package: "effect",
      signature: "{ <E, R>(condition: Effect<boolean, E, R>): <A, E2, R2>(effect: Effect<A, E2, R2>) => Effect<Option<A>, E | E2, R | R2>; <A, E2, R2, E, R>(self: Effect<A, E2, R2>, condition: Effect<boolean, E, R>): Effect<Option<A>, E2 | E, R2 | R>; }",
      description: "Conditionally executes an effect based on the result of another effect.",
      documentation: "Conditionally executes an effect based on the result of another effect.\n\n**Details**\n\nThis function allows you to run an effect only if a conditional effect\nevaluating to a boolean resolves to `true`. If the conditional effect\nevaluates to `true`, the specified effect is executed, and its result is\nwrapped in `Option.some`. If the conditional effect evaluates to `false`, the\neffect is skipped, and the result is `Option.none`.\n\n**When to Use**\n\nThis function is particularly useful when the decision to execute an effect\ndepends on the result of another effect, such as a random value, a\nuser-provided input, or a network request result.\n\n**Example** (Using an Effect as a Condition)\n\n```ts\nimport { Effect, Random } from \"effect\"\n\nconst randomIntOption = Random.nextInt.pipe(\n  Effect.whenEffect(Random.nextBoolean)\n)\n\nconsole.log(Effect.runSync(randomIntOption))\n// Example Output:\n// { _id: 'Option', _tag: 'Some', value: 8609104974198840 }\n```",
      examples: [
        {
          title: "Using an Effect as a Condition",
          code: `import { Effect, Random } from "effect"

const randomIntOption = Random.nextInt.pipe(
  Effect.whenEffect(Random.nextBoolean)
)

console.log(Effect.runSync(randomIntOption))
// Example Output:
// { _id: 'Option', _tag: 'Some', value: 8609104974198840 }`
        }
      ],
      tags: [
        "Conditional Operators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 16733,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L16733"
    },
    {
      id: "effect.whenFiberRef",
      name: "whenFiberRef",
      module: "effect",
      package: "effect",
      signature: "{ <S>(fiberRef: FiberRef<S>, predicate: Predicate<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<[S, Option<A>], E, R>; <A, E, R, S>(self: Effect<A, E, R>, fiberRef: FiberRef<S>, predicate: Predicate<S>): Effect<[S, Option<A>], E, R>; }",
      description: "Executes an effect conditionally based on the value of a `FiberRef` that\nsatisfies a predicate.",
      documentation: "Executes an effect conditionally based on the value of a `FiberRef` that\nsatisfies a predicate.\n\n**Details**\n\nThis function enables you to execute an effect only when the value of a\nspecified `FiberRef` meets a certain condition defined by a predicate. If the\nvalue satisfies the predicate, the effect is executed, and the result is\nwrapped in an `Option.some`. If the predicate is not satisfied, the effect is\nskipped, and the result is `Option.none`. In both cases, the current value of\nthe `FiberRef` is included in the result.",
      examples: [],
      tags: [
        "Conditional Operators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 16827,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L16827"
    },
    {
      id: "effect.whenRef",
      name: "whenRef",
      module: "effect",
      package: "effect",
      signature: "{ <S>(ref: Ref<S>, predicate: Predicate<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<[S, Option<A>], E, R>; <A, E, R, S>(self: Effect<A, E, R>, ref: Ref<S>, predicate: Predicate<S>): Effect<[S, Option<A>], E, R>; }",
      description: "Executes an effect conditionally based on the value of a `Ref` that satisfies\na predicate.",
      documentation: "Executes an effect conditionally based on the value of a `Ref` that satisfies\na predicate.\n\n**Details**\n\nThis function allows you to execute an effect only when the value of a\nspecified `Ref` meets a condition defined by a predicate. If the value\nsatisfies the predicate, the effect is executed, and the result is wrapped in\nan `Option.some`. If the predicate is not satisfied, the effect is skipped,\nand the result is `Option.none`. In both cases, the current value of the\n`Ref` is included in the result.",
      examples: [],
      tags: [
        "Conditional Operators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 16879,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L16879"
    },
    {
      id: "effect.flatMap",
      name: "flatMap",
      module: "effect",
      package: "effect",
      signature: "{ <A, B, E1, R1>(f: (a: A) => Effect<B, E1, R1>): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R1 | R>; <A, E, R, B, E1, R1>(self: Effect<A, E, R>, f: (a: A) => Effect<B, E1, R1>): Effect<B, E | E1, R | R1>; }",
      description: "Chains effects to produce new `Effect` instances, useful for combining\noperations that depend on previous results.",
      documentation: 'Chains effects to produce new `Effect` instances, useful for combining\noperations that depend on previous results.\n\n**Syntax**\n\n```ts skip-type-checking\nconst flatMappedEffect = pipe(myEffect, Effect.flatMap(transformation))\n// or\nconst flatMappedEffect = Effect.flatMap(myEffect, transformation)\n// or\nconst flatMappedEffect = myEffect.pipe(Effect.flatMap(transformation))\n```\n\n**Details**\n\n`flatMap` lets you sequence effects so that the result of one effect can be\nused in the next step. It is similar to `flatMap` used with arrays but works\nspecifically with `Effect` instances, allowing you to avoid deeply nested\neffect structures.\n\nSince effects are immutable, `flatMap` always returns a new effect instead of\nchanging the original one.\n\n**When to Use**\n\nUse `flatMap` when you need to chain multiple effects, ensuring that each\nstep produces a new `Effect` while flattening any nested effects that may\noccur.\n\n**Example**\n\n```ts\nimport { pipe, Effect } from "effect"\n\n// Function to apply a discount safely to a transaction amount\nconst applyDiscount = (\n  total: number,\n  discountRate: number\n): Effect.Effect<number, Error> =>\n  discountRate === 0\n    ? Effect.fail(new Error("Discount rate cannot be zero"))\n    : Effect.succeed(total - (total * discountRate) / 100)\n\n// Simulated asynchronous task to fetch a transaction amount from database\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\n// Chaining the fetch and discount application using `flatMap`\nconst finalAmount = pipe(\n  fetchTransactionAmount,\n  Effect.flatMap((amount) => applyDiscount(amount, 5))\n)\n\nEffect.runPromise(finalAmount).then(console.log)\n// Output: 95\n```',
      examples: [
        {
          code: 'import { pipe, Effect } from "effect"\n\n// Function to apply a discount safely to a transaction amount\nconst applyDiscount = (\n  total: number,\n  discountRate: number\n): Effect.Effect<number, Error> =>\n  discountRate === 0\n    ? Effect.fail(new Error("Discount rate cannot be zero"))\n    : Effect.succeed(total - (total * discountRate) / 100)\n\n// Simulated asynchronous task to fetch a transaction amount from database\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\n// Chaining the fetch and discount application using `flatMap`\nconst finalAmount = pipe(\n  fetchTransactionAmount,\n  Effect.flatMap((amount) => applyDiscount(amount, 5))\n)\n\nEffect.runPromise(finalAmount).then(console.log)\n// Output: 95'
        }
      ],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 16977,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L16977"
    },
    {
      id: "effect.andThen",
      name: "andThen",
      module: "effect",
      package: "effect",
      signature: "{ <A, X>(f: (a: NoInfer<A>) => X): <E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, UnknownException | E, R> : Effect<X, E, R>; <X>(f: NotFunction<X>): <A, E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, UnknownException | E, R> : Effect<X, E, R>; <A, E, R, X>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => X): [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, UnknownException | E, R> : Effect<X, E, R>; <A, E, R, X>(self: Effect<A, E, R>, f: NotFunction<X>): [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, UnknownException | E, R> : Effect<X, E, R>; }",
      description: "/\n * Chains two actions, where the second action can depend on the result of the\n * first.\n *\n * Syntax\n *\n * \n *\n *",
      documentation: '/**\n * Chains two actions, where the second action can depend on the result of the\n * first.\n *\n * **Syntax**\n *\n * ```ts skip-type-checking\n * const transformedEffect = pipe(myEffect, Effect.andThen(anotherEffect))\n * // or\n * const transformedEffect = Effect.andThen(myEffect, anotherEffect)\n * // or\n * const transformedEffect = myEffect.pipe(Effect.andThen(anotherEffect))\n * ```\n *\n * **When to Use**\n *\n * Use `andThen` when you need to run multiple actions in sequence, with the\n * second action depending on the result of the first. This is useful for\n * combining effects or handling computations that must happen in order.\n *\n * **Details**\n *\n * The second action can be:\n *\n * - A constant value (similar to {@link as})\n * - A function returning a value (similar to {@link map})\n * - A `Promise`\n * - A function returning a `Promise`\n * - An `Effect`\n * - A function returning an `Effect` (similar to {@link flatMap})\n *\n * **Note:** `andThen` works well with both `Option` and `Either` types,\n * treating them as effects.\n *\n * **Example** (Applying a Discount Based on Fetched Amount)\n *\n * ```ts\n * import { pipe, Effect } from "effect"\n *\n * // Function to apply a discount safely to a transaction amount\n * const applyDiscount = (\n *   total: number,\n *   discountRate: number\n * ): Effect.Effect<number, Error> =>\n *   discountRate === 0\n *     ? Effect.fail(new Error("Discount rate cannot be zero"))\n *     : Effect.succeed(total - (total * discountRate) / 100)\n *\n * // Simulated asynchronous task to fetch a transaction amount from database\n * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n *\n * // Using Effect.map and Effect.flatMap\n * const result1 = pipe(\n *   fetchTransactionAmount,\n *   Effect.map((amount) => amount * 2),\n *   Effect.flatMap((amount) => applyDiscount(amount, 5))\n * )\n *\n * Effect.runPromise(result1).then(console.log)\n * // Output: 190\n *\n * // Using Effect.andThen\n * const result2 = pipe(\n *   fetchTransactionAmount,\n *   Effect.andThen((amount) => amount * 2),\n *   Effect.andThen((amount) => applyDiscount(amount, 5))\n * )\n *\n * Effect.runPromise(result2).then(console.log)\n * // Output: 190\n * ```\n *\n *',
      examples: [
        {
          code: '* import { pipe, Effect } from "effect"\n *\n * // Function to apply a discount safely to a transaction amount\n * const applyDiscount = (\n *   total: number,\n *   discountRate: number\n * ): Effect.Effect<number, Error> =>\n *   discountRate === 0\n *     ? Effect.fail(new Error("Discount rate cannot be zero"))\n *     : Effect.succeed(total - (total * discountRate) / 100)\n *\n * // Simulated asynchronous task to fetch a transaction amount from database\n * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n *\n * // Using Effect.map and Effect.flatMap\n * const result1 = pipe(\n *   fetchTransactionAmount,\n *   Effect.map((amount) => amount * 2),\n *   Effect.flatMap((amount) => applyDiscount(amount, 5))\n * )\n *\n * Effect.runPromise(result1).then(console.log)\n * // Output: 190\n *\n * // Using Effect.andThen\n * const result2 = pipe(\n *   fetchTransactionAmount,\n *   Effect.andThen((amount) => amount * 2),\n *   Effect.andThen((amount) => applyDiscount(amount, 5))\n * )\n *\n * Effect.runPromise(result2).then(console.log)\n * // Output: 190\n *'
        }
      ],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 17180,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L17180"
    },
    {
      id: "effect.flatten",
      name: "flatten",
      module: "effect",
      package: "effect",
      signature: "<A, E1, R1, E, R>(self: Effect<Effect<A, E1, R1>, E, R>) => Effect<A, E1 | E, R1 | R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 17490,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L17490"
    },
    {
      id: "effect.race",
      name: "race",
      module: "effect",
      package: "effect",
      signature: "{ <A2, E2, R2>(that: Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }",
      description: "Races two effects and returns the result of the first successful one.",
      documentation: 'Races two effects and returns the result of the first successful one.\n\n**Details**\n\nThis function takes two effects and runs them concurrently. The first effect\nthat successfully completes will determine the result of the race, and the\nother effect will be interrupted.\n\nIf neither effect succeeds, the function will fail with a `Cause`\ncontaining all the errors.\n\n**When to Use**\n\nThis is useful when you want to run two effects concurrently, but only care\nabout the first one to succeed. It is commonly used in cases like timeouts,\nretries, or when you want to optimize for the faster response without\nworrying about the other effect.\n\n**Handling Success or Failure with Either**\n\nIf you want to handle the result of whichever task completes first, whether\nit succeeds or fails, you can use the `Effect.either` function. This function\nwraps the result in an `Either` type, allowing you to see if the result\nwas a success (`Right`) or a failure (`Left`).\n\n**Example** (Both Tasks Succeed)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst task1 = Effect.succeed("task1").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() => Console.log("task1 interrupted"))\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() => Console.log("task2 interrupted"))\n)\n\nconst program = Effect.race(task1, task2)\n\nEffect.runFork(program)\n// Output:\n// task1 done\n// task2 interrupted\n```\n\n**Example** (One Task Fails, One Succeeds)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst task1 = Effect.fail("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() => Console.log("task1 interrupted"))\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() => Console.log("task2 interrupted"))\n)\n\nconst program = Effect.race(task1, task2)\n\nEffect.runFork(program)\n// Output:\n// task2 done\n```\n\n**Example** (Both Tasks Fail)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst task1 = Effect.fail("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() => Console.log("task1 interrupted"))\n)\nconst task2 = Effect.fail("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() => Console.log("task2 interrupted"))\n)\n\nconst program = Effect.race(task1, task2)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// {\n//   _id: \'Exit\',\n//   _tag: \'Failure\',\n//   cause: {\n//     _id: \'Cause\',\n//     _tag: \'Parallel\',\n//     left: { _id: \'Cause\', _tag: \'Fail\', failure: \'task1\' },\n//     right: { _id: \'Cause\', _tag: \'Fail\', failure: \'task2\' }\n//   }\n// }\n```\n\n**Example** (Handling Success or Failure with Either)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst task1 = Effect.fail("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() => Console.log("task1 interrupted"))\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() => Console.log("task2 interrupted"))\n)\n\n// Run both tasks concurrently, wrapping the result\n// in Either to capture success or failure\nconst program = Effect.race(Effect.either(task1), Effect.either(task2))\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// task2 interrupted\n// { _id: \'Either\', _tag: \'Left\', left: \'task1\' }\n```',
      examples: [
        {
          title: "Both Tasks Succeed",
          code: 'import { Effect, Console } from "effect"\n\nconst task1 = Effect.succeed("task1").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() => Console.log("task1 interrupted"))\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() => Console.log("task2 interrupted"))\n)\n\nconst program = Effect.race(task1, task2)\n\nEffect.runFork(program)\n// Output:\n// task1 done\n// task2 interrupted'
        },
        {
          title: "One Task Fails, One Succeeds",
          code: 'import { Effect, Console } from "effect"\n\nconst task1 = Effect.fail("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() => Console.log("task1 interrupted"))\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() => Console.log("task2 interrupted"))\n)\n\nconst program = Effect.race(task1, task2)\n\nEffect.runFork(program)\n// Output:\n// task2 done'
        },
        {
          title: "Both Tasks Fail",
          code: `import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.fail("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const program = Effect.race(task1, task2)

Effect.runPromiseExit(program).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Parallel',
//     left: { _id: 'Cause', _tag: 'Fail', failure: 'task1' },
//     right: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }
//   }
// }`
        },
        {
          title: "Handling Success or Failure with Either",
          code: `import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

// Run both tasks concurrently, wrapping the result
// in Either to capture success or failure
const program = Effect.race(Effect.either(task1), Effect.either(task2))

Effect.runPromise(program).then(console.log)
// Output:
// task2 interrupted
// { _id: 'Either', _tag: 'Left', left: 'task1' }`
        }
      ],
      tags: [
        "Racing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 17628,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L17628"
    },
    {
      id: "effect.raceAll",
      name: "raceAll",
      module: "effect",
      package: "effect",
      signature: "<Eff extends Effect<any, any, any>>(all: Iterable<Eff>) => Effect<Effect.Success<Eff>, Effect.Error<Eff>, Effect.Context<Eff>>",
      description: "Races multiple effects and returns the first successful result.",
      documentation: 'Races multiple effects and returns the first successful result.\n\n**Details**\n\nThis function runs multiple effects concurrently and returns the result of\nthe first one to succeed. If one effect succeeds, the others will be\ninterrupted.\n\nIf none of the effects succeed, the function will fail with the last error\nencountered.\n\n**When to Use**\n\nThis is useful when you want to race multiple effects, but only care about\nthe first one to succeed. It is commonly used in cases like timeouts,\nretries, or when you want to optimize for the faster response without\nworrying about the other effects.\n\n**Example** (All Tasks Succeed)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst task1 = Effect.succeed("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() => Console.log("task1 interrupted"))\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() => Console.log("task2 interrupted"))\n)\n\nconst task3 = Effect.succeed("task3").pipe(\n  Effect.delay("150 millis"),\n  Effect.tap(Console.log("task3 done")),\n  Effect.onInterrupt(() => Console.log("task3 interrupted"))\n)\n\nconst program = Effect.raceAll([task1, task2, task3])\n\nEffect.runFork(program)\n// Output:\n// task1 done\n// task2 interrupted\n// task3 interrupted\n```\n\n**Example** (One Task Fails, Two Tasks Succeed)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst task1 = Effect.fail("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() => Console.log("task1 interrupted"))\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() => Console.log("task2 interrupted"))\n)\n\nconst task3 = Effect.succeed("task3").pipe(\n  Effect.delay("150 millis"),\n  Effect.tap(Console.log("task3 done")),\n  Effect.onInterrupt(() => Console.log("task3 interrupted"))\n)\n\nconst program = Effect.raceAll([task1, task2, task3])\n\nEffect.runFork(program)\n// Output:\n// task3 done\n// task2 interrupted\n```\n\n**Example** (All Tasks Fail)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst task1 = Effect.fail("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() => Console.log("task1 interrupted"))\n)\nconst task2 = Effect.fail("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() => Console.log("task2 interrupted"))\n)\n\nconst task3 = Effect.fail("task3").pipe(\n  Effect.delay("150 millis"),\n  Effect.tap(Console.log("task3 done")),\n  Effect.onInterrupt(() => Console.log("task3 interrupted"))\n)\n\nconst program = Effect.raceAll([task1, task2, task3])\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// {\n//   _id: \'Exit\',\n//   _tag: \'Failure\',\n//   cause: { _id: \'Cause\', _tag: \'Fail\', failure: \'task2\' }\n// }\n```',
      examples: [
        {
          title: "All Tasks Succeed",
          code: 'import { Effect, Console } from "effect"\n\nconst task1 = Effect.succeed("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() => Console.log("task1 interrupted"))\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() => Console.log("task2 interrupted"))\n)\n\nconst task3 = Effect.succeed("task3").pipe(\n  Effect.delay("150 millis"),\n  Effect.tap(Console.log("task3 done")),\n  Effect.onInterrupt(() => Console.log("task3 interrupted"))\n)\n\nconst program = Effect.raceAll([task1, task2, task3])\n\nEffect.runFork(program)\n// Output:\n// task1 done\n// task2 interrupted\n// task3 interrupted'
        },
        {
          title: "One Task Fails, Two Tasks Succeed",
          code: 'import { Effect, Console } from "effect"\n\nconst task1 = Effect.fail("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() => Console.log("task1 interrupted"))\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() => Console.log("task2 interrupted"))\n)\n\nconst task3 = Effect.succeed("task3").pipe(\n  Effect.delay("150 millis"),\n  Effect.tap(Console.log("task3 done")),\n  Effect.onInterrupt(() => Console.log("task3 interrupted"))\n)\n\nconst program = Effect.raceAll([task1, task2, task3])\n\nEffect.runFork(program)\n// Output:\n// task3 done\n// task2 interrupted'
        },
        {
          title: "All Tasks Fail",
          code: `import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.fail("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const task3 = Effect.fail("task3").pipe(
  Effect.delay("150 millis"),
  Effect.tap(Console.log("task3 done")),
  Effect.onInterrupt(() => Console.log("task3 interrupted"))
)

const program = Effect.raceAll([task1, task2, task3])

Effect.runPromiseExit(program).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }
// }`
        }
      ],
      tags: [
        "Racing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 18024,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L18024"
    },
    {
      id: "effect.raceFirst",
      name: "raceFirst",
      module: "effect",
      package: "effect",
      signature: "{ <A2, E2, R2>(that: Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }",
      description: "Races two effects and returns the result of the first one to complete.",
      documentation: 'Races two effects and returns the result of the first one to complete.\n\n**Details**\n\nThis function takes two effects and runs them concurrently, returning the\nresult of the first one that completes, regardless of whether it succeeds or\nfails.\n\n**When to Use**\n\nThis function is useful when you want to race two operations, and you want to\nproceed with whichever one finishes first, regardless of whether it succeeds\nor fails.\n\n**Disconnecting Effects**\n\nThe `Effect.raceFirst` function safely interrupts the \u201Closer\u201D effect once the other completes, but it will not resume until the loser is cleanly terminated.\n\nIf you want a quicker return, you can disconnect the interrupt signal for both effects. Instead of calling:\n\n```ts skip-type-checking\nEffect.raceFirst(task1, task2)\n```\n\nYou can use:\n\n```ts skip-type-checking\nEffect.raceFirst(Effect.disconnect(task1), Effect.disconnect(task2))\n```\n\nThis allows both effects to complete independently while still terminating the losing effect in the background.\n\n**Example** (Both Tasks Succeed)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst task1 = Effect.succeed("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() =>\n    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))\n  )\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() =>\n    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))\n  )\n)\n\nconst program = Effect.raceFirst(task1, task2).pipe(\n  Effect.tap(Console.log("more work..."))\n)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// task1 done\n// task2 interrupted\n// more work...\n// { _id: \'Exit\', _tag: \'Success\', value: \'task1\' }\n```\n\n**Example** (One Task Fails, One Succeeds)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst task1 = Effect.fail("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() =>\n    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))\n  )\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() =>\n    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))\n  )\n)\n\nconst program = Effect.raceFirst(task1, task2).pipe(\n  Effect.tap(Console.log("more work..."))\n)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// task2 interrupted\n// {\n//   _id: \'Exit\',\n//   _tag: \'Failure\',\n//   cause: { _id: \'Cause\', _tag: \'Fail\', failure: \'task1\' }\n// }\n```\n\n**Example** (Using Effect.disconnect for Quicker Return)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst task1 = Effect.succeed("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() =>\n    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))\n  )\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() =>\n    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))\n  )\n)\n\n// Race the two tasks with disconnect to allow quicker return\nconst program = Effect.raceFirst(\n  Effect.disconnect(task1),\n  Effect.disconnect(task2)\n).pipe(Effect.tap(Console.log("more work...")))\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// task1 done\n// more work...\n// { _id: \'Exit\', _tag: \'Success\', value: \'task1\' }\n// task2 interrupted\n```',
      examples: [
        {
          title: "Both Tasks Succeed",
          code: `import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() =>
    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
  )
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() =>
    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
  )
)

const program = Effect.raceFirst(task1, task2).pipe(
  Effect.tap(Console.log("more work..."))
)

Effect.runPromiseExit(program).then(console.log)
// Output:
// task1 done
// task2 interrupted
// more work...
// { _id: 'Exit', _tag: 'Success', value: 'task1' }`
        },
        {
          title: "One Task Fails, One Succeeds",
          code: `import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() =>
    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
  )
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() =>
    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
  )
)

const program = Effect.raceFirst(task1, task2).pipe(
  Effect.tap(Console.log("more work..."))
)

Effect.runPromiseExit(program).then(console.log)
// Output:
// task2 interrupted
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'task1' }
// }`
        },
        {
          title: "Using Effect.disconnect for Quicker Return",
          code: `import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() =>
    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
  )
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() =>
    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
  )
)

// Race the two tasks with disconnect to allow quicker return
const program = Effect.raceFirst(
  Effect.disconnect(task1),
  Effect.disconnect(task2)
).pipe(Effect.tap(Console.log("more work...")))

Effect.runPromiseExit(program).then(console.log)
// Output:
// task1 done
// more work...
// { _id: 'Exit', _tag: 'Success', value: 'task1' }
// task2 interrupted`
        }
      ],
      tags: [
        "Racing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 18161,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L18161"
    },
    {
      id: "effect.raceWith",
      name: "raceWith",
      module: "effect",
      package: "effect",
      signature: "{ <A1, E1, R1, E, A, A2, E2, R2, A3, E3, R3>(other: Effect<A1, E1, R1>, options: { readonly onSelfDone: (exit: Exit<A, E>, fiber: Fiber<A1, E1>) => Effect<A2, E2, R2>; readonly onOtherDone: (exit: Exit<A1, E1>, fiber: Fiber<A, E>) => Effect<A3, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R1 | R2 | R3 | R>; <A, E, R, A1, E1, R1, A2, E2, R2, A3, E3, R3>(self: Effect<A, E, R>, other: Effect<A1, E1, R1>, options: { readonly onSelfDone: (exit: Exit<A, E>, fiber: Fiber<A1, E1>) => Effect<A2, E2, R2>; readonly onOtherDone: (exit: Exit<A1, E1>, fiber: Fiber<A, E>) => Effect<A3, E3, R3>; }): Effect<A2 | A3, E2 | E3, R | R1 | R2 | R3>; }",
      description: "Races two effects and calls a finisher when the first one completes.",
      documentation: 'Races two effects and calls a finisher when the first one completes.\n\n**Details**\n\nThis function runs two effects concurrently and calls a specified \u201Cfinisher\u201D\nfunction once one of the effects completes, regardless of whether it succeeds\nor fails.\n\nThe finisher functions for each effect allow you to handle the results of\neach effect as soon as they complete.\n\nThe function takes two finisher callbacks, one for each effect, and allows\nyou to specify how to handle the result of the race.\n\n**When to Use**\n\nThis function is useful when you need to react to the completion of either\neffect without waiting for both to finish. It can be used whenever you want\nto take action based on the first available result.\n\n**Example** (Handling Results of Concurrent Tasks)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst task1 = Effect.succeed("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() =>\n    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))\n  )\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() =>\n    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))\n  )\n)\n\nconst program = Effect.raceWith(task1, task2, {\n  onSelfDone: (exit) => Console.log(`task1 exited with ${exit}`),\n  onOtherDone: (exit) => Console.log(`task2 exited with ${exit}`)\n})\n\nEffect.runFork(program)\n// Output:\n// task1 done\n// task1 exited with {\n//   "_id": "Exit",\n//   "_tag": "Success",\n//   "value": "task1"\n// }\n// task2 interrupted\n```',
      examples: [
        {
          title: "Handling Results of Concurrent Tasks",
          code: 'import { Effect, Console } from "effect"\n\nconst task1 = Effect.succeed("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() =>\n    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))\n  )\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() =>\n    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))\n  )\n)\n\nconst program = Effect.raceWith(task1, task2, {\n  onSelfDone: (exit) => Console.log(`task1 exited with ${exit}`),\n  onOtherDone: (exit) => Console.log(`task2 exited with ${exit}`)\n})\n\nEffect.runFork(program)\n// Output:\n// task1 done\n// task1 exited with {\n//   "_id": "Exit",\n//   "_tag": "Success",\n//   "value": "task1"\n// }\n// task2 interrupted'
        }
      ],
      tags: [
        "Racing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 18497,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L18497"
    },
    {
      id: "effect.summarized",
      name: "summarized",
      module: "effect",
      package: "effect",
      signature: "{ <B, E2, R2, C>(summary: Effect<B, E2, R2>, f: (start: B, end: B) => C): <A, E, R>(self: Effect<A, E, R>) => Effect<[C, A], E2 | E, R2 | R>; <A, E, R, B, E2, R2, C>(self: Effect<A, E, R>, summary: Effect<B, E2, R2>, f: (start: B, end: B) => C): Effect<[C, A], E | E2, R | R2>; }",
      description: "Summarizes a effect by computing some value before and after execution, and\nthen combining the values to produce a summary, together with the result of\nexecution.",
      documentation: "Summarizes a effect by computing some value before and after execution, and\nthen combining the values to produce a summary, together with the result of\nexecution.",
      examples: [],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 18635,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L18635"
    },
    {
      id: "effect.tap",
      name: "tap",
      module: "effect",
      package: "effect",
      signature: "{ <A, X>(f: (a: NoInfer<A>) => X): <E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, UnknownException | E, R> : Effect<A, E, R>; <A, X, E1, R1>(f: (a: NoInfer<A>) => Effect<X, E1, R1>, options: { onlyEffect: true; }): <E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R1 | R>; <X>(f: NotFunction<X>): <A, E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, UnknownException | E, R> : Effect<A, E, R>; <X, E1, R1>(f: Effect<X, E1, R1>, options: { onlyEffect: true; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R1 | R>; <A, E, R, X>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => X): [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, UnknownException | E, R> : Effect<A, E, R>; <A, E, R, X, E1, R1>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => Effect<X, E1, R1>, options: { onlyEffect: true; }): Effect<A, E | E1, R | R1>; <A, E, R, X>(self: Effect<A, E, R>, f: NotFunction<X>): [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, UnknownException | E, R> : Effect<A, E, R>; <A, E, R, X, E1, R1>(self: Effect<A, E, R>, f: Effect<X, E1, R1>, options: { onlyEffect: true; }): Effect<A, E | E1, R | R1>; }",
      description: "Runs a side effect with the result of an effect without changing the original\nvalue.",
      documentation: 'Runs a side effect with the result of an effect without changing the original\nvalue.\n\n**Details**\n\nThis function works similarly to `flatMap`, but it ignores the result of the\nfunction passed to it. The value from the previous effect remains available\nfor the next part of the chain. Note that if the side effect fails, the\nentire chain will fail too.\n\n**When to Use**\n\nUse this function when you want to perform a side effect, like logging or\ntracking, without modifying the main value. This is useful when you need to\nobserve or record an action but want the original value to be passed to the\nnext step.\n\n**Example** (Logging a step in a pipeline)\n\n```ts\nimport { Console, Effect, pipe } from "effect"\n\n// Function to apply a discount safely to a transaction amount\nconst applyDiscount = (\n  total: number,\n  discountRate: number\n): Effect.Effect<number, Error> =>\n  discountRate === 0\n    ? Effect.fail(new Error("Discount rate cannot be zero"))\n    : Effect.succeed(total - (total * discountRate) / 100)\n\n// Simulated asynchronous task to fetch a transaction amount from database\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\nconst finalAmount = pipe(\n  fetchTransactionAmount,\n  // Log the fetched transaction amount\n  Effect.tap((amount) => Console.log(`Apply a discount to: ${amount}`)),\n  // `amount` is still available!\n  Effect.flatMap((amount) => applyDiscount(amount, 5))\n)\n\nEffect.runPromise(finalAmount).then(console.log)\n// Output:\n// Apply a discount to: 100\n// 95\n```',
      examples: [
        {
          title: "Logging a step in a pipeline",
          code: 'import { Console, Effect, pipe } from "effect"\n\n// Function to apply a discount safely to a transaction amount\nconst applyDiscount = (\n  total: number,\n  discountRate: number\n): Effect.Effect<number, Error> =>\n  discountRate === 0\n    ? Effect.fail(new Error("Discount rate cannot be zero"))\n    : Effect.succeed(total - (total * discountRate) / 100)\n\n// Simulated asynchronous task to fetch a transaction amount from database\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\nconst finalAmount = pipe(\n  fetchTransactionAmount,\n  // Log the fetched transaction amount\n  Effect.tap((amount) => Console.log(`Apply a discount to: ${amount}`)),\n  // `amount` is still available!\n  Effect.flatMap((amount) => applyDiscount(amount, 5))\n)\n\nEffect.runPromise(finalAmount).then(console.log)\n// Output:\n// Apply a discount to: 100\n// 95'
        }
      ],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 18709,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L18709"
    },
    {
      id: "effect.tapBoth",
      name: "tapBoth",
      module: "effect",
      package: "effect",
      signature: "{ <E, X, E2, R2, A, X1, E3, R3>(options: { readonly onFailure: (e: NoInfer<E>) => Effect<X, E2, R2>; readonly onSuccess: (a: NoInfer<A>) => Effect<X1, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A, E | E2 | E3, R2 | R3 | R>; <A, E, R, X, E2, R2, X1, E3, R3>(self: Effect<A, E, R>, options: { readonly onFailure: (e: E) => Effect<X, E2, R2>; readonly onSuccess: (a: A) => Effect<X1, E3, R3>; }): Effect<A, E | E2 | E3, R | R2 | R3>; }",
      description: "Allows you to inspect both success and failure outcomes of an effect and\nperform side effects for each.",
      documentation: 'Allows you to inspect both success and failure outcomes of an effect and\nperform side effects for each.\n\n**Details**\n\nThis function enables you to handle both success and failure cases\nseparately, without modifying the main effect\'s result. It is particularly\nuseful for scenarios where you need to log, monitor, or perform additional\nactions depending on whether the effect succeeded or failed.\n\nWhen the effect succeeds, the `onSuccess` handler is executed with the\nsuccess value. When the effect fails, the `onFailure` handler is executed\nwith the failure value. Both handlers can include side effects such as\nlogging or analytics, and neither modifies the original effect\'s output.\n\nIf either the success or failure handler fails, the overall effect will also\nfail.\n\n**Example**\n\n```ts\nimport { Effect, Random, Console } from "effect"\n\n// Simulate a task that might fail\nconst task = Effect.filterOrFail(\n  Random.nextRange(-1, 1),\n  (n) => n >= 0,\n  () => "random number is negative"\n)\n\n// Use tapBoth to log both success and failure outcomes\nconst tapping = Effect.tapBoth(task, {\n  onFailure: (error) => Console.log(`failure: ${error}`),\n  onSuccess: (randomNumber) =>\n    Console.log(`random number: ${randomNumber}`)\n})\n\nEffect.runFork(tapping)\n// Example Output:\n// failure: random number is negative\n```',
      examples: [
        {
          code: 'import { Effect, Random, Console } from "effect"\n\n// Simulate a task that might fail\nconst task = Effect.filterOrFail(\n  Random.nextRange(-1, 1),\n  (n) => n >= 0,\n  () => "random number is negative"\n)\n\n// Use tapBoth to log both success and failure outcomes\nconst tapping = Effect.tapBoth(task, {\n  onFailure: (error) => Console.log(`failure: ${error}`),\n  onSuccess: (randomNumber) =>\n    Console.log(`random number: ${randomNumber}`)\n})\n\nEffect.runFork(tapping)\n// Example Output:\n// failure: random number is negative'
        }
      ],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 19205,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L19205"
    },
    {
      id: "effect.tapDefect",
      name: "tapDefect",
      module: "effect",
      package: "effect",
      signature: "{ <X, E2, R2>(f: (cause: Cause<never>) => Effect<X, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause<never>) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>; }",
      description: "Inspect severe errors or defects (non-recoverable failures) in an effect.",
      documentation: 'Inspect severe errors or defects (non-recoverable failures) in an effect.\n\n**Details**\n\nThis function is specifically designed to handle and inspect defects, which\nare critical failures in your program, such as unexpected runtime exceptions\nor system-level errors. Unlike normal recoverable errors, defects typically\nindicate serious issues that cannot be addressed through standard error\nhandling.\n\nWhen a defect occurs in an effect, the function you provide to this function\nwill be executed, allowing you to log, monitor, or handle the defect in some\nway. Importantly, this does not alter the main result of the effect. If no\ndefect occurs, the effect behaves as if this function was not used.\n\n**Example**\n\n```ts\nimport { Effect, Console } from "effect"\n\n// Simulate a task that fails with a recoverable error\nconst task1: Effect.Effect<number, string> = Effect.fail("NetworkError")\n\n// tapDefect won\'t log anything because NetworkError is not a defect\nconst tapping1 = Effect.tapDefect(task1, (cause) =>\n  Console.log(`defect: ${cause}`)\n)\n\nEffect.runFork(tapping1)\n// No Output\n\n// Simulate a severe failure in the system\nconst task2: Effect.Effect<number, string> = Effect.dieMessage(\n  "Something went wrong"\n)\n\n// Log the defect using tapDefect\nconst tapping2 = Effect.tapDefect(task2, (cause) =>\n  Console.log(`defect: ${cause}`)\n)\n\nEffect.runFork(tapping2)\n// Output:\n// defect: RuntimeException: Something went wrong\n//   ... stack trace ...\n```',
      examples: [
        {
          code: 'import { Effect, Console } from "effect"\n\n// Simulate a task that fails with a recoverable error\nconst task1: Effect.Effect<number, string> = Effect.fail("NetworkError")\n\n// tapDefect won\'t log anything because NetworkError is not a defect\nconst tapping1 = Effect.tapDefect(task1, (cause) =>\n  Console.log(`defect: ${cause}`)\n)\n\nEffect.runFork(tapping1)\n// No Output\n\n// Simulate a severe failure in the system\nconst task2: Effect.Effect<number, string> = Effect.dieMessage(\n  "Something went wrong"\n)\n\n// Log the defect using tapDefect\nconst tapping2 = Effect.tapDefect(task2, (cause) =>\n  Console.log(`defect: ${cause}`)\n)\n\nEffect.runFork(tapping2)\n// Output:\n// defect: RuntimeException: Something went wrong\n//   ... stack trace ...'
        }
      ],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 19358,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L19358"
    },
    {
      id: "effect.tapError",
      name: "tapError",
      module: "effect",
      package: "effect",
      signature: "{ <E, X, E2, R2>(f: (e: NoInfer<E>) => Effect<X, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (e: E) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>; }",
      description: "Execute a side effect on failure without modifying the original effect.",
      documentation: 'Execute a side effect on failure without modifying the original effect.\n\n**Details**\n\nThis function allows you to inspect and react to the failure of an effect by\nexecuting an additional effect. The failure value is passed to the provided\nfunction, enabling you to log it, track it, or perform any other operation.\nImportantly, the original failure remains intact and is re-propagated, so the\neffect\'s behavior is unchanged.\n\nThe side effect you provide is only executed when the effect fails. If the\neffect succeeds, the function is ignored, and the success value is propagated\nas usual.\n\n**Example**\n\n```ts\nimport { Effect, Console } from "effect"\n\n// Simulate a task that fails with an error\nconst task: Effect.Effect<number, string> = Effect.fail("NetworkError")\n\n// Use tapError to log the error message when the task fails\nconst tapping = Effect.tapError(task, (error) =>\n  Console.log(`expected error: ${error}`)\n)\n\nEffect.runFork(tapping)\n// Output:\n// expected error: NetworkError\n```',
      examples: [
        {
          code: 'import { Effect, Console } from "effect"\n\n// Simulate a task that fails with an error\nconst task: Effect.Effect<number, string> = Effect.fail("NetworkError")\n\n// Use tapError to log the error message when the task fails\nconst tapping = Effect.tapError(task, (error) =>\n  Console.log(`expected error: ${error}`)\n)\n\nEffect.runFork(tapping)\n// Output:\n// expected error: NetworkError'
        }
      ],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 19500,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L19500"
    },
    {
      id: "effect.tapErrorTag",
      name: "tapErrorTag",
      module: "effect",
      package: "effect",
      signature: '{ <K extends E extends { _tag: string; } ? E["_tag"] : never, E, A1, E1, R1>(k: K, f: (e: NoInfer<Extract<E, { _tag: K; }>>) => Effect<A1, E1, R1>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R1 | R>; <A, E, R, K extends E extends { _tag: string; } ? E["_tag"] : never, A1, E1, R1>(self: Effect<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => Effect<A1, E1, R1>): Effect<A, E | E1, R | R1>; }',
      description: "Inspect errors matching a specific tag without altering the original effect.",
      documentation: 'Inspect errors matching a specific tag without altering the original effect.\n\n**Details**\n\nThis function allows you to inspect and handle specific error types based on\ntheir `_tag` property. It is particularly useful in applications where errors\nare modeled with tagged types (e.g., union types with discriminating tags).\nBy targeting errors with a specific `_tag`, you can log or perform actions on\nthem while leaving the error channel and overall effect unchanged.\n\nIf the error doesn\'t match the specified tag, this function does nothing, and\nthe effect proceeds as usual.\n\n**Example**\n\n```ts\nimport { Effect, Console } from "effect"\n\nclass NetworkError {\n  readonly _tag = "NetworkError"\n  constructor(readonly statusCode: number) {}\n}\n\nclass ValidationError {\n  readonly _tag = "ValidationError"\n  constructor(readonly field: string) {}\n}\n\n// Create a task that fails with a NetworkError\nconst task: Effect.Effect<number, NetworkError | ValidationError> =\n  Effect.fail(new NetworkError(504))\n\n// Use tapErrorTag to inspect only NetworkError types and log the status code\nconst tapping = Effect.tapErrorTag(task, "NetworkError", (error) =>\n  Console.log(`expected error: ${error.statusCode}`)\n)\n\nEffect.runFork(tapping)\n// Output:\n// expected error: 504\n```',
      examples: [
        {
          code: 'import { Effect, Console } from "effect"\n\nclass NetworkError {\n  readonly _tag = "NetworkError"\n  constructor(readonly statusCode: number) {}\n}\n\nclass ValidationError {\n  readonly _tag = "ValidationError"\n  constructor(readonly field: string) {}\n}\n\n// Create a task that fails with a NetworkError\nconst task: Effect.Effect<number, NetworkError | ValidationError> =\n  Effect.fail(new NetworkError(504))\n\n// Use tapErrorTag to inspect only NetworkError types and log the status code\nconst tapping = Effect.tapErrorTag(task, "NetworkError", (error) =>\n  Console.log(`expected error: ${error.statusCode}`)\n)\n\nEffect.runFork(tapping)\n// Output:\n// expected error: 504'
        }
      ],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 19622,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L19622"
    },
    {
      id: "effect.tapErrorCause",
      name: "tapErrorCause",
      module: "effect",
      package: "effect",
      signature: "{ <E, X, E2, R2>(f: (cause: Cause<NoInfer<E>>) => Effect<X, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause<E>) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>; }",
      description: "Inspect the complete cause of an error, including failures and defects.",
      documentation: 'Inspect the complete cause of an error, including failures and defects.\n\n**Details**\n\nThis function provides access to the full cause of an error, including both\nrecoverable failures and irrecoverable defects. It allows you to handle, log,\nor monitor specific error causes without modifying the result of the effect.\nThe full `Cause` object encapsulates the error and its contextual\ninformation, making it useful for debugging and understanding failure\nscenarios in complex workflows.\n\nThe effect itself is not modified, and any errors or defects remain in the\nerror channel of the original effect.\n\n**Example**\n\n```ts\nimport { Effect, Console } from "effect"\n\n// Create a task that fails with a NetworkError\nconst task1: Effect.Effect<number, string> = Effect.fail("NetworkError")\n\nconst tapping1 = Effect.tapErrorCause(task1, (cause) =>\n  Console.log(`error cause: ${cause}`)\n)\n\nEffect.runFork(tapping1)\n// Output:\n// error cause: Error: NetworkError\n\n// Simulate a severe failure in the system\nconst task2: Effect.Effect<number, string> = Effect.dieMessage(\n  "Something went wrong"\n)\n\nconst tapping2 = Effect.tapErrorCause(task2, (cause) =>\n  Console.log(`error cause: ${cause}`)\n)\n\nEffect.runFork(tapping2)\n// Output:\n// error cause: RuntimeException: Something went wrong\n//   ... stack trace ...\n```',
      examples: [
        {
          code: 'import { Effect, Console } from "effect"\n\n// Create a task that fails with a NetworkError\nconst task1: Effect.Effect<number, string> = Effect.fail("NetworkError")\n\nconst tapping1 = Effect.tapErrorCause(task1, (cause) =>\n  Console.log(`error cause: ${cause}`)\n)\n\nEffect.runFork(tapping1)\n// Output:\n// error cause: Error: NetworkError\n\n// Simulate a severe failure in the system\nconst task2: Effect.Effect<number, string> = Effect.dieMessage(\n  "Something went wrong"\n)\n\nconst tapping2 = Effect.tapErrorCause(task2, (cause) =>\n  Console.log(`error cause: ${cause}`)\n)\n\nEffect.runFork(tapping2)\n// Output:\n// error cause: RuntimeException: Something went wrong\n//   ... stack trace ...'
        }
      ],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 19775,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L19775"
    },
    {
      id: "effect.forever",
      name: "forever",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<never, E, R>",
      description: "Repeats an effect indefinitely until an error occurs.",
      documentation: "Repeats an effect indefinitely until an error occurs.\n\n**Details**\n\nThis function executes an effect repeatedly in an infinite loop. Each\niteration is executed sequentially, and the loop continues until the first\nerror occurs. If the effect succeeds, it starts over from the beginning. If\nthe effect fails, the error is propagated, and the loop stops.\n\nBe cautious when using this function, as it will run indefinitely unless an\nerror interrupts it. This makes it suitable for long-running processes or\ncontinuous polling tasks, but you should ensure proper error handling or\ncombine it with other operators like `timeout` or `schedule` to prevent\nunintentional infinite loops.",
      examples: [],
      tags: [
        "Repetition / Recursion"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 19896,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L19896"
    },
    {
      id: "effect.iterate",
      name: "iterate",
      module: "effect",
      package: "effect",
      signature: "{ <A, B extends A, R, E>(initial: A, options: { readonly while: Refinement<A, B>; readonly body: (b: B) => Effect<A, E, R>; }): Effect<A, E, R>; <A, R, E>(initial: A, options: { readonly while: Predicate<A>; readonly body: (a: A) => Effect<A, E, R>; }): Effect<A, E, R>; }",
      description: "Repeatedly updates a state through an effectful operation until a condition\nis no longer met.",
      documentation: 'Repeatedly updates a state through an effectful operation until a condition\nis no longer met.\n\n**Details**\n\nThis function provides a way to implement effectful loops, similar to a\n`while` loop in JavaScript.\n\n```ts skip-type-checking\nlet result = initial\n\nwhile (options.while(result)) {\n  result = options.body(result)\n}\n\nreturn result\n```\n\nIt starts with an initial state, checks a\ncondition (`while`), and executes a body operation to update the state if the\ncondition evaluates to `true`. The process repeats until the condition\nreturns `false`.\n\nThe state is passed between iterations, allowing the body operation to modify\nit dynamically. The final state after the loop ends is returned as the result\nof the effect.\n\n**When to Use**\n\nThis is particularly useful for scenarios where looping logic involves\nasynchronous or side-effectful operations, such as polling or iterative\ncomputations that depend on external factors.\n\n**Example** (Effectful Iteration)\n\n```ts\nimport { Effect } from "effect"\n\nconst result = Effect.iterate(\n  // Initial result\n  1,\n  {\n    // Condition to continue iterating\n    while: (result) => result <= 5,\n    // Operation to change the result\n    body: (result) => Effect.succeed(result + 1)\n  }\n)\n\nEffect.runPromise(result).then(console.log)\n// Output: 6\n```',
      examples: [
        {
          title: "Effectful Iteration",
          code: 'import { Effect } from "effect"\n\nconst result = Effect.iterate(\n  // Initial result\n  1,\n  {\n    // Condition to continue iterating\n    while: (result) => result <= 5,\n    // Operation to change the result\n    body: (result) => Effect.succeed(result + 1)\n  }\n)\n\nEffect.runPromise(result).then(console.log)\n// Output: 6'
        }
      ],
      tags: [
        "Looping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 19954,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L19954"
    },
    {
      id: "effect.loop",
      name: "loop",
      module: "effect",
      package: "effect",
      signature: "{ <A, B extends A, C, E, R>(initial: A, options: { readonly while: Refinement<A, B>; readonly step: (b: B) => A; readonly body: (b: B) => Effect<C, E, R>; readonly discard?: false; }): Effect<C[], E, R>; <A, C, E, R>(initial: A, options: { readonly while: (a: A) => boolean; readonly step: (a: A) => A; readonly body: (a: A) => Effect<C, E, R>; readonly discard?: false; }): Effect<C[], E, R>; <A, B extends A, C, E, R>(initial: A, options: { readonly while: Refinement<A, B>; readonly step: (b: B) => A; readonly body: (b: B) => Effect<C, E, R>; readonly discard: true; }): Effect<void, E, R>; <A, C, E, R>(initial: A, options: { readonly while: (a: A) => boolean; readonly step: (a: A) => A; readonly body: (a: A) => Effect<C, E, R>; readonly discard: true; }): Effect<void, E, R>; }",
      description: "Repeatedly executes a loop with a state, collecting results or discarding\nthem based on configuration.",
      documentation: 'Repeatedly executes a loop with a state, collecting results or discarding\nthem based on configuration.\n\n**Details**\n\nThis function performs an effectful loop, starting with an initial state and\niterating as long as the `while` condition evaluates to `true`, similar to a\n`while` loop in JavaScript.\n\n```ts skip-type-checking\nlet state = initial\nconst result = []\n\nwhile (options.while(state)) {\n  result.push(options.body(state)) // Perform the effectful operation\n  state = options.step(state) // Update the state\n}\n\nreturn result\n```\n\nDuring each iteration, the `step` function updates the state, and the `body`\neffect is executed.\n\nThe results of the body effect can be collected in an array or discarded\nbased on the `discard` option.\n\n**Discarding Intermediate Results**\n\n- If `discard` is `false` or not provided, the intermediate results are\n  collected into an array and returned as the final result.\n- If `discard` is `true`, the intermediate results are ignored, and the\n  effect returns `void`.\n\n**When to Use**\n\nThis is useful for implementing loops where you need to perform effectful\ncomputations repeatedly, such as processing items in a list, generating\nvalues, or performing iterative updates.\n\n**Example** (Looping with Collected Results)\n\n```ts\nimport { Effect } from "effect"\n\n// A loop that runs 5 times, collecting each iteration\'s result\nconst result = Effect.loop(\n  // Initial state\n  1,\n  {\n    // Condition to continue looping\n    while: (state) => state <= 5,\n    // State update function\n    step: (state) => state + 1,\n    // Effect to be performed on each iteration\n    body: (state) => Effect.succeed(state)\n  }\n)\n\nEffect.runPromise(result).then(console.log)\n// Output: [1, 2, 3, 4, 5]\n```\n\n**Example** (Loop with Discarded Results)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst result = Effect.loop(\n  // Initial state\n  1,\n  {\n    // Condition to continue looping\n    while: (state) => state <= 5,\n    // State update function\n    step: (state) => state + 1,\n    // Effect to be performed on each iteration\n    body: (state) => Console.log(`Currently at state ${state}`),\n    // Discard intermediate results\n    discard: true\n  }\n)\n\nEffect.runPromise(result).then(console.log)\n// Output:\n// Currently at state 1\n// Currently at state 2\n// Currently at state 3\n// Currently at state 4\n// Currently at state 5\n// undefined\n```',
      examples: [
        {
          title: "Looping with Collected Results",
          code: `import { Effect } from "effect"

// A loop that runs 5 times, collecting each iteration's result
const result = Effect.loop(
  // Initial state
  1,
  {
    // Condition to continue looping
    while: (state) => state <= 5,
    // State update function
    step: (state) => state + 1,
    // Effect to be performed on each iteration
    body: (state) => Effect.succeed(state)
  }
)

Effect.runPromise(result).then(console.log)
// Output: [1, 2, 3, 4, 5]`
        },
        {
          title: "Loop with Discarded Results",
          code: 'import { Effect, Console } from "effect"\n\nconst result = Effect.loop(\n  // Initial state\n  1,\n  {\n    // Condition to continue looping\n    while: (state) => state <= 5,\n    // State update function\n    step: (state) => state + 1,\n    // Effect to be performed on each iteration\n    body: (state) => Console.log(`Currently at state ${state}`),\n    // Discard intermediate results\n    discard: true\n  }\n)\n\nEffect.runPromise(result).then(console.log)\n// Output:\n// Currently at state 1\n// Currently at state 2\n// Currently at state 3\n// Currently at state 4\n// Currently at state 5\n// undefined'
        }
      ],
      tags: [
        "Looping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 20175,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L20175"
    },
    {
      id: "effect.repeat",
      name: "repeat",
      module: "effect",
      package: "effect",
      signature: "{ <O extends NoExcessProperties<Repeat.Options<A>, O>, A>(options: O): <E, R>(self: Effect<A, E, R>) => Effect<O extends { schedule: Schedule<infer Out, infer _I, infer _R>; } ? Out : O extends { until: Refinement<A, infer B extends A>; } ? B : A, E | (O extends { while: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never), R | (O extends { schedule: Schedule<infer _O, infer _I, infer R>; } ? R : never) | (O extends { while: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never)>; <B, A, R1>(schedule: Schedule<B, A, R1>): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R1 | R>; <A, E, R, O extends NoExcessProperties<Repeat.Options<A>, O>>(self: Effect<A, E, R>, options: O): Effect<O extends { schedule: Schedule<infer Out, infer _I, infer _R>; } ? Out : O extends { until: Refinement<A, infer B extends A>; } ? B : A, E | (O extends { while: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never), R | (O extends { schedule: Schedule<infer _O, infer _I, infer R>; } ? R : never) | (O extends { while: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never)>; <A, E, R, B, R1>(self: Effect<A, E, R>, schedule: Schedule<B, A, R1>): Effect<B, E, R | R1>; }",
      description: "Repeats an effect based on a specified schedule or until the first failure.",
      documentation: 'Repeats an effect based on a specified schedule or until the first failure.\n\n**Details**\n\nThis function executes an effect repeatedly according to the given schedule.\nEach repetition occurs after the initial execution of the effect, meaning\nthat the schedule determines the number of additional repetitions. For\nexample, using `Schedule.once` will result in the effect being executed twice\n(once initially and once as part of the repetition).\n\nIf the effect succeeds, it is repeated according to the schedule. If it\nfails, the repetition stops immediately, and the failure is returned.\n\nThe schedule can also specify delays between repetitions, making it useful\nfor tasks like retrying operations with backoff, periodic execution, or\nperforming a series of dependent actions.\n\nYou can combine schedules for more advanced repetition logic, such as adding\ndelays, limiting recursions, or dynamically adjusting based on the outcome of\neach execution.\n\n**Example** (Success Example)\n\n```ts\nimport { Effect, Schedule, Console } from "effect"\n\nconst action = Console.log("success")\nconst policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")\nconst program = Effect.repeat(action, policy)\n\nEffect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))\n```\n\n**Example** (Failure Example)\n\n```ts\nimport { Effect, Schedule } from "effect"\n\nlet count = 0\n\n// Define an async effect that simulates an action with possible failures\nconst action = Effect.async<string, string>((resume) => {\n  if (count > 1) {\n    console.log("failure")\n    resume(Effect.fail("Uh oh!"))\n  } else {\n    count++\n    console.log("success")\n    resume(Effect.succeed("yay!"))\n  }\n})\n\nconst policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")\nconst program = Effect.repeat(action, policy)\n\nEffect.runPromiseExit(program).then(console.log)\n```',
      examples: [
        {
          title: "Success Example",
          code: 'import { Effect, Schedule, Console } from "effect"\n\nconst action = Console.log("success")\nconst policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")\nconst program = Effect.repeat(action, policy)\n\nEffect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))'
        },
        {
          title: "Failure Example",
          code: 'import { Effect, Schedule } from "effect"\n\nlet count = 0\n\n// Define an async effect that simulates an action with possible failures\nconst action = Effect.async<string, string>((resume) => {\n  if (count > 1) {\n    console.log("failure")\n    resume(Effect.fail("Uh oh!"))\n  } else {\n    count++\n    console.log("success")\n    resume(Effect.succeed("yay!"))\n  }\n})\n\nconst policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")\nconst program = Effect.repeat(action, policy)\n\nEffect.runPromiseExit(program).then(console.log)'
        }
      ],
      tags: [
        "Repetition / Recursion"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 20686,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L20686"
    },
    {
      id: "effect.repeatN",
      name: "repeatN",
      module: "effect",
      package: "effect",
      signature: "{ (n: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, n: number): Effect<A, E, R>; }",
      description: "Repeats an effect a specified number of times or until the first failure.",
      documentation: 'Repeats an effect a specified number of times or until the first failure.\n\n**Details**\n\nThis function executes an effect initially and then repeats it the specified\nnumber of times, as long as it succeeds. For example, calling\n`repeatN(action, 2)` will execute `action` once initially and then repeat it\ntwo additional times if there are no failures.\n\nIf the effect fails during any repetition, the failure is returned, and no\nfurther repetitions are attempted.\n\n**When to Use**\n\nThis function is useful for tasks that need to be retried a fixed number of\ntimes or for performing repeated actions without requiring a schedule.\n\n**Example**\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst action = Console.log("success")\nconst program = Effect.repeatN(action, 2)\n\nEffect.runPromise(program)\n```',
      examples: [
        {
          code: 'import { Effect, Console } from "effect"\n\nconst action = Console.log("success")\nconst program = Effect.repeatN(action, 2)\n\nEffect.runPromise(program)'
        }
      ],
      tags: [
        "Repetition / Recursion"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 20972,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L20972"
    },
    {
      id: "effect.repeatOrElse",
      name: "repeatOrElse",
      module: "effect",
      package: "effect",
      signature: "{ <R2, A, B, E, E2, R3>(schedule: Schedule<B, A, R2>, orElse: (error: E, option: Option<B>) => Effect<B, E2, R3>): <R>(self: Effect<A, E, R>) => Effect<B, E2, R2 | R3 | R>; <A, E, R, R2, B, E2, R3>(self: Effect<A, E, R>, schedule: Schedule<B, A, R2>, orElse: (error: E, option: Option<B>) => Effect<B, E2, R3>): Effect<B, E2, R | R2 | R3>; }",
      description: "Repeats an effect with a schedule, handling failures using a custom handler.",
      documentation: 'Repeats an effect with a schedule, handling failures using a custom handler.\n\n**Details**\n\nThis function allows you to execute an effect repeatedly based on a specified\nschedule. If the effect fails at any point, a custom failure handler is\ninvoked. The handler is provided with both the failure value and the output\nof the schedule at the time of failure. This enables advanced error recovery\nor alternative fallback logic while maintaining flexibility in how\nrepetitions are handled.\n\nFor example, using a schedule with `recurs(2)` will allow for two additional\nrepetitions after the initial execution, provided the effect succeeds. If a\nfailure occurs during any iteration, the failure handler is invoked to handle\nthe situation.\n\n**Example**\n\n```ts\nimport { Effect, Schedule } from "effect"\n\nlet count = 0\n\n// Define an async effect that simulates an action with possible failures\nconst action = Effect.async<string, string>((resume) => {\n  if (count > 1) {\n    console.log("failure")\n    resume(Effect.fail("Uh oh!"))\n  } else {\n    count++\n    console.log("success")\n    resume(Effect.succeed("yay!"))\n  }\n})\n\nconst policy = Schedule.addDelay(\n  Schedule.recurs(2), // Repeat for a maximum of 2 times\n  () => "100 millis" // Add a delay of 100 milliseconds between repetitions\n)\n\nconst program = Effect.repeatOrElse(action, policy, () =>\n  Effect.sync(() => {\n    console.log("orElse")\n    return count - 1\n  })\n)\n\nEffect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))\n```',
      examples: [
        {
          code: 'import { Effect, Schedule } from "effect"\n\nlet count = 0\n\n// Define an async effect that simulates an action with possible failures\nconst action = Effect.async<string, string>((resume) => {\n  if (count > 1) {\n    console.log("failure")\n    resume(Effect.fail("Uh oh!"))\n  } else {\n    count++\n    console.log("success")\n    resume(Effect.succeed("yay!"))\n  }\n})\n\nconst policy = Schedule.addDelay(\n  Schedule.recurs(2), // Repeat for a maximum of 2 times\n  () => "100 millis" // Add a delay of 100 milliseconds between repetitions\n)\n\nconst program = Effect.repeatOrElse(action, policy, () =>\n  Effect.sync(() => {\n    console.log("orElse")\n    return count - 1\n  })\n)\n\nEffect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))'
        }
      ],
      tags: [
        "Repetition / Recursion"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21094,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21094"
    },
    {
      id: "effect.schedule",
      name: "schedule",
      module: "effect",
      package: "effect",
      signature: "{ <A, R2, Out>(schedule: Schedule<Out, NoInfer<A>, R2>): <E, R>(self: Effect<A, E, R>) => Effect<Out, E, R2 | R>; <A, E, R, R2, Out>(self: Effect<A, E, R>, schedule: Schedule<Out, A, R2>): Effect<Out, E, R | R2>; }",
      description: "Repeats an effect based on a specified schedule.",
      documentation: "Repeats an effect based on a specified schedule.\n\n**Details**\n\nThis function allows you to execute an effect repeatedly according to a given\nschedule. The schedule determines the timing and number of repetitions. Each\nrepetition can also depend on the decision of the schedule, providing\nflexibility for complex workflows. This function does not modify the effect's\nsuccess or failure; it only controls its repetition.\n\nFor example, you can use a schedule that recurs a specific number of times,\nadds delays between repetitions, or customizes repetition behavior based on\nexternal inputs. The effect runs initially and is repeated according to the\nschedule.",
      examples: [],
      tags: [
        "Repetition / Recursion"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21228,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21228"
    },
    {
      id: "effect.scheduleForked",
      name: "scheduleForked",
      module: "effect",
      package: "effect",
      signature: "{ <Out, R2>(schedule: Schedule<Out, unknown, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<RuntimeFiber<Out, E>, never, Scope | R2 | R>; <A, E, R, Out, R2>(self: Effect<A, E, R>, schedule: Schedule<Out, unknown, R2>): Effect<RuntimeFiber<Out, E>, never, Scope | R | R2>; }",
      description: "Runs an effect repeatedly on a new fiber according to a given schedule.",
      documentation: "Runs an effect repeatedly on a new fiber according to a given schedule.\n\n**Details**\n\nThis function starts the provided effect on a new fiber and runs it\nrepeatedly based on the specified schedule. The repetitions are managed by\nthe schedule's rules, which define the timing and number of iterations. The\nfiber is attached to the current scope, meaning it is automatically managed\nand cleaned up when the scope is closed.\n\nThe function returns a `RuntimeFiber` that allows you to monitor or interact\nwith the running fiber.\n\n**When to Use**\n\nThis is particularly useful for concurrent execution of scheduled tasks or\nwhen you want to continue processing without waiting for the repetitions to\ncomplete.",
      examples: [],
      tags: [
        "Repetition / Recursion"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21299,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21299"
    },
    {
      id: "effect.scheduleFrom",
      name: "scheduleFrom",
      module: "effect",
      package: "effect",
      signature: "{ <R2, In, Out>(initial: In, schedule: Schedule<Out, In, R2>): <E, R>(self: Effect<In, E, R>) => Effect<Out, E, R2 | R>; <In, E, R, R2, Out>(self: Effect<In, E, R>, initial: In, schedule: Schedule<Out, In, R2>): Effect<Out, E, R | R2>; }",
      description: "Runs an effect repeatedly according to a schedule, starting from a specified\ninput value.",
      documentation: "Runs an effect repeatedly according to a schedule, starting from a specified\ninput value.\n\n**Details**\n\nThis function allows you to repeatedly execute an effect based on a schedule.\nThe schedule starts with the given `initial` input value, which is passed to\nthe first execution. Subsequent executions of the effect are controlled by\nthe schedule's rules, using the output of the previous iteration as the input\nfor the next one.\n\nThe returned effect will complete when the schedule ends or the effect fails,\npropagating the error.",
      examples: [],
      tags: [
        "Repetition / Recursion"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21367,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21367"
    },
    {
      id: "effect.whileLoop",
      name: "whileLoop",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(options: { readonly while: LazyArg<boolean>; readonly body: LazyArg<Effect<A, E, R>>; readonly step: (a: A) => void; }) => Effect<void, E, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Repetition / Recursion"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21411,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21411"
    },
    {
      id: "effect.getFiberRefs",
      name: "getFiberRefs",
      module: "effect",
      package: "effect",
      signature: "Effect<FiberRefs, never, never>",
      description: "Returns a collection of all `FiberRef` values for the fiber running this\neffect.",
      documentation: "Returns a collection of all `FiberRef` values for the fiber running this\neffect.",
      examples: [],
      tags: [
        "Fiber Refs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21423,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21423"
    },
    {
      id: "effect.inheritFiberRefs",
      name: "inheritFiberRefs",
      module: "effect",
      package: "effect",
      signature: "(childFiberRefs: FiberRefs) => Effect<void, never, never>",
      description: "Inherits values from all `FiberRef` instances into current fiber.",
      documentation: "Inherits values from all `FiberRef` instances into current fiber.",
      examples: [],
      tags: [
        "Fiber Refs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21430,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21430"
    },
    {
      id: "effect.locally",
      name: "locally",
      module: "effect",
      package: "effect",
      signature: "{ <A>(self: FiberRef<A>, value: A): <B, E, R>(use: Effect<B, E, R>) => Effect<B, E, R>; <B, E, R, A>(use: Effect<B, E, R>, self: FiberRef<A>, value: A): Effect<B, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Fiber Refs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21435,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21435"
    },
    {
      id: "effect.locallyWith",
      name: "locallyWith",
      module: "effect",
      package: "effect",
      signature: "{ <A>(self: FiberRef<A>, f: (a: A) => A): <B, E, R>(use: Effect<B, E, R>) => Effect<B, E, R>; <B, E, R, A>(use: Effect<B, E, R>, self: FiberRef<A>, f: (a: A) => A): Effect<B, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Fiber Refs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21451,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21451"
    },
    {
      id: "effect.locallyScoped",
      name: "locallyScoped",
      module: "effect",
      package: "effect",
      signature: "{ <A>(value: A): (self: FiberRef<A>) => Effect<void, never, Scope>; <A>(self: FiberRef<A>, value: A): Effect<void, never, Scope>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Fiber Refs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21467,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21467"
    },
    {
      id: "effect.locallyScopedWith",
      name: "locallyScopedWith",
      module: "effect",
      package: "effect",
      signature: "{ <A>(f: (a: A) => A): (self: FiberRef<A>) => Effect<void, never, Scope>; <A>(self: FiberRef<A>, f: (a: A) => A): Effect<void, never, Scope>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Fiber Refs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21483,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21483"
    },
    {
      id: "effect.patchFiberRefs",
      name: "patchFiberRefs",
      module: "effect",
      package: "effect",
      signature: "(patch: FiberRefsPatch) => Effect<void, never, never>",
      description: "Applies the specified changes to the `FiberRef` values for the fiber\nrunning this workflow.",
      documentation: "Applies the specified changes to the `FiberRef` values for the fiber\nrunning this workflow.",
      examples: [],
      tags: [
        "Fiber Refs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21502,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21502"
    },
    {
      id: "effect.setFiberRefs",
      name: "setFiberRefs",
      module: "effect",
      package: "effect",
      signature: "(fiberRefs: FiberRefs) => Effect<void, never, never>",
      description: "Sets the `FiberRef` values for the fiber running this effect to the values\nin the specified collection of `FiberRef` values.",
      documentation: "Sets the `FiberRef` values for the fiber running this effect to the values\nin the specified collection of `FiberRef` values.",
      examples: [],
      tags: [
        "Fiber Refs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21510,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21510"
    },
    {
      id: "effect.updateFiberRefs",
      name: "updateFiberRefs",
      module: "effect",
      package: "effect",
      signature: "(f: (fiberId: Runtime, fiberRefs: FiberRefs) => FiberRefs) => Effect<void, never, never>",
      description: "Updates the `FiberRef` values for the fiber running this effect using the\nspecified function.",
      documentation: "Updates the `FiberRef` values for the fiber running this effect using the\nspecified function.",
      examples: [],
      tags: [
        "Fiber Refs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21518,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21518"
    },
    {
      id: "effect.isFailure",
      name: "isFailure",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<boolean, never, R>",
      description: "Checks if an effect has failed.",
      documentation: 'Checks if an effect has failed.\n\n**Details**\n\nThis function evaluates whether an effect has resulted in a failure. It\nreturns a boolean value wrapped in an effect, with `true` indicating the\neffect failed and `false` otherwise.\n\nThe resulting effect cannot fail (`never` in the error channel) but retains\nthe context of the original effect.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst failure = Effect.fail("Uh oh!")\n\nconsole.log(Effect.runSync(Effect.isFailure(failure)))\n// Output: true\n\nconst defect = Effect.dieMessage("BOOM!")\n\nEffect.runSync(Effect.isFailure(defect))\n// throws: BOOM!\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst failure = Effect.fail("Uh oh!")\n\nconsole.log(Effect.runSync(Effect.isFailure(failure)))\n// Output: true\n\nconst defect = Effect.dieMessage("BOOM!")\n\nEffect.runSync(Effect.isFailure(defect))\n// throws: BOOM!'
        }
      ],
      tags: [
        "Condition Checking"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21550,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21550"
    },
    {
      id: "effect.isSuccess",
      name: "isSuccess",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<boolean, never, R>",
      description: "Checks if an effect has succeeded.",
      documentation: "Checks if an effect has succeeded.\n\n**Details**\n\nThis function evaluates whether an effect has resulted in a success. It\nreturns a boolean value wrapped in an effect, with `true` indicating the\neffect succeeded and `false` otherwise.\n\nThe resulting effect cannot fail (`never` in the error channel) but retains\nthe context of the original effect.",
      examples: [],
      tags: [
        "Condition Checking"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21566,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21566"
    },
    {
      id: "effect.match",
      name: "match",
      module: "effect",
      package: "effect",
      signature: "{ <E, A2, A, A3>(options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, never, R>; <A, E, R, A2, A3>(self: Effect<A, E, R>, options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): Effect<A2 | A3, never, R>; }",
      description: "Handles both success and failure cases of an effect without performing side\neffects.",
      documentation: 'Handles both success and failure cases of an effect without performing side\neffects.\n\n**Details**\n\n`match` lets you define custom handlers for both success and failure\nscenarios. You provide separate functions to handle each case, allowing you\nto process the result if the effect succeeds, or handle the error if the\neffect fails.\n\n**When to Use**\n\nThis is useful for structuring your code to respond differently to success or\nfailure without triggering side effects.\n\n**Example** (Handling Both Success and Failure Cases)\n\n```ts\nimport { Effect } from "effect"\n\nconst success: Effect.Effect<number, Error> = Effect.succeed(42)\n\nconst program1 = Effect.match(success, {\n  onFailure: (error) => `failure: ${error.message}`,\n  onSuccess: (value) => `success: ${value}`\n})\n\n// Run and log the result of the successful effect\nEffect.runPromise(program1).then(console.log)\n// Output: "success: 42"\n\nconst failure: Effect.Effect<number, Error> = Effect.fail(\n  new Error("Uh oh!")\n)\n\nconst program2 = Effect.match(failure, {\n  onFailure: (error) => `failure: ${error.message}`,\n  onSuccess: (value) => `success: ${value}`\n})\n\n// Run and log the result of the failed effect\nEffect.runPromise(program2).then(console.log)\n// Output: "failure: Uh oh!"\n```',
      examples: [
        {
          title: "Handling Both Success and Failure Cases",
          code: 'import { Effect } from "effect"\n\nconst success: Effect.Effect<number, Error> = Effect.succeed(42)\n\nconst program1 = Effect.match(success, {\n  onFailure: (error) => `failure: ${error.message}`,\n  onSuccess: (value) => `success: ${value}`\n})\n\n// Run and log the result of the successful effect\nEffect.runPromise(program1).then(console.log)\n// Output: "success: 42"\n\nconst failure: Effect.Effect<number, Error> = Effect.fail(\n  new Error("Uh oh!")\n)\n\nconst program2 = Effect.match(failure, {\n  onFailure: (error) => `failure: ${error.message}`,\n  onSuccess: (value) => `success: ${value}`\n})\n\n// Run and log the result of the failed effect\nEffect.runPromise(program2).then(console.log)\n// Output: "failure: Uh oh!"'
        }
      ],
      tags: [
        "Matching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21618,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21618"
    },
    {
      id: "effect.matchCause",
      name: "matchCause",
      module: "effect",
      package: "effect",
      signature: "{ <E, A2, A, A3>(options: { readonly onFailure: (cause: Cause<E>) => A2; readonly onSuccess: (a: A) => A3; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, never, R>; <A, E, R, A2, A3>(self: Effect<A, E, R>, options: { readonly onFailure: (cause: Cause<E>) => A2; readonly onSuccess: (a: A) => A3; }): Effect<A2 | A3, never, R>; }",
      description: "Handles failures by matching the cause of failure.",
      documentation: 'Handles failures by matching the cause of failure.\n\n**Details**\n\nThe `matchCause` function allows you to handle failures with access to the\nfull cause of the failure within a fiber.\n\n**When to Use**\n\nThis is useful for differentiating between different types of errors, such as\nregular failures, defects, or interruptions. You can provide specific\nhandling logic for each failure type based on the cause.\n\n**Example** (Handling Different Failure Causes)\n\n```ts\nimport { Effect } from "effect"\n\nconst task: Effect.Effect<number, Error> = Effect.die("Uh oh!")\n\nconst program = Effect.matchCause(task, {\n  onFailure: (cause) => {\n    switch (cause._tag) {\n      case "Fail":\n        // Handle standard failure\n        return `Fail: ${cause.error.message}`\n      case "Die":\n        // Handle defects (unexpected errors)\n        return `Die: ${cause.defect}`\n      case "Interrupt":\n        // Handle interruption\n        return `${cause.fiberId} interrupted!`\n    }\n    // Fallback for other causes\n    return "failed due to other causes"\n  },\n  onSuccess: (value) =>\n    // task completes successfully\n    `succeeded with ${value} value`\n})\n\nEffect.runPromise(program).then(console.log)\n// Output: "Die: Uh oh!"\n```',
      examples: [
        {
          title: "Handling Different Failure Causes",
          code: 'import { Effect } from "effect"\n\nconst task: Effect.Effect<number, Error> = Effect.die("Uh oh!")\n\nconst program = Effect.matchCause(task, {\n  onFailure: (cause) => {\n    switch (cause._tag) {\n      case "Fail":\n        // Handle standard failure\n        return `Fail: ${cause.error.message}`\n      case "Die":\n        // Handle defects (unexpected errors)\n        return `Die: ${cause.defect}`\n      case "Interrupt":\n        // Handle interruption\n        return `${cause.fiberId} interrupted!`\n    }\n    // Fallback for other causes\n    return "failed due to other causes"\n  },\n  onSuccess: (value) =>\n    // task completes successfully\n    `succeeded with ${value} value`\n})\n\nEffect.runPromise(program).then(console.log)\n// Output: "Die: Uh oh!"'
        }
      ],
      tags: [
        "Matching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21783,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21783"
    },
    {
      id: "effect.matchCauseEffect",
      name: "matchCauseEffect",
      module: "effect",
      package: "effect",
      signature: "{ <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (cause: Cause<E>) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Effect<A, E, R>, options: { readonly onFailure: (cause: Cause<E>) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): Effect<A2 | A3, E2 | E3, R | R2 | R3>; }",
      description: "/\n * Handles failures with access to the cause and allows performing side effects.\n *\n *",
      documentation: '/**\n * Handles failures with access to the cause and allows performing side effects.\n *\n * **Details**\n *\n * The `matchCauseEffect` function works similarly to {@link matchCause}, but it\n * also allows you to perform additional side effects based on the failure\n * cause. This function provides access to the complete cause of the failure,\n * making it possible to differentiate between various failure types, and allows\n * you to respond accordingly while performing side effects (like logging or\n * other operations).\n *\n * **Example** (Handling Different Failure Causes with Side Effects)\n *\n * ```ts\n * import { Effect, Console } from "effect"\n *\n * const task: Effect.Effect<number, Error> = Effect.die("Uh oh!")\n *\n * const program = Effect.matchCauseEffect(task, {\n *   onFailure: (cause) => {\n *     switch (cause._tag) {\n *       case "Fail":\n *         // Handle standard failure with a logged message\n *         return Console.log(`Fail: ${cause.error.message}`)\n *       case "Die":\n *         // Handle defects (unexpected errors) by logging the defect\n *         return Console.log(`Die: ${cause.defect}`)\n *       case "Interrupt":\n *         // Handle interruption and log the fiberId that was interrupted\n *         return Console.log(`${cause.fiberId} interrupted!`)\n *     }\n *     // Fallback for other causes\n *     return Console.log("failed due to other causes")\n *   },\n *   onSuccess: (value) =>\n *     // Log success if the task completes successfully\n *     Console.log(`succeeded with ${value} value`)\n * })\n *\n * Effect.runPromise(program)\n * // Output: "Die: Uh oh!"\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect, Console } from "effect"\n *\n * const task: Effect.Effect<number, Error> = Effect.die("Uh oh!")\n *\n * const program = Effect.matchCauseEffect(task, {\n *   onFailure: (cause) => {\n *     switch (cause._tag) {\n *       case "Fail":\n *         // Handle standard failure with a logged message\n *         return Console.log(`Fail: ${cause.error.message}`)\n *       case "Die":\n *         // Handle defects (unexpected errors) by logging the defect\n *         return Console.log(`Die: ${cause.defect}`)\n *       case "Interrupt":\n *         // Handle interruption and log the fiberId that was interrupted\n *         return Console.log(`${cause.fiberId} interrupted!`)\n *     }\n *     // Fallback for other causes\n *     return Console.log("failed due to other causes")\n *   },\n *   onSuccess: (value) =>\n *     // Log success if the task completes successfully\n *     Console.log(`succeeded with ${value} value`)\n * })\n *\n * Effect.runPromise(program)\n * // Output: "Die: Uh oh!"\n *'
        }
      ],
      tags: [
        "Matching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21949,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21949"
    },
    {
      id: "effect.matchEffect",
      name: "matchEffect",
      module: "effect",
      package: "effect",
      signature: "{ <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (e: E) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Effect<A, E, R>, options: { readonly onFailure: (e: E) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): Effect<A2 | A3, E2 | E3, R | R2 | R3>; }",
      description: "/\n * Handles both success and failure cases of an effect, allowing for additional\n * side effects.\n *\n *",
      documentation: '/**\n * Handles both success and failure cases of an effect, allowing for additional\n * side effects.\n *\n * **Details**\n *\n * The `matchEffect` function is similar to {@link match}, but it enables you to\n * perform side effects in the handlers for both success and failure outcomes.\n *\n * **When to Use**\n *\n * This is useful when you need to execute additional actions, like logging or\n * notifying users, based on whether an effect succeeds or fails.\n *\n * **Example** (Handling Both Success and Failure Cases with Side Effects)\n *\n * ```ts\n * import { Effect } from "effect"\n *\n * const success: Effect.Effect<number, Error> = Effect.succeed(42)\n * const failure: Effect.Effect<number, Error> = Effect.fail(\n *   new Error("Uh oh!")\n * )\n *\n * const program1 = Effect.matchEffect(success, {\n *   onFailure: (error) =>\n *     Effect.succeed(`failure: ${error.message}`).pipe(\n *       Effect.tap(Effect.log)\n *     ),\n *   onSuccess: (value) =>\n *     Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))\n * })\n *\n * console.log(Effect.runSync(program1))\n * // Output:\n * // timestamp=... level=INFO fiber=#0 message="success: 42"\n * // success: 42\n *\n * const program2 = Effect.matchEffect(failure, {\n *   onFailure: (error) =>\n *     Effect.succeed(`failure: ${error.message}`).pipe(\n *       Effect.tap(Effect.log)\n *     ),\n *   onSuccess: (value) =>\n *     Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))\n * })\n *\n * console.log(Effect.runSync(program2))\n * // Output:\n * // timestamp=... level=INFO fiber=#1 message="failure: Uh oh!"\n * // failure: Uh oh!\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect } from "effect"\n *\n * const success: Effect.Effect<number, Error> = Effect.succeed(42)\n * const failure: Effect.Effect<number, Error> = Effect.fail(\n *   new Error("Uh oh!")\n * )\n *\n * const program1 = Effect.matchEffect(success, {\n *   onFailure: (error) =>\n *     Effect.succeed(`failure: ${error.message}`).pipe(\n *       Effect.tap(Effect.log)\n *     ),\n *   onSuccess: (value) =>\n *     Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))\n * })\n *\n * console.log(Effect.runSync(program1))\n * // Output:\n * // timestamp=... level=INFO fiber=#0 message="success: 42"\n * // success: 42\n *\n * const program2 = Effect.matchEffect(failure, {\n *   onFailure: (error) =>\n *     Effect.succeed(`failure: ${error.message}`).pipe(\n *       Effect.tap(Effect.log)\n *     ),\n *   onSuccess: (value) =>\n *     Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))\n * })\n *\n * console.log(Effect.runSync(program2))\n * // Output:\n * // timestamp=... level=INFO fiber=#1 message="failure: Uh oh!"\n * // failure: Uh oh!\n *'
        }
      ],
      tags: [
        "Matching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22118,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22118"
    },
    {
      id: "effect.log",
      name: "log",
      module: "effect",
      package: "effect",
      signature: "(...message: readonly any[]) => Effect<void, never, never>",
      description: "Logs one or more messages or error causes at the current log level.",
      documentation: 'Logs one or more messages or error causes at the current log level.\n\n**Details**\n\nThis function provides a simple way to log messages or error causes during\nthe execution of your effects. By default, logs are recorded at the `INFO`\nlevel, but this can be adjusted using other logging utilities\n(`Logger.withMinimumLogLevel`). Multiple items, including `Cause` instances,\ncan be logged in a single call. When logging `Cause` instances, detailed\nerror information is included in the log output.\n\nThe log output includes useful metadata like the current timestamp, log\nlevel, and fiber ID, making it suitable for debugging and tracking purposes.\nThis function does not interrupt or alter the effect\'s execution flow.\n\n**Example**\n\n```ts\nimport { Cause, Effect } from "effect"\n\nconst program = Effect.log(\n  "message1",\n  "message2",\n  Cause.die("Oh no!"),\n  Cause.die("Oh uh!")\n)\n\nEffect.runFork(program)\n// Output:\n// timestamp=... level=INFO fiber=#0 message=message1 message=message2 cause="Error: Oh no!\n// Error: Oh uh!"\n```',
      examples: [
        {
          code: 'import { Cause, Effect } from "effect"\n\nconst program = Effect.log(\n  "message1",\n  "message2",\n  Cause.die("Oh no!"),\n  Cause.die("Oh uh!")\n)\n\nEffect.runFork(program)\n// Output:\n// timestamp=... level=INFO fiber=#0 message=message1 message=message2 cause="Error: Oh no!\n// Error: Oh uh!"'
        }
      ],
      tags: [
        "Logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22283,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22283"
    },
    {
      id: "effect.logWithLevel",
      name: "logWithLevel",
      module: "effect",
      package: "effect",
      signature: "(level: LogLevel, ...message: readonly any[]) => Effect<void, never, never>",
      description: "Logs messages or error causes at a specified log level.",
      documentation: 'Logs messages or error causes at a specified log level.\n\n**Details**\n\nThis function allows you to log one or more messages or error causes while\nspecifying the desired log level (e.g., DEBUG, INFO, ERROR). It provides\nflexibility in categorizing logs based on their importance or severity,\nmaking it easier to filter logs during debugging or production monitoring.\n\n**Example**\n\n```ts\nimport { Cause, Effect, LogLevel } from "effect"\n\nconst program = Effect.logWithLevel(\n  LogLevel.Error,\n  "Critical error encountered",\n  Cause.die("System failure!")\n)\n\nEffect.runFork(program)\n// Output:\n// timestamp=... level=ERROR fiber=#0 message=Critical error encountered cause="Error: System failure!"\n```',
      examples: [
        {
          code: 'import { Cause, Effect, LogLevel } from "effect"\n\nconst program = Effect.logWithLevel(\n  LogLevel.Error,\n  "Critical error encountered",\n  Cause.die("System failure!")\n)\n\nEffect.runFork(program)\n// Output:\n// timestamp=... level=ERROR fiber=#0 message=Critical error encountered cause="Error: System failure!"'
        }
      ],
      tags: [
        "Logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22313,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22313"
    },
    {
      id: "effect.logTrace",
      name: "logTrace",
      module: "effect",
      package: "effect",
      signature: "(...message: readonly any[]) => Effect<void, never, never>",
      description: "Logs messages at the TRACE log level.",
      documentation: 'Logs messages at the TRACE log level.\n\n**Details**\n\nThis function logs the specified messages at the TRACE level. TRACE logs are\ntypically used for very detailed diagnostic information. These messages are\nnot displayed by default. To view them, you must adjust the logging\nconfiguration by setting the minimum log level to `LogLevel.Trace` using\n`Logger.withMinimumLogLevel`.\n\n**Example**\n\n```ts\nimport { Effect, Logger, LogLevel } from "effect"\n\nconst program = Effect.logTrace("message1").pipe(Logger.withMinimumLogLevel(LogLevel.Trace))\n\nEffect.runFork(program)\n// timestamp=... level=TRACE fiber=#0 message=message1\n```',
      examples: [
        {
          code: 'import { Effect, Logger, LogLevel } from "effect"\n\nconst program = Effect.logTrace("message1").pipe(Logger.withMinimumLogLevel(LogLevel.Trace))\n\nEffect.runFork(program)\n// timestamp=... level=TRACE fiber=#0 message=message1'
        }
      ],
      tags: [
        "Logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22339,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22339"
    },
    {
      id: "effect.logDebug",
      name: "logDebug",
      module: "effect",
      package: "effect",
      signature: "(...message: readonly any[]) => Effect<void, never, never>",
      description: "Logs messages at the DEBUG log level.",
      documentation: 'Logs messages at the DEBUG log level.\n\n**Details**\n\nThis function logs messages at the DEBUG level, which is typically used for\ndiagnosing application behavior during development. DEBUG messages provide\nless detailed information than TRACE logs but are still not shown by default.\nTo view these logs, adjust the log level using `Logger.withMinimumLogLevel`.\n\n**Example**\n\n```ts\nimport { Effect, Logger, LogLevel } from "effect"\n\nconst program = Effect.logDebug("message1").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))\n\nEffect.runFork(program)\n// timestamp=... level=DEBUG fiber=#0 message=message1\n```',
      examples: [
        {
          code: 'import { Effect, Logger, LogLevel } from "effect"\n\nconst program = Effect.logDebug("message1").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))\n\nEffect.runFork(program)\n// timestamp=... level=DEBUG fiber=#0 message=message1'
        }
      ],
      tags: [
        "Logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22364,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22364"
    },
    {
      id: "effect.logInfo",
      name: "logInfo",
      module: "effect",
      package: "effect",
      signature: "(...message: readonly any[]) => Effect<void, never, never>",
      description: "Logs messages at the INFO log level.",
      documentation: "Logs messages at the INFO log level.\n\n**Details**\n\nThis function logs messages at the INFO level, suitable for general\napplication events or operational messages. INFO logs are shown by default\nand are commonly used for highlighting normal, non-error operations.",
      examples: [],
      tags: [
        "Logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22377,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22377"
    },
    {
      id: "effect.logWarning",
      name: "logWarning",
      module: "effect",
      package: "effect",
      signature: "(...message: readonly any[]) => Effect<void, never, never>",
      description: "Logs messages at the WARNING log level.",
      documentation: "Logs messages at the WARNING log level.\n\n**Details**\n\nThis function logs messages at the WARNING level, suitable for highlighting\npotential issues that are not errors but may require attention. These\nmessages indicate that something unexpected occurred or might lead to errors\nin the future.",
      examples: [],
      tags: [
        "Logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22391,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22391"
    },
    {
      id: "effect.logError",
      name: "logError",
      module: "effect",
      package: "effect",
      signature: "(...message: readonly any[]) => Effect<void, never, never>",
      description: "Logs messages at the ERROR log level.",
      documentation: "Logs messages at the ERROR log level.\n\n**Details**\n\nThis function logs messages at the ERROR level, suitable for reporting\napplication errors or failures. These logs are typically used for unexpected\nissues that need immediate attention.",
      examples: [],
      tags: [
        "Logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22404,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22404"
    },
    {
      id: "effect.logFatal",
      name: "logFatal",
      module: "effect",
      package: "effect",
      signature: "(...message: readonly any[]) => Effect<void, never, never>",
      description: "Logs messages at the FATAL log level.",
      documentation: "Logs messages at the FATAL log level.\n\n**Details**\n\nThis function logs messages at the FATAL level, suitable for reporting\ncritical errors that cause the application to terminate or stop functioning.\nThese logs are typically used for unrecoverable errors that require immediate\nattention.",
      examples: [],
      tags: [
        "Logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22418,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22418"
    },
    {
      id: "effect.withLogSpan",
      name: "withLogSpan",
      module: "effect",
      package: "effect",
      signature: "{ (label: string): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, label: string): Effect<A, E, R>; }",
      description: "Adds a log span to an effect for tracking and logging its execution duration.",
      documentation: 'Adds a log span to an effect for tracking and logging its execution duration.\n\n**Details**\n\nThis function wraps an effect with a log span, providing performance\nmonitoring and debugging capabilities. The log span tracks the duration of\nthe wrapped effect and logs it with the specified label. This is particularly\nuseful when analyzing time-sensitive operations or understanding the\nexecution time of specific tasks in your application.\n\nThe logged output will include the label and the total time taken for the\noperation. The span information is included in the log metadata, making it\neasy to trace performance metrics in logs.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.sleep("1 second")\n  yield* Effect.log("The job is finished!")\n}).pipe(Effect.withLogSpan("myspan"))\n\nEffect.runFork(program)\n// timestamp=... level=INFO fiber=#0 message="The job is finished!" myspan=1011ms\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.sleep("1 second")\n  yield* Effect.log("The job is finished!")\n}).pipe(Effect.withLogSpan("myspan"))\n\nEffect.runFork(program)\n// timestamp=... level=INFO fiber=#0 message="The job is finished!" myspan=1011ms'
        }
      ],
      tags: [
        "Logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22451,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22451"
    },
    {
      id: "effect.annotateLogs",
      name: "annotateLogs",
      module: "effect",
      package: "effect",
      signature: "{ (key: string, value: unknown): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; (values: Record<string, unknown>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, key: string, value: unknown): Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, values: Record<string, unknown>): Effect<A, E, R>; }",
      description: "Adds custom annotations to log entries generated within an effect.",
      documentation: 'Adds custom annotations to log entries generated within an effect.\n\n**Details**\n\nThis function allows you to enhance log messages by appending additional\ncontext in the form of key-value pairs. These annotations are included in\nevery log message created during the execution of the effect, making the logs\nmore informative and easier to trace.\n\nThe annotations can be specified as a single key-value pair or as a record of\nmultiple key-value pairs. This is particularly useful for tracking\noperations, debugging, or associating specific metadata with logs for better\nobservability.\n\nThe annotated key-value pairs will appear alongside the log message in the\noutput.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log("message1")\n  yield* Effect.log("message2")\n}).pipe(Effect.annotateLogs("taskId", "1234")) // Annotation as key/value pair\n\nEffect.runFork(program)\n// timestamp=... level=INFO fiber=#0 message=message1 taskId=1234\n// timestamp=... level=INFO fiber=#0 message=message2 taskId=1234\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log("message1")\n  yield* Effect.log("message2")\n}).pipe(Effect.annotateLogs("taskId", "1234")) // Annotation as key/value pair\n\nEffect.runFork(program)\n// timestamp=... level=INFO fiber=#0 message=message1 taskId=1234\n// timestamp=... level=INFO fiber=#0 message=message2 taskId=1234'
        }
      ],
      tags: [
        "Logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22557,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22557"
    },
    {
      id: "effect.annotateLogsScoped",
      name: "annotateLogsScoped",
      module: "effect",
      package: "effect",
      signature: "{ (key: string, value: unknown): Effect<void, never, Scope>; (values: Record<string, unknown>): Effect<void, never, Scope>; }",
      description: "Adds log annotations with a limited scope to enhance contextual logging.",
      documentation: 'Adds log annotations with a limited scope to enhance contextual logging.\n\n**Details**\n\nThis function allows you to apply key-value annotations to log entries\ngenerated within a specific scope of your effect computations. The\nannotations are restricted to the defined `Scope`, ensuring that they are\nonly applied to logs produced during that scope. Once the scope ends, the\nannotations are automatically removed, making it easier to manage\ncontext-specific logging without affecting other parts of your application.\n\nThe annotations can be provided as a single key-value pair or as a record of\nmultiple key-value pairs. This flexibility enables fine-grained control over\nthe additional metadata included in logs for specific tasks or operations.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log("no annotations")\n  yield* Effect.annotateLogsScoped({ key: "value" })\n  yield* Effect.log("message1") // Annotation is applied to this log\n  yield* Effect.log("message2") // Annotation is applied to this log\n}).pipe(Effect.scoped, Effect.andThen(Effect.log("no annotations again")))\n\nEffect.runFork(program)\n// timestamp=... level=INFO fiber=#0 message="no annotations"\n// timestamp=... level=INFO fiber=#0 message=message1 key=value\n// timestamp=... level=INFO fiber=#0 message=message2 key=value\n// timestamp=... level=INFO fiber=#0 message="no annotations again"\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log("no annotations")\n  yield* Effect.annotateLogsScoped({ key: "value" })\n  yield* Effect.log("message1") // Annotation is applied to this log\n  yield* Effect.log("message2") // Annotation is applied to this log\n}).pipe(Effect.scoped, Effect.andThen(Effect.log("no annotations again")))\n\nEffect.runFork(program)\n// timestamp=... level=INFO fiber=#0 message="no annotations"\n// timestamp=... level=INFO fiber=#0 message=message1 key=value\n// timestamp=... level=INFO fiber=#0 message=message2 key=value\n// timestamp=... level=INFO fiber=#0 message="no annotations again"'
        }
      ],
      tags: [
        "Logging"
      ],
      since: "3.1.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22755,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22755"
    },
    {
      id: "effect.logAnnotations",
      name: "logAnnotations",
      module: "effect",
      package: "effect",
      signature: "Effect<HashMap<string, unknown>, never, never>",
      description: "Retrieves the current log annotations for the current scope.",
      documentation: "Retrieves the current log annotations for the current scope.\n\n**Details**\n\nThis function provides access to the log annotations associated with the\ncurrent scope. Log annotations are key-value pairs that provide additional\ncontext to log entries. They are often used to add metadata such as tags,\nidentifiers, or extra debugging information to logs.\n\nBy using this function, you can inspect or utilize the annotations applied to\nthe current scope, making it easier to trace and debug specific sections of\nyour application.",
      examples: [],
      tags: [
        "Logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22859,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22859"
    },
    {
      id: "effect.withUnhandledErrorLogLevel",
      name: "withUnhandledErrorLogLevel",
      module: "effect",
      package: "effect",
      signature: "{ (level: Option<LogLevel>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, level: Option<LogLevel>): Effect<A, E, R>; }",
      description: "Configures whether child fibers will log unhandled errors and at what log\nlevel.",
      documentation: 'Configures whether child fibers will log unhandled errors and at what log\nlevel.\n\n**Details**\n\nThis function allows you to control whether unhandled errors from child\nfibers are logged and to specify the log level for these errors. By default,\nunhandled errors are reported via the logger. However, using this function,\nyou can choose to suppress these logs by passing `Option.none` or adjust the\nlog level to a specific severity, such as `Error`, `Warning`, or `Info`.\n\nThis configuration is scoped to the effect it is applied to, meaning the\nchanges only apply to the child fibers created within that effect\'s context.\nIt is especially useful when you want to reduce noise in logs or prioritize\ncertain types of errors.\n\n**Example**\n\n```ts\nimport { Effect, Fiber, LogLevel, Option } from "effect"\n\nconst program = Effect.gen(function*() {\n  const fiber = yield* Effect.fork(Effect.fail("Unhandled error!"))\n  yield* Fiber.join(fiber)\n})\n\nEffect.runFork(program.pipe(Effect.withUnhandledErrorLogLevel(Option.some(LogLevel.Error))))\n// Output:\n// timestamp=... level=ERROR fiber=#1 message="Fiber terminated with an unhandled error" cause="Error: Unhandled error!"\n```',
      examples: [
        {
          code: 'import { Effect, Fiber, LogLevel, Option } from "effect"\n\nconst program = Effect.gen(function*() {\n  const fiber = yield* Effect.fork(Effect.fail("Unhandled error!"))\n  yield* Fiber.join(fiber)\n})\n\nEffect.runFork(program.pipe(Effect.withUnhandledErrorLogLevel(Option.some(LogLevel.Error))))\n// Output:\n// timestamp=... level=ERROR fiber=#1 message="Fiber terminated with an unhandled error" cause="Error: Unhandled error!"'
        }
      ],
      tags: [
        "Logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22895,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22895"
    },
    {
      id: "effect.whenLogLevel",
      name: "whenLogLevel",
      module: "effect",
      package: "effect",
      signature: '{ (level: LogLevel | "All" | "Fatal" | "Error" | "Warning" | "Info" | "Debug" | "Trace" | "None"): <A, E, R>(self: Effect<A, E, R>) => Effect<Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, level: LogLevel | "All" | "Fatal" | "Error" | "Warning" | "Info" | "Debug" | "Trace" | "None"): Effect<Option<A>, E, R>; }',
      description: "Conditionally executes an effect based on the specified log level and currently enabled log level.",
      documentation: 'Conditionally executes an effect based on the specified log level and currently enabled log level.\n\n**Details**\n\nThis function runs the provided effect only if the specified log level is\nenabled. If the log level is enabled, the effect is executed and its result\nis wrapped in `Some`. If the log level is not enabled, the effect is not\nexecuted and `None` is returned.\n\nThis function is useful for conditionally executing logging-related effects\nor other operations that depend on the current log level configuration.\n\n**Example**\n\n```ts\nimport { Effect, Logger, LogLevel } from "effect"\n\nconst program = Effect.gen(function* () {\n  yield* Effect.whenLogLevel(Effect.logTrace("message1"), LogLevel.Trace); // returns `None`\n  yield* Effect.whenLogLevel(Effect.logDebug("message2"), LogLevel.Debug); // returns `Some`\n}).pipe(Logger.withMinimumLogLevel(LogLevel.Debug));\n\nEffect.runFork(program)\n// timestamp=... level=DEBUG fiber=#0 message=message2\n```',
      examples: [
        {
          code: 'import { Effect, Logger, LogLevel } from "effect"\n\nconst program = Effect.gen(function* () {\n  yield* Effect.whenLogLevel(Effect.logTrace("message1"), LogLevel.Trace); // returns `None`\n  yield* Effect.whenLogLevel(Effect.logDebug("message2"), LogLevel.Debug); // returns `Some`\n}).pipe(Logger.withMinimumLogLevel(LogLevel.Debug));\n\nEffect.runFork(program)\n// timestamp=... level=DEBUG fiber=#0 message=message2'
        }
      ],
      tags: [
        "Logging"
      ],
      since: "3.13.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23001,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23001"
    },
    {
      id: "effect.orDie",
      name: "orDie",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, never, R>",
      description: "Converts an effect's failure into a fiber termination, removing the error\nfrom the effect's type.",
      documentation: 'Converts an effect\'s failure into a fiber termination, removing the error\nfrom the effect\'s type.\n\n**Details**\n\nThe `orDie` function is used when you encounter errors that you do not want\nto handle or recover from. It removes the error type from the effect and\nensures that any failure will terminate the fiber. This is useful for\npropagating failures as defects, signaling that they should not be handled\nwithin the effect.\n\n**When to Use*\n\nUse `orDie` when failures should be treated as unrecoverable defects and no\nerror handling is required.\n\n**Example** (Propagating an Error as a Defect)\n\n```ts\nimport { Effect } from "effect"\n\nconst divide = (a: number, b: number) =>\n  b === 0\n    ? Effect.fail(new Error("Cannot divide by zero"))\n    : Effect.succeed(a / b)\n\n//      \u250C\u2500\u2500\u2500 Effect<number, never, never>\n//      \u25BC\nconst program = Effect.orDie(divide(1, 0))\n\nEffect.runPromise(program).catch(console.error)\n// Output:\n// (FiberFailure) Error: Cannot divide by zero\n//   ...stack trace...\n```',
      examples: [
        {
          title: "Propagating an Error as a Defect",
          code: 'import { Effect } from "effect"\n\nconst divide = (a: number, b: number) =>\n  b === 0\n    ? Effect.fail(new Error("Cannot divide by zero"))\n    : Effect.succeed(a / b)\n\n//      \u250C\u2500\u2500\u2500 Effect<number, never, never>\n//      \u25BC\nconst program = Effect.orDie(divide(1, 0))\n\nEffect.runPromise(program).catch(console.error)\n// Output:\n// (FiberFailure) Error: Cannot divide by zero\n//   ...stack trace...'
        }
      ],
      tags: [
        "Converting Failures to Defects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23111,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23111"
    },
    {
      id: "effect.orDieWith",
      name: "orDieWith",
      module: "effect",
      package: "effect",
      signature: "{ <E>(f: (error: E) => unknown): <A, R>(self: Effect<A, E, R>) => Effect<A, never, R>; <A, E, R>(self: Effect<A, E, R>, f: (error: E) => unknown): Effect<A, never, R>; }",
      description: "/\n * Converts an effect's failure into a fiber termination with a custom error.\n *\n *",
      documentation: '/**\n * Converts an effect\'s failure into a fiber termination with a custom error.\n *\n * **Details**\n *\n * The `orDieWith` function behaves like {@link orDie}, but it allows you to provide a mapping\n * function to transform the error before terminating the fiber. This is useful for cases where\n * you want to include a more detailed or user-friendly error when the failure is propagated\n * as a defect.\n *\n * **When to Use**\n *\n * Use `orDieWith` when failures should terminate the fiber as defects, and you want to customize\n * the error for clarity or debugging purposes.\n *\n * **Example** (Customizing Defect)\n *\n * ```ts\n * import { Effect } from "effect"\n *\n * const divide = (a: number, b: number) =>\n *   b === 0\n *     ? Effect.fail(new Error("Cannot divide by zero"))\n *     : Effect.succeed(a / b)\n *\n * //      \u250C\u2500\u2500\u2500 Effect<number, never, never>\n * //      \u25BC\n * const program = Effect.orDieWith(\n *   divide(1, 0),\n *   (error) => new Error(`defect: ${error.message}`)\n * )\n *\n * Effect.runPromise(program).catch(console.error)\n * // Output:\n * // (FiberFailure) Error: defect: Cannot divide by zero\n * //   ...stack trace...\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect } from "effect"\n *\n * const divide = (a: number, b: number) =>\n *   b === 0\n *     ? Effect.fail(new Error("Cannot divide by zero"))\n *     : Effect.succeed(a / b)\n *\n * //      \u250C\u2500\u2500\u2500 Effect<number, never, never>\n * //      \u25BC\n * const program = Effect.orDieWith(\n *   divide(1, 0),\n *   (error) => new Error(`defect: ${error.message}`)\n * )\n *\n * Effect.runPromise(program).catch(console.error)\n * // Output:\n * // (FiberFailure) Error: defect: Cannot divide by zero\n * //   ...stack trace...\n *'
        }
      ],
      tags: [
        "Converting Failures to Defects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23155,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23155"
    },
    {
      id: "effect.orElse",
      name: "orElse",
      module: "effect",
      package: "effect",
      signature: "{ <A2, E2, R2>(that: LazyArg<Effect<A2, E2, R2>>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: LazyArg<Effect<A2, E2, R2>>): Effect<A | A2, E2, R | R2>; }",
      description: "Attempts one effect, and if it fails, falls back to another effect.",
      documentation: 'Attempts one effect, and if it fails, falls back to another effect.\n\n**Details**\n\nThis function allows you to try executing an effect, and if it fails\n(produces an error), a fallback effect is executed instead. The fallback\neffect is defined as a lazy argument, meaning it will only be evaluated if\nthe first effect fails. This provides a way to recover from errors by\nspecifying an alternative path of execution.\n\nThe error type of the resulting effect will be that of the fallback effect,\nas the first effect\'s error is replaced when the fallback is executed.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst success = Effect.succeed("success")\nconst failure = Effect.fail("failure")\nconst fallback = Effect.succeed("fallback")\n\n// Try the success effect first, fallback is not used\nconst program1 = Effect.orElse(success, () => fallback)\nconsole.log(Effect.runSync(program1))\n// Output: "success"\n\n// Try the failure effect first, fallback is used\nconst program2 = Effect.orElse(failure, () => fallback)\nconsole.log(Effect.runSync(program2))\n// Output: "fallback"\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst success = Effect.succeed("success")\nconst failure = Effect.fail("failure")\nconst fallback = Effect.succeed("fallback")\n\n// Try the success effect first, fallback is not used\nconst program1 = Effect.orElse(success, () => fallback)\nconsole.log(Effect.runSync(program1))\n// Output: "success"\n\n// Try the failure effect first, fallback is used\nconst program2 = Effect.orElse(failure, () => fallback)\nconsole.log(Effect.runSync(program2))\n// Output: "fallback"'
        }
      ],
      tags: [
        "Fallback"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23284,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23284"
    },
    {
      id: "effect.orElseFail",
      name: "orElseFail",
      module: "effect",
      package: "effect",
      signature: "{ <E2>(evaluate: LazyArg<E2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, evaluate: LazyArg<E2>): Effect<A, E2, R>; }",
      description: "Replaces the failure of an effect with a custom failure value.",
      documentation: "Replaces the failure of an effect with a custom failure value.\n\n**Details**\n\nThis function allows you to handle the failure of an effect by replacing it\nwith a predefined failure value. If the effect fails, the new failure value\nprovided by the `evaluate` function will be returned instead of the original\nfailure. If the effect succeeds, the original success value is returned\nunchanged.\n\n**When to Use**\n\nThis is particularly useful when you want to standardize error handling or\nprovide a consistent failure value for specific operations. It simplifies\nerror management by ensuring that all failures are replaced with a controlled\nalternative.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst validate = (age: number): Effect.Effect<number, string> => {\n  if (age < 0) {\n    return Effect.fail(\"NegativeAgeError\")\n  } else if (age < 18) {\n    return Effect.fail(\"IllegalAgeError\")\n  } else {\n    return Effect.succeed(age)\n  }\n}\n\nconst program = Effect.orElseFail(validate(-1), () => \"invalid age\")\n\nconsole.log(Effect.runSyncExit(program))\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'invalid age' }\n// }\n```",
      examples: [
        {
          code: `import { Effect } from "effect"

const validate = (age: number): Effect.Effect<number, string> => {
  if (age < 0) {
    return Effect.fail("NegativeAgeError")
  } else if (age < 18) {
    return Effect.fail("IllegalAgeError")
  } else {
    return Effect.succeed(age)
  }
}

const program = Effect.orElseFail(validate(-1), () => "invalid age")

console.log(Effect.runSyncExit(program))
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'invalid age' }
// }`
        }
      ],
      tags: [
        "Fallback"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23415,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23415"
    },
    {
      id: "effect.orElseSucceed",
      name: "orElseSucceed",
      module: "effect",
      package: "effect",
      signature: "{ <A2>(evaluate: LazyArg<A2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, never, R>; <A, E, R, A2>(self: Effect<A, E, R>, evaluate: LazyArg<A2>): Effect<A | A2, never, R>; }",
      description: "Ensures the effect always succeeds by replacing failures with a default\nsuccess value.",
      documentation: 'Ensures the effect always succeeds by replacing failures with a default\nsuccess value.\n\n**Details**\n\nThis function transforms an effect that may fail into one that cannot fail by\nreplacing any failure with a provided success value. If the original effect\nfails, the failure is "swallowed," and the specified success value is\nreturned instead. If the original effect succeeds, its value remains\nunchanged.\n\n**When to Use**\n\nThis is especially useful for providing default values in case of failure,\nensuring that an effect always completes successfully. By using this\nfunction, you can avoid the need for complex error handling and guarantee a\nfallback result.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst validate = (age: number): Effect.Effect<number, string> => {\n  if (age < 0) {\n    return Effect.fail("NegativeAgeError")\n  } else if (age < 18) {\n    return Effect.fail("IllegalAgeError")\n  } else {\n    return Effect.succeed(age)\n  }\n}\n\nconst program = Effect.orElseSucceed(validate(-1), () => 18)\n\nconsole.log(Effect.runSyncExit(program))\n// Output:\n// { _id: \'Exit\', _tag: \'Success\', value: 18 }\n```',
      examples: [
        {
          code: `import { Effect } from "effect"

const validate = (age: number): Effect.Effect<number, string> => {
  if (age < 0) {
    return Effect.fail("NegativeAgeError")
  } else if (age < 18) {
    return Effect.fail("IllegalAgeError")
  } else {
    return Effect.succeed(age)
  }
}

const program = Effect.orElseSucceed(validate(-1), () => 18)

console.log(Effect.runSyncExit(program))
// Output:
// { _id: 'Exit', _tag: 'Success', value: 18 }`
        }
      ],
      tags: [
        "Fallback"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23561,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23561"
    },
    {
      id: "effect.firstSuccessOf",
      name: "firstSuccessOf",
      module: "effect",
      package: "effect",
      signature: "<Eff extends Effect<any, any, any>>(effects: Iterable<Eff>) => Effect<Effect.Success<Eff>, Effect.Error<Eff>, Effect.Context<Eff>>",
      description: "Runs a sequence of effects and returns the result of the first successful\none.",
      documentation: 'Runs a sequence of effects and returns the result of the first successful\none.\n\n**Details**\n\nThis function allows you to execute a collection of effects in sequence,\nstopping at the first success. If an effect succeeds, its result is\nimmediately returned, and no further effects in the sequence are executed.\nHowever, if all the effects fail, the function will return the error of the\nlast effect.\n\nThe execution is sequential, meaning that effects are evaluated one at a time\nin the order they are provided. This ensures predictable behavior and avoids\nunnecessary computations.\n\nIf the collection of effects is empty, an `IllegalArgumentException` is\nthrown, indicating that the operation is invalid without any effects to try.\n\n**When to Use**\n\nThis is particularly useful when you have multiple fallback strategies or\nalternative sources to obtain a result, such as attempting multiple APIs,\nretrieving configurations, or accessing resources in a prioritized manner.\n\n**Example**\n\n```ts\nimport { Effect, Console } from "effect"\n\ninterface Config {\n  host: string\n  port: number\n  apiKey: string\n}\n\n// Create a configuration object with sample values\nconst makeConfig = (name: string): Config => ({\n  host: `${name}.example.com`,\n  port: 8080,\n  apiKey: "12345-abcde"\n})\n\n// Simulate retrieving configuration from a remote node\nconst remoteConfig = (name: string): Effect.Effect<Config, Error> =>\n  Effect.gen(function* () {\n    // Simulate node3 being the only one with available config\n    if (name === "node3") {\n      yield* Console.log(`Config for ${name} found`)\n      return makeConfig(name)\n    } else {\n      yield* Console.log(`Unavailable config for ${name}`)\n      return yield* Effect.fail(new Error(`Config not found for ${name}`))\n    }\n  })\n\n// Define the master configuration and potential fallback nodes\nconst masterConfig = remoteConfig("master")\nconst nodeConfigs = ["node1", "node2", "node3", "node4"].map(remoteConfig)\n\n// Attempt to find a working configuration,\n// starting with the master and then falling back to other nodes\nconst config = Effect.firstSuccessOf([masterConfig, ...nodeConfigs])\n\n// Run the effect to retrieve the configuration\nconst result = Effect.runSync(config)\n\nconsole.log(result)\n// Output:\n// Unavailable config for master\n// Unavailable config for node1\n// Unavailable config for node2\n// Config for node3 found\n// { host: \'node3.example.com\', port: 8080, apiKey: \'12345-abcde\' }\n```',
      examples: [
        {
          code: 'import { Effect, Console } from "effect"\n\ninterface Config {\n  host: string\n  port: number\n  apiKey: string\n}\n\n// Create a configuration object with sample values\nconst makeConfig = (name: string): Config => ({\n  host: `${name}.example.com`,\n  port: 8080,\n  apiKey: "12345-abcde"\n})\n\n// Simulate retrieving configuration from a remote node\nconst remoteConfig = (name: string): Effect.Effect<Config, Error> =>\n  Effect.gen(function* () {\n    // Simulate node3 being the only one with available config\n    if (name === "node3") {\n      yield* Console.log(`Config for ${name} found`)\n      return makeConfig(name)\n    } else {\n      yield* Console.log(`Unavailable config for ${name}`)\n      return yield* Effect.fail(new Error(`Config not found for ${name}`))\n    }\n  })\n\n// Define the master configuration and potential fallback nodes\nconst masterConfig = remoteConfig("master")\nconst nodeConfigs = ["node1", "node2", "node3", "node4"].map(remoteConfig)\n\n// Attempt to find a working configuration,\n// starting with the master and then falling back to other nodes\nconst config = Effect.firstSuccessOf([masterConfig, ...nodeConfigs])\n\n// Run the effect to retrieve the configuration\nconst result = Effect.runSync(config)\n\nconsole.log(result)\n// Output:\n// Unavailable config for master\n// Unavailable config for node1\n// Unavailable config for node2\n// Config for node3 found\n// { host: \'node3.example.com\', port: 8080, apiKey: \'12345-abcde\' }'
        }
      ],
      tags: [
        "Fallback"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23732,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23732"
    },
    {
      id: "effect.random",
      name: "random",
      module: "effect",
      package: "effect",
      signature: "Effect<Random, never, never>",
      description: "Retrieves the `Random` service from the context.",
      documentation: "Retrieves the `Random` service from the context.",
      examples: [],
      tags: [
        "Random"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23739,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23739"
    },
    {
      id: "effect.randomWith",
      name: "randomWith",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(f: (random: Random) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "Retrieves the `Random` service from the context and uses it to run the\nspecified effect.",
      documentation: "Retrieves the `Random` service from the context and uses it to run the\nspecified effect.",
      examples: [],
      tags: [
        "Random"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23747,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23747"
    },
    {
      id: "effect.withRandom",
      name: "withRandom",
      module: "effect",
      package: "effect",
      signature: "{ <X extends Random.Random>(value: X): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <X extends Random.Random, A, E, R>(effect: Effect<A, E, R>, value: X): Effect<A, E, R>; }",
      description: "Executes the specified effect with the specified implementation of the\n`Random` service.",
      documentation: "Executes the specified effect with the specified implementation of the\n`Random` service.",
      examples: [],
      tags: [
        "Random"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23755,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23755"
    },
    {
      id: "effect.withRandomFixed",
      name: "withRandomFixed",
      module: "effect",
      package: "effect",
      signature: "{ <T extends RA.NonEmptyArray<any>>(values: T): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <T extends RA.NonEmptyArray<any>, A, E, R>(effect: Effect<A, E, R>, values: T): Effect<A, E, R>; }",
      description: "Executes the specified effect with a `Random` service that cycles through\na provided array of values.",
      documentation: "Executes the specified effect with a `Random` service that cycles through\na provided array of values.",
      examples: [
        {
          code: 'import { Effect, Random } from "effect"\n\nEffect.gen(function*() {\n  console.log(yield* Random.next) // 0.2\n  console.log(yield* Random.next) // 0.5\n  console.log(yield* Random.next) // 0.8\n}).pipe(Effect.withRandomFixed([0.2, 0.5, 0.8]))'
        }
      ],
      tags: [
        "Random"
      ],
      since: "3.11.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23791,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23791"
    },
    {
      id: "effect.withRandomScoped",
      name: "withRandomScoped",
      module: "effect",
      package: "effect",
      signature: "<A extends Random.Random>(value: A) => Effect<void, never, Scope>",
      description: "Sets the implementation of the `Random` service to the specified value and\nrestores it to its original value when the scope is closed.",
      documentation: "Sets the implementation of the `Random` service to the specified value and\nrestores it to its original value when the scope is closed.",
      examples: [],
      tags: [
        "Random"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23838,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23838"
    },
    {
      id: "effect.runtime",
      name: "runtime",
      module: "effect",
      package: "effect",
      signature: "<R = never>() => Effect<Runtime<R>, never, R>",
      description: "Returns an effect that accesses the runtime, which can be used to (unsafely)\nexecute tasks.",
      documentation: "Returns an effect that accesses the runtime, which can be used to (unsafely)\nexecute tasks.\n\n**When to Use**\n\nThis is useful for integration with legacy code that must call back into\nEffect code.",
      examples: [],
      tags: [
        "Runtime"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23851,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23851"
    },
    {
      id: "effect.getRuntimeFlags",
      name: "getRuntimeFlags",
      module: "effect",
      package: "effect",
      signature: "Effect<RuntimeFlags, never, never>",
      description: "Retrieves an effect that succeeds with the current runtime flags, which\ngovern behavior and features of the runtime system.",
      documentation: "Retrieves an effect that succeeds with the current runtime flags, which\ngovern behavior and features of the runtime system.",
      examples: [],
      tags: [
        "Runtime"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23859,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23859"
    },
    {
      id: "effect.patchRuntimeFlags",
      name: "patchRuntimeFlags",
      module: "effect",
      package: "effect",
      signature: "(patch: RuntimeFlagsPatch) => Effect<void, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Runtime"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23864,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23864"
    },
    {
      id: "effect.withRuntimeFlagsPatch",
      name: "withRuntimeFlagsPatch",
      module: "effect",
      package: "effect",
      signature: "{ (update: RuntimeFlagsPatch): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, update: RuntimeFlagsPatch): Effect<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Runtime"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23869,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23869"
    },
    {
      id: "effect.withRuntimeFlagsPatchScoped",
      name: "withRuntimeFlagsPatchScoped",
      module: "effect",
      package: "effect",
      signature: "(update: RuntimeFlagsPatch) => Effect<void, never, Scope>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Runtime"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23885,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23885"
    },
    {
      id: "effect.tagMetrics",
      name: "tagMetrics",
      module: "effect",
      package: "effect",
      signature: "{ (key: string, value: string): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; (values: Record<string, string>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, key: string, value: string): Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, values: Record<string, string>): Effect<A, E, R>; }",
      description: "Tags each metric in an effect with specific key-value pairs.",
      documentation: "Tags each metric in an effect with specific key-value pairs.\n\n**Details**\n\nThis function allows you to tag all metrics in an effect with a set of\nkey-value pairs or a single key-value pair. Tags help you add metadata to\nmetrics, making it easier to filter and categorize them in monitoring\nsystems. The provided tags will apply to all metrics generated within the\neffect's scope.",
      examples: [],
      tags: [
        "Metrics"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23900,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23900"
    },
    {
      id: "effect.labelMetrics",
      name: "labelMetrics",
      module: "effect",
      package: "effect",
      signature: "{ (labels: Iterable<MetricLabel>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, labels: Iterable<MetricLabel>): Effect<A, E, R>; }",
      description: "Adds labels to metrics within an effect using `MetricLabel` objects.",
      documentation: "Adds labels to metrics within an effect using `MetricLabel` objects.\n\n**Details**\n\nThis function allows you to label metrics using `MetricLabel` objects. Labels\nhelp add structured metadata to metrics for categorization and filtering in\nmonitoring systems. The provided labels will apply to all metrics within the\neffect's execution.",
      examples: [],
      tags: [
        "Metrics"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23975,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23975"
    },
    {
      id: "effect.tagMetricsScoped",
      name: "tagMetricsScoped",
      module: "effect",
      package: "effect",
      signature: "(key: string, value: string) => Effect<void, never, Scope>",
      description: "Tags metrics within a scope with a specific key-value pair.",
      documentation: "Tags metrics within a scope with a specific key-value pair.\n\n**Details**\n\nThis function tags all metrics within a scope with the provided key-value\npair. Once the scope is closed, the tag is automatically removed. This is\nuseful for applying temporary context-specific tags to metrics during scoped\noperations.",
      examples: [],
      tags: [
        "Metrics"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24018,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24018"
    },
    {
      id: "effect.labelMetricsScoped",
      name: "labelMetricsScoped",
      module: "effect",
      package: "effect",
      signature: "(labels: readonly MetricLabel[]) => Effect<void, never, Scope>",
      description: "Adds labels to metrics within a scope using `MetricLabel` objects.",
      documentation: "Adds labels to metrics within a scope using `MetricLabel` objects.\n\n**Details**\n\nThis function allows you to apply labels to all metrics generated within a\nspecific scope using an array of `MetricLabel` objects. These labels provide\nadditional metadata to metrics, which can be used for categorization,\nfiltering, or monitoring purposes. The labels are scoped and will be removed\nautomatically once the scope is closed, ensuring they are only applied\ntemporarily within the defined context.",
      examples: [],
      tags: [
        "Metrics"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24034,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24034"
    },
    {
      id: "effect.metricLabels",
      name: "metricLabels",
      module: "effect",
      package: "effect",
      signature: "Effect<readonly MetricLabel[], never, never>",
      description: "Retrieves the metric labels associated with the current scope.",
      documentation: "Retrieves the metric labels associated with the current scope.",
      examples: [],
      tags: [
        "Metrics"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24041,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24041"
    },
    {
      id: "effect.withMetric",
      name: "withMetric",
      module: "effect",
      package: "effect",
      signature: "{ <Type, In, Out>(metric: Metric<Type, In, Out>): <A extends In, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A extends In, E, R, Type, In, Out>(self: Effect<A, E, R>, metric: Metric<Type, In, Out>): Effect<A, E, R>; }",
      description: "Associates a metric with the current effect, updating it as the effect progresses.",
      documentation: "Associates a metric with the current effect, updating it as the effect progresses.",
      examples: [],
      tags: [
        "Metrics"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24048,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24048"
    },
    {
      id: "effect.unsafeMakeSemaphore",
      name: "unsafeMakeSemaphore",
      module: "effect",
      package: "effect",
      signature: "(permits: number) => Semaphore",
      description: "Unsafely creates a new Semaphore.",
      documentation: "Unsafely creates a new Semaphore.",
      examples: [],
      tags: [
        "Semaphore"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24135,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24135"
    },
    {
      id: "effect.makeSemaphore",
      name: "makeSemaphore",
      module: "effect",
      package: "effect",
      signature: "(permits: number) => Effect<Semaphore, never, never>",
      description: "Creates a new semaphore with the specified number of permits.",
      documentation: 'Creates a new semaphore with the specified number of permits.\n\n**Details**\n\nThis function initializes a semaphore that controls concurrent access to a\nshared resource. The number of permits determines how many tasks can access\nthe resource concurrently.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\n// Create a semaphore with 3 permits\nconst mutex = Effect.makeSemaphore(3)\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\n// Create a semaphore with 3 permits\nconst mutex = Effect.makeSemaphore(3)'
        }
      ],
      tags: [
        "Semaphore"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24157,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24157"
    },
    {
      id: "effect.unsafeMakeLatch",
      name: "unsafeMakeLatch",
      module: "effect",
      package: "effect",
      signature: "(open?: boolean) => Latch",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Latch"
      ],
      since: "3.8.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24265,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24265"
    },
    {
      id: "effect.makeLatch",
      name: "makeLatch",
      module: "effect",
      package: "effect",
      signature: "(open?: boolean) => Effect<Latch, never, never>",
      description: "Creates a new `Latch`, starting in the specified state.",
      documentation: 'Creates a new `Latch`, starting in the specified state.\n\n**Details**\n\nThis function initializes a `Latch` safely, ensuring proper runtime\nguarantees. By default, the latch starts in the closed state.\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  // Create a latch, starting in the closed state\n  const latch = yield* Effect.makeLatch(false)\n\n  // Fork a fiber that logs "open sesame" when the latch is opened\n  const fiber = yield* Console.log("open sesame").pipe(\n    latch.whenOpen,\n    Effect.fork\n  )\n\n  yield* Effect.sleep("1 second")\n\n  // Open the latch\n  yield* latch.open\n  yield* fiber.await\n})\n\nEffect.runFork(program)\n// Output: open sesame (after 1 second)\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  // Create a latch, starting in the closed state\n  const latch = yield* Effect.makeLatch(false)\n\n  // Fork a fiber that logs "open sesame" when the latch is opened\n  const fiber = yield* Console.log("open sesame").pipe(\n    latch.whenOpen,\n    Effect.fork\n  )\n\n  yield* Effect.sleep("1 second")\n\n  // Open the latch\n  yield* latch.open\n  yield* fiber.await\n})\n\nEffect.runFork(program)\n// Output: open sesame (after 1 second)'
        }
      ],
      tags: [
        "Latch"
      ],
      since: "3.8.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24303,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24303"
    },
    {
      id: "effect.runFork",
      name: "runFork",
      module: "effect",
      package: "effect",
      signature: "<A, E>(effect: Effect<A, E, never>, options?: RunForkOptions) => RuntimeFiber<A, E>",
      description: "Runs an effect in the background, returning a fiber that can be observed or\ninterrupted. Unless you specifically need a `Promise` or synchronous operation, `runFork`\nis a good default choice.",
      documentation: 'Runs an effect in the background, returning a fiber that can be observed or\ninterrupted.\n\nUnless you specifically need a `Promise` or synchronous operation, `runFork`\nis a good default choice.\n\n**Details**\n\nThis function is the foundational way to execute an effect in the background.\nIt creates a "fiber," a lightweight, cooperative thread of execution that can\nbe observed (to access its result), interrupted, or joined. Fibers are useful\nfor concurrent programming and allow effects to run independently of the main\nprogram flow.\n\nOnce the effect is running in a fiber, you can monitor its progress, cancel\nit if necessary, or retrieve its result when it completes. If the effect\nfails, the fiber will propagate the failure, which you can observe and\nhandle.\n\n**When to Use**\n\nUse this function when you need to run an effect in the background,\nespecially if the effect is long-running or performs periodic tasks. It\'s\nsuitable for tasks that need to run independently but might still need\nobservation or management, like logging, monitoring, or scheduled tasks.\n\nThis function is ideal if you don\'t need the result immediately or if the\neffect is part of a larger concurrent workflow.\n\n**Example** (Running an Effect in the Background)\n\n```ts\nimport { Effect, Console, Schedule, Fiber } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, never, never>\n//      \u25BC\nconst program = Effect.repeat(\n  Console.log("running..."),\n  Schedule.spaced("200 millis")\n)\n\n//      \u250C\u2500\u2500\u2500 RuntimeFiber<number, never>\n//      \u25BC\nconst fiber = Effect.runFork(program)\n\nsetTimeout(() => {\n  Effect.runFork(Fiber.interrupt(fiber))\n}, 500)\n```',
      examples: [
        {
          title: "Running an Effect in the Background",
          code: 'import { Effect, Console, Schedule, Fiber } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, never, never>\n//      \u25BC\nconst program = Effect.repeat(\n  Console.log("running..."),\n  Schedule.spaced("200 millis")\n)\n\n//      \u250C\u2500\u2500\u2500 RuntimeFiber<number, never>\n//      \u25BC\nconst fiber = Effect.runFork(program)\n\nsetTimeout(() => {\n  Effect.runFork(Fiber.interrupt(fiber))\n}, 500)'
        }
      ],
      tags: [
        "Running Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24358,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24358"
    },
    {
      id: "effect.runCallback",
      name: "runCallback",
      module: "effect",
      package: "effect",
      signature: "<A, E>(effect: Effect<A, E, never>, options?: RunCallbackOptions<A, E>) => Cancel<A, E>",
      description: "Executes an effect asynchronously and handles the result using a callback.",
      documentation: "Executes an effect asynchronously and handles the result using a callback.\n\n**Details**\n\nThis function runs an effect asynchronously and passes the result (`Exit`) to\na specified callback. The callback is invoked with the outcome of the effect:\n- On success, the callback receives the successful result.\n- On failure, the callback receives the failure information.\n\n**When to Use**\n\nThis function is effectful and should only be invoked at the edges of your\nprogram.",
      examples: [],
      tags: [
        "Running Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24377,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24377"
    },
    {
      id: "effect.runPromise",
      name: "runPromise",
      module: "effect",
      package: "effect",
      signature: "<A, E>(effect: Effect<A, E, never>, options?: { readonly signal?: AbortSignal; }) => Promise<A>",
      description: "Executes an effect and returns the result as a `Promise`.",
      documentation: 'Executes an effect and returns the result as a `Promise`.\n\n**Details**\n\nThis function runs an effect and converts its result into a `Promise`. If the\neffect succeeds, the `Promise` will resolve with the successful result. If\nthe effect fails, the `Promise` will reject with an error, which includes the\nfailure details of the effect.\n\nThe optional `options` parameter allows you to pass an `AbortSignal` for\ncancellation, enabling more fine-grained control over asynchronous tasks.\n\n**When to Use**\n\nUse this function when you need to execute an effect and work with its result\nin a promise-based system, such as when integrating with third-party\nlibraries that expect `Promise` results.\n\n**Example** (Running a Successful Effect as a Promise)\n\n```ts\nimport { Effect } from "effect"\n\nEffect.runPromise(Effect.succeed(1)).then(console.log)\n// Output: 1\n```\n\n**Example** (Handling a Failing Effect as a Rejected Promise)\n\n```ts\nimport { Effect } from "effect"\n\nEffect.runPromise(Effect.fail("my error")).catch(console.error)\n// Output:\n// (FiberFailure) Error: my error\n```',
      examples: [
        {
          title: "Running a Successful Effect as a Promise",
          code: 'import { Effect } from "effect"\n\nEffect.runPromise(Effect.succeed(1)).then(console.log)\n// Output: 1'
        },
        {
          title: "Handling a Failing Effect as a Rejected Promise",
          code: 'import { Effect } from "effect"\n\nEffect.runPromise(Effect.fail("my error")).catch(console.error)\n// Output:\n// (FiberFailure) Error: my error'
        }
      ],
      tags: [
        "Running Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24422,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24422"
    },
    {
      id: "effect.runPromiseExit",
      name: "runPromiseExit",
      module: "effect",
      package: "effect",
      signature: "<A, E>(effect: Effect<A, E, never>, options?: { readonly signal?: AbortSignal; }) => Promise<Exit<A, E>>",
      description: "Runs an effect and returns a `Promise` that resolves to an `Exit`,\nrepresenting the outcome.",
      documentation: 'Runs an effect and returns a `Promise` that resolves to an `Exit`,\nrepresenting the outcome.\n\n**Details**\n\nThis function executes an effect and resolves to an `Exit` object. The `Exit`\ntype provides detailed information about the result of the effect:\n- If the effect succeeds, the `Exit` will be of type `Success` and include\n  the value produced by the effect.\n- If the effect fails, the `Exit` will be of type `Failure` and contain a\n  `Cause` object, detailing the failure.\n\nUsing this function allows you to examine both successful results and failure\ncases in a unified way, while still leveraging `Promise` for handling the\nasynchronous behavior of the effect.\n\n**When to Use**\n\nUse this function when you need to understand the outcome of an effect,\nwhether it succeeded or failed, and want to work with this result using\n`Promise` syntax. This is particularly useful when integrating with systems\nthat rely on promises but need more detailed error handling than a simple\nrejection.\n\n**Example** (Handling Results as Exit)\n\n```ts\nimport { Effect } from "effect"\n\n// Execute a successful effect and get the Exit result as a Promise\nEffect.runPromiseExit(Effect.succeed(1)).then(console.log)\n// Output:\n// {\n//   _id: "Exit",\n//   _tag: "Success",\n//   value: 1\n// }\n\n// Execute a failing effect and get the Exit result as a Promise\nEffect.runPromiseExit(Effect.fail("my error")).then(console.log)\n// Output:\n// {\n//   _id: "Exit",\n//   _tag: "Failure",\n//   cause: {\n//     _id: "Cause",\n//     _tag: "Fail",\n//     failure: "my error"\n//   }\n// }\n```',
      examples: [
        {
          title: "Handling Results as Exit",
          code: 'import { Effect } from "effect"\n\n// Execute a successful effect and get the Exit result as a Promise\nEffect.runPromiseExit(Effect.succeed(1)).then(console.log)\n// Output:\n// {\n//   _id: "Exit",\n//   _tag: "Success",\n//   value: 1\n// }\n\n// Execute a failing effect and get the Exit result as a Promise\nEffect.runPromiseExit(Effect.fail("my error")).then(console.log)\n// Output:\n// {\n//   _id: "Exit",\n//   _tag: "Failure",\n//   cause: {\n//     _id: "Cause",\n//     _tag: "Fail",\n//     failure: "my error"\n//   }\n// }'
        }
      ],
      tags: [
        "Running Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24481,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24481"
    },
    {
      id: "effect.runSync",
      name: "runSync",
      module: "effect",
      package: "effect",
      signature: "<A, E>(effect: Effect<A, E, never>) => A",
      description: "/\n * Executes an effect synchronously, running it immediately and returning the\n * result.\n *\n *",
      documentation: '/**\n * Executes an effect synchronously, running it immediately and returning the\n * result.\n *\n * **Details**\n *\n * This function evaluates the provided effect synchronously, returning its\n * result directly. It is ideal for effects that do not fail or include\n * asynchronous operations. If the effect does fail or involves async tasks, it\n * will throw an error. Execution stops at the point of failure or asynchronous\n * operation, making it unsuitable for effects that require asynchronous\n * handling.\n *\n * **Important**: Attempting to run effects that involve asynchronous operations\n * or failures will result in exceptions being thrown, so use this function with\n * care for purely synchronous and error-free effects.\n *\n * **When to Use**\n *\n * Use this function when:\n * - You are sure that the effect will not fail or involve asynchronous\n *   operations.\n * - You need a direct, synchronous result from the effect.\n * - You are working within a context where asynchronous effects are not\n *   allowed.\n *\n * Avoid using this function for effects that can fail or require asynchronous\n * handling. For such cases, consider using {@link runPromise}or\n * {@link runSyncExit}.\n *\n * **Example** (Synchronous Logging)\n *\n * ```ts\n * import { Effect } from "effect"\n *\n * const program = Effect.sync(() => {\n *   console.log("Hello, World!")\n *   return 1\n * })\n *\n * const result = Effect.runSync(program)\n * // Output: Hello, World!\n *\n * console.log(result)\n * // Output: 1\n * ```\n *\n * **Example** (Incorrect Usage with Failing or Async Effects)\n *\n * ```ts\n * import { Effect } from "effect"\n *\n * try {\n *   // Attempt to run an effect that fails\n *   Effect.runSync(Effect.fail("my error"))\n * } catch (e) {\n *   console.error(e)\n * }\n * // Output:\n * // (FiberFailure) Error: my error\n *\n * try {\n *   // Attempt to run an effect that involves async work\n *   Effect.runSync(Effect.promise(() => Promise.resolve(1)))\n * } catch (e) {\n *   console.error(e)\n * }\n * // Output:\n * // (FiberFailure) AsyncFiberException: Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect } from "effect"\n *\n * const program = Effect.sync(() => {\n *   console.log("Hello, World!")\n *   return 1\n * })\n *\n * const result = Effect.runSync(program)\n * // Output: Hello, World!\n *\n * console.log(result)\n * // Output: 1\n *'
        },
        {
          code: '* import { Effect } from "effect"\n *\n * try {\n *   // Attempt to run an effect that fails\n *   Effect.runSync(Effect.fail("my error"))\n * } catch (e) {\n *   console.error(e)\n * }\n * // Output:\n * // (FiberFailure) Error: my error\n *\n * try {\n *   // Attempt to run an effect that involves async work\n *   Effect.runSync(Effect.promise(() => Promise.resolve(1)))\n * } catch (e) {\n *   console.error(e)\n * }\n * // Output:\n * // (FiberFailure) AsyncFiberException: Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work\n *'
        }
      ],
      tags: [
        "Running Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24561,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24561"
    },
    {
      id: "effect.runSyncExit",
      name: "runSyncExit",
      module: "effect",
      package: "effect",
      signature: "<A, E>(effect: Effect<A, E, never>) => Exit<A, E>",
      description: "Runs an effect synchronously and returns the result as an `Exit` type.",
      documentation: 'Runs an effect synchronously and returns the result as an `Exit` type.\n\n**Details**\n\nThis function executes the provided effect synchronously and returns an `Exit`\ntype that encapsulates the outcome of the effect:\n- If the effect succeeds, the result is wrapped in a `Success`.\n- If the effect fails, it returns a `Failure` containing a `Cause` that explains\n  the failure.\n\nIf the effect involves asynchronous operations, this function will return a `Failure`\nwith a `Die` cause, indicating that it cannot resolve the effect synchronously.\nThis makes the function suitable for use only with effects that are synchronous\nin nature.\n\n**When to Use**\n\nUse this function when:\n- You want to handle both success and failure outcomes in a structured way using the `Exit` type.\n- You are working with effects that are purely synchronous and do not involve asynchronous operations.\n- You need to debug or inspect failures, including their causes, in a detailed manner.\n\nAvoid using this function for effects that involve asynchronous operations, as it will fail with a `Die` cause.\n\n**Example** (Handling Results as Exit)\n\n```ts\nimport { Effect } from "effect"\n\nconsole.log(Effect.runSyncExit(Effect.succeed(1)))\n// Output:\n// {\n//   _id: "Exit",\n//   _tag: "Success",\n//   value: 1\n// }\n\nconsole.log(Effect.runSyncExit(Effect.fail("my error")))\n// Output:\n// {\n//   _id: "Exit",\n//   _tag: "Failure",\n//   cause: {\n//     _id: "Cause",\n//     _tag: "Fail",\n//     failure: "my error"\n//   }\n// }\n```\n\n**Example** (Asynchronous Operation Resulting in Die)\n\n```ts\nimport { Effect } from "effect"\n\nconsole.log(Effect.runSyncExit(Effect.promise(() => Promise.resolve(1))))\n// Output:\n// {\n//   _id: \'Exit\',\n//   _tag: \'Failure\',\n//   cause: {\n//     _id: \'Cause\',\n//     _tag: \'Die\',\n//     defect: [Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work] {\n//       fiber: [FiberRuntime],\n//       _tag: \'AsyncFiberException\',\n//       name: \'AsyncFiberException\'\n//     }\n//   }\n// }\n```',
      examples: [
        {
          title: "Handling Results as Exit",
          code: 'import { Effect } from "effect"\n\nconsole.log(Effect.runSyncExit(Effect.succeed(1)))\n// Output:\n// {\n//   _id: "Exit",\n//   _tag: "Success",\n//   value: 1\n// }\n\nconsole.log(Effect.runSyncExit(Effect.fail("my error")))\n// Output:\n// {\n//   _id: "Exit",\n//   _tag: "Failure",\n//   cause: {\n//     _id: "Cause",\n//     _tag: "Fail",\n//     failure: "my error"\n//   }\n// }'
        },
        {
          title: "Asynchronous Operation Resulting in Die",
          code: `import { Effect } from "effect"

console.log(Effect.runSyncExit(Effect.promise(() => Promise.resolve(1))))
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Die',
//     defect: [Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work] {
//       fiber: [FiberRuntime],
//       _tag: 'AsyncFiberException',
//       name: 'AsyncFiberException'
//     }
//   }
// }`
        }
      ],
      tags: [
        "Running Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24638,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24638"
    },
    {
      id: "effect.validate",
      name: "validate",
      module: "effect",
      package: "effect",
      signature: '{ <B, E1, R1>(that: Effect<B, E1, R1>, options?: { readonly concurrent?: boolean; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): <A, E, R>(self: Effect<A, E, R>) => Effect<[A, B], E1 | E, R1 | R>; <A, E, R, B, E1, R1>(self: Effect<A, E, R>, that: Effect<B, E1, R1>, options?: { readonly concurrent?: boolean; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): Effect<[A, B], E | E1, R | R1>; }',
      description: "Combines multiple effects and accumulates both successes and failures.",
      documentation: "Combines multiple effects and accumulates both successes and failures.\n\n**Details**\n\nThis function allows you to combine multiple effects, continuing through all\neffects even if some of them fail. Unlike other functions that stop execution\nupon encountering an error, this function collects all errors into a `Cause`.\nThe final result includes all successes and the accumulated failures.\n\nBy default, effects are executed sequentially, but you can control\nconcurrency and batching behavior using the `options` parameter. This\nprovides flexibility in scenarios where you want to maximize performance or\nensure specific ordering.\n\n**Example**\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Console.log(\"task1\").pipe(Effect.as(1))\nconst task2 = Effect.fail(\"Oh uh!\").pipe(Effect.as(2))\nconst task3 = Console.log(\"task2\").pipe(Effect.as(3))\nconst task4 = Effect.fail(\"Oh no!\").pipe(Effect.as(4))\n\nconst program = task1.pipe(\n  Effect.validate(task2),\n  Effect.validate(task3),\n  Effect.validate(task4)\n)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// task1\n// task2\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Sequential',\n//     left: { _id: 'Cause', _tag: 'Fail', failure: 'Oh uh!' },\n//     right: { _id: 'Cause', _tag: 'Fail', failure: 'Oh no!' }\n//   }\n// }\n```",
      examples: [
        {
          code: `import { Effect, Console } from "effect"

const task1 = Console.log("task1").pipe(Effect.as(1))
const task2 = Effect.fail("Oh uh!").pipe(Effect.as(2))
const task3 = Console.log("task2").pipe(Effect.as(3))
const task4 = Effect.fail("Oh no!").pipe(Effect.as(4))

const program = task1.pipe(
  Effect.validate(task2),
  Effect.validate(task3),
  Effect.validate(task4)
)

Effect.runPromiseExit(program).then(console.log)
// Output:
// task1
// task2
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Sequential',
//     left: { _id: 'Cause', _tag: 'Fail', failure: 'Oh uh!' },
//     right: { _id: 'Cause', _tag: 'Fail', failure: 'Oh no!' }
//   }
// }`
        }
      ],
      tags: [
        "Error Accumulation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24691,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24691"
    },
    {
      id: "effect.validateWith",
      name: "validateWith",
      module: "effect",
      package: "effect",
      signature: '{ <B, E1, R1, A, C>(that: Effect<B, E1, R1>, f: (a: A, b: B) => C, options?: { readonly concurrent?: boolean; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): <E, R>(self: Effect<A, E, R>) => Effect<C, E1 | E, R1 | R>; <A, E, R, B, E1, R1, C>(self: Effect<A, E, R>, that: Effect<B, E1, R1>, f: (a: A, b: B) => C, options?: { readonly concurrent?: boolean; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): Effect<C, E | E1, R | R1>; }',
      description: "Sequentially combines two effects using a specified combiner function while\naccumulating errors.",
      documentation: "Sequentially combines two effects using a specified combiner function while\naccumulating errors.\n\n**Details**\n\nThis function combines two effects, `self` and `that`, into a single effect\nby applying the provided combiner function to their results. If both effects\nsucceed, the combiner function is applied to their results to produce the\nfinal value. If either effect fails, the failures are accumulated into a\ncombined `Cause`.\n\nBy default, effects are executed sequentially. However, the execution mode\ncan be controlled using the `options` parameter to enable concurrency,\nbatching, or customized finalizer behavior.",
      examples: [],
      tags: [
        "Error Accumulation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24826,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24826"
    },
    {
      id: "effect.zip",
      name: "zip",
      module: "effect",
      package: "effect",
      signature: '{ <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): <A, E, R>(self: Effect<A, E, R>) => Effect<[A, A2], E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): Effect<[A, A2], E | E2, R | R2>; }',
      description: "Combines two effects into a single effect, producing a tuple of their\nresults.",
      documentation: 'Combines two effects into a single effect, producing a tuple of their\nresults.\n\n**Details**\n\nThis function combines two effects, `self` and `that`, into one. It executes\nthe first effect (`self`) and then the second effect (`that`), collecting\ntheir results into a tuple. Both effects must succeed for the resulting\neffect to succeed. If either effect fails, the entire operation fails.\n\nBy default, the effects are executed sequentially. If the `concurrent` option\nis set to `true`, the effects will run concurrently, potentially improving\nperformance for independent operations.\n\n**Example** (Combining Two Effects Sequentially)\n\n```ts\nimport { Effect } from "effect"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Effect.log("task1 done"))\n)\nconst task2 = Effect.succeed("hello").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Effect.log("task2 done"))\n)\n\n// Combine the two effects together\n//\n//      \u250C\u2500\u2500\u2500 Effect<[number, string], never, never>\n//      \u25BC\nconst program = Effect.zip(task1, task2)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message="task1 done"\n// timestamp=... level=INFO fiber=#0 message="task2 done"\n// [ 1, \'hello\' ]\n```\n\n**Example** (Combining Two Effects Concurrently)\n\n```ts\nimport { Effect } from "effect"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Effect.log("task1 done"))\n)\nconst task2 = Effect.succeed("hello").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Effect.log("task2 done"))\n)\n\n// Run both effects concurrently using the concurrent option\nconst program = Effect.zip(task1, task2, { concurrent: true })\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message="task2 done"\n// timestamp=... level=INFO fiber=#0 message="task1 done"\n// [ 1, \'hello\' ]\n```',
      examples: [
        {
          title: "Combining Two Effects Sequentially",
          code: `import { Effect } from "effect"

const task1 = Effect.succeed(1).pipe(
  Effect.delay("200 millis"),
  Effect.tap(Effect.log("task1 done"))
)
const task2 = Effect.succeed("hello").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Effect.log("task2 done"))
)

// Combine the two effects together
//
//      \u250C\u2500\u2500\u2500 Effect<[number, string], never, never>
//      \u25BC
const program = Effect.zip(task1, task2)

Effect.runPromise(program).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#0 message="task1 done"
// timestamp=... level=INFO fiber=#0 message="task2 done"
// [ 1, 'hello' ]`
        },
        {
          title: "Combining Two Effects Concurrently",
          code: `import { Effect } from "effect"

const task1 = Effect.succeed(1).pipe(
  Effect.delay("200 millis"),
  Effect.tap(Effect.log("task1 done"))
)
const task2 = Effect.succeed("hello").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Effect.log("task2 done"))
)

// Run both effects concurrently using the concurrent option
const program = Effect.zip(task1, task2, { concurrent: true })

Effect.runPromise(program).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#0 message="task2 done"
// timestamp=... level=INFO fiber=#0 message="task1 done"
// [ 1, 'hello' ]`
        }
      ],
      tags: [
        "Zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24949,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24949"
    },
    {
      id: "effect.zipLeft",
      name: "zipLeft",
      module: "effect",
      package: "effect",
      signature: '{ <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): Effect<A, E | E2, R | R2>; }',
      description: "Executes two effects sequentially, returning the result of the first effect\nand ignoring the result of the second.",
      documentation: 'Executes two effects sequentially, returning the result of the first effect\nand ignoring the result of the second.\n\n**Details**\n\nThis function allows you to run two effects in sequence, where the result of\nthe first effect is preserved, and the result of the second effect is\ndiscarded. By default, the two effects are executed sequentially. If you need\nthem to run concurrently, you can pass the `{ concurrent: true }` option.\n\nThe second effect will always be executed, even though its result is ignored.\nThis makes it useful for cases where you want to execute an effect for its\nside effects while keeping the result of another effect.\n\n**When to Use**\n\nUse this function when you are only interested in the result of the first\neffect but still need to run the second effect for its side effects, such as\nlogging or performing a cleanup action.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Effect.log("task1 done"))\n)\nconst task2 = Effect.succeed("hello").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Effect.log("task2 done"))\n)\n\nconst program = Effect.zipLeft(task1, task2)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message="task1 done"\n// timestamp=... level=INFO fiber=#0 message="task2 done"\n// 1\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Effect.log("task1 done"))\n)\nconst task2 = Effect.succeed("hello").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Effect.log("task2 done"))\n)\n\nconst program = Effect.zipLeft(task1, task2)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message="task1 done"\n// timestamp=... level=INFO fiber=#0 message="task2 done"\n// 1'
        }
      ],
      tags: [
        "Zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25157,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25157"
    },
    {
      id: "effect.zipRight",
      name: "zipRight",
      module: "effect",
      package: "effect",
      signature: '{ <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): Effect<A2, E | E2, R | R2>; }',
      description: "Executes two effects sequentially, returning the result of the second effect\nwhile ignoring the result of the first.",
      documentation: 'Executes two effects sequentially, returning the result of the second effect\nwhile ignoring the result of the first.\n\n**Details**\n\nThis function allows you to run two effects in sequence, keeping the result\nof the second effect and discarding the result of the first. By default, the\ntwo effects are executed sequentially. If you need them to run concurrently,\nyou can pass the `{ concurrent: true }` option.\n\nThe first effect will always be executed, even though its result is ignored.\nThis makes it useful for scenarios where the first effect is needed for its\nside effects, but only the result of the second effect is important.\n\n**When to Use**\n\nUse this function when you are only interested in the result of the second\neffect but still need to run the first effect for its side effects, such as\ninitialization or setup tasks.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Effect.log("task1 done"))\n)\nconst task2 = Effect.succeed("hello").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Effect.log("task2 done"))\n)\n\nconst program = Effect.zipRight(task1, task2)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message="task1 done"\n// timestamp=... level=INFO fiber=#0 message="task2 done"\n// hello\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Effect.log("task1 done"))\n)\nconst task2 = Effect.succeed("hello").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Effect.log("task2 done"))\n)\n\nconst program = Effect.zipRight(task1, task2)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message="task1 done"\n// timestamp=... level=INFO fiber=#0 message="task2 done"\n// hello'
        }
      ],
      tags: [
        "Zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25319,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25319"
    },
    {
      id: "effect.zipWith",
      name: "zipWith",
      module: "effect",
      package: "effect",
      signature: '{ <A2, E2, R2, A, B>(that: Effect<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): <E, R>(self: Effect<A, E, R>) => Effect<B, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, B>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): Effect<B, E | E2, R | R2>; }',
      description: "/\n * Combines two effects sequentially and applies a function to their results to\n * produce a single value.\n *\n *",
      documentation: '/**\n * Combines two effects sequentially and applies a function to their results to\n * produce a single value.\n *\n * **Details**\n *\n * This function runs two effects in sequence (or concurrently, if the `{\n * concurrent: true }` option is provided) and combines their results using a\n * provided function. Unlike {@link zip}, which returns a tuple of the results,\n * this function processes the results with a custom function to produce a\n * single output.\n *\n * **Example** (Combining Effects with a Custom Function)\n *\n * ```ts\n * import { Effect } from "effect"\n *\n * const task1 = Effect.succeed(1).pipe(\n *   Effect.delay("200 millis"),\n *   Effect.tap(Effect.log("task1 done"))\n * )\n * const task2 = Effect.succeed("hello").pipe(\n *   Effect.delay("100 millis"),\n *   Effect.tap(Effect.log("task2 done"))\n * )\n *\n * const task3 = Effect.zipWith(\n *   task1,\n *   task2,\n *   // Combines results into a single value\n *   (number, string) => number + string.length\n * )\n *\n * Effect.runPromise(task3).then(console.log)\n * // Output:\n * // timestamp=... level=INFO fiber=#3 message="task1 done"\n * // timestamp=... level=INFO fiber=#2 message="task2 done"\n * // 6\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect } from "effect"\n *\n * const task1 = Effect.succeed(1).pipe(\n *   Effect.delay("200 millis"),\n *   Effect.tap(Effect.log("task1 done"))\n * )\n * const task2 = Effect.succeed("hello").pipe(\n *   Effect.delay("100 millis"),\n *   Effect.tap(Effect.log("task2 done"))\n * )\n *\n * const task3 = Effect.zipWith(\n *   task1,\n *   task2,\n *   // Combines results into a single value\n *   (number, string) => number + string.length\n * )\n *\n * Effect.runPromise(task3).then(console.log)\n * // Output:\n * // timestamp=... level=INFO fiber=#3 message="task1 done"\n * // timestamp=... level=INFO fiber=#2 message="task2 done"\n * // 6\n *'
        }
      ],
      tags: [
        "Zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25474,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25474"
    },
    {
      id: "effect.ap",
      name: "ap",
      module: "effect",
      package: "effect",
      signature: "{ <A, E2, R2>(that: Effect<A, E2, R2>): <B, R, E>(self: Effect<(a: A) => B, E, R>) => Effect<B, E2 | E, R2 | R>; <A, B, E, R, E2, R2>(self: Effect<(a: A) => B, E, R>, that: Effect<A, E2, R2>): Effect<B, E | E2, R | R2>; }",
      description: "Applies the function produced by one effect to the value produced by another effect.",
      documentation: "Applies the function produced by one effect to the value produced by another effect.\n\n**Details**\n\nThis function combines two effects:\n- The first effect produces a function of type `(a: A) => B`.\n- The second effect produces a value of type `A`.\n\nOnce both effects complete successfully, the function is applied to the value, resulting in an effect that produces a value of type `B`.",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25585,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25585"
    },
    {
      id: "effect.blocked",
      name: "blocked",
      module: "effect",
      package: "effect",
      signature: "<A, E>(blockedRequests: RequestBlock, _continue: Effect<A, E, never>) => Blocked<A, E>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Requests & Batching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25619,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25619"
    },
    {
      id: "effect.runRequestBlock",
      name: "runRequestBlock",
      module: "effect",
      package: "effect",
      signature: "(blockedRequests: RequestBlock) => Effect<void, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Requests & Batching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25624,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25624"
    },
    {
      id: "effect.step",
      name: "step",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<Exit<A, E> | Blocked<A, E>, never, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Requests & Batching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25629,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25629"
    },
    {
      id: "effect.request",
      name: "request",
      module: "effect",
      package: "effect",
      signature: "{ <A extends Request.Request<any, any>, Ds extends RequestResolver<A> | Effect<RequestResolver<A>, any, any>>(dataSource: Ds): (self: A) => Effect<Request.Success<A>, Request.Error<A>, [Ds] extends [Effect<any, any, any>] ? Effect.Context<Ds> : never>; <Ds extends RequestResolver<A> | Effect<RequestResolver<A>, any, any>, A extends Request.Request<any, any>>(self: A, dataSource: Ds): Effect<Request.Success<A>, Request.Error<A>, [Ds] extends [Effect<any, any, any>] ? Effect.Context<Ds> : never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Requests & Batching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25634,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25634"
    },
    {
      id: "effect.cacheRequestResult",
      name: "cacheRequestResult",
      module: "effect",
      package: "effect",
      signature: "<A extends Request.Request<any, any>>(request: A, result: Request.Result<A>) => Effect<void, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Requests & Batching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25654,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25654"
    },
    {
      id: "effect.withRequestBatching",
      name: "withRequestBatching",
      module: "effect",
      package: "effect",
      signature: "{ (requestBatching: boolean): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, requestBatching: boolean): Effect<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Requests & Batching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25659,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25659"
    },
    {
      id: "effect.withRequestCaching",
      name: "withRequestCaching",
      module: "effect",
      package: "effect",
      signature: "{ (strategy: boolean): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, strategy: boolean): Effect<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Requests & Batching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25675,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25675"
    },
    {
      id: "effect.withRequestCache",
      name: "withRequestCache",
      module: "effect",
      package: "effect",
      signature: "{ (cache: Cache): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, cache: Cache): Effect<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Requests & Batching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25691,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25691"
    },
    {
      id: "effect.tracer",
      name: "tracer",
      module: "effect",
      package: "effect",
      signature: "Effect<Tracer, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25707,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25707"
    },
    {
      id: "effect.tracerWith",
      name: "tracerWith",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(f: (tracer: Tracer) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25712,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25712"
    },
    {
      id: "effect.withTracer",
      name: "withTracer",
      module: "effect",
      package: "effect",
      signature: "{ (value: Tracer): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, value: Tracer): Effect<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25717,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25717"
    },
    {
      id: "effect.withTracerScoped",
      name: "withTracerScoped",
      module: "effect",
      package: "effect",
      signature: "(value: Tracer) => Effect<void, never, Scope>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25733,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25733"
    },
    {
      id: "effect.withTracerEnabled",
      name: "withTracerEnabled",
      module: "effect",
      package: "effect",
      signature: "{ (enabled: boolean): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, enabled: boolean): Effect<A, E, R>; }",
      description: "Disable the tracer for the given Effect.",
      documentation: 'Disable the tracer for the given Effect.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nEffect.succeed(42).pipe(\n  Effect.withSpan("my-span"),\n  // the span will not be registered with the tracer\n  Effect.withTracerEnabled(false)\n)\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nEffect.succeed(42).pipe(\n  Effect.withSpan("my-span"),\n  // the span will not be registered with the tracer\n  Effect.withTracerEnabled(false)\n)'
        }
      ],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25752,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25752"
    },
    {
      id: "effect.withTracerTiming",
      name: "withTracerTiming",
      module: "effect",
      package: "effect",
      signature: "{ (enabled: boolean): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, enabled: boolean): Effect<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25796,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25796"
    },
    {
      id: "effect.annotateSpans",
      name: "annotateSpans",
      module: "effect",
      package: "effect",
      signature: "{ (key: string, value: unknown): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; (values: Record<string, unknown>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, key: string, value: unknown): Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, values: Record<string, unknown>): Effect<A, E, R>; }",
      description: "Adds annotations to each span in the effect for enhanced traceability.",
      documentation: "Adds annotations to each span in the effect for enhanced traceability.\n\n**Details**\n\nThis function lets you attach key-value annotations to all spans generated\nduring the execution of an effect. Annotations provide additional context,\nsuch as metadata or labels, which can help you understand and debug\nasynchronous workflows more effectively.\n\nYou can either pass a single key-value pair or a record of key-value pairs to\nannotate the spans. These annotations can then be visualized in tracing tools\nthat support span annotations.",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25825,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25825"
    },
    {
      id: "effect.annotateCurrentSpan",
      name: "annotateCurrentSpan",
      module: "effect",
      package: "effect",
      signature: "{ (key: string, value: unknown): Effect<void, never, never>; (values: Record<string, unknown>): Effect<void, never, never>; }",
      description: "/\n * Adds annotations to the currently active span for traceability.\n *\n *",
      documentation: "/**\n * Adds annotations to the currently active span for traceability.\n *\n * **Details**\n *\n * This function adds key-value annotations to the currently active span in the\n * effect's trace. These annotations help provide more context about the\n * operation being executed at a specific point in time. Unlike\n * {@link annotateSpans}, which applies to all spans in an effect, this function\n * focuses solely on the active span.\n *\n * You can either pass a single key-value pair or a record of key-value pairs to\n * annotate the span. These annotations are useful for adding metadata to\n * operations, especially in systems with detailed observability requirements.\n *\n *",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25917,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25917"
    },
    {
      id: "effect.currentSpan",
      name: "currentSpan",
      module: "effect",
      package: "effect",
      signature: "Effect<Span, NoSuchElementException, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25961,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25961"
    },
    {
      id: "effect.currentParentSpan",
      name: "currentParentSpan",
      module: "effect",
      package: "effect",
      signature: "Effect<AnySpan, NoSuchElementException, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25966,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25966"
    },
    {
      id: "effect.spanAnnotations",
      name: "spanAnnotations",
      module: "effect",
      package: "effect",
      signature: "Effect<HashMap<string, unknown>, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25971,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25971"
    },
    {
      id: "effect.spanLinks",
      name: "spanLinks",
      module: "effect",
      package: "effect",
      signature: "Effect<Chunk<SpanLink>, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25976,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25976"
    },
    {
      id: "effect.linkSpans",
      name: "linkSpans",
      module: "effect",
      package: "effect",
      signature: "{ (span: AnySpan, attributes?: Record<string, unknown>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, span: AnySpan, attributes?: Record<string, unknown>): Effect<A, E, R>; }",
      description: "For all spans in this effect, add a link with the provided span.",
      documentation: "For all spans in this effect, add a link with the provided span.",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25983,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25983"
    },
    {
      id: "effect.linkSpanCurrent",
      name: "linkSpanCurrent",
      module: "effect",
      package: "effect",
      signature: "{ (span: AnySpan, attributes?: Readonly<Record<string, unknown>>): Effect<void, never, never>; (links: readonly SpanLink[]): Effect<void, never, never>; }",
      description: "Add span links to the current span.",
      documentation: "Add span links to the current span.",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "3.14.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26005,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26005"
    },
    {
      id: "effect.makeSpan",
      name: "makeSpan",
      module: "effect",
      package: "effect",
      signature: "(name: string, options?: SpanOptions) => Effect<Span, never, never>",
      description: "Create a new span for tracing.",
      documentation: "Create a new span for tracing.",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26027,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26027"
    },
    {
      id: "effect.makeSpanScoped",
      name: "makeSpanScoped",
      module: "effect",
      package: "effect",
      signature: "(name: string, options?: SpanOptions) => Effect<Span, never, Scope>",
      description: "Create a new span for tracing, and automatically close it when the Scope\nfinalizes. The span is not added to the current span stack, so no child spans will be\ncreated for it.",
      documentation: "Create a new span for tracing, and automatically close it when the Scope\nfinalizes.\n\nThe span is not added to the current span stack, so no child spans will be\ncreated for it.",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26038,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26038"
    },
    {
      id: "effect.useSpan",
      name: "useSpan",
      module: "effect",
      package: "effect",
      signature: "{ <A, E, R>(name: string, evaluate: (span: Span) => Effect<A, E, R>): Effect<A, E, R>; <A, E, R>(name: string, options: SpanOptions, evaluate: (span: Span) => Effect<A, E, R>): Effect<A, E, R>; }",
      description: "Create a new span for tracing, and automatically close it when the effect\ncompletes. The span is not added to the current span stack, so no child spans will be\ncreated for it.",
      documentation: "Create a new span for tracing, and automatically close it when the effect\ncompletes.\n\nThe span is not added to the current span stack, so no child spans will be\ncreated for it.",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26049,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26049"
    },
    {
      id: "effect.withSpan",
      name: "withSpan",
      module: "effect",
      package: "effect",
      signature: "{ (name: string, options?: SpanOptions): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, ParentSpan>>; <A, E, R>(self: Effect<A, E, R>, name: string, options?: SpanOptions): Effect<A, E, Exclude<R, ParentSpan>>; }",
      description: "Wraps the effect with a new span for tracing.",
      documentation: "Wraps the effect with a new span for tracing.",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26079,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26079"
    },
    {
      id: "effect.functionWithSpan",
      name: "functionWithSpan",
      module: "effect",
      package: "effect",
      signature: "<Args extends Array<any>, Ret extends Effect<any, any, any>>(options: { readonly body: (...args: Args) => Ret; readonly options: FunctionWithSpanOptions | ((...args: Args) => FunctionWithSpanOptions); readonly captureStackTrace?: boolean; }) => (...args: Args) => Unify<Ret>",
      description: "Wraps a function that returns an effect with a new span for tracing.",
      documentation: 'Wraps a function that returns an effect with a new span for tracing.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst getTodo = Effect.functionWithSpan({\n  body: (id: number) => Effect.succeed(`Got todo ${id}!`),\n  options: (id) => ({\n    name: `getTodo-${id}`,\n    attributes: { id }\n  })\n})\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst getTodo = Effect.functionWithSpan({\n  body: (id: number) => Effect.succeed(`Got todo ${id}!`),\n  options: (id) => ({\n    name: `getTodo-${id}`,\n    attributes: { id }\n  })\n})'
        }
      ],
      tags: [
        "Tracing"
      ],
      since: "3.2.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26130,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26130"
    },
    {
      id: "effect.withSpanScoped",
      name: "withSpanScoped",
      module: "effect",
      package: "effect",
      signature: "{ (name: string, options?: SpanOptions): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Scope | Exclude<R, ParentSpan>>; <A, E, R>(self: Effect<A, E, R>, name: string, options?: SpanOptions): Effect<A, E, Scope | Exclude<R, ParentSpan>>; }",
      description: "Wraps the effect with a new span for tracing. The span is ended when the Scope is finalized.",
      documentation: "Wraps the effect with a new span for tracing.\n\nThe span is ended when the Scope is finalized.",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26143,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26143"
    },
    {
      id: "effect.withParentSpan",
      name: "withParentSpan",
      module: "effect",
      package: "effect",
      signature: "{ (span: AnySpan): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, ParentSpan>>; <A, E, R>(self: Effect<A, E, R>, span: AnySpan): Effect<A, E, Exclude<R, ParentSpan>>; }",
      description: "Adds the provided span to the current span stack.",
      documentation: "Adds the provided span to the current span stack.",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26169,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26169"
    },
    {
      id: "effect.fromNullable",
      name: "fromNullable",
      module: "effect",
      package: "effect",
      signature: "<A>(value: A) => Effect<NonNullable<A>, NoSuchElementException, never>",
      description: "Safely handles nullable values by creating an effect that fails for `null` or\n`undefined`.",
      documentation: "Safely handles nullable values by creating an effect that fails for `null` or\n`undefined`.\n\n**Details**\n\nThis function ensures that an input value is non-null and non-undefined\nbefore processing it. If the value is valid, the effect succeeds with the\nvalue. If the value is `null` or `undefined`, the effect fails with a\n`NoSuchElementException`. This is particularly useful for avoiding\nnull-related errors by clearly separating valid values from invalid ones in\neffectful computations.\n\nThe failure with `NoSuchElementException` allows you to explicitly handle\ncases where a value is expected but not provided, leading to safer and more\npredictable code.\n\n**When to Use**\n\nUse this function when working with values that may be `null` or `undefined`\nand you want to ensure that only non-null values are processed. It helps\nenforce null-safety and makes error handling more explicit.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, NoSuchElementException, never>\n//      \u25BC\nconst maybe1 = Effect.fromNullable(1)\n\nEffect.runPromiseExit(maybe1).then(console.log)\n// Output:\n// { _id: 'Exit', _tag: 'Success', value: 1 }\n\n//      \u250C\u2500\u2500\u2500 Effect<number, NoSuchElementException, never>\n//      \u25BC\nconst maybe2 = Effect.fromNullable(null as number | null)\n\nEffect.runPromiseExit(maybe2).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Fail',\n//     failure: { _tag: 'NoSuchElementException' }\n//   }\n// }\n```",
      examples: [
        {
          code: `import { Effect } from "effect"

//      \u250C\u2500\u2500\u2500 Effect<number, NoSuchElementException, never>
//      \u25BC
const maybe1 = Effect.fromNullable(1)

Effect.runPromiseExit(maybe1).then(console.log)
// Output:
// { _id: 'Exit', _tag: 'Success', value: 1 }

//      \u250C\u2500\u2500\u2500 Effect<number, NoSuchElementException, never>
//      \u25BC
const maybe2 = Effect.fromNullable(null as number | null)

Effect.runPromiseExit(maybe2).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: { _tag: 'NoSuchElementException' }
//   }
// }`
        }
      ],
      tags: [
        "Optional Wrapping & Unwrapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26241,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26241"
    },
    {
      id: "effect.optionFromOptional",
      name: "optionFromOptional",
      module: "effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<Option<A>, Exclude<E, NoSuchElementException>, R>",
      description: "Converts an effect that may fail with a `NoSuchElementException` into an\neffect that succeeds with an `Option`.",
      documentation: "Converts an effect that may fail with a `NoSuchElementException` into an\neffect that succeeds with an `Option`.\n\n**Details**\n\nThis function transforms an effect that might fail with\n`Cause.NoSuchElementException` into an effect that succeeds with an `Option`\ntype. If the original effect succeeds, its value is wrapped in `Option.some`.\nIf it fails specifically due to a `NoSuchElementException`, the failure is\nmapped to `Option.none`. Other types of failures remain unchanged and are\npassed through as they are.\n\nThis is useful when working with effects where you want to gracefully handle\nthe absence of a value while preserving other potential failures.\n\n**When to Use**\n\nUse this function when you need to handle missing values as `Option.none`\nrather than throwing or propagating errors like `NoSuchElementException`.\nIt\u2019s ideal for scenarios where you want to explicitly represent optionality\nin a type-safe way while retaining other failure information.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, NoSuchElementException, never>\n//      \u25BC\nconst maybe1 = Effect.fromNullable(1)\n\n//      \u250C\u2500\u2500\u2500 Effect<Option<number>, never, never>\n//      \u25BC\nconst option1 = Effect.optionFromOptional(maybe1)\n\nEffect.runPromise(option1).then(console.log)\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n\n//      \u250C\u2500\u2500\u2500 Effect<number, NoSuchElementException, never>\n//      \u25BC\nconst maybe2 = Effect.fromNullable(null as number | null)\n\n//      \u250C\u2500\u2500\u2500 Effect<Option<number>, never, never>\n//      \u25BC\nconst option2 = Effect.optionFromOptional(maybe2)\n\nEffect.runPromise(option2).then(console.log)\n// Output: { _tag: 'None' }\n```",
      examples: [
        {
          code: `import { Effect } from "effect"

//      \u250C\u2500\u2500\u2500 Effect<number, NoSuchElementException, never>
//      \u25BC
const maybe1 = Effect.fromNullable(1)

//      \u250C\u2500\u2500\u2500 Effect<Option<number>, never, never>
//      \u25BC
const option1 = Effect.optionFromOptional(maybe1)

Effect.runPromise(option1).then(console.log)
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

//      \u250C\u2500\u2500\u2500 Effect<number, NoSuchElementException, never>
//      \u25BC
const maybe2 = Effect.fromNullable(null as number | null)

//      \u250C\u2500\u2500\u2500 Effect<Option<number>, never, never>
//      \u25BC
const option2 = Effect.optionFromOptional(maybe2)

Effect.runPromise(option2).then(console.log)
// Output: { _tag: 'None' }`
        }
      ],
      tags: [
        "Optional Wrapping & Unwrapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26296,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26296"
    },
    {
      id: "effect.transposeOption",
      name: "transposeOption",
      module: "effect",
      package: "effect",
      signature: "<A = never, E = never, R = never>(self: Option<Effect<A, E, R>>) => Effect<Option<A>, E, R>",
      description: "Converts an `Option` of an `Effect` into an `Effect` of an `Option`.",
      documentation: "Converts an `Option` of an `Effect` into an `Effect` of an `Option`.\n\n**Details**\n\nThis function transforms an `Option<Effect<A, E, R>>` into an\n`Effect<Option<A>, E, R>`. If the `Option` is `None`, the resulting `Effect`\nwill immediately succeed with a `None` value. If the `Option` is `Some`, the\ninner `Effect` will be executed, and its result wrapped in a `Some`.\n\n**Example**\n\n```ts\nimport { Effect, Option } from \"effect\"\n\n//      \u250C\u2500\u2500\u2500 Option<Effect<number, never, never>>\n//      \u25BC\nconst maybe = Option.some(Effect.succeed(42))\n\n//      \u250C\u2500\u2500\u2500 Effect<Option<number>, never, never>\n//      \u25BC\nconst result = Effect.transposeOption(maybe)\n\nconsole.log(Effect.runSync(result))\n// Output: { _id: 'Option', _tag: 'Some', value: 42 }\n```",
      examples: [
        {
          code: `import { Effect, Option } from "effect"

//      \u250C\u2500\u2500\u2500 Option<Effect<number, never, never>>
//      \u25BC
const maybe = Option.some(Effect.succeed(42))

//      \u250C\u2500\u2500\u2500 Effect<Option<number>, never, never>
//      \u25BC
const result = Effect.transposeOption(maybe)

console.log(Effect.runSync(result))
// Output: { _id: 'Option', _tag: 'Some', value: 42 }`
        }
      ],
      tags: [
        "Optional Wrapping & Unwrapping"
      ],
      since: "3.13.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26327,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26327"
    },
    {
      id: "effect.transposeMapOption",
      name: "transposeMapOption",
      module: "effect",
      package: "effect",
      signature: "(<A, B, E = never, R = never>(f: (self: A) => Effect<B, E, R>) => (self: Option<A>) => Effect<Option<B>, E, R>) & (<A, B, E = never, R = never>(self: Option<A>, f: (self: A) => Effect<B, E, R>) => Effect<Option<B>, E, R>)",
      description: "Applies an `Effect` on an `Option` and transposes the result.",
      documentation: "Applies an `Effect` on an `Option` and transposes the result.\n\n**Details**\n\nIf the `Option` is `None`, the resulting `Effect` will immediately succeed with a `None` value.\nIf the `Option` is `Some`, the effectful operation will be executed on the inner value, and its result wrapped in a `Some`.",
      examples: [
        {
          code: `import { Effect, Option, pipe } from "effect"

//          \u250C\u2500\u2500\u2500 Effect<Option<number>, never, never>>
//          \u25BC
const noneResult = pipe(
  Option.none(),
  Effect.transposeMapOption(() => Effect.succeed(42)) // will not be executed
)
console.log(Effect.runSync(noneResult))
// Output: { _id: 'Option', _tag: 'None' }

//          \u250C\u2500\u2500\u2500 Effect<Option<number>, never, never>>
//          \u25BC
const someSuccessResult = pipe(
  Option.some(42),
  Effect.transposeMapOption((value) => Effect.succeed(value * 2))
)
console.log(Effect.runSync(someSuccessResult))
// Output: { _id: 'Option', _tag: 'Some', value: 84 }`
        }
      ],
      tags: [
        "Optional Wrapping & Unwrapping"
      ],
      since: "3.14.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26362,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26362"
    },
    {
      id: "effect.Tag",
      name: "Tag",
      module: "effect",
      package: "effect",
      signature: "<const Id extends string>(id: Id) => <Self, Type extends Tag.AllowedType>() => TagClass<Self, Id, Type> & (Type extends Record<PropertyKey, any> ? Tag.Proxy<Self, Type> : {}) & { use: <X>(body: (_: Type) => X) => [X] extends [Effect<infer A, infer E, infer R>] ? Effect<A, E, Self | R> : [X] extends [PromiseLike<infer A>] ? Effect<A, UnknownException, Self> : Effect<X, never, Self>; }",
      description: "Creates a unique tag for a dependency, embedding the service's methods as\nstatic properties.",
      documentation: 'Creates a unique tag for a dependency, embedding the service\'s methods as\nstatic properties.\n\n**Details**\n\nThis function allows you to define a `Tag` for a service or dependency in\nyour application. The `Tag` not only acts as an identifier but also provides\ndirect access to the service\'s methods via static properties. This makes it\neasier to access and use the service in your code without manually managing\ncontexts.\n\nIn the example below, the fields of the service (in this case, the `notify`\nmethod) are turned into static properties of the Notifications class, making\nit easier to access them.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nclass Notifications extends Effect.Tag("Notifications")<\n  Notifications,\n  { readonly notify: (message: string) => Effect.Effect<void> }\n>() {}\n\n// Create an effect that depends on the Notifications service\nconst action = Notifications.notify("Hello, world!")\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nclass Notifications extends Effect.Tag("Notifications")<\n  Notifications,\n  { readonly notify: (message: string) => Effect.Effect<void> }\n>() {}\n\n// Create an effect that depends on the Notifications service\nconst action = Notifications.notify("Hello, world!")'
        }
      ],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26430,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26430"
    },
    {
      id: "effect.Service",
      name: "Service",
      module: "effect",
      package: "effect",
      signature: '<Self = never>() => [Self] extends [never] ? "Missing `Self` generic - use `class Self extends Effect.Service<Self>()...`" : { <const Key extends string, const Make extends { readonly scoped: Effect<Service.AllowedType<Key, Make>, any, any> | ((...args: any) => Effect<Service.AllowedType<Key, Make>, any, any>); readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly \u0CA0_\u0CA0: never; } | { readonly effect: Effect<Service.AllowedType<Key, Make>, any, any> | ((...args: any) => Effect<Service.AllowedType<Key, Make>, any, any>); readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly \u0CA0_\u0CA0: never; } | { readonly sync: LazyArg<Service.AllowedType<Key, Make>>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly \u0CA0_\u0CA0: never; } | { readonly succeed: Service.AllowedType<Key, Make>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly \u0CA0_\u0CA0: never; }>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly scoped: Effect<Service.AllowedType<Key, Make>, any, any> | ((...args: any) => Effect<Service.AllowedType<Key, Make>, any, any>); readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly effect: Effect<Service.AllowedType<Key, Make>, any, any> | ((...args: any) => Effect<Service.AllowedType<Key, Make>, any, any>); readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly sync: LazyArg<Service.AllowedType<Key, Make>>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly succeed: Service.AllowedType<Key, Make>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; }',
      description: "Simplifies the creation and management of services in Effect by defining both\na `Tag` and a `Layer`.",
      documentation: 'Simplifies the creation and management of services in Effect by defining both\na `Tag` and a `Layer`.\n\n**Details**\n\nThis function allows you to streamline the creation of services by combining\nthe definition of a `Context.Tag` and a `Layer` in a single step. It supports\nvarious ways of providing the service implementation:\n- Using an `effect` to define the service dynamically.\n- Using `sync` or `succeed` to define the service statically.\n- Using `scoped` to create services with lifecycle management.\n\nIt also allows you to specify dependencies for the service, which will be\nprovided automatically when the service is used. Accessors can be optionally\ngenerated for the service, making it more convenient to use.\n\n**Example**\n\n```ts\nimport { Effect } from \'effect\';\n\nclass Prefix extends Effect.Service<Prefix>()("Prefix", {\n sync: () => ({ prefix: "PRE" })\n}) {}\n\nclass Logger extends Effect.Service<Logger>()("Logger", {\n accessors: true,\n effect: Effect.gen(function* () {\n   const { prefix } = yield* Prefix\n   return {\n     info: (message: string) =>\n       Effect.sync(() => {\n         console.log(`[${prefix}][${message}]`)\n       })\n   }\n }),\n dependencies: [Prefix.Default]\n}) {}\n```',
      examples: [
        {
          code: 'import { Effect } from \'effect\';\n\nclass Prefix extends Effect.Service<Prefix>()("Prefix", {\n sync: () => ({ prefix: "PRE" })\n}) {}\n\nclass Logger extends Effect.Service<Logger>()("Logger", {\n accessors: true,\n effect: Effect.gen(function* () {\n   const { prefix } = yield* Prefix\n   return {\n     info: (message: string) =>\n       Effect.sync(() => {\n         console.log(`[${prefix}][${message}]`)\n       })\n   }\n }),\n dependencies: [Prefix.Default]\n}) {}'
        }
      ],
      tags: [
        "Context"
      ],
      since: "3.9.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26479,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26479"
    },
    {
      id: "effect.fn",
      name: "fn",
      module: "effect",
      package: "effect",
      signature: "fn.Gen & fn.NonGen & ((name: string, options?: SpanOptions) => fn.Gen & fn.NonGen)",
      description: "The `Effect.fn` function allows you to create traced functions that return an\neffect. It provides two key features: - Stack traces with location details if an error occurs.\n- Automatic span creation for tracing when a span name is provided. If a span name is passed as the first argument, the function's execution is\ntracked using that name. If no name is provided, stack tracing still works,\nbut spans are not created. A function can be defined using either: - A generator function, allowing the use of `yield*` for effect composition.\n- A regular function that returns an `Effect`. `Effect.fn` automatically creates spans. The spans capture information about\nthe function execution, including metadata and error details. `Effect.fn` also acts as a pipe function, allowing you to create a pipeline\nafter the function definition using the effect returned by the generator\nfunction as the starting value of the pipeline.",
      documentation: "The `Effect.fn` function allows you to create traced functions that return an\neffect. It provides two key features:\n\n- **Stack traces with location details** if an error occurs.\n- **Automatic span creation** for tracing when a span name is provided.\n\nIf a span name is passed as the first argument, the function's execution is\ntracked using that name. If no name is provided, stack tracing still works,\nbut spans are not created.\n\nA function can be defined using either:\n\n- A generator function, allowing the use of `yield*` for effect composition.\n- A regular function that returns an `Effect`.\n\n**Example** (Creating a Traced Function with a Span Name)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst myfunc = Effect.fn(\"myspan\")(function* <N extends number>(n: N) {\n  yield* Effect.annotateCurrentSpan(\"n\", n) // Attach metadata to the span\n  console.log(`got: ${n}`)\n  yield* Effect.fail(new Error(\"Boom!\")) // Simulate failure\n})\n\nEffect.runFork(myfunc(100).pipe(Effect.catchAllCause(Effect.logError)))\n// Output:\n// got: 100\n// timestamp=... level=ERROR fiber=#0 cause=\"Error: Boom!\n//     at <anonymous> (/.../index.ts:6:22) <= Raise location\n//     at myspan (/.../index.ts:3:23)  <= Definition location\n//     at myspan (/.../index.ts:9:16)\" <= Call location\n```\n\n`Effect.fn` automatically creates spans. The spans capture information about\nthe function execution, including metadata and error details.\n\n**Example** (Exporting Spans to the Console)\n\n```ts skip-type-checking\nimport { Effect } from \"effect\"\nimport { NodeSdk } from \"@effect/opentelemetry\"\nimport {\n  ConsoleSpanExporter,\n  BatchSpanProcessor\n} from \"@opentelemetry/sdk-trace-base\"\n\nconst myfunc = Effect.fn(\"myspan\")(function* <N extends number>(n: N) {\n  yield* Effect.annotateCurrentSpan(\"n\", n)\n  console.log(`got: ${n}`)\n  yield* Effect.fail(new Error(\"Boom!\"))\n})\n\nconst program = myfunc(100)\n\nconst NodeSdkLive = NodeSdk.layer(() => ({\n  resource: { serviceName: \"example\" },\n  // Export span data to the console\n  spanProcessor: new BatchSpanProcessor(new ConsoleSpanExporter())\n}))\n\nEffect.runFork(program.pipe(Effect.provide(NodeSdkLive)))\n// Output:\n// got: 100\n// {\n//   resource: {\n//     attributes: {\n//       'service.name': 'example',\n//       'telemetry.sdk.language': 'nodejs',\n//       'telemetry.sdk.name': '@effect/opentelemetry',\n//       'telemetry.sdk.version': '1.30.1'\n//     }\n//   },\n//   instrumentationScope: { name: 'example', version: undefined, schemaUrl: undefined },\n//   traceId: '22801570119e57a6e2aacda3dec9665b',\n//   parentId: undefined,\n//   traceState: undefined,\n//   name: 'myspan',\n//   id: '7af530c1e01bc0cb',\n//   kind: 0,\n//   timestamp: 1741182277518402.2,\n//   duration: 4300.416,\n//   attributes: {\n//     n: 100,\n//     'code.stacktrace': 'at <anonymous> (/.../index.ts:8:23)\\n' +\n//       'at <anonymous> (/.../index.ts:14:17)'\n//   },\n//   status: { code: 2, message: 'Boom!' },\n//   events: [\n//     {\n//       name: 'exception',\n//       attributes: {\n//         'exception.type': 'Error',\n//         'exception.message': 'Boom!',\n//         'exception.stacktrace': 'Error: Boom!\\n' +\n//           '    at <anonymous> (/.../index.ts:11:22)\\n' +\n//           '    at myspan (/.../index.ts:8:23)\\n' +\n//           '    at myspan (/.../index.ts:14:17)'\n//       },\n//       time: [ 1741182277, 522702583 ],\n//       droppedAttributesCount: 0\n//     }\n//   ],\n//   links: []\n// }\n```\n\n`Effect.fn` also acts as a pipe function, allowing you to create a pipeline\nafter the function definition using the effect returned by the generator\nfunction as the starting value of the pipeline.\n\n**Example** (Creating a Traced Function with a Delay)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst myfunc = Effect.fn(\n  function* (n: number) {\n    console.log(`got: ${n}`)\n    yield* Effect.fail(new Error(\"Boom!\"))\n  },\n  // You can access both the created effect and the original arguments\n  (effect, n) => Effect.delay(effect, `${n / 100} seconds`)\n)\n\nEffect.runFork(myfunc(100).pipe(Effect.catchAllCause(Effect.logError)))\n// Output:\n// got: 100\n// timestamp=... level=ERROR fiber=#0 cause=\"Error: Boom! (<= after 1 second)\n```",
      examples: [
        {
          title: "Creating a Traced Function with a Span Name",
          code: 'import { Effect } from "effect"\n\nconst myfunc = Effect.fn("myspan")(function* <N extends number>(n: N) {\n  yield* Effect.annotateCurrentSpan("n", n) // Attach metadata to the span\n  console.log(`got: ${n}`)\n  yield* Effect.fail(new Error("Boom!")) // Simulate failure\n})\n\nEffect.runFork(myfunc(100).pipe(Effect.catchAllCause(Effect.logError)))\n// Output:\n// got: 100\n// timestamp=... level=ERROR fiber=#0 cause="Error: Boom!\n//     at <anonymous> (/.../index.ts:6:22) <= Raise location\n//     at myspan (/.../index.ts:3:23)  <= Definition location\n//     at myspan (/.../index.ts:9:16)" <= Call location'
        },
        {
          title: "Exporting Spans to the Console",
          code: `import { Effect } from "effect"
import { NodeSdk } from "@effect/opentelemetry"
import {
  ConsoleSpanExporter,
  BatchSpanProcessor
} from "@opentelemetry/sdk-trace-base"

const myfunc = Effect.fn("myspan")(function* <N extends number>(n: N) {
  yield* Effect.annotateCurrentSpan("n", n)
  console.log(\`got: \${n}\`)
  yield* Effect.fail(new Error("Boom!"))
})

const program = myfunc(100)

const NodeSdkLive = NodeSdk.layer(() => ({
  resource: { serviceName: "example" },
  // Export span data to the console
  spanProcessor: new BatchSpanProcessor(new ConsoleSpanExporter())
}))

Effect.runFork(program.pipe(Effect.provide(NodeSdkLive)))
// Output:
// got: 100
// {
//   resource: {
//     attributes: {
//       'service.name': 'example',
//       'telemetry.sdk.language': 'nodejs',
//       'telemetry.sdk.name': '@effect/opentelemetry',
//       'telemetry.sdk.version': '1.30.1'
//     }
//   },
//   instrumentationScope: { name: 'example', version: undefined, schemaUrl: undefined },
//   traceId: '22801570119e57a6e2aacda3dec9665b',
//   parentId: undefined,
//   traceState: undefined,
//   name: 'myspan',
//   id: '7af530c1e01bc0cb',
//   kind: 0,
//   timestamp: 1741182277518402.2,
//   duration: 4300.416,
//   attributes: {
//     n: 100,
//     'code.stacktrace': 'at <anonymous> (/.../index.ts:8:23)\\n' +
//       'at <anonymous> (/.../index.ts:14:17)'
//   },
//   status: { code: 2, message: 'Boom!' },
//   events: [
//     {
//       name: 'exception',
//       attributes: {
//         'exception.type': 'Error',
//         'exception.message': 'Boom!',
//         'exception.stacktrace': 'Error: Boom!\\n' +
//           '    at <anonymous> (/.../index.ts:11:22)\\n' +
//           '    at myspan (/.../index.ts:8:23)\\n' +
//           '    at myspan (/.../index.ts:14:17)'
//       },
//       time: [ 1741182277, 522702583 ],
//       droppedAttributesCount: 0
//     }
//   ],
//   links: []
// }`
        },
        {
          title: "Creating a Traced Function with a Delay",
          code: 'import { Effect } from "effect"\n\nconst myfunc = Effect.fn(\n  function* (n: number) {\n    console.log(`got: ${n}`)\n    yield* Effect.fail(new Error("Boom!"))\n  },\n  // You can access both the created effect and the original arguments\n  (effect, n) => Effect.delay(effect, `${n / 100} seconds`)\n)\n\nEffect.runFork(myfunc(100).pipe(Effect.catchAllCause(Effect.logError)))\n// Output:\n// got: 100\n// timestamp=... level=ERROR fiber=#0 cause="Error: Boom! (<= after 1 second)'
        }
      ],
      tags: [
        "Tracing"
      ],
      since: "3.11.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26934,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26934"
    },
    {
      id: "effect.fnUntraced",
      name: "fnUntraced",
      module: "effect",
      package: "effect",
      signature: "fn.Untraced",
      description: "/\n * Same as {@link fn}, but allows you to create a function that is not traced, for when performance is critical.\n *\n *",
      documentation: "/**\n * Same as {@link fn}, but allows you to create a function that is not traced, for when performance is critical.\n *\n *",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "3.12.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26943,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26943"
    },
    {
      id: "effect.ensureSuccessType",
      name: "ensureSuccessType",
      module: "effect",
      package: "effect",
      signature: "<A>() => <A2 extends A, E, R>(effect: Effect<A2, E, R>) => Effect<A2, E, R>",
      description: "A no-op type constraint that enforces the success channel of an Effect conforms to\nthe specified success type `A`.",
      documentation: "A no-op type constraint that enforces the success channel of an Effect conforms to\nthe specified success type `A`.",
      examples: [
        {
          code: 'import { Effect } from "effect"\n\n// Ensure that the program does not expose any unhandled errors.\nconst program = Effect.succeed(42).pipe(Effect.ensureSuccessType<number>())'
        }
      ],
      tags: [
        "Type constraints"
      ],
      since: "3.17.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26957,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26957"
    },
    {
      id: "effect.ensureErrorType",
      name: "ensureErrorType",
      module: "effect",
      package: "effect",
      signature: "<E>() => <A, E2 extends E, R>(effect: Effect<A, E2, R>) => Effect<A, E2, R>",
      description: "A no-op type constraint that enforces the error channel of an Effect conforms to\nthe specified error type `E`.",
      documentation: "A no-op type constraint that enforces the error channel of an Effect conforms to\nthe specified error type `E`.",
      examples: [
        {
          code: 'import { Effect } from "effect"\n\n// Ensure that the program does not expose any unhandled errors.\nconst program = Effect.succeed(42).pipe(Effect.ensureErrorType<never>())'
        }
      ],
      tags: [
        "Type constraints"
      ],
      since: "3.17.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26971,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26971"
    },
    {
      id: "effect.ensureRequirementsType",
      name: "ensureRequirementsType",
      module: "effect",
      package: "effect",
      signature: "<R>() => <A, E, R2 extends R>(effect: Effect<A, E, R2>) => Effect<A, E, R2>",
      description: "A no-op type constraint that enforces the requirements channel of an Effect conforms to\nthe specified requirements type `R`.",
      documentation: "A no-op type constraint that enforces the requirements channel of an Effect conforms to\nthe specified requirements type `R`.",
      examples: [
        {
          code: 'import { Effect } from "effect"\n\n// Ensure that the program does not have any requirements.\nconst program = Effect.succeed(42).pipe(Effect.ensureRequirementsType<never>())'
        }
      ],
      tags: [
        "Type constraints"
      ],
      since: "3.17.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26985,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26985"
    },
    {
      id: "Effect.EffectTypeId",
      name: "EffectTypeId",
      module: "Effect",
      package: "effect",
      signature: "typeof EffectTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 56,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L56"
    },
    {
      id: "Effect.isEffect",
      name: "isEffect",
      module: "Effect",
      package: "effect",
      signature: "(u: unknown) => u is Effect<unknown, unknown, unknown>",
      description: "Checks if a given value is an `Effect` value.",
      documentation: "Checks if a given value is an `Effect` value.\n\n**When to Use**\n\nThis function can be useful for checking the type of a value before\nattempting to operate on it as an `Effect` value. For example, you could use\n`Effect.isEffect` to check the type of a value before using it as an argument\nto a function that expects an `Effect` value.",
      examples: [],
      tags: [
        "Guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 241,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L241"
    },
    {
      id: "Effect.cachedWithTTL",
      name: "cachedWithTTL",
      module: "Effect",
      package: "effect",
      signature: "{ (timeToLive: DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<A, E, never>, never, R>; <A, E, R>(self: Effect<A, E, R>, timeToLive: DurationInput): Effect<Effect<A, E, never>, never, R>; }",
      description: 'Returns an effect that caches its result for a specified `Duration`,\nknown as "timeToLive" (TTL).',
      documentation: 'Returns an effect that caches its result for a specified `Duration`,\nknown as "timeToLive" (TTL).\n\n**Details**\n\nThis function is used to cache the result of an effect for a specified amount\nof time. This means that the first time the effect is evaluated, its result\nis computed and stored.\n\nIf the effect is evaluated again within the specified `timeToLive`, the\ncached result will be used, avoiding recomputation.\n\nAfter the specified duration has passed, the cache expires, and the effect\nwill be recomputed upon the next evaluation.\n\n**When to Use**\n\nUse this function when you have an effect that involves costly operations or\ncomputations, and you want to avoid repeating them within a short time frame.\n\nIt\'s ideal for scenarios where the result of an effect doesn\'t change\nfrequently and can be reused for a specified duration.\n\nBy caching the result, you can improve efficiency and reduce unnecessary\ncomputations, especially in performance-critical applications.\n\n**Example**\n\n```ts\nimport { Effect, Console } from "effect"\n\nlet i = 1\nconst expensiveTask = Effect.promise<string>(() => {\n  console.log("expensive task...")\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(`result ${i++}`)\n    }, 100)\n  })\n})\n\nconst program = Effect.gen(function* () {\n  const cached = yield* Effect.cachedWithTTL(expensiveTask, "150 millis")\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* Effect.sleep("100 millis")\n  yield* cached.pipe(Effect.andThen(Console.log))\n})\n\nEffect.runFork(program)\n// Output:\n// expensive task...\n// result 1\n// result 1\n// expensive task...\n// result 2\n```',
      examples: [
        {
          code: 'import { Effect, Console } from "effect"\n\nlet i = 1\nconst expensiveTask = Effect.promise<string>(() => {\n  console.log("expensive task...")\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(`result ${i++}`)\n    }, 100)\n  })\n})\n\nconst program = Effect.gen(function* () {\n  const cached = yield* Effect.cachedWithTTL(expensiveTask, "150 millis")\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* Effect.sleep("100 millis")\n  yield* cached.pipe(Effect.andThen(Console.log))\n})\n\nEffect.runFork(program)\n// Output:\n// expensive task...\n// result 1\n// result 1\n// expensive task...\n// result 2'
        }
      ],
      tags: [
        "Caching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 309,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L309"
    },
    {
      id: "Effect.cachedInvalidateWithTTL",
      name: "cachedInvalidateWithTTL",
      module: "Effect",
      package: "effect",
      signature: "{ (timeToLive: DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<[Effect<A, E, never>, Effect<void, never, never>], never, R>; <A, E, R>(self: Effect<A, E, R>, timeToLive: DurationInput): Effect<[Effect<A, E, never>, Effect<void, never, never>], never, R>; }",
      description: "/\n * Caches an effect's result for a specified duration and allows manual\n * invalidation before expiration.\n *\n *",
      documentation: '/**\n * Caches an effect\'s result for a specified duration and allows manual\n * invalidation before expiration.\n *\n * **Details**\n *\n * This function behaves similarly to {@link cachedWithTTL}by caching the\n * result of an effect for a specified period of time. However, it introduces an\n * additional feature: it provides an effect that allows you to manually\n * invalidate the cached result before it naturally expires.\n *\n * This gives you more control over the cache, allowing you to refresh the\n * result when needed, even if the original cache has not yet expired.\n *\n * Once the cache is invalidated, the next time the effect is evaluated, the\n * result will be recomputed, and the cache will be refreshed.\n *\n * **When to Use**\n *\n * Use this function when you have an effect whose result needs to be cached for\n * a certain period, but you also want the option to refresh the cache manually\n * before the expiration time.\n *\n * This is useful when you need to ensure that the cached data remains valid for\n * a certain period but still want to invalidate it if the underlying data\n * changes or if you want to force a recomputation.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Console } from "effect"\n *\n * let i = 1\n * const expensiveTask = Effect.promise<string>(() => {\n *   console.log("expensive task...")\n *   return new Promise((resolve) => {\n *     setTimeout(() => {\n *       resolve(`result ${i++}`)\n *     }, 100)\n *   })\n * })\n *\n * const program = Effect.gen(function* () {\n *   const [cached, invalidate] = yield* Effect.cachedInvalidateWithTTL(\n *     expensiveTask,\n *     "1 hour"\n *   )\n *   yield* cached.pipe(Effect.andThen(Console.log))\n *   yield* cached.pipe(Effect.andThen(Console.log))\n *   yield* invalidate\n *   yield* cached.pipe(Effect.andThen(Console.log))\n * })\n *\n * Effect.runFork(program)\n * // Output:\n * // expensive task...\n * // result 1\n * // result 1\n * // expensive task...\n * // result 2\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect, Console } from "effect"\n *\n * let i = 1\n * const expensiveTask = Effect.promise<string>(() => {\n *   console.log("expensive task...")\n *   return new Promise((resolve) => {\n *     setTimeout(() => {\n *       resolve(`result ${i++}`)\n *     }, 100)\n *   })\n * })\n *\n * const program = Effect.gen(function* () {\n *   const [cached, invalidate] = yield* Effect.cachedInvalidateWithTTL(\n *     expensiveTask,\n *     "1 hour"\n *   )\n *   yield* cached.pipe(Effect.andThen(Console.log))\n *   yield* cached.pipe(Effect.andThen(Console.log))\n *   yield* invalidate\n *   yield* cached.pipe(Effect.andThen(Console.log))\n * })\n *\n * Effect.runFork(program)\n * // Output:\n * // expensive task...\n * // result 1\n * // result 1\n * // expensive task...\n * // result 2\n *'
        }
      ],
      tags: [
        "Caching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 517,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L517"
    },
    {
      id: "Effect.cached",
      name: "cached",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<Effect<A, E, R>, never, never>",
      description: "Returns an effect that lazily computes a result and caches it for subsequent\nevaluations.",
      documentation: 'Returns an effect that lazily computes a result and caches it for subsequent\nevaluations.\n\n**Details**\n\nThis function wraps an effect and ensures that its result is computed only\nonce. Once the result is computed, it is cached, meaning that subsequent\nevaluations of the same effect will return the cached result without\nre-executing the logic.\n\n**When to Use**\n\nUse this function when you have an expensive or time-consuming operation that\nyou want to avoid repeating. The first evaluation will compute the result,\nand all following evaluations will immediately return the cached value,\nimproving performance and reducing unnecessary work.\n\n**Example**\n\n```ts\nimport { Effect, Console } from "effect"\n\nlet i = 1\nconst expensiveTask = Effect.promise<string>(() => {\n  console.log("expensive task...")\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(`result ${i++}`)\n    }, 100)\n  })\n})\n\nconst program = Effect.gen(function* () {\n  console.log("non-cached version:")\n  yield* expensiveTask.pipe(Effect.andThen(Console.log))\n  yield* expensiveTask.pipe(Effect.andThen(Console.log))\n  console.log("cached version:")\n  const cached = yield* Effect.cached(expensiveTask)\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* cached.pipe(Effect.andThen(Console.log))\n})\n\nEffect.runFork(program)\n// Output:\n// non-cached version:\n// expensive task...\n// result 1\n// expensive task...\n// result 2\n// cached version:\n// expensive task...\n// result 3\n// result 3\n```',
      examples: [
        {
          code: 'import { Effect, Console } from "effect"\n\nlet i = 1\nconst expensiveTask = Effect.promise<string>(() => {\n  console.log("expensive task...")\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(`result ${i++}`)\n    }, 100)\n  })\n})\n\nconst program = Effect.gen(function* () {\n  console.log("non-cached version:")\n  yield* expensiveTask.pipe(Effect.andThen(Console.log))\n  yield* expensiveTask.pipe(Effect.andThen(Console.log))\n  console.log("cached version:")\n  const cached = yield* Effect.cached(expensiveTask)\n  yield* cached.pipe(Effect.andThen(Console.log))\n  yield* cached.pipe(Effect.andThen(Console.log))\n})\n\nEffect.runFork(program)\n// Output:\n// non-cached version:\n// expensive task...\n// result 1\n// expensive task...\n// result 2\n// cached version:\n// expensive task...\n// result 3\n// result 3'
        }
      ],
      tags: [
        "Caching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 725,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L725"
    },
    {
      id: "Effect.cachedFunction",
      name: "cachedFunction",
      module: "Effect",
      package: "effect",
      signature: "<A, B, E, R>(f: (a: A) => Effect<B, E, R>, eq?: Equivalence<A>) => Effect<(a: A) => Effect<B, E, R>, never, never>",
      description: "Returns a memoized version of a function with effects, reusing results for\nthe same inputs.",
      documentation: 'Returns a memoized version of a function with effects, reusing results for\nthe same inputs.\n\n**Details**\n\nThis function creates a memoized version of a given function that performs an\neffect. Memoization ensures that once a result is computed for a specific\ninput, it is stored and reused for subsequent calls with the same input,\nreducing the need to recompute the result.\n\nThe function can optionally take an `Equivalence` parameter to\ndetermine how inputs are compared for caching purposes.\n\n**When to Use**\n\nUse this function when you have a function that performs an effect and you\nwant to avoid recomputing the result for the same input multiple times.\n\nIt\'s ideal for functions that produce deterministic results based on their\ninputs, and you want to improve performance by caching the output.\n\nThis is particularly useful in scenarios where the function involves\nexpensive calculations or operations that should be avoided after the first\nexecution with the same parameters.\n\n**Example**\n\n```ts\nimport { Effect, Random } from "effect"\n\nconst program = Effect.gen(function* () {\n  const randomNumber = (n: number) => Random.nextIntBetween(1, n)\n  console.log("non-memoized version:")\n  console.log(yield* randomNumber(10))\n  console.log(yield* randomNumber(10))\n\n  console.log("memoized version:")\n  const memoized = yield* Effect.cachedFunction(randomNumber)\n  console.log(yield* memoized(10))\n  console.log(yield* memoized(10))\n})\n\nEffect.runFork(program)\n// Example Output:\n// non-memoized version:\n// 2\n// 8\n// memoized version:\n// 5\n// 5\n```',
      examples: [
        {
          code: 'import { Effect, Random } from "effect"\n\nconst program = Effect.gen(function* () {\n  const randomNumber = (n: number) => Random.nextIntBetween(1, n)\n  console.log("non-memoized version:")\n  console.log(yield* randomNumber(10))\n  console.log(yield* randomNumber(10))\n\n  console.log("memoized version:")\n  const memoized = yield* Effect.cachedFunction(randomNumber)\n  console.log(yield* memoized(10))\n  console.log(yield* memoized(10))\n})\n\nEffect.runFork(program)\n// Example Output:\n// non-memoized version:\n// 2\n// 8\n// memoized version:\n// 5\n// 5'
        }
      ],
      tags: [
        "Caching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 782,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L782"
    },
    {
      id: "Effect.once",
      name: "once",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<Effect<void, E, R>, never, never>",
      description: "Returns an effect that executes only once, regardless of how many times it's\ncalled.",
      documentation: 'Returns an effect that executes only once, regardless of how many times it\'s\ncalled.\n\n**Details**\n\nThis function ensures that a specific effect is executed only a single time,\nno matter how many times it is invoked. The result of the effect will be\ncached, and subsequent calls to the effect will immediately return the cached\nresult without re-executing the original logic.\n\n**When to Use**\n\nUse this function when you need to perform a task only once, regardless of\nhow many times the effect is triggered. It\'s particularly useful when you\nhave initialization tasks, logging, or other one-time actions that should not\nbe repeated. This can help optimize performance and avoid redundant actions.\n\n**Example**\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst program = Effect.gen(function* () {\n  const task1 = Console.log("task1")\n  yield* Effect.repeatN(task1, 2)\n  const task2 = yield* Effect.once(Console.log("task2"))\n  yield* Effect.repeatN(task2, 2)\n})\n\nEffect.runFork(program)\n// Output:\n// task1\n// task1\n// task1\n// task2\n```',
      examples: [
        {
          code: 'import { Effect, Console } from "effect"\n\nconst program = Effect.gen(function* () {\n  const task1 = Console.log("task1")\n  yield* Effect.repeatN(task1, 2)\n  const task2 = yield* Effect.once(Console.log("task2"))\n  yield* Effect.repeatN(task2, 2)\n})\n\nEffect.runFork(program)\n// Output:\n// task1\n// task1\n// task1\n// task2'
        }
      ],
      tags: [
        "Caching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 824,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L824"
    },
    {
      id: "Effect.all",
      name: "all",
      module: "Effect",
      package: "effect",
      signature: '<const Arg extends Iterable<Effect<any, any, any>> | Record<string, Effect<any, any, any>>, O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard?: boolean | undefined; readonly mode?: "default" | "validate" | "either" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, O>>(arg: Arg, options?: O) => All.Return<Arg, O>',
      description: "Combines multiple effects into one, returning results based on the input\nstructure.",
      documentation: "Combines multiple effects into one, returning results based on the input\nstructure.\n\n**Details**\n\nUse this function when you need to run multiple effects and combine their\nresults into a single output. It supports tuples, iterables, structs, and\nrecords, making it flexible for different input types.\n\nFor instance, if the input is a tuple:\n\n```ts skip-type-checking\n//         \u250C\u2500\u2500\u2500 a tuple of effects\n//         \u25BC\nEffect.all([effect1, effect2, ...])\n```\n\nthe effects are executed sequentially, and the result is a new effect\ncontaining the results as a tuple. The results in the tuple match the order\nof the effects passed to `Effect.all`.\n\n**Concurrency**\n\nYou can control the execution order (e.g., sequential vs. concurrent) using\nthe `concurrency` option.\n\n**Short-Circuiting Behavior**\n\nThis function stops execution on the first error it encounters, this is\ncalled \"short-circuiting\". If any effect in the collection fails, the\nremaining effects will not run, and the error will be propagated. To change\nthis behavior, you can use the `mode` option, which allows all effects to run\nand collect results as `Either` or `Option`.\n\n**The `mode` option**\n\nThe `{ mode: \"either\" }` option changes the behavior of `Effect.all` to\nensure all effects run, even if some fail. Instead of stopping on the first\nfailure, this mode collects both successes and failures, returning an array\nof `Either` instances where each result is either a `Right` (success) or a\n`Left` (failure).\n\nSimilarly, the `{ mode: \"validate\" }` option uses `Option` to indicate\nsuccess or failure. Each effect returns `None` for success and `Some` with\nthe error for failure.\n\n**Example** (Combining Effects in Tuples)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst tupleOfEffects = [\n  Effect.succeed(42).pipe(Effect.tap(Console.log)),\n  Effect.succeed(\"Hello\").pipe(Effect.tap(Console.log))\n] as const\n\n//      \u250C\u2500\u2500\u2500 Effect<[number, string], never, never>\n//      \u25BC\nconst resultsAsTuple = Effect.all(tupleOfEffects)\n\nEffect.runPromise(resultsAsTuple).then(console.log)\n// Output:\n// 42\n// Hello\n// [ 42, 'Hello' ]\n```\n\n**Example** (Combining Effects in Iterables)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst iterableOfEffects: Iterable<Effect.Effect<number>> = [1, 2, 3].map(\n  (n) => Effect.succeed(n).pipe(Effect.tap(Console.log))\n)\n\n//      \u250C\u2500\u2500\u2500 Effect<number[], never, never>\n//      \u25BC\nconst resultsAsArray = Effect.all(iterableOfEffects)\n\nEffect.runPromise(resultsAsArray).then(console.log)\n// Output:\n// 1\n// 2\n// 3\n// [ 1, 2, 3 ]\n```\n\n**Example** (Combining Effects in Structs)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst structOfEffects = {\n  a: Effect.succeed(42).pipe(Effect.tap(Console.log)),\n  b: Effect.succeed(\"Hello\").pipe(Effect.tap(Console.log))\n}\n\n//      \u250C\u2500\u2500\u2500 Effect<{ a: number; b: string; }, never, never>\n//      \u25BC\nconst resultsAsStruct = Effect.all(structOfEffects)\n\nEffect.runPromise(resultsAsStruct).then(console.log)\n// Output:\n// 42\n// Hello\n// { a: 42, b: 'Hello' }\n```\n\n**Example** (Combining Effects in Records)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst recordOfEffects: Record<string, Effect.Effect<number>> = {\n  key1: Effect.succeed(1).pipe(Effect.tap(Console.log)),\n  key2: Effect.succeed(2).pipe(Effect.tap(Console.log))\n}\n\n//      \u250C\u2500\u2500\u2500 Effect<{ [x: string]: number; }, never, never>\n//      \u25BC\nconst resultsAsRecord = Effect.all(recordOfEffects)\n\nEffect.runPromise(resultsAsRecord).then(console.log)\n// Output:\n// 1\n// 2\n// { key1: 1, key2: 2 }\n```\n\n**Example** (Short-Circuiting Behavior)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst program = Effect.all([\n  Effect.succeed(\"Task1\").pipe(Effect.tap(Console.log)),\n  Effect.fail(\"Task2: Oh no!\").pipe(Effect.tap(Console.log)),\n  // Won't execute due to earlier failure\n  Effect.succeed(\"Task3\").pipe(Effect.tap(Console.log))\n])\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// Task1\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Task2: Oh no!' }\n// }\n```\n\n**Example** (Collecting Results with `mode: \"either\"`)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst effects = [\n  Effect.succeed(\"Task1\").pipe(Effect.tap(Console.log)),\n  Effect.fail(\"Task2: Oh no!\").pipe(Effect.tap(Console.log)),\n  Effect.succeed(\"Task3\").pipe(Effect.tap(Console.log))\n]\n\nconst program = Effect.all(effects, { mode: \"either\" })\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// Task1\n// Task3\n// {\n//   _id: 'Exit',\n//   _tag: 'Success',\n//   value: [\n//     { _id: 'Either', _tag: 'Right', right: 'Task1' },\n//     { _id: 'Either', _tag: 'Left', left: 'Task2: Oh no!' },\n//     { _id: 'Either', _tag: 'Right', right: 'Task3' }\n//   ]\n// }\n```\n\n**Example** (Collecting Results with `mode: \"validate\"`)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst effects = [\n  Effect.succeed(\"Task1\").pipe(Effect.tap(Console.log)),\n  Effect.fail(\"Task2: Oh no!\").pipe(Effect.tap(Console.log)),\n  Effect.succeed(\"Task3\").pipe(Effect.tap(Console.log))\n]\n\nconst program = Effect.all(effects, { mode: \"validate\" })\n\nEffect.runPromiseExit(program).then((result) => console.log(\"%o\", result))\n// Output:\n// Task1\n// Task3\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Fail',\n//     failure: [\n//       { _id: 'Option', _tag: 'None' },\n//       { _id: 'Option', _tag: 'Some', value: 'Task2: Oh no!' },\n//       { _id: 'Option', _tag: 'None' }\n//     ]\n//   }\n// }\n```",
      examples: [
        {
          title: "Combining Effects in Tuples",
          code: `import { Effect, Console } from "effect"

const tupleOfEffects = [
  Effect.succeed(42).pipe(Effect.tap(Console.log)),
  Effect.succeed("Hello").pipe(Effect.tap(Console.log))
] as const

//      \u250C\u2500\u2500\u2500 Effect<[number, string], never, never>
//      \u25BC
const resultsAsTuple = Effect.all(tupleOfEffects)

Effect.runPromise(resultsAsTuple).then(console.log)
// Output:
// 42
// Hello
// [ 42, 'Hello' ]`
        },
        {
          title: "Combining Effects in Iterables",
          code: 'import { Effect, Console } from "effect"\n\nconst iterableOfEffects: Iterable<Effect.Effect<number>> = [1, 2, 3].map(\n  (n) => Effect.succeed(n).pipe(Effect.tap(Console.log))\n)\n\n//      \u250C\u2500\u2500\u2500 Effect<number[], never, never>\n//      \u25BC\nconst resultsAsArray = Effect.all(iterableOfEffects)\n\nEffect.runPromise(resultsAsArray).then(console.log)\n// Output:\n// 1\n// 2\n// 3\n// [ 1, 2, 3 ]'
        },
        {
          title: "Combining Effects in Structs",
          code: `import { Effect, Console } from "effect"

const structOfEffects = {
  a: Effect.succeed(42).pipe(Effect.tap(Console.log)),
  b: Effect.succeed("Hello").pipe(Effect.tap(Console.log))
}

//      \u250C\u2500\u2500\u2500 Effect<{ a: number; b: string; }, never, never>
//      \u25BC
const resultsAsStruct = Effect.all(structOfEffects)

Effect.runPromise(resultsAsStruct).then(console.log)
// Output:
// 42
// Hello
// { a: 42, b: 'Hello' }`
        },
        {
          title: "Combining Effects in Records",
          code: 'import { Effect, Console } from "effect"\n\nconst recordOfEffects: Record<string, Effect.Effect<number>> = {\n  key1: Effect.succeed(1).pipe(Effect.tap(Console.log)),\n  key2: Effect.succeed(2).pipe(Effect.tap(Console.log))\n}\n\n//      \u250C\u2500\u2500\u2500 Effect<{ [x: string]: number; }, never, never>\n//      \u25BC\nconst resultsAsRecord = Effect.all(recordOfEffects)\n\nEffect.runPromise(resultsAsRecord).then(console.log)\n// Output:\n// 1\n// 2\n// { key1: 1, key2: 2 }'
        },
        {
          title: "Short-Circuiting Behavior",
          code: `import { Effect, Console } from "effect"

const program = Effect.all([
  Effect.succeed("Task1").pipe(Effect.tap(Console.log)),
  Effect.fail("Task2: Oh no!").pipe(Effect.tap(Console.log)),
  // Won't execute due to earlier failure
  Effect.succeed("Task3").pipe(Effect.tap(Console.log))
])

Effect.runPromiseExit(program).then(console.log)
// Output:
// Task1
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Task2: Oh no!' }
// }`
        },
        {
          title: 'Collecting Results with `mode: "either"`',
          code: `import { Effect, Console } from "effect"

const effects = [
  Effect.succeed("Task1").pipe(Effect.tap(Console.log)),
  Effect.fail("Task2: Oh no!").pipe(Effect.tap(Console.log)),
  Effect.succeed("Task3").pipe(Effect.tap(Console.log))
]

const program = Effect.all(effects, { mode: "either" })

Effect.runPromiseExit(program).then(console.log)
// Output:
// Task1
// Task3
// {
//   _id: 'Exit',
//   _tag: 'Success',
//   value: [
//     { _id: 'Either', _tag: 'Right', right: 'Task1' },
//     { _id: 'Either', _tag: 'Left', left: 'Task2: Oh no!' },
//     { _id: 'Either', _tag: 'Right', right: 'Task3' }
//   ]
// }`
        },
        {
          title: 'Collecting Results with `mode: "validate"`',
          code: `import { Effect, Console } from "effect"

const effects = [
  Effect.succeed("Task1").pipe(Effect.tap(Console.log)),
  Effect.fail("Task2: Oh no!").pipe(Effect.tap(Console.log)),
  Effect.succeed("Task3").pipe(Effect.tap(Console.log))
]

const program = Effect.all(effects, { mode: "validate" })

Effect.runPromiseExit(program).then((result) => console.log("%o", result))
// Output:
// Task1
// Task3
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: [
//       { _id: 'Option', _tag: 'None' },
//       { _id: 'Option', _tag: 'Some', value: 'Task2: Oh no!' },
//       { _id: 'Option', _tag: 'None' }
//     ]
//   }
// }`
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 1044,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L1044"
    },
    {
      id: "Effect.allWith",
      name: "allWith",
      module: "Effect",
      package: "effect",
      signature: '<O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard?: boolean | undefined; readonly mode?: "default" | "validate" | "either" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, O>>(options?: O) => <const Arg extends Iterable<Effect<any, any, any>> | Record<string, Effect<any, any, any>>>(arg: Arg) => All.Return<Arg, O>',
      description: "/\n * A data-last version of {@link all}, designed for use in pipelines.\n *\n *",
      documentation: '/**\n * A data-last version of {@link all}, designed for use in pipelines.\n *\n * **When to Use**\n *\n * This function enables you to combine multiple effects and customize execution\n * options such as concurrency levels. This version is useful in functional\n * pipelines where you first define your data and then apply operations to it.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, pipe } from "effect"\n *\n * const task1 = Effect.succeed(1).pipe(\n *   Effect.delay("200 millis"),\n *   Effect.tap(Effect.log("task1 done"))\n * )\n *\n * const task2 = Effect.succeed("hello").pipe(\n *   Effect.delay("100 millis"),\n *   Effect.tap(Effect.log("task2 done"))\n * )\n *\n * const program = pipe(\n *   [task1, task2],\n *   // Run both effects concurrently using the concurrent option\n *   Effect.allWith({ concurrency: 2 })\n * )\n *\n * Effect.runPromise(program).then(console.log)\n * // Output:\n * // timestamp=... level=INFO fiber=#3 message="task2 done"\n * // timestamp=... level=INFO fiber=#2 message="task1 done"\n * // [ 1, \'hello\' ]\n * ```\n *\n *',
      examples: [
        {
          code: `* import { Effect, pipe } from "effect"
 *
 * const task1 = Effect.succeed(1).pipe(
 *   Effect.delay("200 millis"),
 *   Effect.tap(Effect.log("task1 done"))
 * )
 *
 * const task2 = Effect.succeed("hello").pipe(
 *   Effect.delay("100 millis"),
 *   Effect.tap(Effect.log("task2 done"))
 * )
 *
 * const program = pipe(
 *   [task1, task2],
 *   // Run both effects concurrently using the concurrent option
 *   Effect.allWith({ concurrency: 2 })
 * )
 *
 * Effect.runPromise(program).then(console.log)
 * // Output:
 * // timestamp=... level=INFO fiber=#3 message="task2 done"
 * // timestamp=... level=INFO fiber=#2 message="task1 done"
 * // [ 1, 'hello' ]
 *`
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 1091,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L1091"
    },
    {
      id: "Effect.allSuccesses",
      name: "allSuccesses",
      module: "Effect",
      package: "effect",
      signature: '<X extends Effect<any, any, any>>(elements: Iterable<X>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }) => Effect<Effect.Success<X>[], never, Effect.Context<X>>',
      description: "Evaluates and runs each effect in the iterable, collecting only the\nsuccessful results while discarding failures.",
      documentation: 'Evaluates and runs each effect in the iterable, collecting only the\nsuccessful results while discarding failures.\n\n**Details**\n\nThis function function processes an iterable of effects and runs each one. If\nan effect is successful, its result is collected; if it fails, the result is\ndiscarded. This ensures that only successful outcomes are kept.\n\n**Options**\n\nThe function also allows you to customize how the effects are handled by\nspecifying options such as concurrency, batching, and how finalizers behave.\nThese options provide flexibility in running the effects concurrently or\nadjusting other execution details.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst tasks = [\n  Effect.succeed(1),\n  Effect.fail("Error 1"),\n  Effect.succeed(2),\n  Effect.fail("Error 2")\n]\n\nconst program = Effect.gen(function*() {\n  const successfulResults = yield* Effect.allSuccesses(tasks)\n  console.log(successfulResults)\n})\n\nEffect.runFork(program)\n// Output: [1, 2]\n\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst tasks = [\n  Effect.succeed(1),\n  Effect.fail("Error 1"),\n  Effect.succeed(2),\n  Effect.fail("Error 2")\n]\n\nconst program = Effect.gen(function*() {\n  const successfulResults = yield* Effect.allSuccesses(tasks)\n  console.log(successfulResults)\n})\n\nEffect.runFork(program)\n// Output: [1, 2]'
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 1215,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L1215"
    },
    {
      id: "Effect.dropUntil",
      name: "dropUntil",
      module: "Effect",
      package: "effect",
      signature: "{ <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<A[], E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>): Effect<A[], E, R>; }",
      description: "Drops elements until the effectful predicate returns `true`.",
      documentation: 'Drops elements until the effectful predicate returns `true`.\n\n**Details**\n\nThis function processes a collection of elements and uses an effectful\npredicate to determine when to stop dropping elements. It drops elements from\nthe beginning of the collection until the predicate returns `true`.\n\nThe predicate is a function that takes an element and its index in the\ncollection and returns an effect that evaluates to a boolean.\n\nOnce the predicate returns `true`, the remaining elements of the collection\nare returned.\n\n**Note**: The first element for which the predicate returns `true` is also\ndropped.\n\n**When to Use**\n\nThis function allows you to conditionally skip over a part of the collection\nbased on some criteria defined in the predicate.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.dropUntil(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [5, 6]\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.dropUntil(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [5, 6]'
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 1266,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L1266"
    },
    {
      id: "Effect.dropWhile",
      name: "dropWhile",
      module: "Effect",
      package: "effect",
      signature: "{ <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<A[], E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>): Effect<A[], E, R>; }",
      description: "Drops elements as long as the predicate returns `true`.",
      documentation: 'Drops elements as long as the predicate returns `true`.\n\n**Details**\n\nThis function processes a collection of elements and uses a predicate to\ndecide whether to drop an element.\n\nThe predicate is a function that takes an element and its index, and it\nreturns an effect that evaluates to a boolean.\n\nAs long as the predicate returns `true`, elements will continue to be dropped\nfrom the collection.\n\nOnce the predicate returns `false`, the remaining elements are kept.\n\n**When to Use**\n\nThis function allows you to discard elements from the start of a collection\nbased on a condition, and only keep the rest when the condition no longer\nholds.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n <= 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.dropWhile(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [4, 5, 6]\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n <= 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.dropWhile(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [4, 5, 6]'
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 1407,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L1407"
    },
    {
      id: "Effect.takeUntil",
      name: "takeUntil",
      module: "Effect",
      package: "effect",
      signature: "{ <A, R, E>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<A[], E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): Effect<A[], E, R>; }",
      description: "Takes elements from a collection until the effectful predicate returns\n`true`.",
      documentation: 'Takes elements from a collection until the effectful predicate returns\n`true`.\n\n**Details**\n\nThis function processes a collection of elements and uses an effectful\npredicate to decide when to stop taking elements. The elements are taken from\nthe beginning of the collection until the predicate returns `true`.\n\nThe predicate is a function that takes an element and its index in the\ncollection, and returns an effect that resolves to a boolean.\n\nOnce the predicate returns `true`, the remaining elements of the collection\nare discarded, and the function stops taking more elements.\n\n**Note**: The first element for which the predicate returns `true` is also\nincluded in the result.\n\n**When to Use**\n\nUse this function when you want to conditionally take elements from a\ncollection based on a dynamic condition. For example, you may want to collect\nnumbers from a list until a certain threshold is reached, or gather items\nuntil a specific condition is met.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.takeUntil(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [ 1, 2, 3, 4 ]\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.takeUntil(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [ 1, 2, 3, 4 ]'
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 1550,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L1550"
    },
    {
      id: "Effect.takeWhile",
      name: "takeWhile",
      module: "Effect",
      package: "effect",
      signature: "{ <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<A[], E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): Effect<A[], E, R>; }",
      description: "Takes elements as long as the predicate returns `true`.",
      documentation: 'Takes elements as long as the predicate returns `true`.\n\n**Details**\n\nThis function processes a collection of elements and uses a predicate to\ndecide whether to take an element.\n\nThe predicate is a function that takes an element and its index, and it\nreturns an effect that evaluates to a boolean.\n\nAs long as the predicate returns `true`, elements will continue to be taken\nfrom the collection.\n\nOnce the predicate returns `false`, the remaining elements are discarded.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n <= 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.takeWhile(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [1, 2, 3]\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst numbers = [1, 2, 3, 4, 5, 6]\nconst predicate = (n: number, i: number) => Effect.succeed(n <= 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.takeWhile(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [1, 2, 3]'
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 1690,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L1690"
    },
    {
      id: "Effect.every",
      name: "every",
      module: "Effect",
      package: "effect",
      signature: "{ <A, E, R>(predicate: (a: A, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<boolean, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>): Effect<boolean, E, R>; }",
      description: "Determines whether all elements of the iterable satisfy the effectful\npredicate.",
      documentation: 'Determines whether all elements of the iterable satisfy the effectful\npredicate.\n\n**Details**\n\nThis function checks whether every element in a given collection (an\niterable) satisfies a condition defined by an effectful predicate.\n\nThe predicate is a function that takes an element and its index, and it\nreturns an effect that evaluates to a boolean.\n\nThe function will process each element and return `true` if all elements\nsatisfy the predicate; otherwise, it returns `false`.\n\n**When to Use**\n\nThis function is useful when you need to verify that all items in a\ncollection meet certain criteria, even when the evaluation of each item\ninvolves effects, such as asynchronous checks or complex computations.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst numbers = [2, 4, 6, 8]\nconst predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)\n\nconst program = Effect.gen(function*() {\n  const allEven = yield* Effect.every(numbers, predicate)\n  console.log(allEven)\n})\n\nEffect.runFork(program)\n// Output: true\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst numbers = [2, 4, 6, 8]\nconst predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)\n\nconst program = Effect.gen(function*() {\n  const allEven = yield* Effect.every(numbers, predicate)\n  console.log(allEven)\n})\n\nEffect.runFork(program)\n// Output: true'
        }
      ],
      tags: [
        "Condition Checking"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 1814,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L1814"
    },
    {
      id: "Effect.exists",
      name: "exists",
      module: "Effect",
      package: "effect",
      signature: '{ <A, E, R>(predicate: (a: A, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): (elements: Iterable<A>) => Effect<boolean, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): Effect<boolean, E, R>; }',
      description: "Determines whether any element of the iterable satisfies the effectual\npredicate.",
      documentation: 'Determines whether any element of the iterable satisfies the effectual\npredicate.\n\n**Details**\n\nThis function checks whether any element in a given collection (an iterable)\nsatisfies a condition defined by an effectful predicate.\n\nThe predicate is a function that takes an element and its index, and it\nreturns an effect that evaluates to a boolean.\n\nThe function will process each element, and if any element satisfies the\npredicate (returns `true`), the function will immediately return `true`.\n\nIf none of the elements satisfy the condition, it will return `false`.\n\n**When to Use**\n\nThis function allows you to quickly check for a condition in a collection\nwithout having to manually iterate over it.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst numbers = [1, 2, 3, 4]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 2)\n\nconst program = Effect.gen(function*() {\n  const hasLargeNumber = yield* Effect.exists(numbers, predicate)\n  console.log(hasLargeNumber)\n})\n\nEffect.runFork(program)\n// Output: true\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst numbers = [1, 2, 3, 4]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 2)\n\nconst program = Effect.gen(function*() {\n  const hasLargeNumber = yield* Effect.exists(numbers, predicate)\n  console.log(hasLargeNumber)\n})\n\nEffect.runFork(program)\n// Output: true'
        }
      ],
      tags: [
        "Condition Checking"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 1951,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L1951"
    },
    {
      id: "Effect.filter",
      name: "filter",
      module: "Effect",
      package: "effect",
      signature: '{ <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly negate?: boolean; readonly concurrentFinalizers?: boolean; }): (elements: Iterable<A>) => Effect<A[], E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly negate?: boolean; readonly concurrentFinalizers?: boolean; }): Effect<A[], E, R>; }',
      description: "Filters an iterable using the specified effectful predicate.",
      documentation: 'Filters an iterable using the specified effectful predicate.\n\n**Details**\n\nThis function filters a collection (an iterable) by applying an effectful\npredicate.\n\nThe predicate is a function that takes an element and its index, and it\nreturns an effect that evaluates to a boolean.\n\nThe function processes each element in the collection and keeps only those\nthat satisfy the condition defined by the predicate.\n\n**Options**\n\nYou can also adjust the behavior with options such as concurrency, batching,\nor whether to negate the condition.\n\n**When to Use**\n\nThis function allows you to selectively keep or remove elements based on a\ncondition that may involve asynchronous or side-effect-causing operations.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst numbers = [1, 2, 3, 4, 5]\nconst predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.filter(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [2, 4]\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst numbers = [1, 2, 3, 4, 5]\nconst predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.filter(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: [2, 4]'
        }
      ],
      tags: [
        "Filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 2097,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L2097"
    },
    {
      id: "Effect.filterMap",
      name: "filterMap",
      module: "Effect",
      package: "effect",
      signature: "{ <Eff extends Effect<any, any, any>, B>(pf: (a: Effect.Success<Eff>) => Option<B>): (elements: Iterable<Eff>) => Effect<B[], Effect.Error<Eff>, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>, B>(elements: Iterable<Eff>, pf: (a: Effect.Success<Eff>) => Option<B>): Effect<B[], Effect.Error<Eff>, Effect.Context<Eff>>; }",
      description: "Filters and maps elements sequentially in one operation. This function processes each element one by one. It applies a function that\nreturns an `Option` to each element. If the function returns `Some`, the\nelement is kept; if it returns `None`, the element is removed. The operation\nis done sequentially for each element.",
      documentation: 'Filters and maps elements sequentially in one operation.\n\nThis function processes each element one by one. It applies a function that\nreturns an `Option` to each element. If the function returns `Some`, the\nelement is kept; if it returns `None`, the element is removed. The operation\nis done sequentially for each element.\n\n**Example**\n\n```ts\nimport { Console, Effect, Option } from "effect"\n\nconst task = (n: number) =>\n  Effect.succeed(n).pipe(\n    Effect.delay(1000 - (n * 100)),\n    Effect.tap(Console.log(`task${n} done`))\n  )\n\nconst program = Effect.filterMap(\n  [task(1), task(2), task(3), task(4)],\n  (n) => n % 2 === 0 ? Option.some(n) : Option.none()\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// task1 done\n// task2 done\n// task3 done\n// task4 done\n// [ 2, 4 ]\n```',
      examples: [
        {
          code: 'import { Console, Effect, Option } from "effect"\n\nconst task = (n: number) =>\n  Effect.succeed(n).pipe(\n    Effect.delay(1000 - (n * 100)),\n    Effect.tap(Console.log(`task${n} done`))\n  )\n\nconst program = Effect.filterMap(\n  [task(1), task(2), task(3), task(4)],\n  (n) => n % 2 === 0 ? Option.some(n) : Option.none()\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// task1 done\n// task2 done\n// task3 done\n// task4 done\n// [ 2, 4 ]'
        }
      ],
      tags: [
        "Filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 2235,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L2235"
    },
    {
      id: "Effect.findFirst",
      name: "findFirst",
      module: "Effect",
      package: "effect",
      signature: "{ <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Option<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): Effect<Option<A>, E, R>; }",
      description: "Returns the first element that satisfies the effectful predicate.",
      documentation: "Returns the first element that satisfies the effectful predicate.\n\n**Details**\n\nThis function processes a collection of elements and applies an effectful\npredicate to each element.\n\nThe predicate is a function that takes an element and its index in the\ncollection, and it returns an effect that evaluates to a boolean.\n\nThe function stops as soon as it finds the first element for which the\npredicate returns `true` and returns that element wrapped in an `Option`.\n\nIf no element satisfies the predicate, the result will be `None`.\n\n**When to Use**\n\nThis function allows you to efficiently find an element that meets a specific\ncondition, even when the evaluation involves effects like asynchronous\noperations or side effects.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst numbers = [1, 2, 3, 4, 5]\nconst predicate = (n: number, i: number) => Effect.succeed(n > 3)\n\nconst program = Effect.gen(function*() {\n  const result = yield* Effect.findFirst(numbers, predicate)\n  console.log(result)\n})\n\nEffect.runFork(program)\n// Output: { _id: 'Option', _tag: 'Some', value: 4 }\n```",
      examples: [
        {
          code: `import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5]
const predicate = (n: number, i: number) => Effect.succeed(n > 3)

const program = Effect.gen(function*() {
  const result = yield* Effect.findFirst(numbers, predicate)
  console.log(result)
})

Effect.runFork(program)
// Output: { _id: 'Option', _tag: 'Some', value: 4 }`
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 2353,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L2353"
    },
    {
      id: "Effect.forEach",
      name: "forEach",
      module: "Effect",
      package: "effect",
      signature: '{ <B, E, R, S extends Iterable<any>>(f: (a: ReadonlyArray.Infer<S>, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly discard?: false; readonly concurrentFinalizers?: boolean; }): (self: S) => Effect<ReadonlyArray.With<S, B>, E, R>; <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly discard: true; readonly concurrentFinalizers?: boolean; }): (self: Iterable<A>) => Effect<void, E, R>; <B, E, R, S extends Iterable<any>>(self: S, f: (a: ReadonlyArray.Infer<S>, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly discard?: false; readonly concurrentFinalizers?: boolean; }): Effect<ReadonlyArray.With<S, B>, E, R>; <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly discard: true; readonly concurrentFinalizers?: boolean; }): Effect<void, E, R>; }',
      description: "Executes an effectful operation for each element in an `Iterable`.",
      documentation: 'Executes an effectful operation for each element in an `Iterable`.\n\n**Details**\n\nThis function applies a provided operation to each element in the iterable,\nproducing a new effect that returns an array of results.\n\nIf any effect fails, the iteration stops immediately (short-circuiting), and\nthe error is propagated.\n\n**Concurrency**\n\nThe `concurrency` option controls how many operations are performed\nconcurrently. By default, the operations are performed sequentially.\n\n**Discarding Results**\n\nIf the `discard` option is set to `true`, the intermediate results are not\ncollected, and the final result of the operation is `void`.\n\n**Example** (Applying Effects to Iterable Elements)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst result = Effect.forEach([1, 2, 3, 4, 5], (n, index) =>\n  Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2))\n)\n\nEffect.runPromise(result).then(console.log)\n// Output:\n// Currently at index 0\n// Currently at index 1\n// Currently at index 2\n// Currently at index 3\n// Currently at index 4\n// [ 2, 4, 6, 8, 10 ]\n```\n\n**Example** (Discarding Results)\n\n```ts\nimport { Effect, Console } from "effect"\n\n// Apply effects but discard the results\nconst result = Effect.forEach(\n  [1, 2, 3, 4, 5],\n  (n, index) =>\n    Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2)),\n  { discard: true }\n)\n\nEffect.runPromise(result).then(console.log)\n// Output:\n// Currently at index 0\n// Currently at index 1\n// Currently at index 2\n// Currently at index 3\n// Currently at index 4\n// undefined\n```',
      examples: [
        {
          title: "Applying Effects to Iterable Elements",
          code: 'import { Effect, Console } from "effect"\n\nconst result = Effect.forEach([1, 2, 3, 4, 5], (n, index) =>\n  Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2))\n)\n\nEffect.runPromise(result).then(console.log)\n// Output:\n// Currently at index 0\n// Currently at index 1\n// Currently at index 2\n// Currently at index 3\n// Currently at index 4\n// [ 2, 4, 6, 8, 10 ]'
        },
        {
          title: "Discarding Results",
          code: 'import { Effect, Console } from "effect"\n\n// Apply effects but discard the results\nconst result = Effect.forEach(\n  [1, 2, 3, 4, 5],\n  (n, index) =>\n    Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2)),\n  { discard: true }\n)\n\nEffect.runPromise(result).then(console.log)\n// Output:\n// Currently at index 0\n// Currently at index 1\n// Currently at index 2\n// Currently at index 3\n// Currently at index 4\n// undefined'
        }
      ],
      tags: [
        "Looping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 2509,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L2509"
    },
    {
      id: "Effect.head",
      name: "head",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<Iterable<A>, E, R>) => Effect<A, E | NoSuchElementException, R>",
      description: "Returns the first element of the iterable if the collection is non-empty, or\nfails with the error `NoSuchElementException` if the collection is empty.",
      documentation: 'Returns the first element of the iterable if the collection is non-empty, or\nfails with the error `NoSuchElementException` if the collection is empty.\n\n**When to Use**\n\nThis function is useful when you need to retrieve the first item from a\ncollection and want to handle the case where the collection might be empty\nwithout causing an unhandled exception.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\n// Simulate an async operation\nconst fetchNumbers = Effect.succeed([1, 2, 3]).pipe(Effect.delay("100 millis"))\n\nconst program = Effect.gen(function*() {\n  const firstElement = yield* Effect.head(fetchNumbers)\n  console.log(firstElement)\n})\n\nEffect.runFork(program)\n// Output: 1\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\n// Simulate an async operation\nconst fetchNumbers = Effect.succeed([1, 2, 3]).pipe(Effect.delay("100 millis"))\n\nconst program = Effect.gen(function*() {\n  const firstElement = yield* Effect.head(fetchNumbers)\n  console.log(firstElement)\n})\n\nEffect.runFork(program)\n// Output: 1'
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 2837,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L2837"
    },
    {
      id: "Effect.mergeAll",
      name: "mergeAll",
      module: "Effect",
      package: "effect",
      signature: '{ <Z, Eff extends Effect<any, any, any>>(zero: Z, f: (z: Z, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): (elements: Iterable<Eff>) => Effect<Z, Effect.Error<Eff>, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>, Z>(elements: Iterable<Eff>, zero: Z, f: (z: Z, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): Effect<Z, Effect.Error<Eff>, Effect.Context<Eff>>; }',
      description: "Merges an `Iterable<Effect<A, E, R>>` to a single effect.",
      documentation: 'Merges an `Iterable<Effect<A, E, R>>` to a single effect.\n\n**Details**\n\nThis function takes an iterable of effects and combines them into a single\neffect. It does this by iterating over each effect in the collection and\napplying a function that accumulates results into a "zero" value, which\nstarts with an initial value and is updated with each effect\'s success.\n\nThe provided function `f` is called for each element in the iterable,\nallowing you to specify how to combine the results.\n\n**Options**\n\nThe function also allows you to customize how the effects are handled by\nspecifying options such as concurrency, batching, and how finalizers behave.\nThese options provide flexibility in running the effects concurrently or\nadjusting other execution details.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst numbers = [Effect.succeed(1), Effect.succeed(2), Effect.succeed(3)]\nconst add = (sum: number, value: number, i: number) => sum + value\nconst zero = 0\n\nconst program = Effect.gen(function*() {\n  const total = yield* Effect.mergeAll(numbers, zero, add)\n  console.log(total)\n})\n\nEffect.runFork(program)\n// Output: 6\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst numbers = [Effect.succeed(1), Effect.succeed(2), Effect.succeed(3)]\nconst add = (sum: number, value: number, i: number) => sum + value\nconst zero = 0\n\nconst program = Effect.gen(function*() {\n  const total = yield* Effect.mergeAll(numbers, zero, add)\n  console.log(total)\n})\n\nEffect.runFork(program)\n// Output: 6'
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 2879,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L2879"
    },
    {
      id: "Effect.partition",
      name: "partition",
      module: "Effect",
      package: "effect",
      signature: '{ <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): (elements: Iterable<A>) => Effect<[excluded: E[], satisfying: B[]], never, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): Effect<[excluded: E[], satisfying: B[]], never, R>; }',
      description: "Processes an iterable and applies an effectful function to each element,\ncategorizing the results into successes and failures.",
      documentation: "Processes an iterable and applies an effectful function to each element,\ncategorizing the results into successes and failures.\n\n**Details**\n\nThis function processes each element in the provided iterable by applying an\neffectful function to it. The results are then categorized into two separate\nlists: one for failures and another for successes. This separation allows you\nto handle the two categories differently. Failures are collected in a list\nwithout interrupting the processing of the remaining elements, so the\noperation continues even if some elements fail. This is particularly useful\nwhen you need to handle both successful and failed results separately,\nwithout stopping the entire process on encountering a failure.\n\n**When to Use**\n\nUse this function when you want to process a collection of items and handle\nerrors or failures without interrupting the processing of other items. It's\nuseful when you need to distinguish between successful and failed results and\nprocess them separately, for example, when logging errors while continuing to\nwork with valid data. The function ensures that failures are captured, while\nsuccesses are processed normally.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\n//      \u250C\u2500\u2500\u2500 Effect<[string[], number[]], never, never>\n//      \u25BC\nconst program = Effect.partition([0, 1, 2, 3, 4], (n) => {\n  if (n % 2 === 0) {\n    return Effect.succeed(n)\n  } else {\n    return Effect.fail(`${n} is not even`)\n  }\n})\n\nEffect.runPromise(program).then(console.log, console.error)\n// Output:\n// [ [ '1 is not even', '3 is not even' ], [ 0, 2, 4 ] ]\n```",
      examples: [
        {
          code: "import { Effect } from \"effect\"\n\n//      \u250C\u2500\u2500\u2500 Effect<[string[], number[]], never, never>\n//      \u25BC\nconst program = Effect.partition([0, 1, 2, 3, 4], (n) => {\n  if (n % 2 === 0) {\n    return Effect.succeed(n)\n  } else {\n    return Effect.fail(`${n} is not even`)\n  }\n})\n\nEffect.runPromise(program).then(console.log, console.error)\n// Output:\n// [ [ '1 is not even', '3 is not even' ], [ 0, 2, 4 ] ]"
        }
      ],
      tags: [
        "Error Accumulation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 3023,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L3023"
    },
    {
      id: "Effect.reduce",
      name: "reduce",
      module: "Effect",
      package: "effect",
      signature: "{ <Z, A, E, R>(zero: Z, f: (z: Z, a: A, i: number) => Effect<Z, E, R>): (elements: Iterable<A>) => Effect<Z, E, R>; <A, Z, E, R>(elements: Iterable<A>, zero: Z, f: (z: Z, a: A, i: number) => Effect<Z, E, R>): Effect<Z, E, R>; }",
      description: "Reduces an `Iterable<A>` using an effectual function `f`, working\nsequentially from left to right.",
      documentation: 'Reduces an `Iterable<A>` using an effectual function `f`, working\nsequentially from left to right.\n\n**Details**\n\nThis function takes an iterable and applies a function `f` to each element in\nthe iterable. The function works sequentially, starting with an initial value\n`zero` and then combining it with each element in the collection. The\nprovided function `f` is called for each element in the iterable, allowing\nyou to accumulate a result based on the current value and the element being\nprocessed.\n\n**When to Use**\n\nThe function is often used for operations like summing a collection of\nnumbers or combining results from multiple tasks. It ensures that operations\nare performed one after the other, maintaining the order of the elements.\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduce(\n  [1, 2, 3, 4],\n  0,\n  (acc, id, i) =>\n    processOrder(id)\n      .pipe(Effect.map((order) => acc + order.price))\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Order 1 processed\n// Order 2 processed\n// Order 3 processed\n// Order 4 processed\n// 1000\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduce(\n  [1, 2, 3, 4],\n  0,\n  (acc, id, i) =>\n    processOrder(id)\n      .pipe(Effect.map((order) => acc + order.price))\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Order 1 processed\n// Order 2 processed\n// Order 3 processed\n// Order 4 processed\n// 1000'
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 3186,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L3186"
    },
    {
      id: "Effect.reduceWhile",
      name: "reduceWhile",
      module: "Effect",
      package: "effect",
      signature: "{ <Z, A, E, R>(zero: Z, options: { readonly while: Predicate<Z>; readonly body: (s: Z, a: A, i: number) => Effect<Z, E, R>; }): (elements: Iterable<A>) => Effect<Z, E, R>; <A, Z, E, R>(elements: Iterable<A>, zero: Z, options: { readonly while: Predicate<Z>; readonly body: (s: Z, a: A, i: number) => Effect<Z, E, R>; }): Effect<Z, E, R>; }",
      description: "Reduces an `Iterable<A>` using an effectual function `body`, working\nsequentially from left to right, stopping the process early when the\npredicate `while` is not satisfied.",
      documentation: 'Reduces an `Iterable<A>` using an effectual function `body`, working\nsequentially from left to right, stopping the process early when the\npredicate `while` is not satisfied.\n\n**Details**\n\nThis function processes a collection of elements, applying a function `body`\nto reduce them to a single value, starting from the first element. It checks\nthe value of the accumulator against a predicate (`while`). If at any point\nthe predicate returns `false`, the reduction stops, and the accumulated\nresult is returned.\n\n**When to Use**\n\nUse this function when you need to reduce a collection of elements, but only\ncontinue the process as long as a certain condition holds true. For example,\nif you want to sum values in a list but stop as soon as the sum exceeds a\ncertain threshold, you can use this function.\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduceWhile(\n  [1, 2, 3, 4],\n  0,\n  {\n    body: (acc, id, i) =>\n      processOrder(id)\n        .pipe(Effect.map((order) => acc + order.price)),\n    while: (acc) => acc < 500\n  }\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Order 1 processed\n// Order 2 processed\n// Order 3 processed\n// 600\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduceWhile(\n  [1, 2, 3, 4],\n  0,\n  {\n    body: (acc, id, i) =>\n      processOrder(id)\n        .pipe(Effect.map((order) => acc + order.price)),\n    while: (acc) => acc < 500\n  }\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Order 1 processed\n// Order 2 processed\n// Order 3 processed\n// 600'
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 3343,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L3343"
    },
    {
      id: "Effect.reduceRight",
      name: "reduceRight",
      module: "Effect",
      package: "effect",
      signature: "{ <A, Z, R, E>(zero: Z, f: (a: A, z: Z, i: number) => Effect<Z, E, R>): (elements: Iterable<A>) => Effect<Z, E, R>; <A, Z, R, E>(elements: Iterable<A>, zero: Z, f: (a: A, z: Z, i: number) => Effect<Z, E, R>): Effect<Z, E, R>; }",
      description: "Reduces an `Iterable<A>` using an effectual function `f`, working\nsequentially from right to left.",
      documentation: 'Reduces an `Iterable<A>` using an effectual function `f`, working\nsequentially from right to left.\n\n**Details**\n\nThis function takes an iterable and applies a function `f` to each element in\nthe iterable. The function works sequentially, starting with an initial value\n`zero` and then combining it with each element in the collection. The\nprovided function `f` is called for each element in the iterable, allowing\nyou to accumulate a result based on the current value and the element being\nprocessed.\n\n**When to Use**\n\nThe function is often used for operations like summing a collection of\nnumbers or combining results from multiple tasks. It ensures that operations\nare performed one after the other, maintaining the order of the elements.\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduceRight(\n  [1, 2, 3, 4],\n  0,\n  (id, acc, i) =>\n    processOrder(id)\n      .pipe(Effect.map((order) => acc + order.price))\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Order 4 processed\n// Order 3 processed\n// Order 2 processed\n// Order 1 processed\n// 1000\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduceRight(\n  [1, 2, 3, 4],\n  0,\n  (id, acc, i) =>\n    processOrder(id)\n      .pipe(Effect.map((order) => acc + order.price))\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Order 4 processed\n// Order 3 processed\n// Order 2 processed\n// Order 1 processed\n// 1000'
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 3505,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L3505"
    },
    {
      id: "Effect.reduceEffect",
      name: "reduceEffect",
      module: "Effect",
      package: "effect",
      signature: '{ <Z, E, R, Eff extends Effect<any, any, any>>(zero: Effect<Z, E, R>, f: (z: NoInfer<Z>, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): (elements: Iterable<Eff>) => Effect<Z, E | Effect.Error<Eff>, R | Effect.Context<Eff>>; <Eff extends Effect<any, any, any>, Z, E, R>(elements: Iterable<Eff>, zero: Effect<Z, E, R>, f: (z: NoInfer<Z>, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): Effect<Z, E | Effect.Error<Eff>, R | Effect.Context<Eff>>; }',
      description: "Reduces an `Iterable<Effect<A, E, R>>` to a single effect.",
      documentation: 'Reduces an `Iterable<Effect<A, E, R>>` to a single effect.\n\n**Details**\n\nThis function processes a collection of effects and combines them into one\nsingle effect. It starts with an initial effect (`zero`) and applies a\nfunction `f` to each element in the collection.\n\n**Options**\n\nThe function also allows you to customize how the effects are handled by\nspecifying options such as concurrency, batching, and how finalizers behave.\nThese options provide flexibility in running the effects concurrently or\nadjusting other execution details.\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduceEffect(\n  [processOrder(1), processOrder(2), processOrder(3), processOrder(4)],\n  Effect.succeed(0),\n  (acc, order, i) => acc + order.price\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Order 1 processed\n// Order 2 processed\n// Order 3 processed\n// Order 4 processed\n// 1000\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\nconst processOrder = (id: number) =>\n  Effect.succeed({ id, price: 100 * id })\n    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))\n\nconst program = Effect.reduceEffect(\n  [processOrder(1), processOrder(2), processOrder(3), processOrder(4)],\n  Effect.succeed(0),\n  (acc, order, i) => acc + order.price\n)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// Order 1 processed\n// Order 2 processed\n// Order 3 processed\n// Order 4 processed\n// 1000'
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 3652,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L3652"
    },
    {
      id: "Effect.replicate",
      name: "replicate",
      module: "Effect",
      package: "effect",
      signature: "{ (n: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>[]; <A, E, R>(self: Effect<A, E, R>, n: number): Effect<A, E, R>[]; }",
      description: "Replicates the given effect `n` times.",
      documentation: 'Replicates the given effect `n` times.\n\n**Details**\n\nThis function takes an effect and replicates it a specified number of times\n(`n`). The result is an array of `n` effects, each of which is identical to\nthe original effect.\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\nconst task = Effect.succeed("Hello, World!").pipe(\n  Effect.tap(Console.log)\n)\n\nconst program = Effect.gen(function*() {\n  // Replicate the task 3 times\n  const tasks = Effect.replicate(task, 3)\n  for (const t of tasks) {\n    // Run each task\n    yield* t\n  }\n})\n\nEffect.runFork(program)\n// Output:\n// Hello, World!\n// Hello, World!\n// Hello, World!\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\nconst task = Effect.succeed("Hello, World!").pipe(\n  Effect.tap(Console.log)\n)\n\nconst program = Effect.gen(function*() {\n  // Replicate the task 3 times\n  const tasks = Effect.replicate(task, 3)\n  for (const t of tasks) {\n    // Run each task\n    yield* t\n  }\n})\n\nEffect.runFork(program)\n// Output:\n// Hello, World!\n// Hello, World!\n// Hello, World!'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 3786,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L3786"
    },
    {
      id: "Effect.replicateEffect",
      name: "replicateEffect",
      module: "Effect",
      package: "effect",
      signature: '{ (n: number, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly discard?: false; readonly concurrentFinalizers?: boolean; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A[], E, R>; (n: number, options: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly discard: true; readonly concurrentFinalizers?: boolean; }): <A, E, R>(self: Effect<A, E, R>) => Effect<void, E, R>; <A, E, R>(self: Effect<A, E, R>, n: number, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly discard?: false; readonly concurrentFinalizers?: boolean; }): Effect<A[], E, R>; <A, E, R>(self: Effect<A, E, R>, n: number, options: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly discard: true; readonly concurrentFinalizers?: boolean; }): Effect<void, E, R>; }',
      description: "Performs this effect the specified number of times and collects the results.",
      documentation: 'Performs this effect the specified number of times and collects the results.\n\n**Details**\n\nThis function repeats an effect multiple times and collects the results into\nan array. You specify how many times to execute the effect, and it runs that\nmany times, either in sequence or concurrently depending on the provided\noptions.\n\n**Options**\n\nIf the `discard` option is set to `true`, the intermediate results are not\ncollected, and the final result of the operation is `void`.\n\nThe function also allows you to customize how the effects are handled by\nspecifying options such as concurrency, batching, and how finalizers behave.\nThese options provide flexibility in running the effects concurrently or\nadjusting other execution details.\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\nlet counter = 0\n\nconst task = Effect.sync(() => ++counter).pipe(\n  Effect.tap(() => Console.log(`Task completed`))\n)\n\nconst program = Effect.gen(function*() {\n  // Replicate the task 3 times and collect the results\n  const results = yield* Effect.replicateEffect(task, 3)\n  yield* Console.log(`Results: ${results.join(", ")}`)\n})\n\nEffect.runFork(program)\n// Output:\n// Task completed\n// Task completed\n// Task completed\n// Results: 1, 2, 3\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\nlet counter = 0\n\nconst task = Effect.sync(() => ++counter).pipe(\n  Effect.tap(() => Console.log(`Task completed`))\n)\n\nconst program = Effect.gen(function*() {\n  // Replicate the task 3 times and collect the results\n  const results = yield* Effect.replicateEffect(task, 3)\n  yield* Console.log(`Results: ${results.join(", ")}`)\n})\n\nEffect.runFork(program)\n// Output:\n// Task completed\n// Task completed\n// Task completed\n// Results: 1, 2, 3'
        }
      ],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 3910,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L3910"
    },
    {
      id: "Effect.validateAll",
      name: "validateAll",
      module: "Effect",
      package: "effect",
      signature: '{ <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly discard?: false; readonly concurrentFinalizers?: boolean; }): (elements: Iterable<A>) => Effect<B[], [E, ...E[]], R>; <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly discard: true; readonly concurrentFinalizers?: boolean; }): (elements: Iterable<A>) => Effect<void, [E, ...E[]], R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly discard?: false; readonly concurrentFinalizers?: boolean; }): Effect<B[], [E, ...E[]], R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly discard: true; readonly concurrentFinalizers?: boolean; }): Effect<void, [E, ...E[]], R>; }',
      description: "/\n * Applies an effectful operation to each element in a collection while\n * collecting both successes and failures.\n *\n *",
      documentation: "/**\n * Applies an effectful operation to each element in a collection while\n * collecting both successes and failures.\n *\n * **Details**\n *\n * This function allows you to apply an effectful operation to every item in a\n * collection.\n *\n * Unlike {@link forEach}, which would stop at the first error, this function\n * continues processing all elements, accumulating both successes and failures.\n *\n * **When to Use**\n *\n * Use this function when you want to process every item in a collection, even\n * if some items fail. This is particularly useful when you need to perform\n * operations on all elements without halting due to an error.\n *\n * Keep in mind that if there are any failures, **all successes will be lost**,\n * so this function is not suitable when you need to keep the successful results\n * in case of errors.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Console } from \"effect\"\n *\n * //      \u250C\u2500\u2500\u2500 Effect<number[], [string, ...string[]], never>\n * //      \u25BC\n * const program = Effect.validateAll([1, 2, 3, 4, 5], (n) => {\n *   if (n < 4) {\n *     return Console.log(`item ${n}`).pipe(Effect.as(n))\n *   } else {\n *     return Effect.fail(`${n} is not less that 4`)\n *   }\n * })\n *\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // item 1\n * // item 2\n * // item 3\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: {\n * //     _id: 'Cause',\n * //     _tag: 'Fail',\n * //     failure: [ '4 is not less that 4', '5 is not less that 4' ]\n * //   }\n * // }\n * ```\n *\n *",
      examples: [
        {
          code: "* import { Effect, Console } from \"effect\"\n *\n * //      \u250C\u2500\u2500\u2500 Effect<number[], [string, ...string[]], never>\n * //      \u25BC\n * const program = Effect.validateAll([1, 2, 3, 4, 5], (n) => {\n *   if (n < 4) {\n *     return Console.log(`item ${n}`).pipe(Effect.as(n))\n *   } else {\n *     return Effect.fail(`${n} is not less that 4`)\n *   }\n * })\n *\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // item 1\n * // item 2\n * // item 3\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: {\n * //     _id: 'Cause',\n * //     _tag: 'Fail',\n * //     failure: [ '4 is not less that 4', '5 is not less that 4' ]\n * //   }\n * // }\n *"
        }
      ],
      tags: [
        "Error Accumulation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4188,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4188"
    },
    {
      id: "Effect.validateFirst",
      name: "validateFirst",
      module: "Effect",
      package: "effect",
      signature: '{ <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): (elements: Iterable<A>) => Effect<B, E[], R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): Effect<B, E[], R>; }',
      description: "/\n * This function is similar to {@link validateAll}but with a key difference: it\n * returns the first successful result or all errors if none of the operations\n * succeed.\n *\n *",
      documentation: '/**\n * This function is similar to {@link validateAll}but with a key difference: it\n * returns the first successful result or all errors if none of the operations\n * succeed.\n *\n * **Details**\n *\n * This function processes a collection of elements and applies an effectful\n * operation to each. Unlike {@link validateAll}, which accumulates both\n * successes and failures, `Effect.validateFirst` stops and returns the first\n * success it encounters. If no success occurs, it returns all accumulated\n * errors. This can be useful when you are interested in the first successful\n * result and want to avoid processing further once a valid result is found.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Console } from "effect"\n *\n * //      \u250C\u2500\u2500\u2500 Effect<number, string[], never>\n * //      \u25BC\n * const program = Effect.validateFirst([1, 2, 3, 4, 5], (n) => {\n *   if (n < 4) {\n *     return Effect.fail(`${n} is not less that 4`)\n *   } else {\n *     return Console.log(`item ${n}`).pipe(Effect.as(n))\n *   }\n * })\n *\n * Effect.runPromise(program).then(console.log, console.error)\n * // Output:\n * // item 4\n * // 4\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect, Console } from "effect"\n *\n * //      \u250C\u2500\u2500\u2500 Effect<number, string[], never>\n * //      \u25BC\n * const program = Effect.validateFirst([1, 2, 3, 4, 5], (n) => {\n *   if (n < 4) {\n *     return Effect.fail(`${n} is not less that 4`)\n *   } else {\n *     return Console.log(`item ${n}`).pipe(Effect.as(n))\n *   }\n * })\n *\n * Effect.runPromise(program).then(console.log, console.error)\n * // Output:\n * // item 4\n * // 4\n *'
        }
      ],
      tags: [
        "Error Accumulation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4496,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4496"
    },
    {
      id: "Effect.async",
      name: "async",
      module: "Effect",
      package: "effect",
      signature: "<A, E = never, R = never>(resume: (callback: (_: Effect<A, E, R>) => void, signal: AbortSignal) => void | Effect<void, never, R>, blockingOn?: FiberId) => Effect<A, E, R>",
      description: "Creates an `Effect` from a callback-based asynchronous function.",
      documentation: 'Creates an `Effect` from a callback-based asynchronous function.\n\n**Details**\n\nThe `resume` function:\n- Must be called exactly once. Any additional calls will be ignored.\n- Can return an optional `Effect` that will be run if the `Fiber` executing\n  this `Effect` is interrupted. This can be useful in scenarios where you\n  need to handle resource cleanup if the operation is interrupted.\n- Can receive an `AbortSignal` to handle interruption if needed.\n\nThe `FiberId` of the fiber that may complete the async callback may also be\nspecified using the `blockingOn` argument. This is called the "blocking\nfiber" because it suspends the fiber executing the `async` effect (i.e.\nsemantically blocks the fiber from making progress). Specifying this fiber id\nin cases where it is known will improve diagnostics, but not affect the\nbehavior of the returned effect.\n\n**When to Use**\n\nUse `Effect.async` when dealing with APIs that use callback-style instead of\n`async/await` or `Promise`.\n\n**Example** (Wrapping a Callback API)\n\n```ts\nimport { Effect } from "effect"\nimport * as NodeFS from "node:fs"\n\nconst readFile = (filename: string) =>\n  Effect.async<Buffer, Error>((resume) => {\n    NodeFS.readFile(filename, (error, data) => {\n      if (error) {\n        // Resume with a failed Effect if an error occurs\n        resume(Effect.fail(error))\n      } else {\n        // Resume with a succeeded Effect if successful\n        resume(Effect.succeed(data))\n      }\n    })\n  })\n\n//      \u250C\u2500\u2500\u2500 Effect<Buffer, Error, never>\n//      \u25BC\nconst program = readFile("example.txt")\n```\n\n**Example** (Handling Interruption with Cleanup)\n\n```ts\nimport { Effect, Fiber } from "effect"\nimport * as NodeFS from "node:fs"\n\n// Simulates a long-running operation to write to a file\nconst writeFileWithCleanup = (filename: string, data: string) =>\n  Effect.async<void, Error>((resume) => {\n    const writeStream = NodeFS.createWriteStream(filename)\n\n    // Start writing data to the file\n    writeStream.write(data)\n\n    // When the stream is finished, resume with success\n    writeStream.on("finish", () => resume(Effect.void))\n\n    // In case of an error during writing, resume with failure\n    writeStream.on("error", (err) => resume(Effect.fail(err)))\n\n    // Handle interruption by returning a cleanup effect\n    return Effect.sync(() => {\n      console.log(`Cleaning up ${filename}`)\n      NodeFS.unlinkSync(filename)\n    })\n  })\n\nconst program = Effect.gen(function* () {\n  const fiber = yield* Effect.fork(\n    writeFileWithCleanup("example.txt", "Some long data...")\n  )\n  // Simulate interrupting the fiber after 1 second\n  yield* Effect.sleep("1 second")\n  yield* Fiber.interrupt(fiber) // This will trigger the cleanup\n})\n\n// Run the program\nEffect.runPromise(program)\n// Output:\n// Cleaning up example.txt\n```\n\n**Example** (Handling Interruption with AbortSignal)\n\n```ts\nimport { Effect, Fiber } from "effect"\n\n// A task that supports interruption using AbortSignal\nconst interruptibleTask = Effect.async<void, Error>((resume, signal) => {\n  // Handle interruption\n  signal.addEventListener("abort", () => {\n    console.log("Abort signal received")\n    clearTimeout(timeoutId)\n  })\n\n  // Simulate a long-running task\n  const timeoutId = setTimeout(() => {\n    console.log("Operation completed")\n    resume(Effect.void)\n  }, 2000)\n})\n\nconst program = Effect.gen(function* () {\n  const fiber = yield* Effect.fork(interruptibleTask)\n  // Simulate interrupting the fiber after 1 second\n  yield* Effect.sleep("1 second")\n  yield* Fiber.interrupt(fiber)\n})\n\n// Run the program\nEffect.runPromise(program)\n// Output:\n// Abort signal received\n```',
      examples: [
        {
          title: "Wrapping a Callback API",
          code: 'import { Effect } from "effect"\nimport * as NodeFS from "node:fs"\n\nconst readFile = (filename: string) =>\n  Effect.async<Buffer, Error>((resume) => {\n    NodeFS.readFile(filename, (error, data) => {\n      if (error) {\n        // Resume with a failed Effect if an error occurs\n        resume(Effect.fail(error))\n      } else {\n        // Resume with a succeeded Effect if successful\n        resume(Effect.succeed(data))\n      }\n    })\n  })\n\n//      \u250C\u2500\u2500\u2500 Effect<Buffer, Error, never>\n//      \u25BC\nconst program = readFile("example.txt")'
        },
        {
          title: "Handling Interruption with Cleanup",
          code: 'import { Effect, Fiber } from "effect"\nimport * as NodeFS from "node:fs"\n\n// Simulates a long-running operation to write to a file\nconst writeFileWithCleanup = (filename: string, data: string) =>\n  Effect.async<void, Error>((resume) => {\n    const writeStream = NodeFS.createWriteStream(filename)\n\n    // Start writing data to the file\n    writeStream.write(data)\n\n    // When the stream is finished, resume with success\n    writeStream.on("finish", () => resume(Effect.void))\n\n    // In case of an error during writing, resume with failure\n    writeStream.on("error", (err) => resume(Effect.fail(err)))\n\n    // Handle interruption by returning a cleanup effect\n    return Effect.sync(() => {\n      console.log(`Cleaning up ${filename}`)\n      NodeFS.unlinkSync(filename)\n    })\n  })\n\nconst program = Effect.gen(function* () {\n  const fiber = yield* Effect.fork(\n    writeFileWithCleanup("example.txt", "Some long data...")\n  )\n  // Simulate interrupting the fiber after 1 second\n  yield* Effect.sleep("1 second")\n  yield* Fiber.interrupt(fiber) // This will trigger the cleanup\n})\n\n// Run the program\nEffect.runPromise(program)\n// Output:\n// Cleaning up example.txt'
        },
        {
          title: "Handling Interruption with AbortSignal",
          code: 'import { Effect, Fiber } from "effect"\n\n// A task that supports interruption using AbortSignal\nconst interruptibleTask = Effect.async<void, Error>((resume, signal) => {\n  // Handle interruption\n  signal.addEventListener("abort", () => {\n    console.log("Abort signal received")\n    clearTimeout(timeoutId)\n  })\n\n  // Simulate a long-running task\n  const timeoutId = setTimeout(() => {\n    console.log("Operation completed")\n    resume(Effect.void)\n  }, 2000)\n})\n\nconst program = Effect.gen(function* () {\n  const fiber = yield* Effect.fork(interruptibleTask)\n  // Simulate interrupting the fiber after 1 second\n  yield* Effect.sleep("1 second")\n  yield* Fiber.interrupt(fiber)\n})\n\n// Run the program\nEffect.runPromise(program)\n// Output:\n// Abort signal received'
        }
      ],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4718,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4718"
    },
    {
      id: "Effect.asyncEffect",
      name: "asyncEffect",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R, R3, E2, R2>(register: (callback: (_: Effect<A, E, R>) => void) => Effect<void | Effect<void, never, R3>, E2, R2>) => Effect<A, E | E2, R | R3 | R2>",
      description: "/\n * A variant of {@link async}where the registration function may return an `Effect`.\n *\n *",
      documentation: "/**\n * A variant of {@link async}where the registration function may return an `Effect`.\n *\n *",
      examples: [],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4725,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4725"
    },
    {
      id: "Effect.custom",
      name: "custom",
      module: "Effect",
      package: "effect",
      signature: "{ <X, A, E, R>(i0: X, body: (this: { effect_instruction_i0: X; }) => Effect<A, E, R>): Effect<A, E, R>; <X, Y, A, E, R>(i0: X, i1: Y, body: (this: { effect_instruction_i0: X; effect_instruction_i1: Y; }) => Effect<A, E, R>): Effect<A, E, R>; <X, Y, Z, A, E, R>(i0: X, i1: Y, i2: Z, body: (this: { effect_instruction_i0: X; effect_instruction_i1: Y; effect_instruction_i2: Z; }) => Effect<A, E, R>): Effect<A, E, R>; }",
      description: 'Low level constructor that enables for custom stack tracing cutpoints. It is meant to be called with a bag of instructions that become available in\nthe "this" of the effect.',
      documentation: 'Low level constructor that enables for custom stack tracing cutpoints.\n\nIt is meant to be called with a bag of instructions that become available in\nthe "this" of the effect.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst throwingFunction = () => { throw new Error() }\nconst blowUp = Effect.custom(throwingFunction, function() {\n  return Effect.succeed(this.effect_instruction_i0())\n})\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst throwingFunction = () => { throw new Error() }\nconst blowUp = Effect.custom(throwingFunction, function() {\n  return Effect.succeed(this.effect_instruction_i0())\n})'
        }
      ],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4746,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4746"
    },
    {
      id: "Effect.withFiberRuntime",
      name: "withFiberRuntime",
      module: "Effect",
      package: "effect",
      signature: "<A, E = never, R = never>(withRuntime: (fiber: RuntimeFiber<A, E>, status: Running) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4824,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4824"
    },
    {
      id: "Effect.fail",
      name: "fail",
      module: "Effect",
      package: "effect",
      signature: "<E>(error: E) => Effect<never, E, never>",
      description: "/\n * Creates an `Effect` that represents a recoverable error.\n *\n *",
      documentation: '/**\n * Creates an `Effect` that represents a recoverable error.\n *\n * **When to Use**\n *\n * Use this function to explicitly signal an error in an `Effect`. The error\n * will keep propagating unless it is handled. You can handle the error with\n * functions like {@link catchAll}or {@link catchTag}.\n *\n * **Example** (Creating a Failed Effect)\n *\n * ```ts\n * import { Effect } from "effect"\n *\n * //      \u250C\u2500\u2500\u2500 Effect<never, Error, never>\n * //      \u25BC\n * const failure = Effect.fail(\n *   new Error("Operation failed due to network error")\n * )\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect } from "effect"\n *\n * //      \u250C\u2500\u2500\u2500 Effect<never, Error, never>\n * //      \u25BC\n * const failure = Effect.fail(\n *   new Error("Operation failed due to network error")\n * )\n *'
        }
      ],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4851,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4851"
    },
    {
      id: "Effect.failSync",
      name: "failSync",
      module: "Effect",
      package: "effect",
      signature: "<E>(evaluate: LazyArg<E>) => Effect<never, E, never>",
      description: "Creates an `Effect` that fails with the specified error, evaluated lazily.",
      documentation: "Creates an `Effect` that fails with the specified error, evaluated lazily.",
      examples: [],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4858,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4858"
    },
    {
      id: "Effect.failCause",
      name: "failCause",
      module: "Effect",
      package: "effect",
      signature: "<E>(cause: Cause<E>) => Effect<never, E, never>",
      description: "Creates an `Effect` that fails with the specified `Cause`.",
      documentation: "Creates an `Effect` that fails with the specified `Cause`.",
      examples: [],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4865,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4865"
    },
    {
      id: "Effect.failCauseSync",
      name: "failCauseSync",
      module: "Effect",
      package: "effect",
      signature: "<E>(evaluate: LazyArg<Cause<E>>) => Effect<never, E, never>",
      description: "Creates an `Effect` that fails with the specified `Cause`, evaluated lazily.",
      documentation: "Creates an `Effect` that fails with the specified `Cause`, evaluated lazily.",
      examples: [],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4872,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4872"
    },
    {
      id: "Effect.die",
      name: "die",
      module: "Effect",
      package: "effect",
      signature: "(defect: unknown) => Effect<never, never, never>",
      description: "Creates an effect that terminates a fiber with a specified error.",
      documentation: 'Creates an effect that terminates a fiber with a specified error.\n\n**Details**\n\nThis function is used to signal a defect, which represents a critical and\nunexpected error in the code. When invoked, it produces an effect that does\nnot handle the error and instead terminates the fiber.\n\nThe error channel of the resulting effect is of type `never`, indicating that\nit cannot recover from this failure.\n\n**When to Use**\n\nUse this function when encountering unexpected conditions in your code that\nshould not be handled as regular errors but instead represent unrecoverable\ndefects.\n\n**Example** (Terminating on Division by Zero with a Specified Error)\n\n```ts\nimport { Effect } from "effect"\n\nconst divide = (a: number, b: number) =>\n  b === 0\n    ? Effect.die(new Error("Cannot divide by zero"))\n    : Effect.succeed(a / b)\n\n//      \u250C\u2500\u2500\u2500 Effect<number, never, never>\n//      \u25BC\nconst program = divide(1, 0)\n\nEffect.runPromise(program).catch(console.error)\n// Output:\n// (FiberFailure) Error: Cannot divide by zero\n//   ...stack trace...\n```',
      examples: [
        {
          title: "Terminating on Division by Zero with a Specified Error",
          code: 'import { Effect } from "effect"\n\nconst divide = (a: number, b: number) =>\n  b === 0\n    ? Effect.die(new Error("Cannot divide by zero"))\n    : Effect.succeed(a / b)\n\n//      \u250C\u2500\u2500\u2500 Effect<number, never, never>\n//      \u25BC\nconst program = divide(1, 0)\n\nEffect.runPromise(program).catch(console.error)\n// Output:\n// (FiberFailure) Error: Cannot divide by zero\n//   ...stack trace...'
        }
      ],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4919,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4919"
    },
    {
      id: "Effect.dieMessage",
      name: "dieMessage",
      module: "Effect",
      package: "effect",
      signature: "(message: string) => Effect<never, never, never>",
      description: "Creates an effect that terminates a fiber with a `RuntimeException`\ncontaining the specified message.",
      documentation: 'Creates an effect that terminates a fiber with a `RuntimeException`\ncontaining the specified message.\n\n**Details**\n\nThis function is used to signal a defect, representing a critical and\nunexpected error in the code. When invoked, it produces an effect that\nterminates the fiber with a `RuntimeException` carrying the given message.\n\nThe resulting effect has an error channel of type `never`, indicating it does\nnot handle or recover from the error.\n\n**When to Use**\n\nUse this function when you want to terminate a fiber due to an unrecoverable\ndefect and include a clear explanation in the message.\n\n**Example** (Terminating on Division by Zero with a Specified Message)\n\n```ts\nimport { Effect } from "effect"\n\nconst divide = (a: number, b: number) =>\n  b === 0\n    ? Effect.dieMessage("Cannot divide by zero")\n    : Effect.succeed(a / b)\n\n//      \u250C\u2500\u2500\u2500 Effect<number, never, never>\n//      \u25BC\nconst program = divide(1, 0)\n\nEffect.runPromise(program).catch(console.error)\n// Output:\n// (FiberFailure) RuntimeException: Cannot divide by zero\n//   ...stack trace...\n```',
      examples: [
        {
          title: "Terminating on Division by Zero with a Specified Message",
          code: 'import { Effect } from "effect"\n\nconst divide = (a: number, b: number) =>\n  b === 0\n    ? Effect.dieMessage("Cannot divide by zero")\n    : Effect.succeed(a / b)\n\n//      \u250C\u2500\u2500\u2500 Effect<number, never, never>\n//      \u25BC\nconst program = divide(1, 0)\n\nEffect.runPromise(program).catch(console.error)\n// Output:\n// (FiberFailure) RuntimeException: Cannot divide by zero\n//   ...stack trace...'
        }
      ],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4965,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4965"
    },
    {
      id: "Effect.dieSync",
      name: "dieSync",
      module: "Effect",
      package: "effect",
      signature: "(evaluate: LazyArg<unknown>) => Effect<never, never, never>",
      description: "Creates an effect that dies with the specified error, evaluated lazily.",
      documentation: "Creates an effect that dies with the specified error, evaluated lazily.\n\n**Details**\n\nThis function allows you to create an effect that will terminate with a fatal error.\nThe error is provided as a lazy argument, meaning it will only be evaluated when the effect runs.",
      examples: [],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 4979,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4979"
    },
    {
      id: "Effect.gen",
      name: "gen",
      module: "Effect",
      package: "effect",
      signature: "{ <Eff extends YieldWrap<Effect<any, any, any>>, AEff>(f: (resume: Adapter) => Generator<Eff, AEff, never>): Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never>; <Self, Eff extends YieldWrap<Effect<any, any, any>>, AEff>(self: Self, f: (this: Self, resume: Adapter) => Generator<Eff, AEff, never>): Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never>; }",
      description: "Provides a way to write effectful code using generator functions, simplifying\ncontrol flow and error handling.",
      documentation: 'Provides a way to write effectful code using generator functions, simplifying\ncontrol flow and error handling.\n\n**When to Use**\n\n`Effect.gen` allows you to write code that looks and behaves like synchronous\ncode, but it can handle asynchronous tasks, errors, and complex control flow\n(like loops and conditions). It helps make asynchronous code more readable\nand easier to manage.\n\nThe generator functions work similarly to `async/await` but with more\nexplicit control over the execution of effects. You can `yield*` values from\neffects and return the final result at the end.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst addServiceCharge = (amount: number) => amount + 1\n\nconst applyDiscount = (\n  total: number,\n  discountRate: number\n): Effect.Effect<number, Error> =>\n  discountRate === 0\n    ? Effect.fail(new Error("Discount rate cannot be zero"))\n    : Effect.succeed(total - (total * discountRate) / 100)\n\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\nconst fetchDiscountRate = Effect.promise(() => Promise.resolve(5))\n\nexport const program = Effect.gen(function* () {\n  const transactionAmount = yield* fetchTransactionAmount\n  const discountRate = yield* fetchDiscountRate\n  const discountedAmount = yield* applyDiscount(\n    transactionAmount,\n    discountRate\n  )\n  const finalAmount = addServiceCharge(discountedAmount)\n  return `Final amount to charge: ${finalAmount}`\n})\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst addServiceCharge = (amount: number) => amount + 1\n\nconst applyDiscount = (\n  total: number,\n  discountRate: number\n): Effect.Effect<number, Error> =>\n  discountRate === 0\n    ? Effect.fail(new Error("Discount rate cannot be zero"))\n    : Effect.succeed(total - (total * discountRate) / 100)\n\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\nconst fetchDiscountRate = Effect.promise(() => Promise.resolve(5))\n\nexport const program = Effect.gen(function* () {\n  const transactionAmount = yield* fetchTransactionAmount\n  const discountRate = yield* fetchDiscountRate\n  const discountedAmount = yield* applyDiscount(\n    transactionAmount,\n    discountRate\n  )\n  const finalAmount = addServiceCharge(discountedAmount)\n  return `Final amount to charge: ${finalAmount}`\n})'
        }
      ],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5029,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5029"
    },
    {
      id: "Effect.never",
      name: "never",
      module: "Effect",
      package: "effect",
      signature: "Effect<never, never, never>",
      description: "An effect that that runs indefinitely and never produces any result. The\nmoral equivalent of `while(true) {}`, only without the wasted CPU cycles.",
      documentation: "An effect that that runs indefinitely and never produces any result. The\nmoral equivalent of `while(true) {}`, only without the wasted CPU cycles.\n\n**When to Use**\n\nIt could be useful for long-running background tasks or to simulate waiting\nbehavior without actually consuming resources. This effect is ideal for cases\nwhere you want to keep the program alive or in a certain state without\nperforming any active work.",
      examples: [],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5180,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5180"
    },
    {
      id: "Effect.none",
      name: "none",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<Option<A>, E, R>) => Effect<void, NoSuchElementException | E, R>",
      description: "Ensures the `Option` is `None`, returning `void`. Otherwise, raises a\n`NoSuchElementException`.",
      documentation: "Ensures the `Option` is `None`, returning `void`. Otherwise, raises a\n`NoSuchElementException`.\n\n**Details**\n\nThis function checks if the provided `Option` is `None`. If it is, it returns\nan effect that produces no result (i.e., `void`). If the `Option` is not\n`None` (i.e., it contains a value), the function will raise a\n`NoSuchElementException` error.\n\n**When to Use**\n\nThis is useful when you want to ensure that a certain value is absent (i.e.,\n`None`) before continuing execution, and to handle cases where the value is\nunexpectedly present.",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5200,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5200"
    },
    {
      id: "Effect.promise",
      name: "promise",
      module: "Effect",
      package: "effect",
      signature: "<A>(evaluate: (signal: AbortSignal) => PromiseLike<A>) => Effect<A, never, never>",
      description: "/\n * Creates an `Effect` that represents an asynchronous computation guaranteed to\n * succeed.\n *\n *",
      documentation: '/**\n * Creates an `Effect` that represents an asynchronous computation guaranteed to\n * succeed.\n *\n * **Details**\n *\n * The provided function (`thunk`) returns a `Promise` that should never reject; if it does, the error\n * will be treated as a "defect".\n *\n * This defect is not a standard error but indicates a flaw in the logic that\n * was expected to be error-free. You can think of it similar to an unexpected\n * crash in the program, which can be further managed or logged using tools like\n * {@link catchAllDefect}.\n *\n * **Interruptions**\n *\n * An optional `AbortSignal` can be provided to allow for interruption of the\n * wrapped `Promise` API.\n *\n * **When to Use**\n *\n * Use this function when you are sure the operation will not reject.\n *\n * **Example** (Delayed Message)\n *\n * ```ts\n * import { Effect } from "effect"\n *\n * const delay = (message: string) =>\n *   Effect.promise<string>(\n *     () =>\n *       new Promise((resolve) => {\n *         setTimeout(() => {\n *           resolve(message)\n *         }, 2000)\n *       })\n *   )\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, never, never>\n * //      \u25BC\n * const program = delay("Async operation completed successfully!")\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect } from "effect"\n *\n * const delay = (message: string) =>\n *   Effect.promise<string>(\n *     () =>\n *       new Promise((resolve) => {\n *         setTimeout(() => {\n *           resolve(message)\n *         }, 2000)\n *       })\n *   )\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, never, never>\n * //      \u25BC\n * const program = delay("Async operation completed successfully!")\n *'
        }
      ],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5249,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5249"
    },
    {
      id: "Effect.succeed",
      name: "succeed",
      module: "Effect",
      package: "effect",
      signature: "<A>(value: A) => Effect<A, never, never>",
      description: "Creates an `Effect` that always succeeds with a given value.",
      documentation: 'Creates an `Effect` that always succeeds with a given value.\n\n**When to Use**\n\nUse this function when you need an effect that completes successfully with a\nspecific value without any errors or external dependencies.\n\n**Example** (Creating a Successful Effect)\n\n```ts\nimport { Effect } from "effect"\n\n// Creating an effect that represents a successful scenario\n//\n//      \u250C\u2500\u2500\u2500 Effect<number, never, never>\n//      \u25BC\nconst success = Effect.succeed(42)\n```',
      examples: [
        {
          title: "Creating a Successful Effect",
          code: 'import { Effect } from "effect"\n\n// Creating an effect that represents a successful scenario\n//\n//      \u250C\u2500\u2500\u2500 Effect<number, never, never>\n//      \u25BC\nconst success = Effect.succeed(42)'
        }
      ],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5275,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5275"
    },
    {
      id: "Effect.succeedNone",
      name: "succeedNone",
      module: "Effect",
      package: "effect",
      signature: "Effect<Option<never>, never, never>",
      description: "Returns an effect which succeeds with `None`.",
      documentation: "Returns an effect which succeeds with `None`.\n\n**When to Use**\n\nUse this function when you need to represent the absence of a value in your\ncode, especially when working with optional data. This can be helpful when\nyou want to indicate that no result is available without throwing an error or\nperforming additional logic.",
      examples: [],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5291,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5291"
    },
    {
      id: "Effect.succeedSome",
      name: "succeedSome",
      module: "Effect",
      package: "effect",
      signature: "<A>(value: A) => Effect<Option<A>, never, never>",
      description: "Returns an effect which succeeds with the value wrapped in a `Some`.",
      documentation: "Returns an effect which succeeds with the value wrapped in a `Some`.",
      examples: [],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5300,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5300"
    },
    {
      id: "Effect.suspend",
      name: "suspend",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(effect: LazyArg<Effect<A, E, R>>) => Effect<A, E, R>",
      description: "Delays the creation of an `Effect` until it is actually needed.",
      documentation: 'Delays the creation of an `Effect` until it is actually needed.\n\n**Details**\n\nThe `Effect.suspend` function takes a thunk that represents the effect and\nwraps it in a suspended effect. This means the effect will not be created\nuntil it is explicitly needed, which is helpful in various scenarios:\n- **Lazy Evaluation**: Helps optimize performance by deferring computations,\n  especially when the effect might not be needed, or when its computation is\n  expensive. This also ensures that any side effects or scoped captures are\n  re-executed on each invocation.\n- **Handling Circular Dependencies**: Useful in managing circular\n  dependencies, such as recursive functions that need to avoid eager\n  evaluation to prevent stack overflow.\n- **Unifying Return Types**: Can help TypeScript unify return types in\n  situations where multiple branches of logic return different effects,\n  simplifying type inference.\n\n**When to Use**\n\nUse this function when you need to defer the evaluation of an effect until it\nis required. This is particularly useful for optimizing expensive\ncomputations, managing circular dependencies, or resolving type inference\nissues.\n\n**Example** (Lazy Evaluation with Side Effects)\n\n```ts\nimport { Effect } from "effect"\n\nlet i = 0\n\nconst bad = Effect.succeed(i++)\n\nconst good = Effect.suspend(() => Effect.succeed(i++))\n\nconsole.log(Effect.runSync(bad)) // Output: 0\nconsole.log(Effect.runSync(bad)) // Output: 0\n\nconsole.log(Effect.runSync(good)) // Output: 1\nconsole.log(Effect.runSync(good)) // Output: 2\n```\n\n**Example** (Recursive Fibonacci)\n\n```ts\nimport { Effect } from "effect"\n\nconst blowsUp = (n: number): Effect.Effect<number> =>\n  n < 2\n    ? Effect.succeed(1)\n    : Effect.zipWith(blowsUp(n - 1), blowsUp(n - 2), (a, b) => a + b)\n\nconsole.log(Effect.runSync(blowsUp(32)))\n// crash: JavaScript heap out of memory\n\nconst allGood = (n: number): Effect.Effect<number> =>\n  n < 2\n    ? Effect.succeed(1)\n    : Effect.zipWith(\n        Effect.suspend(() => allGood(n - 1)),\n        Effect.suspend(() => allGood(n - 2)),\n        (a, b) => a + b\n      )\n\nconsole.log(Effect.runSync(allGood(32)))\n// Output: 3524578\n```\n\n**Example** (Using Effect.suspend to Help TypeScript Infer Types)\n\n```ts\nimport { Effect } from "effect"\n\n//   Without suspend, TypeScript may struggle with type inference.\n//   Inferred type:\n//     (a: number, b: number) =>\n//       Effect<never, Error, never> | Effect<number, never, never>\nconst withoutSuspend = (a: number, b: number) =>\n  b === 0\n    ? Effect.fail(new Error("Cannot divide by zero"))\n    : Effect.succeed(a / b)\n\n//   Using suspend to unify return types.\n//   Inferred type:\n//     (a: number, b: number) => Effect<number, Error, never>\nconst withSuspend = (a: number, b: number) =>\n  Effect.suspend(() =>\n    b === 0\n      ? Effect.fail(new Error("Cannot divide by zero"))\n      : Effect.succeed(a / b)\n  )\n```',
      examples: [
        {
          title: "Lazy Evaluation with Side Effects",
          code: 'import { Effect } from "effect"\n\nlet i = 0\n\nconst bad = Effect.succeed(i++)\n\nconst good = Effect.suspend(() => Effect.succeed(i++))\n\nconsole.log(Effect.runSync(bad)) // Output: 0\nconsole.log(Effect.runSync(bad)) // Output: 0\n\nconsole.log(Effect.runSync(good)) // Output: 1\nconsole.log(Effect.runSync(good)) // Output: 2'
        },
        {
          title: "Recursive Fibonacci",
          code: 'import { Effect } from "effect"\n\nconst blowsUp = (n: number): Effect.Effect<number> =>\n  n < 2\n    ? Effect.succeed(1)\n    : Effect.zipWith(blowsUp(n - 1), blowsUp(n - 2), (a, b) => a + b)\n\nconsole.log(Effect.runSync(blowsUp(32)))\n// crash: JavaScript heap out of memory\n\nconst allGood = (n: number): Effect.Effect<number> =>\n  n < 2\n    ? Effect.succeed(1)\n    : Effect.zipWith(\n        Effect.suspend(() => allGood(n - 1)),\n        Effect.suspend(() => allGood(n - 2)),\n        (a, b) => a + b\n      )\n\nconsole.log(Effect.runSync(allGood(32)))\n// Output: 3524578'
        },
        {
          title: "Using Effect.suspend to Help TypeScript Infer Types",
          code: 'import { Effect } from "effect"\n\n//   Without suspend, TypeScript may struggle with type inference.\n//   Inferred type:\n//     (a: number, b: number) =>\n//       Effect<never, Error, never> | Effect<number, never, never>\nconst withoutSuspend = (a: number, b: number) =>\n  b === 0\n    ? Effect.fail(new Error("Cannot divide by zero"))\n    : Effect.succeed(a / b)\n\n//   Using suspend to unify return types.\n//   Inferred type:\n//     (a: number, b: number) => Effect<number, Error, never>\nconst withSuspend = (a: number, b: number) =>\n  Effect.suspend(() =>\n    b === 0\n      ? Effect.fail(new Error("Cannot divide by zero"))\n      : Effect.succeed(a / b)\n  )'
        }
      ],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5399,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5399"
    },
    {
      id: "Effect.sync",
      name: "sync",
      module: "Effect",
      package: "effect",
      signature: "<A>(thunk: LazyArg<A>) => Effect<A, never, never>",
      description: "/\n * Creates an `Effect` that represents a synchronous side-effectful computation.\n *\n *",
      documentation: '/**\n * Creates an `Effect` that represents a synchronous side-effectful computation.\n *\n * **Details**\n *\n * The provided function (`thunk`) must not throw errors; if it does, the error\n * will be treated as a "defect".\n *\n * This defect is not a standard error but indicates a flaw in the logic that\n * was expected to be error-free. You can think of it similar to an unexpected\n * crash in the program, which can be further managed or logged using tools like\n * {@link catchAllDefect}.\n *\n * **When to Use**\n *\n * Use this function when you are sure the operation will not fail.\n *\n * **Example** (Logging a Message)\n *\n * ```ts\n * import { Effect } from "effect"\n *\n * const log = (message: string) =>\n *   Effect.sync(() => {\n *     console.log(message) // side effect\n *   })\n *\n * //      \u250C\u2500\u2500\u2500 Effect<void, never, never>\n * //      \u25BC\n * const program = log("Hello, World!")\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect } from "effect"\n *\n * const log = (message: string) =>\n *   Effect.sync(() => {\n *     console.log(message) // side effect\n *   })\n *\n * //      \u250C\u2500\u2500\u2500 Effect<void, never, never>\n * //      \u25BC\n * const program = log("Hello, World!")\n *'
        }
      ],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5437,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5437"
    },
    {
      id: "Effect.yieldNow",
      name: "yieldNow",
      module: "Effect",
      package: "effect",
      signature: "(options?: { readonly priority?: number; }) => Effect<void, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5459,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5459"
    },
    {
      id: "Effect.catchAll",
      name: "catchAll",
      module: "Effect",
      package: "effect",
      signature: "{ <E, A2, E2, R2>(f: (e: E) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (e: E) => Effect<A2, E2, R2>): Effect<A | A2, E2, R | R2>; }",
      description: "Handles all errors in an effect by providing a fallback effect.",
      documentation: 'Handles all errors in an effect by providing a fallback effect.\n\n**Details**\n\nThis function catches any errors that may occur during the execution of an\neffect and allows you to handle them by specifying a fallback effect. This\nensures that the program continues without failing by recovering from errors\nusing the provided fallback logic.\n\n**Note**: This function only handles recoverable errors. It will not recover\nfrom unrecoverable defects.\n\n**Example** (Providing Recovery Logic for Recoverable Errors)\n\n```ts\nimport { Effect, Random } from "effect"\n\nclass HttpError {\n  readonly _tag = "HttpError"\n}\n\nclass ValidationError {\n  readonly _tag = "ValidationError"\n}\n\n//      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return "some result"\n})\n\n//      \u250C\u2500\u2500\u2500 Effect<string, never, never>\n//      \u25BC\nconst recovered = program.pipe(\n  Effect.catchAll((error) =>\n    Effect.succeed(`Recovering from ${error._tag}`)\n  )\n)\n```',
      examples: [
        {
          title: "Providing Recovery Logic for Recoverable Errors",
          code: 'import { Effect, Random } from "effect"\n\nclass HttpError {\n  readonly _tag = "HttpError"\n}\n\nclass ValidationError {\n  readonly _tag = "ValidationError"\n}\n\n//      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return "some result"\n})\n\n//      \u250C\u2500\u2500\u2500 Effect<string, never, never>\n//      \u25BC\nconst recovered = program.pipe(\n  Effect.catchAll((error) =>\n    Effect.succeed(`Recovering from ${error._tag}`)\n  )\n)'
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5582,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5582"
    },
    {
      id: "Effect.catchAllCause",
      name: "catchAllCause",
      module: "Effect",
      package: "effect",
      signature: "{ <E, A2, E2, R2>(f: (cause: Cause<E>) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause<E>) => Effect<A2, E2, R2>): Effect<A | A2, E2, R | R2>; }",
      description: "Handles both recoverable and unrecoverable errors by providing a recovery\neffect.",
      documentation: 'Handles both recoverable and unrecoverable errors by providing a recovery\neffect.\n\n**When to Use**\n\nThe `catchAllCause` function allows you to handle all errors, including\nunrecoverable defects, by providing a recovery effect. The recovery logic is\nbased on the `Cause` of the error, which provides detailed information about\nthe failure.\n\n**When to Recover from Defects**\n\nDefects are unexpected errors that typically shouldn\'t be recovered from, as\nthey often indicate serious issues. However, in some cases, such as\ndynamically loaded plugins, controlled recovery might be needed.\n\n**Example** (Recovering from All Errors)\n\n```ts\nimport { Cause, Effect } from "effect"\n\n// Define an effect that may fail with a recoverable or unrecoverable error\nconst program = Effect.fail("Something went wrong!")\n\n// Recover from all errors by examining the cause\nconst recovered = program.pipe(\n  Effect.catchAllCause((cause) =>\n    Cause.isFailure(cause)\n      ? Effect.succeed("Recovered from a regular error")\n      : Effect.succeed("Recovered from a defect")\n  )\n)\n\nEffect.runPromise(recovered).then(console.log)\n// Output: "Recovered from a regular error"\n```',
      examples: [
        {
          title: "Recovering from All Errors",
          code: 'import { Cause, Effect } from "effect"\n\n// Define an effect that may fail with a recoverable or unrecoverable error\nconst program = Effect.fail("Something went wrong!")\n\n// Recover from all errors by examining the cause\nconst recovered = program.pipe(\n  Effect.catchAllCause((cause) =>\n    Cause.isFailure(cause)\n      ? Effect.succeed("Recovered from a regular error")\n      : Effect.succeed("Recovered from a defect")\n  )\n)\n\nEffect.runPromise(recovered).then(console.log)\n// Output: "Recovered from a regular error"'
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5737,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5737"
    },
    {
      id: "Effect.catchAllDefect",
      name: "catchAllDefect",
      module: "Effect",
      package: "effect",
      signature: "{ <A2, E2, R2>(f: (defect: unknown) => Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (defect: unknown) => Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }",
      description: "/\n * Recovers from all defects using a provided recovery function.\n *\n *",
      documentation: '/**\n * Recovers from all defects using a provided recovery function.\n *\n * **When to Use**\n *\n * There is no sensible way to recover from defects. This method should be used\n * only at the boundary between Effect and an external system, to transmit\n * information on a defect for diagnostic or explanatory purposes.\n *\n * **Details**\n *\n * `catchAllDefect` allows you to handle defects, which are unexpected errors\n * that usually cause the program to terminate. This function lets you recover\n * from these defects by providing a function that handles the error. However,\n * it does not handle expected errors (like those from {@link fail}) or\n * execution interruptions (like those from {@link interrupt}).\n *\n * **When to Recover from Defects**\n *\n * Defects are unexpected errors that typically shouldn\'t be recovered from, as\n * they often indicate serious issues. However, in some cases, such as\n * dynamically loaded plugins, controlled recovery might be needed.\n *\n * **Example** (Handling All Defects)\n *\n * ```ts\n * import { Effect, Cause, Console } from "effect"\n *\n * // Simulating a runtime error\n * const task = Effect.dieMessage("Boom!")\n *\n * const program = Effect.catchAllDefect(task, (defect) => {\n *   if (Cause.isRuntimeException(defect)) {\n *     return Console.log(\n *       `RuntimeException defect caught: ${defect.message}`\n *     )\n *   }\n *   return Console.log("Unknown defect caught.")\n * })\n *\n * // We get an Exit.Success because we caught all defects\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // RuntimeException defect caught: Boom!\n * // {\n * //   _id: "Exit",\n * //   _tag: "Success",\n * //   value: undefined\n * // }\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect, Cause, Console } from "effect"\n *\n * // Simulating a runtime error\n * const task = Effect.dieMessage("Boom!")\n *\n * const program = Effect.catchAllDefect(task, (defect) => {\n *   if (Cause.isRuntimeException(defect)) {\n *     return Console.log(\n *       `RuntimeException defect caught: ${defect.message}`\n *     )\n *   }\n *   return Console.log("Unknown defect caught.")\n * })\n *\n * // We get an Exit.Success because we caught all defects\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // RuntimeException defect caught: Boom!\n * // {\n * //   _id: "Exit",\n * //   _tag: "Success",\n * //   value: undefined\n * // }\n *'
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 5877,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L5877"
    },
    {
      id: "Effect.catchIf",
      name: "catchIf",
      module: "Effect",
      package: "effect",
      signature: "{ <E, EB extends E, A2, E2, R2>(refinement: Refinement<NoInfer<E>, EB>, f: (e: EB) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | Exclude<E, EB>, R2 | R>; <E, A2, E2, R2>(predicate: Predicate<NoInfer<E>>, f: (e: NoInfer<E>) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>; <A, E, R, EB extends E, A2, E2, R2>(self: Effect<A, E, R>, refinement: Refinement<E, EB>, f: (e: EB) => Effect<A2, E2, R2>): Effect<A | A2, E2 | Exclude<E, EB>, R | R2>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, predicate: Predicate<E>, f: (e: E) => Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }",
      description: "/\n * Recovers from specific errors based on a predicate.\n *\n *",
      documentation: '/**\n * Recovers from specific errors based on a predicate.\n *\n * **When to Use**\n *\n * `catchIf` works similarly to {@link catchSome}, but it allows you to\n * recover from errors by providing a predicate function. If the predicate\n * matches the error, the recovery effect is applied. This function doesn\'t\n * alter the error type, so the resulting effect still carries the original\n * error type unless a user-defined type guard is used to narrow the type.\n *\n * **Example** (Catching Specific Errors with a Predicate)\n *\n * ```ts\n * import { Effect, Random } from "effect"\n *\n * class HttpError {\n *   readonly _tag = "HttpError"\n * }\n *\n * class ValidationError {\n *   readonly _tag = "ValidationError"\n * }\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n * //      \u25BC\n * const program = Effect.gen(function* () {\n *   const n1 = yield* Random.next\n *   const n2 = yield* Random.next\n *   if (n1 < 0.5) {\n *     yield* Effect.fail(new HttpError())\n *   }\n *   if (n2 < 0.5) {\n *     yield* Effect.fail(new ValidationError())\n *   }\n *   return "some result"\n * })\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, ValidationError, never>\n * //      \u25BC\n * const recovered = program.pipe(\n *   Effect.catchIf(\n *     // Only handle HttpError errors\n *     (error) => error._tag === "HttpError",\n *     () => Effect.succeed("Recovering from HttpError")\n *   )\n * )\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect, Random } from "effect"\n *\n * class HttpError {\n *   readonly _tag = "HttpError"\n * }\n *\n * class ValidationError {\n *   readonly _tag = "ValidationError"\n * }\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n * //      \u25BC\n * const program = Effect.gen(function* () {\n *   const n1 = yield* Random.next\n *   const n2 = yield* Random.next\n *   if (n1 < 0.5) {\n *     yield* Effect.fail(new HttpError())\n *   }\n *   if (n2 < 0.5) {\n *     yield* Effect.fail(new ValidationError())\n *   }\n *   return "some result"\n * })\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, ValidationError, never>\n * //      \u25BC\n * const recovered = program.pipe(\n *   Effect.catchIf(\n *     // Only handle HttpError errors\n *     (error) => error._tag === "HttpError",\n *     () => Effect.succeed("Recovering from HttpError")\n *   )\n * )\n *'
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 6041,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L6041"
    },
    {
      id: "Effect.catchSome",
      name: "catchSome",
      module: "Effect",
      package: "effect",
      signature: "{ <E, A2, E2, R2>(pf: (e: NoInfer<E>) => Option<Effect<A2, E2, R2>>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, pf: (e: NoInfer<E>) => Option<Effect<A2, E2, R2>>): Effect<A | A2, E | E2, R | R2>; }",
      description: "Catches and recovers from specific types of errors, allowing you to attempt\nrecovery only for certain errors.",
      documentation: 'Catches and recovers from specific types of errors, allowing you to attempt\nrecovery only for certain errors.\n\n**Details**\n\n`catchSome` lets you selectively catch and handle errors of certain\ntypes by providing a recovery effect for specific errors. If the error\nmatches a condition, recovery is attempted; if not, it doesn\'t affect the\nprogram. This function doesn\'t alter the error type, meaning the error type\nremains the same as in the original effect.\n\n**Example** (Handling Specific Errors with Effect.catchSome)\n\n```ts\nimport { Effect, Random, Option } from "effect"\n\nclass HttpError {\n  readonly _tag = "HttpError"\n}\n\nclass ValidationError {\n  readonly _tag = "ValidationError"\n}\n\n//      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return "some result"\n})\n\n//      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n//      \u25BC\nconst recovered = program.pipe(\n  Effect.catchSome((error) => {\n    // Only handle HttpError errors\n    if (error._tag === "HttpError") {\n      return Option.some(Effect.succeed("Recovering from HttpError"))\n    } else {\n      return Option.none()\n    }\n  })\n)\n```',
      examples: [
        {
          title: "Handling Specific Errors with Effect.catchSome",
          code: 'import { Effect, Random, Option } from "effect"\n\nclass HttpError {\n  readonly _tag = "HttpError"\n}\n\nclass ValidationError {\n  readonly _tag = "ValidationError"\n}\n\n//      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return "some result"\n})\n\n//      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n//      \u25BC\nconst recovered = program.pipe(\n  Effect.catchSome((error) => {\n    // Only handle HttpError errors\n    if (error._tag === "HttpError") {\n      return Option.some(Effect.succeed("Recovering from HttpError"))\n    } else {\n      return Option.none()\n    }\n  })\n)'
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 6313,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L6313"
    },
    {
      id: "Effect.catchSomeCause",
      name: "catchSomeCause",
      module: "Effect",
      package: "effect",
      signature: "{ <E, A2, E2, R2>(f: (cause: Cause<NoInfer<E>>) => Option<Effect<A2, E2, R2>>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause<NoInfer<E>>) => Option<Effect<A2, E2, R2>>): Effect<A | A2, E | E2, R | R2>; }",
      description: "Recovers from specific causes using a provided partial function.",
      documentation: "Recovers from specific causes using a provided partial function.",
      examples: [],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 6442,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L6442"
    },
    {
      id: "Effect.catchSomeDefect",
      name: "catchSomeDefect",
      module: "Effect",
      package: "effect",
      signature: "{ <A2, E2, R2>(pf: (defect: unknown) => Option<Effect<A2, E2, R2>>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, pf: (defect: unknown) => Option<Effect<A2, E2, R2>>): Effect<A | A2, E | E2, R | R2>; }",
      description: "/\n * Recovers from specific defects using a provided partial function.\n *\n *",
      documentation: "/**\n * Recovers from specific defects using a provided partial function.\n *\n * **Details**\n *\n * `catchSomeDefect` allows you to handle specific defects, which are\n * unexpected errors that can cause the program to stop. It uses a partial\n * function to catch only certain defects and ignores others. The function does\n * not handle expected errors (such as those caused by {@link fail}) or\n * interruptions in execution (like those caused by {@link interrupt}).\n *\n * This function provides a way to handle certain types of defects while\n * allowing others to propagate and cause failure in the program.\n *\n * **Note**: There is no sensible way to recover from defects. This method\n * should be used only at the boundary between Effect and an external system, to\n * transmit information on a defect for diagnostic or explanatory purposes.\n *\n * **How the Partial Function Works**\n *\n * The function provided to `catchSomeDefect` acts as a filter and a handler for defects:\n * - It receives the defect as an input.\n * - If the defect matches a specific condition (e.g., a certain error type), the function returns\n *   an `Option.some` containing the recovery logic.\n * - If the defect does not match, the function returns `Option.none`, allowing the defect to propagate.\n *\n * **Example** (Handling Specific Defects)\n *\n * ```ts\n * import { Effect, Cause, Option, Console } from \"effect\"\n *\n * // Simulating a runtime error\n * const task = Effect.dieMessage(\"Boom!\")\n *\n * const program = Effect.catchSomeDefect(task, (defect) => {\n *   if (Cause.isIllegalArgumentException(defect)) {\n *     return Option.some(\n *       Console.log(\n *         `Caught an IllegalArgumentException defect: ${defect.message}`\n *       )\n *     )\n *   }\n *   return Option.none()\n * })\n *\n * // Since we are only catching IllegalArgumentException\n * // we will get an Exit.Failure because we simulated a runtime error.\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: {\n * //     _id: 'Cause',\n * //     _tag: 'Die',\n * //     defect: { _tag: 'RuntimeException' }\n * //   }\n * // }\n * ```\n *\n *",
      examples: [
        {
          code: `* import { Effect, Cause, Option, Console } from "effect"
 *
 * // Simulating a runtime error
 * const task = Effect.dieMessage("Boom!")
 *
 * const program = Effect.catchSomeDefect(task, (defect) => {
 *   if (Cause.isIllegalArgumentException(defect)) {
 *     return Option.some(
 *       Console.log(
 *         \`Caught an IllegalArgumentException defect: \${defect.message}\`
 *       )
 *     )
 *   }
 *   return Option.none()
 * })
 *
 * // Since we are only catching IllegalArgumentException
 * // we will get an Exit.Failure because we simulated a runtime error.
 * Effect.runPromiseExit(program).then(console.log)
 * // Output:
 * // {
 * //   _id: 'Exit',
 * //   _tag: 'Failure',
 * //   cause: {
 * //     _id: 'Cause',
 * //     _tag: 'Die',
 * //     defect: { _tag: 'RuntimeException' }
 * //   }
 * // }
 *`
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 6527,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L6527"
    },
    {
      id: "Effect.catchTag",
      name: "catchTag",
      module: "Effect",
      package: "effect",
      signature: '{ <E, const K extends RA.NonEmptyReadonlyArray<E extends { _tag: string; } ? E["_tag"] : never>, A1, E1, R1>(...args: [...tags: K, f: (e: Extract<NoInfer<E>, { _tag: K[number]; }>) => Effect<A1, E1, R1>]): <A, R>(self: Effect<A, E, R>) => Effect<A1 | A, E1 | Exclude<E, { _tag: K[number]; }>, R1 | R>; <A, E, R, const K extends RA.NonEmptyReadonlyArray<E extends { _tag: string; } ? E["_tag"] : never>, A1, E1, R1>(self: Effect<A, E, R>, ...args: [...tags: K, f: (e: Extract<NoInfer<E>, { _tag: K[number]; }>) => Effect<A1, E1, R1>]): Effect<A | A1, E1 | Exclude<E, { _tag: K[number]; }>, R | R1>; }',
      description: "Catches and handles specific errors by their `_tag` field, which is used as a\ndiscriminator.",
      documentation: 'Catches and handles specific errors by their `_tag` field, which is used as a\ndiscriminator.\n\n**When to Use**\n\n`catchTag` is useful when your errors are tagged with a readonly `_tag` field\nthat identifies the error type. You can use this function to handle specific\nerror types by matching the `_tag` value. This allows for precise error\nhandling, ensuring that only specific errors are caught and handled.\n\nThe error type must have a readonly `_tag` field to use `catchTag`. This\nfield is used to identify and match errors.\n\n**Example** (Handling Errors by Tag)\n\n```ts\nimport { Effect, Random } from "effect"\n\nclass HttpError {\n  readonly _tag = "HttpError"\n}\n\nclass ValidationError {\n  readonly _tag = "ValidationError"\n}\n\n//      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return "some result"\n})\n\n//      \u250C\u2500\u2500\u2500 Effect<string, ValidationError, never>\n//      \u25BC\nconst recovered = program.pipe(\n  // Only handle HttpError errors\n  Effect.catchTag("HttpError", (_HttpError) =>\n    Effect.succeed("Recovering from HttpError")\n  )\n)\n```',
      examples: [
        {
          title: "Handling Errors by Tag",
          code: 'import { Effect, Random } from "effect"\n\nclass HttpError {\n  readonly _tag = "HttpError"\n}\n\nclass ValidationError {\n  readonly _tag = "ValidationError"\n}\n\n//      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return "some result"\n})\n\n//      \u250C\u2500\u2500\u2500 Effect<string, ValidationError, never>\n//      \u25BC\nconst recovered = program.pipe(\n  // Only handle HttpError errors\n  Effect.catchTag("HttpError", (_HttpError) =>\n    Effect.succeed("Recovering from HttpError")\n  )\n)'
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 6714,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L6714"
    },
    {
      id: "Effect.catchTags",
      name: "catchTags",
      module: "Effect",
      package: "effect",
      signature: '{ <E, Cases extends { [K in Extract<E, { _tag: string; }>["_tag"]]+?: ((error: Extract<E, { _tag: K; }>) => Effect<any, any, any>); } & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string; }>["_tag"]>]: never; })>(cases: Cases): <A, R>(self: Effect<A, E, R>) => Effect<A | { [K in keyof Cases]: Cases[K] extends (...args: any[]) => Effect<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: any[]) => Effect<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: any[]) => Effect<any, any, infer R> ? R : never; }[keyof Cases]>; <R, E, A, Cases extends { [K in Extract<E, { _tag: string; }>["_tag"]]+?: ((error: Extract<E, { _tag: K; }>) => Effect<any, any, any>); } & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string; }>["_tag"]>]: never; })>(self: Effect<A, E, R>, cases: Cases): Effect<A | { [K in keyof Cases]: Cases[K] extends (...args: any[]) => Effect<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: any[]) => Effect<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: any[]) => Effect<any, any, infer R> ? R : never; }[keyof Cases]>; }',
      description: "/\n * Handles multiple errors in a single block of code using their `_tag` field.\n *\n *",
      documentation: '/**\n * Handles multiple errors in a single block of code using their `_tag` field.\n *\n * **When to Use**\n *\n * `catchTags` is a convenient way to handle multiple error types at\n * once. Instead of using {@link catchTag}multiple times, you can pass an\n * object where each key is an error type\'s `_tag`, and the value is the handler\n * for that specific error. This allows you to catch and recover from multiple\n * error types in a single call.\n *\n * The error type must have a readonly `_tag` field to use `catchTag`. This\n * field is used to identify and match errors.\n *\n * **Example** (Handling Multiple Tagged Error Types at Once)\n *\n * ```ts\n * import { Effect, Random } from "effect"\n *\n * class HttpError {\n *   readonly _tag = "HttpError"\n * }\n *\n * class ValidationError {\n *   readonly _tag = "ValidationError"\n * }\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n * //      \u25BC\n * const program = Effect.gen(function* () {\n *   const n1 = yield* Random.next\n *   const n2 = yield* Random.next\n *   if (n1 < 0.5) {\n *     yield* Effect.fail(new HttpError())\n *   }\n *   if (n2 < 0.5) {\n *     yield* Effect.fail(new ValidationError())\n *   }\n *   return "some result"\n * })\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, never, never>\n * //      \u25BC\n * const recovered = program.pipe(\n *   Effect.catchTags({\n *     HttpError: (_HttpError) =>\n *       Effect.succeed(`Recovering from HttpError`),\n *     ValidationError: (_ValidationError) =>\n *       Effect.succeed(`Recovering from ValidationError`)\n *   })\n * )\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect, Random } from "effect"\n *\n * class HttpError {\n *   readonly _tag = "HttpError"\n * }\n *\n * class ValidationError {\n *   readonly _tag = "ValidationError"\n * }\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n * //      \u25BC\n * const program = Effect.gen(function* () {\n *   const n1 = yield* Random.next\n *   const n2 = yield* Random.next\n *   if (n1 < 0.5) {\n *     yield* Effect.fail(new HttpError())\n *   }\n *   if (n2 < 0.5) {\n *     yield* Effect.fail(new ValidationError())\n *   }\n *   return "some result"\n * })\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, never, never>\n * //      \u25BC\n * const recovered = program.pipe(\n *   Effect.catchTags({\n *     HttpError: (_HttpError) =>\n *       Effect.succeed(`Recovering from HttpError`),\n *     ValidationError: (_ValidationError) =>\n *       Effect.succeed(`Recovering from ValidationError`)\n *   })\n * )\n *'
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 6900,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L6900"
    },
    {
      id: "Effect.cause",
      name: "cause",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<Cause<E>, never, R>",
      description: "Retrieves the cause of a failure in an effect.",
      documentation: 'Retrieves the cause of a failure in an effect.\n\n**Details**\n\nThis function allows you to expose the detailed cause of an effect, which\nincludes a more precise representation of failures, such as error messages\nand defects.\n\n**When to Use**\n\nThis function is helpful when you need to inspect the cause of a failure in\nan effect, giving you more information than just the error message. It can be\nused to log, handle, or analyze failures in more detail, including\ndistinguishing between different types of defects (e.g., runtime exceptions,\ninterruptions, etc.).\n\n**Example**\n\n```ts\nimport { Effect, Console } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, string, never>\n//      \u25BC\nconst program = Effect.fail("Oh uh!").pipe(Effect.as(2))\n\n//      \u250C\u2500\u2500\u2500 Effect<void, never, never>\n//      \u25BC\nconst recovered = Effect.gen(function* () {\n  const cause = yield* Effect.cause(program)\n  yield* Console.log(cause)\n})\n```',
      examples: [
        {
          code: 'import { Effect, Console } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, string, never>\n//      \u25BC\nconst program = Effect.fail("Oh uh!").pipe(Effect.as(2))\n\n//      \u250C\u2500\u2500\u2500 Effect<void, never, never>\n//      \u25BC\nconst recovered = Effect.gen(function* () {\n  const cause = yield* Effect.cause(program)\n  yield* Console.log(cause)\n})'
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 7089,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L7089"
    },
    {
      id: "Effect.eventually",
      name: "eventually",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, never, R>",
      description: "Runs an effect repeatedly until it succeeds, ignoring errors.",
      documentation: 'Runs an effect repeatedly until it succeeds, ignoring errors.\n\n**Details**\n\nThis function takes an effect and runs it repeatedly until the effect\nsuccessfully completes. If the effect fails, it will ignore the error and\nretry the operation. This is useful when you need to perform a task that may\nfail occasionally, but you want to keep trying until it eventually succeeds.\nIt works by repeatedly executing the effect until it no longer throws an\nerror.\n\n**When to Use**\n\nUse this function when you want to retry an operation multiple times until it\nsucceeds. It is helpful in cases where the operation may fail temporarily\n(e.g., a network request), and you want to keep trying without handling or\nworrying about the errors.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nlet counter = 0\n\nconst effect = Effect.try(() => {\n  counter++\n  if (counter < 3) {\n    console.log("running effect")\n    throw new Error("error")\n  } else {\n    console.log("effect done")\n    return "some result"\n  }\n})\n\nconst program = Effect.eventually(effect)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// running effect\n// running effect\n// effect done\n// some result\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nlet counter = 0\n\nconst effect = Effect.try(() => {\n  counter++\n  if (counter < 3) {\n    console.log("running effect")\n    throw new Error("error")\n  } else {\n    console.log("effect done")\n    return "some result"\n  }\n})\n\nconst program = Effect.eventually(effect)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// running effect\n// running effect\n// effect done\n// some result'
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 7140,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L7140"
    },
    {
      id: "Effect.ignore",
      name: "ignore",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<void, never, R>",
      description: "Discards both the success and failure values of an effect.",
      documentation: 'Discards both the success and failure values of an effect.\n\n**When to Use**\n\n`ignore` allows you to run an effect without caring about its result, whether\nit succeeds or fails. This is useful when you only care about the side\neffects of the effect and do not need to handle or process its outcome.\n\n**Example** (Using Effect.ignore to Discard Values)\n\n```ts\nimport { Effect } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, string, never>\n//      \u25BC\nconst task = Effect.fail("Uh oh!").pipe(Effect.as(5))\n\n//      \u250C\u2500\u2500\u2500 Effect<void, never, never>\n//      \u25BC\nconst program = Effect.ignore(task)\n```',
      examples: [
        {
          title: "Using Effect.ignore to Discard Values",
          code: 'import { Effect } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, string, never>\n//      \u25BC\nconst task = Effect.fail("Uh oh!").pipe(Effect.as(5))\n\n//      \u250C\u2500\u2500\u2500 Effect<void, never, never>\n//      \u25BC\nconst program = Effect.ignore(task)'
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 7169,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L7169"
    },
    {
      id: "Effect.ignoreLogged",
      name: "ignoreLogged",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<void, never, R>",
      description: "Ignores the result of an effect but logs any failures.",
      documentation: "Ignores the result of an effect but logs any failures.\n\n**Details**\n\nThis function takes an effect and returns a new effect that ignores whether\nthe original effect succeeds or fails. However, if the effect fails, it will\nlog the failure at the Debug level, so you can keep track of any issues that\narise.\n\n**When to Use**\n\nThis is useful in scenarios where you want to continue with your program\nregardless of the result of the effect, but you still want to be aware of\npotential failures that may need attention later.",
      examples: [],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 7189,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L7189"
    },
    {
      id: "Effect.parallelErrors",
      name: "parallelErrors",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, E[], R>",
      description: "Combines all errors from concurrent operations into a single error.",
      documentation: `Combines all errors from concurrent operations into a single error.

**Details**

This function is used when you have multiple operations running at the same
time, and you want to capture all the errors that occur across those
operations. Instead of handling each error separately, it combines all the
errors into one unified error.

**When to Use**

When using this function, any errors that occur in the concurrently running
operations will be grouped together into a single error. This helps simplify
error handling in cases where you don't need to differentiate between each
failure, but simply want to know that multiple failures occurred.

**Example**

\`\`\`ts
import { Effect } from "effect"

const fail1 = Effect.fail("Oh uh!")
const fail2 = Effect.fail("Oh no!")
const die = Effect.dieMessage("Boom!")

// Run all effects concurrently and capture all errors
const program = Effect.all([fail1, fail2, die], {
  concurrency: "unbounded"
}).pipe(Effect.asVoid, Effect.parallelErrors)

Effect.runPromiseExit(program).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: [ 'Oh uh!', 'Oh no!' ] }
// }
\`\`\``,
      examples: [
        {
          code: `import { Effect } from "effect"

const fail1 = Effect.fail("Oh uh!")
const fail2 = Effect.fail("Oh no!")
const die = Effect.dieMessage("Boom!")

// Run all effects concurrently and capture all errors
const program = Effect.all([fail1, fail2, die], {
  concurrency: "unbounded"
}).pipe(Effect.asVoid, Effect.parallelErrors)

Effect.runPromiseExit(program).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: [ 'Oh uh!', 'Oh no!' ] }
// }`
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 7233,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L7233"
    },
    {
      id: "Effect.sandbox",
      name: "sandbox",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, Cause<E>, R>",
      description: "/\n * Transforms an effect to expose detailed error causes.\n *\n *",
      documentation: '/**\n * Transforms an effect to expose detailed error causes.\n *\n * **Details**\n *\n * This function enhances an effect by providing detailed information about any\n * error, defect, or interruption that may occur during its execution. It\n * modifies the error channel of the effect so that it includes a full cause of\n * the failure, wrapped in a `Cause<E>` type.\n *\n * After applying this function, you can use operators like {@link catchAll}and\n * {@link catchTags}to handle specific types of errors.\n *\n * If you no longer need the detailed cause information, you can revert the\n * changes using {@link unsandbox}to return to the original error-handling\n * behavior.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Console } from "effect"\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, Error, never>\n * //      \u25BC\n * const task = Effect.fail(new Error("Oh uh!")).pipe(\n *   Effect.as("primary result")\n * )\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, Cause<Error>, never>\n * //      \u25BC\n * const sandboxed = Effect.sandbox(task)\n *\n * const program = Effect.catchTags(sandboxed, {\n *   Die: (cause) =>\n *     Console.log(`Caught a defect: ${cause.defect}`).pipe(\n *       Effect.as("fallback result on defect")\n *     ),\n *   Interrupt: (cause) =>\n *     Console.log(`Caught a defect: ${cause.fiberId}`).pipe(\n *       Effect.as("fallback result on fiber interruption")\n *     ),\n *   Fail: (cause) =>\n *     Console.log(`Caught a defect: ${cause.error}`).pipe(\n *       Effect.as("fallback result on failure")\n *     )\n * })\n *\n * // Restore the original error handling with unsandbox\n * const main = Effect.unsandbox(program)\n *\n * Effect.runPromise(main).then(console.log)\n * // Output:\n * // Caught a defect: Oh uh!\n * // fallback result on failure\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect, Console } from "effect"\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, Error, never>\n * //      \u25BC\n * const task = Effect.fail(new Error("Oh uh!")).pipe(\n *   Effect.as("primary result")\n * )\n *\n * //      \u250C\u2500\u2500\u2500 Effect<string, Cause<Error>, never>\n * //      \u25BC\n * const sandboxed = Effect.sandbox(task)\n *\n * const program = Effect.catchTags(sandboxed, {\n *   Die: (cause) =>\n *     Console.log(`Caught a defect: ${cause.defect}`).pipe(\n *       Effect.as("fallback result on defect")\n *     ),\n *   Interrupt: (cause) =>\n *     Console.log(`Caught a defect: ${cause.fiberId}`).pipe(\n *       Effect.as("fallback result on fiber interruption")\n *     ),\n *   Fail: (cause) =>\n *     Console.log(`Caught a defect: ${cause.error}`).pipe(\n *       Effect.as("fallback result on failure")\n *     )\n * })\n *\n * // Restore the original error handling with unsandbox\n * const main = Effect.unsandbox(program)\n *\n * Effect.runPromise(main).then(console.log)\n * // Output:\n * // Caught a defect: Oh uh!\n * // fallback result on failure\n *'
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 7295,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L7295"
    },
    {
      id: "Effect.retry",
      name: "retry",
      module: "Effect",
      package: "effect",
      signature: "{ <E, O extends NoExcessProperties<Retry.Options<E>, O>>(options: O): <A, R>(self: Effect<A, E, R>) => Effect<A, (O extends { schedule: Schedule<infer _O, infer _I, infer _R>; } ? E : O extends { until: Refinement<E, infer E2 extends E>; } ? E2 : E) | (O extends { while: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never), R | (O extends { schedule: Schedule<infer _O, infer _I, infer R>; } ? R : never) | (O extends { while: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never)>; <B, E, R1>(policy: Schedule<B, NoInfer<E>, R1>): <A, R>(self: Effect<A, E, R>) => Effect<A, E, R1 | R>; <A, E, R, O extends NoExcessProperties<Retry.Options<E>, O>>(self: Effect<A, E, R>, options: O): Effect<A, (O extends { schedule: Schedule<infer _O, infer _I, infer _R>; } ? E : O extends { until: Refinement<E, infer E2 extends E>; } ? E2 : E) | (O extends { while: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never), R | (O extends { schedule: Schedule<infer _O, infer _I, infer R>; } ? R : never) | (O extends { while: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never)>; <A, E, R, B, R1>(self: Effect<A, E, R>, policy: Schedule<B, NoInfer<E>, R1>): Effect<A, E, R | R1>; }",
      description: "/\n * Retries a failing effect based on a defined retry policy.\n *\n *",
      documentation: '/**\n * Retries a failing effect based on a defined retry policy.\n *\n * **Details**\n *\n * The `Effect.retry` function takes an effect and a {@link Schedule}policy,\n * and will automatically retry the effect if it fails, following the rules of\n * the policy.\n *\n * If the effect ultimately succeeds, the result will be returned.\n *\n * If the maximum retries are exhausted and the effect still fails, the failure\n * is propagated.\n *\n * **When to Use**\n *\n * This can be useful when dealing with intermittent failures, such as network\n * issues or temporary resource unavailability. By defining a retry policy, you\n * can control the number of retries, the delay between them, and when to stop\n * retrying.\n *\n * **Example** (Retrying with a Fixed Delay)\n *\n * ```ts\n * import { Effect, Schedule } from "effect"\n *\n * let count = 0\n *\n * // Simulates an effect with possible failures\n * const task = Effect.async<string, Error>((resume) => {\n *   if (count <= 2) {\n *     count++\n *     console.log("failure")\n *     resume(Effect.fail(new Error()))\n *   } else {\n *     console.log("success")\n *     resume(Effect.succeed("yay!"))\n *   }\n * })\n *\n * // Define a repetition policy using a fixed delay between retries\n * const policy = Schedule.fixed("100 millis")\n *\n * const repeated = Effect.retry(task, policy)\n *\n * Effect.runPromise(repeated).then(console.log)\n * // Output:\n * // failure\n * // failure\n * // failure\n * // success\n * // yay!\n * ```\n *\n * **Example** (Retrying a Task up to 5 times)\n *\n * ```ts\n * import { Effect } from "effect"\n *\n * let count = 0\n *\n * // Simulates an effect with possible failures\n * const task = Effect.async<string, Error>((resume) => {\n *   if (count <= 2) {\n *     count++\n *     console.log("failure")\n *     resume(Effect.fail(new Error()))\n *   } else {\n *     console.log("success")\n *     resume(Effect.succeed("yay!"))\n *   }\n * })\n *\n * // Retry the task up to 5 times\n * Effect.runPromise(Effect.retry(task, { times: 5 })).then(console.log)\n * // Output:\n * // failure\n * // failure\n * // failure\n * // success\n * ```\n *\n * **Example** (Retrying Until a Specific Condition is Met)\n *\n * ```ts\n * import { Effect } from "effect"\n *\n * let count = 0\n *\n * // Define an effect that simulates varying error on each invocation\n * const action = Effect.failSync(() => {\n *   console.log(`Action called ${++count} time(s)`)\n *   return `Error ${count}`\n * })\n *\n * // Retry the action until a specific condition is met\n * const program = Effect.retry(action, {\n *   until: (err) => err === "Error 3"\n * })\n *\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // Action called 1 time(s)\n * // Action called 2 time(s)\n * // Action called 3 time(s)\n * // {\n * //   _id: \'Exit\',\n * //   _tag: \'Failure\',\n * //   cause: { _id: \'Cause\', _tag: \'Fail\', failure: \'Error 3\' }\n * // }\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect, Schedule } from "effect"\n *\n * let count = 0\n *\n * // Simulates an effect with possible failures\n * const task = Effect.async<string, Error>((resume) => {\n *   if (count <= 2) {\n *     count++\n *     console.log("failure")\n *     resume(Effect.fail(new Error()))\n *   } else {\n *     console.log("success")\n *     resume(Effect.succeed("yay!"))\n *   }\n * })\n *\n * // Define a repetition policy using a fixed delay between retries\n * const policy = Schedule.fixed("100 millis")\n *\n * const repeated = Effect.retry(task, policy)\n *\n * Effect.runPromise(repeated).then(console.log)\n * // Output:\n * // failure\n * // failure\n * // failure\n * // success\n * // yay!\n *'
        },
        {
          code: '* import { Effect } from "effect"\n *\n * let count = 0\n *\n * // Simulates an effect with possible failures\n * const task = Effect.async<string, Error>((resume) => {\n *   if (count <= 2) {\n *     count++\n *     console.log("failure")\n *     resume(Effect.fail(new Error()))\n *   } else {\n *     console.log("success")\n *     resume(Effect.succeed("yay!"))\n *   }\n * })\n *\n * // Retry the task up to 5 times\n * Effect.runPromise(Effect.retry(task, { times: 5 })).then(console.log)\n * // Output:\n * // failure\n * // failure\n * // failure\n * // success\n *'
        },
        {
          code: "* import { Effect } from \"effect\"\n *\n * let count = 0\n *\n * // Define an effect that simulates varying error on each invocation\n * const action = Effect.failSync(() => {\n *   console.log(`Action called ${++count} time(s)`)\n *   return `Error ${count}`\n * })\n *\n * // Retry the action until a specific condition is met\n * const program = Effect.retry(action, {\n *   until: (err) => err === \"Error 3\"\n * })\n *\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // Action called 1 time(s)\n * // Action called 2 time(s)\n * // Action called 3 time(s)\n * // {\n * //   _id: 'Exit',\n * //   _tag: 'Failure',\n * //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Error 3' }\n * // }\n *"
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 7449,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L7449"
    },
    {
      id: "Effect.withExecutionPlan",
      name: "withExecutionPlan",
      module: "Effect",
      package: "effect",
      signature: "{ <Input, Provides, PlanE, PlanR>(plan: ExecutionPlan<{ provides: Provides; input: Input; error: PlanE; requirements: PlanR; }>): <A, E extends Input, R>(effect: Effect<A, E, R>) => Effect<A, PlanE | E, PlanR | Exclude<R, Provides>>; <A, E extends Input, R, Provides, Input, PlanE, PlanR>(effect: Effect<A, E, R>, plan: ExecutionPlan<{ provides: Provides; input: Input; error: PlanE; requirements: PlanR; }>): Effect<A, E | PlanE, PlanR | Exclude<R, Provides>>; }",
      description: "Apply an `ExecutionPlan` to the effect, which allows you to fallback to\ndifferent resources in case of failure.",
      documentation: "Apply an `ExecutionPlan` to the effect, which allows you to fallback to\ndifferent resources in case of failure.",
      examples: [],
      tags: [
        "Error handling"
      ],
      since: "3.16.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 7935,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L7935"
    },
    {
      id: "Effect.retryOrElse",
      name: "retryOrElse",
      module: "Effect",
      package: "effect",
      signature: "{ <A1, E, R1, A2, E2, R2>(policy: Schedule<A1, NoInfer<E>, R1>, orElse: (e: NoInfer<E>, out: A1) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R1 | R2 | R>; <A, E, R, A1, R1, A2, E2, R2>(self: Effect<A, E, R>, policy: Schedule<A1, NoInfer<E>, R1>, orElse: (e: NoInfer<E>, out: A1) => Effect<A2, E2, R2>): Effect<A | A2, E2, R | R1 | R2>; }",
      description: "/\n * Retries a failing effect and runs a fallback effect if retries are exhausted.\n *\n *",
      documentation: '/**\n * Retries a failing effect and runs a fallback effect if retries are exhausted.\n *\n * **Details**\n *\n * The `Effect.retryOrElse` function attempts to retry a failing effect multiple\n * times according to a defined {@link Schedule}policy.\n *\n * If the retries are exhausted and the effect still fails, it runs a fallback\n * effect instead.\n *\n * **When to Use**\n *\n * This function is useful when you want to handle failures gracefully by\n * specifying an alternative action after repeated failures.\n *\n * **Example** (Retrying with Fallback)\n *\n * ```ts\n * import { Effect, Schedule, Console } from "effect"\n *\n * let count = 0\n *\n * // Simulates an effect with possible failures\n * const task = Effect.async<string, Error>((resume) => {\n *   if (count <= 2) {\n *     count++\n *     console.log("failure")\n *     resume(Effect.fail(new Error()))\n *   } else {\n *     console.log("success")\n *     resume(Effect.succeed("yay!"))\n *   }\n * })\n *\n * // Retry the task with a delay between retries and a maximum of 2 retries\n * const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")\n *\n * // If all retries fail, run the fallback effect\n * const repeated = Effect.retryOrElse(\n *   task,\n *   policy,\n *   // fallback\n *   () => Console.log("orElse").pipe(Effect.as("default value"))\n * )\n *\n * Effect.runPromise(repeated).then(console.log)\n * // Output:\n * // failure\n * // failure\n * // failure\n * // orElse\n * // default value\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect, Schedule, Console } from "effect"\n *\n * let count = 0\n *\n * // Simulates an effect with possible failures\n * const task = Effect.async<string, Error>((resume) => {\n *   if (count <= 2) {\n *     count++\n *     console.log("failure")\n *     resume(Effect.fail(new Error()))\n *   } else {\n *     console.log("success")\n *     resume(Effect.succeed("yay!"))\n *   }\n * })\n *\n * // Retry the task with a delay between retries and a maximum of 2 retries\n * const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")\n *\n * // If all retries fail, run the fallback effect\n * const repeated = Effect.retryOrElse(\n *   task,\n *   policy,\n *   // fallback\n *   () => Console.log("orElse").pipe(Effect.as("default value"))\n * )\n *\n * Effect.runPromise(repeated).then(console.log)\n * // Output:\n * // failure\n * // failure\n * // failure\n * // orElse\n * // default value\n *'
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8025,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8025"
    },
    {
      id: "Effect.tryMap",
      name: "tryMap",
      module: "Effect",
      package: "effect",
      signature: "{ <A, B, E1>(options: { readonly try: (a: A) => B; readonly catch: (error: unknown) => E1; }): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R>; <A, E, R, B, E1>(self: Effect<A, E, R>, options: { readonly try: (a: A) => B; readonly catch: (error: unknown) => E1; }): Effect<B, E | E1, R>; }",
      description: "Returns an effect that maps its success using the specified side-effecting\n`try` function, converting any errors into typed failed effects using the\n`catch` function.",
      documentation: "Returns an effect that maps its success using the specified side-effecting\n`try` function, converting any errors into typed failed effects using the\n`catch` function.",
      examples: [],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8227,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8227"
    },
    {
      id: "Effect.tryMapPromise",
      name: "tryMapPromise",
      module: "Effect",
      package: "effect",
      signature: "{ <A, B, E1>(options: { readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>; readonly catch: (error: unknown) => E1; }): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R>; <A, E, R, B, E1>(self: Effect<A, E, R>, options: { readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>; readonly catch: (error: unknown) => E1; }): Effect<B, E | E1, R>; }",
      description: "Returns an effect that maps its success using the specified side-effecting\n`try` function, converting any promise rejections into typed failed effects\nusing the `catch` function. An optional `AbortSignal` can be provided to allow for interruption of the\nwrapped `Promise` API.",
      documentation: "Returns an effect that maps its success using the specified side-effecting\n`try` function, converting any promise rejections into typed failed effects\nusing the `catch` function.\n\nAn optional `AbortSignal` can be provided to allow for interruption of the\nwrapped `Promise` API.",
      examples: [],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8270,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8270"
    },
    {
      id: "Effect.tryPromise",
      name: "tryPromise",
      module: "Effect",
      package: "effect",
      signature: "{ <A, E>(options: { readonly try: (signal: AbortSignal) => PromiseLike<A>; readonly catch: (error: unknown) => E; }): Effect<A, E, never>; <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>): Effect<A, UnknownException, never>; }",
      description: "Creates an `Effect` that represents an asynchronous computation that might\nfail.",
      documentation: 'Creates an `Effect` that represents an asynchronous computation that might\nfail.\n\n**When to Use**\n\nIn situations where you need to perform asynchronous operations that might\nfail, such as fetching data from an API, you can use the `tryPromise`\nconstructor. This constructor is designed to handle operations that could\nthrow exceptions by capturing those exceptions and transforming them into\nmanageable errors.\n\n**Error Handling**\n\nThere are two ways to handle errors with `tryPromise`:\n\n1. If you don\'t provide a `catch` function, the error is caught and the\n   effect fails with an `UnknownException`.\n2. If you provide a `catch` function, the error is caught and the `catch`\n   function maps it to an error of type `E`.\n\n**Interruptions**\n\nAn optional `AbortSignal` can be provided to allow for interruption of the\nwrapped `Promise` API.\n\n**Example** (Fetching a TODO Item)\n\n```ts\nimport { Effect } from "effect"\n\nconst getTodo = (id: number) =>\n  // Will catch any errors and propagate them as UnknownException\n  Effect.tryPromise(() =>\n    fetch(`https://jsonplaceholder.typicode.com/todos/${id}`)\n  )\n\n//      \u250C\u2500\u2500\u2500 Effect<Response, UnknownException, never>\n//      \u25BC\nconst program = getTodo(1)\n```\n\n**Example** (Custom Error Handling)\n\n```ts\nimport { Effect } from "effect"\n\nconst getTodo = (id: number) =>\n  Effect.tryPromise({\n    try: () => fetch(`https://jsonplaceholder.typicode.com/todos/${id}`),\n    // remap the error\n    catch: (unknown) => new Error(`something went wrong ${unknown}`)\n  })\n\n//      \u250C\u2500\u2500\u2500 Effect<Response, Error, never>\n//      \u25BC\nconst program = getTodo(1)\n```',
      examples: [
        {
          title: "Fetching a TODO Item",
          code: 'import { Effect } from "effect"\n\nconst getTodo = (id: number) =>\n  // Will catch any errors and propagate them as UnknownException\n  Effect.tryPromise(() =>\n    fetch(`https://jsonplaceholder.typicode.com/todos/${id}`)\n  )\n\n//      \u250C\u2500\u2500\u2500 Effect<Response, UnknownException, never>\n//      \u25BC\nconst program = getTodo(1)'
        },
        {
          title: "Custom Error Handling",
          code: 'import { Effect } from "effect"\n\nconst getTodo = (id: number) =>\n  Effect.tryPromise({\n    try: () => fetch(`https://jsonplaceholder.typicode.com/todos/${id}`),\n    // remap the error\n    catch: (unknown) => new Error(`something went wrong ${unknown}`)\n  })\n\n//      \u250C\u2500\u2500\u2500 Effect<Response, Error, never>\n//      \u25BC\nconst program = getTodo(1)'
        }
      ],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8370,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8370"
    },
    {
      id: "Effect.unsandbox",
      name: "unsandbox",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, Cause<E>, R>) => Effect<A, E, R>",
      description: "/\n * The `unsandbox` function is used to revert an effect that has been\n * sandboxed by {@link sandbox}. When you apply `unsandbox`, the\n * effect's error channel is restored to its original state, without the\n * detailed `Cause<E>` information. This means that any underlying causes of\n * errors, defects, or fiber interruptions are no longer exposed in the error\n * channel.\n *\n * This function is useful when you want to remove the detailed error tracking\n * provided by `sandbox` and return to the standard error handling for\n * your effect. Once unsandboxed, the effect behaves as if `sandbox` was\n * never applied.\n *\n *",
      documentation: "/**\n * The `unsandbox` function is used to revert an effect that has been\n * sandboxed by {@link sandbox}. When you apply `unsandbox`, the\n * effect's error channel is restored to its original state, without the\n * detailed `Cause<E>` information. This means that any underlying causes of\n * errors, defects, or fiber interruptions are no longer exposed in the error\n * channel.\n *\n * This function is useful when you want to remove the detailed error tracking\n * provided by `sandbox` and return to the standard error handling for\n * your effect. Once unsandboxed, the effect behaves as if `sandbox` was\n * never applied.\n *\n *",
      examples: [],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8523,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8523"
    },
    {
      id: "Effect.allowInterrupt",
      name: "allowInterrupt",
      module: "Effect",
      package: "effect",
      signature: "Effect<void, never, never>",
      description: "Allows interruption of the current fiber, even in uninterruptible regions.",
      documentation: "Allows interruption of the current fiber, even in uninterruptible regions.\n\n**Details**\n\nThis effect checks whether any other fibers are attempting to interrupt the\ncurrent fiber. If so, it allows the current fiber to perform a\nself-interruption.\n\n**When to Use**\n\nThis is useful in situations where you want to allow interruption to happen\neven in regions of the code that are normally uninterruptible.",
      examples: [],
      tags: [
        "Interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8541,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8541"
    },
    {
      id: "Effect.checkInterruptible",
      name: "checkInterruptible",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(f: (isInterruptible: boolean) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "Checks if interruption is allowed and executes a callback accordingly.",
      documentation: 'Checks if interruption is allowed and executes a callback accordingly.\n\n**Details**\n\nThis function checks the current interrupt status of the running fiber. It\nthen calls the provided callback, passing a boolean indicating whether\ninterruption is allowed.\n\n**When to Use**\n\nThis is useful for handling specific logic based on whether the current\noperation can be interrupted, such as when performing asynchronous operations\nor handling cancellation.\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.checkInterruptible((isInterruptible) => {\n    if (isInterruptible) {\n      return Console.log("You can interrupt this operation.")\n    } else {\n      return Console.log("This operation cannot be interrupted.")\n    }\n  })\n})\n\nEffect.runPromise(program)\n// Output: You can interrupt this operation.\n\nEffect.runPromise(program.pipe(Effect.uninterruptible))\n// Output: This operation cannot be interrupted.\n\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.checkInterruptible((isInterruptible) => {\n    if (isInterruptible) {\n      return Console.log("You can interrupt this operation.")\n    } else {\n      return Console.log("This operation cannot be interrupted.")\n    }\n  })\n})\n\nEffect.runPromise(program)\n// Output: You can interrupt this operation.\n\nEffect.runPromise(program.pipe(Effect.uninterruptible))\n// Output: This operation cannot be interrupted.'
        }
      ],
      tags: [
        "Interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8583,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8583"
    },
    {
      id: "Effect.disconnect",
      name: "disconnect",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>",
      description: "Provides a way to handle timeouts in uninterruptible effects, allowing them\nto continue in the background while the main control flow proceeds with the\ntimeout error.",
      documentation: 'Provides a way to handle timeouts in uninterruptible effects, allowing them\nto continue in the background while the main control flow proceeds with the\ntimeout error.\n\n**Details**\n\nThe `disconnect` function allows an uninterruptible effect to continue\nrunning in the background, while enabling the main control flow to\nimmediately recognize a timeout condition. This is useful when you want to\navoid blocking the program due to long-running tasks, especially when those\ntasks do not need to affect the flow of the rest of the program.\n\nWithout `disconnect`, an uninterruptible effect will ignore the\ntimeout and continue executing until it completes. The timeout error will\nonly be assessed after the effect finishes, which can cause delays in\nrecognizing a timeout.\n\nWith `disconnect`, the uninterruptible effect proceeds in the\nbackground while the main program flow can immediately handle the timeout\nerror or trigger alternative logic. This enables faster timeout handling\nwithout waiting for the completion of the long-running task.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst longRunningTask = Effect.gen(function* () {\n  console.log("Start heavy processing...")\n  yield* Effect.sleep("5 seconds") // Simulate a long process\n  console.log("Heavy processing done.")\n  return "Data processed"\n})\n\nconst timedEffect = longRunningTask.pipe(\n  Effect.uninterruptible,\n  // Allows the task to finish in the background if it times out\n  Effect.disconnect,\n  Effect.timeout("1 second")\n)\n\nEffect.runPromiseExit(timedEffect).then(console.log)\n// Output:\n// Start heavy processing...\n// {\n//   _id: \'Exit\',\n//   _tag: \'Failure\',\n//   cause: {\n//     _id: \'Cause\',\n//     _tag: \'Fail\',\n//     failure: { _tag: \'TimeoutException\' }\n//   }\n// }\n// Heavy processing done.\n```',
      examples: [
        {
          code: `import { Effect } from "effect"

const longRunningTask = Effect.gen(function* () {
  console.log("Start heavy processing...")
  yield* Effect.sleep("5 seconds") // Simulate a long process
  console.log("Heavy processing done.")
  return "Data processed"
})

const timedEffect = longRunningTask.pipe(
  Effect.uninterruptible,
  // Allows the task to finish in the background if it times out
  Effect.disconnect,
  Effect.timeout("1 second")
)

Effect.runPromiseExit(timedEffect).then(console.log)
// Output:
// Start heavy processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: { _tag: 'TimeoutException' }
//   }
// }
// Heavy processing done.`
        }
      ],
      tags: [
        "Interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8647,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8647"
    },
    {
      id: "Effect.interrupt",
      name: "interrupt",
      module: "Effect",
      package: "effect",
      signature: "Effect<never, never, never>",
      description: "/\n * Represents an effect that interrupts the current fiber.\n *\n *",
      documentation: `/**
 * Represents an effect that interrupts the current fiber.
 *
 * **Details**
 *
 * This effect models the explicit interruption of the fiber in which it runs.
 * When executed, it causes the fiber to stop its operation immediately,
 * capturing the interruption details such as the fiber's ID and its start time.
 * The resulting interruption can be observed in the \`Exit\` type if the effect
 * is run with functions like {@link runPromiseExit}.
 *
 * **Example**
 *
 * \`\`\`ts
 * import { Effect } from "effect"
 *
 * const program = Effect.gen(function* () {
 *   console.log("start")
 *   yield* Effect.sleep("2 seconds")
 *   yield* Effect.interrupt
 *   console.log("done")
 *   return "some result"
 * })
 *
 * Effect.runPromiseExit(program).then(console.log)
 * // Output:
 * // start
 * // {
 * //   _id: 'Exit',
 * //   _tag: 'Failure',
 * //   cause: {
 * //     _id: 'Cause',
 * //     _tag: 'Interrupt',
 * //     fiberId: {
 * //       _id: 'FiberId',
 * //       _tag: 'Runtime',
 * //       id: 0,
 * //       startTimeMillis: ...
 * //     }
 * //   }
 * // }
 * \`\`\`
 *
 *`,
      examples: [
        {
          code: `* import { Effect } from "effect"
 *
 * const program = Effect.gen(function* () {
 *   console.log("start")
 *   yield* Effect.sleep("2 seconds")
 *   yield* Effect.interrupt
 *   console.log("done")
 *   return "some result"
 * })
 *
 * Effect.runPromiseExit(program).then(console.log)
 * // Output:
 * // start
 * // {
 * //   _id: 'Exit',
 * //   _tag: 'Failure',
 * //   cause: {
 * //     _id: 'Cause',
 * //     _tag: 'Interrupt',
 * //     fiberId: {
 * //       _id: 'FiberId',
 * //       _tag: 'Runtime',
 * //       id: 0,
 * //       startTimeMillis: ...
 * //     }
 * //   }
 * // }
 *`
        }
      ],
      tags: [
        "Interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8694,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8694"
    },
    {
      id: "Effect.interruptWith",
      name: "interruptWith",
      module: "Effect",
      package: "effect",
      signature: "(fiberId: FiberId) => Effect<never, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8699,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8699"
    },
    {
      id: "Effect.interruptible",
      name: "interruptible",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>",
      description: "Marks an effect as interruptible.",
      documentation: "Marks an effect as interruptible.",
      examples: [],
      tags: [
        "Interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8706,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8706"
    },
    {
      id: "Effect.interruptibleMask",
      name: "interruptibleMask",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(f: (restore: <AX, EX, RX>(effect: Effect<AX, EX, RX>) => Effect<AX, EX, RX>) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "/\n * This function behaves like {@link interruptible}, but it also provides a\n * `restore` function. This function can be used to restore the interruptibility\n * of any specific region of code.\n *\n *",
      documentation: "/**\n * This function behaves like {@link interruptible}, but it also provides a\n * `restore` function. This function can be used to restore the interruptibility\n * of any specific region of code.\n *\n *",
      examples: [],
      tags: [
        "Interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8715,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8715"
    },
    {
      id: "Effect.onInterrupt",
      name: "onInterrupt",
      module: "Effect",
      package: "effect",
      signature: "{ <X, R2>(cleanup: (interruptors: HashSet<FiberId>) => Effect<X, never, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, cleanup: (interruptors: HashSet<FiberId>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }",
      description: "Registers a cleanup effect to run when an effect is interrupted.",
      documentation: 'Registers a cleanup effect to run when an effect is interrupted.\n\n**Details**\n\nThis function allows you to specify an effect to run when the fiber is\ninterrupted. This effect will be executed when the fiber is interrupted,\nallowing you to perform cleanup or other actions.\n\n**Example** (Running a Cleanup Action on Interruption)\n\n```ts\nimport { Console, Effect } from "effect"\n\n// This handler is executed when the fiber is interrupted\nconst handler = Effect.onInterrupt((_fibers) => Console.log("Cleanup completed"))\n\nconst success = Console.log("Task completed").pipe(Effect.as("some result"), handler)\n\nEffect.runFork(success)\n// Output:\n// Task completed\n\nconst failure = Console.log("Task failed").pipe(Effect.andThen(Effect.fail("some error")), handler)\n\nEffect.runFork(failure)\n// Output:\n// Task failed\n\nconst interruption = Console.log("Task interrupted").pipe(Effect.andThen(Effect.interrupt), handler)\n\nEffect.runFork(interruption)\n// Output:\n// Task interrupted\n// Cleanup completed\n```',
      examples: [
        {
          title: "Running a Cleanup Action on Interruption",
          code: 'import { Console, Effect } from "effect"\n\n// This handler is executed when the fiber is interrupted\nconst handler = Effect.onInterrupt((_fibers) => Console.log("Cleanup completed"))\n\nconst success = Console.log("Task completed").pipe(Effect.as("some result"), handler)\n\nEffect.runFork(success)\n// Output:\n// Task completed\n\nconst failure = Console.log("Task failed").pipe(Effect.andThen(Effect.fail("some error")), handler)\n\nEffect.runFork(failure)\n// Output:\n// Task failed\n\nconst interruption = Console.log("Task interrupted").pipe(Effect.andThen(Effect.interrupt), handler)\n\nEffect.runFork(interruption)\n// Output:\n// Task interrupted\n// Cleanup completed'
        }
      ],
      tags: [
        "Interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8756,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8756"
    },
    {
      id: "Effect.uninterruptible",
      name: "uninterruptible",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>",
      description: "Marks an effect as uninterruptible.",
      documentation: "Marks an effect as uninterruptible.",
      examples: [],
      tags: [
        "Interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8846,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8846"
    },
    {
      id: "Effect.uninterruptibleMask",
      name: "uninterruptibleMask",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(f: (restore: <AX, EX, RX>(effect: Effect<AX, EX, RX>) => Effect<AX, EX, RX>) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "/\n * This function behaves like {@link uninterruptible}, but it also provides a\n * `restore` function. This function can be used to restore the interruptibility\n * of any specific region of code.\n *\n *",
      documentation: "/**\n * This function behaves like {@link uninterruptible}, but it also provides a\n * `restore` function. This function can be used to restore the interruptibility\n * of any specific region of code.\n *\n *",
      examples: [],
      tags: [
        "Interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8855,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8855"
    },
    {
      id: "Effect.liftPredicate",
      name: "liftPredicate",
      module: "Effect",
      package: "effect",
      signature: "{ <T extends A, E, B extends T = T, A = T>(predicate: Refinement<T, B> | Predicate<T>, orFailWith: (a: EqualsWith<T, B, A, Exclude<A, B>>) => E): (a: A) => Effect<EqualsWith<T, B, A, B>, E, never>; <A, E, B extends A = A>(self: A, predicate: Refinement<A, B> | Predicate<A>, orFailWith: (a: EqualsWith<A, B, A, Exclude<A, B>>) => E): Effect<B, E, never>; }",
      description: "Transforms a `Predicate` function into an `Effect` returning the input value if the predicate returns `true`\nor failing with specified error if the predicate fails",
      documentation: 'Transforms a `Predicate` function into an `Effect` returning the input value if the predicate returns `true`\nor failing with specified error if the predicate fails\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst isPositive = (n: number): boolean => n > 0\n\n// succeeds with `1`\nEffect.liftPredicate(1, isPositive, n => `${n} is not positive`)\n\n// fails with `"0 is not positive"`\nEffect.liftPredicate(0, isPositive, n => `${n} is not positive`)\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst isPositive = (n: number): boolean => n > 0\n\n// succeeds with `1`\nEffect.liftPredicate(1, isPositive, n => `${n} is not positive`)\n\n// fails with `"0 is not positive"`\nEffect.liftPredicate(0, isPositive, n => `${n} is not positive`)'
        }
      ],
      tags: [
        "Condition Checking"
      ],
      since: "3.4.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8877,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8877"
    },
    {
      id: "Effect.as",
      name: "as",
      module: "Effect",
      package: "effect",
      signature: "{ <B>(value: B): <A, E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A, E, R, B>(self: Effect<A, E, R>, value: B): Effect<B, E, R>; }",
      description: "Replaces the value inside an effect with a constant value.",
      documentation: 'Replaces the value inside an effect with a constant value.\n\n**Details**\n\nThis function allows you to ignore the original value inside an effect and\nreplace it with a constant value.\n\n**When to Use**\n\nIt is useful when you no longer need the value produced by an effect but want\nto ensure that the effect completes successfully with a specific constant\nresult instead. For instance, you can replace the value produced by a\ncomputation with a predefined value, ignoring what was calculated before.\n\n**Example** (Replacing a Value)\n\n```ts\nimport { pipe, Effect } from "effect"\n\n// Replaces the value 5 with the constant "new value"\nconst program = pipe(Effect.succeed(5), Effect.as("new value"))\n\nEffect.runPromise(program).then(console.log)\n// Output: "new value"\n```',
      examples: [
        {
          title: "Replacing a Value",
          code: 'import { pipe, Effect } from "effect"\n\n// Replaces the value 5 with the constant "new value"\nconst program = pipe(Effect.succeed(5), Effect.as("new value"))\n\nEffect.runPromise(program).then(console.log)\n// Output: "new value"'
        }
      ],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 8953,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8953"
    },
    {
      id: "Effect.asSome",
      name: "asSome",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<Option<A>, E, R>",
      description: "This function maps the success value of an `Effect` value to a `Some` value\nin an `Option` value. If the original `Effect` value fails, the returned\n`Effect` value will also fail.",
      documentation: "This function maps the success value of an `Effect` value to a `Some` value\nin an `Option` value. If the original `Effect` value fails, the returned\n`Effect` value will also fail.",
      examples: [],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9025,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9025"
    },
    {
      id: "Effect.asSomeError",
      name: "asSomeError",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, Option<E>, R>",
      description: "This function maps the error value of an `Effect` value to a `Some` value\nin an `Option` value. If the original `Effect` value succeeds, the returned\n`Effect` value will also succeed.",
      documentation: "This function maps the error value of an `Effect` value to a `Some` value\nin an `Option` value. If the original `Effect` value succeeds, the returned\n`Effect` value will also succeed.",
      examples: [],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9034,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9034"
    },
    {
      id: "Effect.asVoid",
      name: "asVoid",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<void, E, R>",
      description: "This function maps the success value of an `Effect` value to `void`. If the\noriginal `Effect` value succeeds, the returned `Effect` value will also\nsucceed. If the original `Effect` value fails, the returned `Effect` value\nwill fail with the same error.",
      documentation: "This function maps the success value of an `Effect` value to `void`. If the\noriginal `Effect` value succeeds, the returned `Effect` value will also\nsucceed. If the original `Effect` value fails, the returned `Effect` value\nwill fail with the same error.",
      examples: [],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9044,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9044"
    },
    {
      id: "Effect.flip",
      name: "flip",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<E, A, R>",
      description: "Swaps the success and error channels of an effect.",
      documentation: 'Swaps the success and error channels of an effect.\n\n**Details**\n\nThis function reverses the flow of an effect by swapping its success and\nerror channels. The success value becomes an error, and the error value\nbecomes a success.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, string, never>\n//      \u25BC\nconst program = Effect.fail("Oh uh!").pipe(Effect.as(2))\n\n//      \u250C\u2500\u2500\u2500 Effect<string, number, never>\n//      \u25BC\nconst flipped = Effect.flip(program)\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, string, never>\n//      \u25BC\nconst program = Effect.fail("Oh uh!").pipe(Effect.as(2))\n\n//      \u250C\u2500\u2500\u2500 Effect<string, number, never>\n//      \u25BC\nconst flipped = Effect.flip(program)'
        }
      ],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9071,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9071"
    },
    {
      id: "Effect.flipWith",
      name: "flipWith",
      module: "Effect",
      package: "effect",
      signature: "{ <E, A, R, E2, A2, R2>(f: (effect: Effect<E, A, R>) => Effect<E2, A2, R2>): (self: Effect<A, E, R>) => Effect<A2, E2, R2>; <A, E, R, E2, A2, R2>(self: Effect<A, E, R>, f: (effect: Effect<E, A, R>) => Effect<E2, A2, R2>): Effect<A2, E2, R2>; }",
      description: "Swaps the error/value parameters, applies the function `f` and flips the\nparameters back",
      documentation: "Swaps the error/value parameters, applies the function `f` and flips the\nparameters back",
      examples: [],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9079,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9079"
    },
    {
      id: "Effect.map",
      name: "map",
      module: "Effect",
      package: "effect",
      signature: "{ <A, B>(f: (a: A) => B): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A, E, R, B>(self: Effect<A, E, R>, f: (a: A) => B): Effect<B, E, R>; }",
      description: "Transforms the value inside an effect by applying a function to it.",
      documentation: 'Transforms the value inside an effect by applying a function to it.\n\n**Syntax**\n\n```ts skip-type-checking\nconst mappedEffect = pipe(myEffect, Effect.map(transformation))\n// or\nconst mappedEffect = Effect.map(myEffect, transformation)\n// or\nconst mappedEffect = myEffect.pipe(Effect.map(transformation))\n```\n\n**Details**\n\n`map` takes a function and applies it to the value contained within an\neffect, creating a new effect with the transformed value.\n\nIt\'s important to note that effects are immutable, meaning that the original\neffect is not modified. Instead, a new effect is returned with the updated\nvalue.\n\n**Example** (Adding a Service Charge)\n\n```ts\nimport { pipe, Effect } from "effect"\n\nconst addServiceCharge = (amount: number) => amount + 1\n\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\nconst finalAmount = pipe(\n  fetchTransactionAmount,\n  Effect.map(addServiceCharge)\n)\n\nEffect.runPromise(finalAmount).then(console.log)\n// Output: 101\n```',
      examples: [
        {
          title: "Adding a Service Charge",
          code: 'import { pipe, Effect } from "effect"\n\nconst addServiceCharge = (amount: number) => amount + 1\n\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\nconst finalAmount = pipe(\n  fetchTransactionAmount,\n  Effect.map(addServiceCharge)\n)\n\nEffect.runPromise(finalAmount).then(console.log)\n// Output: 101'
        }
      ],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9144,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9144"
    },
    {
      id: "Effect.mapAccum",
      name: "mapAccum",
      module: "Effect",
      package: "effect",
      signature: "{ <S, A, B, E, R, I extends Iterable<A> = Iterable<A>>(initial: S, f: (state: S, a: ReadonlyArray.Infer<I>, i: number) => Effect<readonly [S, B], E, R>): (elements: I) => Effect<[S, ReadonlyArray.With<I, B>], E, R>; <A, S, B, E, R, I extends Iterable<A> = Iterable<A>>(elements: I, initial: S, f: (state: S, a: ReadonlyArray.Infer<I>, i: number) => Effect<readonly [S, B], E, R>): Effect<[S, ReadonlyArray.With<I, B>], E, R>; }",
      description: "Applies a stateful transformation to each element of a collection, producing\nnew elements along with an updated state.",
      documentation: 'Applies a stateful transformation to each element of a collection, producing\nnew elements along with an updated state.\n\n**When to Use**\n\nUse `mapAccum` when you need to process each element of a collection while\nkeeping track of some state across iterations.\n\n**Details**\n\n`mapAccum` takes an initial state (`initial`) and a function (`f`) that is\napplied to each element. This function returns a new state and a transformed\nelement. The final effect produces both the accumulated state and the\ntransformed collection.\n\nIf the input collection is a non-empty array, the return type will match the\ninput collection type.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\n// Define an initial state and a transformation function\nconst initialState = 0\n\nconst transformation = (state: number, element: string) =>\n  Effect.succeed<[number, string]>([state + element.length, element.toUpperCase()])\n\n// Apply mapAccum to transform an array of strings\nconst program = Effect.mapAccum(["a", "bb", "ccc"], initialState, transformation)\n\nEffect.runPromise(program).then(([finalState, transformedCollection]) => {\n  console.log(finalState)\n  console.log(transformedCollection)\n})\n// Output:\n// 6\n// [ \'A\', \'BB\', \'CCC\' ]\n```',
      examples: [
        {
          code: `import { Effect } from "effect"

// Define an initial state and a transformation function
const initialState = 0

const transformation = (state: number, element: string) =>
  Effect.succeed<[number, string]>([state + element.length, element.toUpperCase()])

// Apply mapAccum to transform an array of strings
const program = Effect.mapAccum(["a", "bb", "ccc"], initialState, transformation)

Effect.runPromise(program).then(([finalState, transformedCollection]) => {
  console.log(finalState)
  console.log(transformedCollection)
})
// Output:
// 6
// [ 'A', 'BB', 'CCC' ]`
        }
      ],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9287,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9287"
    },
    {
      id: "Effect.mapBoth",
      name: "mapBoth",
      module: "Effect",
      package: "effect",
      signature: "{ <E, E2, A, A2>(options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): <R>(self: Effect<A, E, R>) => Effect<A2, E2, R>; <A, E, R, E2, A2>(self: Effect<A, E, R>, options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): Effect<A2, E2, R>; }",
      description: "Applies transformations to both the success and error channels of an effect.",
      documentation: 'Applies transformations to both the success and error channels of an effect.\n\n**Details**\n\nThis function takes two map functions as arguments: one for the error channel\nand one for the success channel. You can use it when you want to modify both\nthe error and the success values without altering the overall success or\nfailure status of the effect.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, string, never>\n//      \u25BC\nconst simulatedTask = Effect.fail("Oh no!").pipe(Effect.as(1))\n\n//      \u250C\u2500\u2500\u2500 Effect<boolean, Error, never>\n//      \u25BC\nconst modified = Effect.mapBoth(simulatedTask, {\n  onFailure: (message) => new Error(message),\n  onSuccess: (n) => n > 0\n})\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, string, never>\n//      \u25BC\nconst simulatedTask = Effect.fail("Oh no!").pipe(Effect.as(1))\n\n//      \u250C\u2500\u2500\u2500 Effect<boolean, Error, never>\n//      \u25BC\nconst modified = Effect.mapBoth(simulatedTask, {\n  onFailure: (message) => new Error(message),\n  onSuccess: (n) => n > 0\n})'
        }
      ],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9414,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9414"
    },
    {
      id: "Effect.mapError",
      name: "mapError",
      module: "Effect",
      package: "effect",
      signature: "{ <E, E2>(f: (e: E) => E2): <A, R>(self: Effect<A, E, R>) => Effect<A, E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, f: (e: E) => E2): Effect<A, E2, R>; }",
      description: "Transforms or modifies the error produced by an effect without affecting its\nsuccess value.",
      documentation: 'Transforms or modifies the error produced by an effect without affecting its\nsuccess value.\n\n**When to Use**\n\nThis function is helpful when you want to enhance the error with additional\ninformation, change the error type, or apply custom error handling while\nkeeping the original behavior of the effect\'s success values intact. It only\noperates on the error channel and leaves the success channel unchanged.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, string, never>\n//      \u25BC\nconst simulatedTask = Effect.fail("Oh no!").pipe(Effect.as(1))\n\n//      \u250C\u2500\u2500\u2500 Effect<number, Error, never>\n//      \u25BC\nconst mapped = Effect.mapError(\n  simulatedTask,\n  (message) => new Error(message)\n)\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, string, never>\n//      \u25BC\nconst simulatedTask = Effect.fail("Oh no!").pipe(Effect.as(1))\n\n//      \u250C\u2500\u2500\u2500 Effect<number, Error, never>\n//      \u25BC\nconst mapped = Effect.mapError(\n  simulatedTask,\n  (message) => new Error(message)\n)'
        }
      ],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9525,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9525"
    },
    {
      id: "Effect.mapErrorCause",
      name: "mapErrorCause",
      module: "Effect",
      package: "effect",
      signature: "{ <E, E2>(f: (cause: Cause<E>) => Cause<E2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, f: (cause: Cause<E>) => Cause<E2>): Effect<A, E2, R>; }",
      description: "Maps the cause of failure of an effect using a specified function.",
      documentation: "Maps the cause of failure of an effect using a specified function.",
      examples: [],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9608,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9608"
    },
    {
      id: "Effect.merge",
      name: "merge",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A | E, never, R>",
      description: "Combines both success and error channels of an effect into a single outcome.",
      documentation: 'Combines both success and error channels of an effect into a single outcome.\n\n**Details**\n\nThis function transforms an effect that may fail into one that always returns\na value, where both success and failure outcomes are handled as values in the\nsuccess channel.\n\n**When to Use**\n\nThis can be useful when you want to continue execution regardless of the\nerror type and still capture both successful results and errors as part of\nthe outcome.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, string, never>\n//      \u25BC\nconst program = Effect.fail("Oh uh!").pipe(Effect.as(2))\n\n//      \u250C\u2500\u2500\u2500 Effect<number | string, never, never>\n//      \u25BC\nconst recovered = Effect.merge(program)\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, string, never>\n//      \u25BC\nconst program = Effect.fail("Oh uh!").pipe(Effect.as(2))\n\n//      \u250C\u2500\u2500\u2500 Effect<number | string, never, never>\n//      \u25BC\nconst recovered = Effect.merge(program)'
        }
      ],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9662,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9662"
    },
    {
      id: "Effect.negate",
      name: "negate",
      module: "Effect",
      package: "effect",
      signature: "<E, R>(self: Effect<boolean, E, R>) => Effect<boolean, E, R>",
      description: "Returns a new effect with the boolean value of this effect negated.",
      documentation: "Returns a new effect with the boolean value of this effect negated.",
      examples: [],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9669,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9669"
    },
    {
      id: "Effect.acquireRelease",
      name: "acquireRelease",
      module: "Effect",
      package: "effect",
      signature: "{ <A, X, R2>(release: (a: A, exit: Exit<unknown, unknown>) => Effect<X, never, R2>): <E, R>(acquire: Effect<A, E, R>) => Effect<A, E, R2 | R | Scope>; <A, E, R, X, R2>(acquire: Effect<A, E, R>, release: (a: A, exit: Exit<unknown, unknown>) => Effect<X, never, R2>): Effect<A, E, R | R2 | Scope>; }",
      description: "Creates a scoped resource using an `acquire` and `release` effect.",
      documentation: 'Creates a scoped resource using an `acquire` and `release` effect.\n\n**Details**\n\nThis function helps manage resources by combining two `Effect` values: one\nfor acquiring the resource and one for releasing it.\n\n`acquireRelease` does the following:\n\n  1. Ensures that the effect that acquires the resource will not be\n     interrupted. Note that acquisition may still fail due to internal\n     reasons (such as an uncaught exception).\n  2. Ensures that the `release` effect will not be interrupted, and will be\n     executed as long as the acquisition effect successfully acquires the\n     resource.\n\nIf the `acquire` function succeeds, the `release` function is added to the\nlist of finalizers for the scope. This ensures that the release will happen\nautomatically when the scope is closed.\n\nBoth `acquire` and `release` run uninterruptibly, meaning they cannot be\ninterrupted while they are executing.\n\nAdditionally, the `release` function can be influenced by the exit value when\nthe scope closes, allowing for custom handling of how the resource is\nreleased based on the execution outcome.\n\n**When to Use**\n\nThis function is used to ensure that an effect that represents the\nacquisition of a resource (for example, opening a file, launching a thread,\netc.) will not be interrupted, and that the resource will always be released\nwhen the `Effect` completes execution.\n\n**Example** (Defining a Simple Resource)\n\n```ts\nimport { Effect } from "effect"\n\n// Define an interface for a resource\ninterface MyResource {\n  readonly contents: string\n  readonly close: () => Promise<void>\n}\n\n// Simulate resource acquisition\nconst getMyResource = (): Promise<MyResource> =>\n  Promise.resolve({\n    contents: "lorem ipsum",\n    close: () =>\n      new Promise((resolve) => {\n        console.log("Resource released")\n        resolve()\n      })\n  })\n\n// Define how the resource is acquired\nconst acquire = Effect.tryPromise({\n  try: () =>\n    getMyResource().then((res) => {\n      console.log("Resource acquired")\n      return res\n    }),\n  catch: () => new Error("getMyResourceError")\n})\n\n// Define how the resource is released\nconst release = (res: MyResource) => Effect.promise(() => res.close())\n\n// Create the resource management workflow\n//\n//      \u250C\u2500\u2500\u2500 Effect<MyResource, Error, Scope>\n//      \u25BC\nconst resource = Effect.acquireRelease(acquire, release)\n```',
      examples: [
        {
          title: "Defining a Simple Resource",
          code: 'import { Effect } from "effect"\n\n// Define an interface for a resource\ninterface MyResource {\n  readonly contents: string\n  readonly close: () => Promise<void>\n}\n\n// Simulate resource acquisition\nconst getMyResource = (): Promise<MyResource> =>\n  Promise.resolve({\n    contents: "lorem ipsum",\n    close: () =>\n      new Promise((resolve) => {\n        console.log("Resource released")\n        resolve()\n      })\n  })\n\n// Define how the resource is acquired\nconst acquire = Effect.tryPromise({\n  try: () =>\n    getMyResource().then((res) => {\n      console.log("Resource acquired")\n      return res\n    }),\n  catch: () => new Error("getMyResourceError")\n})\n\n// Define how the resource is released\nconst release = (res: MyResource) => Effect.promise(() => res.close())\n\n// Create the resource management workflow\n//\n//      \u250C\u2500\u2500\u2500 Effect<MyResource, Error, Scope>\n//      \u25BC\nconst resource = Effect.acquireRelease(acquire, release)'
        }
      ],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9752,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9752"
    },
    {
      id: "Effect.acquireReleaseInterruptible",
      name: "acquireReleaseInterruptible",
      module: "Effect",
      package: "effect",
      signature: "{ <X, R2>(release: (exit: Exit<unknown, unknown>) => Effect<X, never, R2>): <A, E, R>(acquire: Effect<A, E, R>) => Effect<A, E, Scope | R2 | R>; <A, E, R, X, R2>(acquire: Effect<A, E, R>, release: (exit: Exit<unknown, unknown>) => Effect<X, never, R2>): Effect<A, E, Scope | R | R2>; }",
      description: "/\n * Creates a scoped resource with an interruptible acquire action.\n *\n *",
      documentation: "/**\n * Creates a scoped resource with an interruptible acquire action.\n *\n * **Details**\n *\n * This function is similar to {@link acquireRelease}, but it allows the\n * acquisition of the resource to be interrupted. The `acquire` effect, which\n * represents the process of obtaining the resource, can be interrupted if\n * necessary.\n *\n *",
      examples: [],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 9933,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9933"
    },
    {
      id: "Effect.acquireUseRelease",
      name: "acquireUseRelease",
      module: "Effect",
      package: "effect",
      signature: "{ <A2, E2, R2, A, X, R3>(use: (a: A) => Effect<A2, E2, R2>, release: (a: A, exit: Exit<A2, E2>) => Effect<X, never, R3>): <E, R>(acquire: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | R3 | R>; <A, E, R, A2, E2, R2, X, R3>(acquire: Effect<A, E, R>, use: (a: A) => Effect<A2, E2, R2>, release: (a: A, exit: Exit<A2, E2>) => Effect<X, never, R3>): Effect<A2, E | E2, R | R2 | R3>; }",
      description: "Many real-world operations involve working with resources that must be released when no longer needed, such as: - Database connections\n- File handles\n- Network requests This function ensures that a resource is: 1. Acquired properly.\n2. Used for its intended purpose.\n3. Released even if an error occurs.",
      documentation: 'Many real-world operations involve working with resources that must be released when no longer needed, such as:\n\n- Database connections\n- File handles\n- Network requests\n\nThis function ensures that a resource is:\n\n1. **Acquired** properly.\n2. **Used** for its intended purpose.\n3. **Released** even if an error occurs.\n\n**Example** (Automatically Managing Resource Lifetime)\n\n```ts\nimport { Effect, Console } from "effect"\n\n// Define an interface for a resource\ninterface MyResource {\n  readonly contents: string\n  readonly close: () => Promise<void>\n}\n\n// Simulate resource acquisition\nconst getMyResource = (): Promise<MyResource> =>\n  Promise.resolve({\n    contents: "lorem ipsum",\n    close: () =>\n      new Promise((resolve) => {\n        console.log("Resource released")\n        resolve()\n      })\n  })\n\n// Define how the resource is acquired\nconst acquire = Effect.tryPromise({\n  try: () =>\n    getMyResource().then((res) => {\n      console.log("Resource acquired")\n      return res\n    }),\n  catch: () => new Error("getMyResourceError")\n})\n\n// Define how the resource is released\nconst release = (res: MyResource) => Effect.promise(() => res.close())\n\nconst use = (res: MyResource) => Console.log(`content is ${res.contents}`)\n\n//      \u250C\u2500\u2500\u2500 Effect<void, Error, never>\n//      \u25BC\nconst program = Effect.acquireUseRelease(acquire, use, release)\n\nEffect.runPromise(program)\n// Output:\n// Resource acquired\n// content is lorem ipsum\n// Resource released\n```',
      examples: [
        {
          title: "Automatically Managing Resource Lifetime",
          code: 'import { Effect, Console } from "effect"\n\n// Define an interface for a resource\ninterface MyResource {\n  readonly contents: string\n  readonly close: () => Promise<void>\n}\n\n// Simulate resource acquisition\nconst getMyResource = (): Promise<MyResource> =>\n  Promise.resolve({\n    contents: "lorem ipsum",\n    close: () =>\n      new Promise((resolve) => {\n        console.log("Resource released")\n        resolve()\n      })\n  })\n\n// Define how the resource is acquired\nconst acquire = Effect.tryPromise({\n  try: () =>\n    getMyResource().then((res) => {\n      console.log("Resource acquired")\n      return res\n    }),\n  catch: () => new Error("getMyResourceError")\n})\n\n// Define how the resource is released\nconst release = (res: MyResource) => Effect.promise(() => res.close())\n\nconst use = (res: MyResource) => Console.log(`content is ${res.contents}`)\n\n//      \u250C\u2500\u2500\u2500 Effect<void, Error, never>\n//      \u25BC\nconst program = Effect.acquireUseRelease(acquire, use, release)\n\nEffect.runPromise(program)\n// Output:\n// Resource acquired\n// content is lorem ipsum\n// Resource released'
        }
      ],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 10027,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L10027"
    },
    {
      id: "Effect.addFinalizer",
      name: "addFinalizer",
      module: "Effect",
      package: "effect",
      signature: "<X, R>(finalizer: (exit: Exit<unknown, unknown>) => Effect<X, never, R>) => Effect<void, never, Scope | R>",
      description: "Ensures a finalizer is added to the scope of the calling effect, guaranteeing\nit runs when the scope is closed.",
      documentation: "Ensures a finalizer is added to the scope of the calling effect, guaranteeing\nit runs when the scope is closed.\n\n**Details**\n\nThis function adds a finalizer that will execute whenever the scope of the\neffect is closed, regardless of whether the effect succeeds, fails, or is\ninterrupted. The finalizer receives the `Exit` value of the effect's scope,\nallowing it to react differently depending on how the effect concludes.\n\nFinalizers are a reliable way to manage resource cleanup, ensuring that\nresources such as file handles, network connections, or database transactions\nare properly closed even in the event of an unexpected interruption or error.\n\nFinalizers operate in conjunction with Effect's scoped resources. If an\neffect with a finalizer is wrapped in a scope, the finalizer will execute\nautomatically when the scope ends.\n\n**Example** (Adding a Finalizer on Success)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\n//      \u250C\u2500\u2500\u2500 Effect<string, never, Scope>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  yield* Effect.addFinalizer((exit) =>\n    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)\n  )\n  return \"some result\"\n})\n\n// Wrapping the effect in a scope\n//\n//      \u250C\u2500\u2500\u2500 Effect<string, never, never>\n//      \u25BC\nconst runnable = Effect.scoped(program)\n\nEffect.runPromiseExit(runnable).then(console.log)\n// Output:\n// Finalizer executed. Exit status: Success\n// { _id: 'Exit', _tag: 'Success', value: 'some result' }\n```\n\n**Example** (Adding a Finalizer on Failure)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\n//      \u250C\u2500\u2500\u2500 Effect<never, string, Scope>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  yield* Effect.addFinalizer((exit) =>\n    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)\n  )\n  return yield* Effect.fail(\"Uh oh!\")\n})\n\n// Wrapping the effect in a scope\n//\n//      \u250C\u2500\u2500\u2500 Effect<never, string, never>\n//      \u25BC\nconst runnable = Effect.scoped(program)\n\nEffect.runPromiseExit(runnable).then(console.log)\n// Output:\n// Finalizer executed. Exit status: Failure\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Uh oh!' }\n// }\n```\n\n**Example** (Adding a Finalizer on Interruption)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\n//      \u250C\u2500\u2500\u2500 Effect<never, never, Scope>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  yield* Effect.addFinalizer((exit) =>\n    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)\n  )\n  return yield* Effect.interrupt\n})\n\n// Wrapping the effect in a scope\n//\n//      \u250C\u2500\u2500\u2500 Effect<never, never, never>\n//      \u25BC\nconst runnable = Effect.scoped(program)\n\nEffect.runPromiseExit(runnable).then(console.log)\n// Output:\n// Finalizer executed. Exit status: Failure\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Interrupt',\n//     fiberId: {\n//       _id: 'FiberId',\n//       _tag: 'Runtime',\n//       id: 0,\n//       startTimeMillis: ...\n//     }\n//   }\n// }\n```",
      examples: [
        {
          title: "Adding a Finalizer on Success",
          code: `import { Effect, Console } from "effect"

//      \u250C\u2500\u2500\u2500 Effect<string, never, Scope>
//      \u25BC
const program = Effect.gen(function* () {
  yield* Effect.addFinalizer((exit) =>
    Console.log(\`Finalizer executed. Exit status: \${exit._tag}\`)
  )
  return "some result"
})

// Wrapping the effect in a scope
//
//      \u250C\u2500\u2500\u2500 Effect<string, never, never>
//      \u25BC
const runnable = Effect.scoped(program)

Effect.runPromiseExit(runnable).then(console.log)
// Output:
// Finalizer executed. Exit status: Success
// { _id: 'Exit', _tag: 'Success', value: 'some result' }`
        },
        {
          title: "Adding a Finalizer on Failure",
          code: `import { Effect, Console } from "effect"

//      \u250C\u2500\u2500\u2500 Effect<never, string, Scope>
//      \u25BC
const program = Effect.gen(function* () {
  yield* Effect.addFinalizer((exit) =>
    Console.log(\`Finalizer executed. Exit status: \${exit._tag}\`)
  )
  return yield* Effect.fail("Uh oh!")
})

// Wrapping the effect in a scope
//
//      \u250C\u2500\u2500\u2500 Effect<never, string, never>
//      \u25BC
const runnable = Effect.scoped(program)

Effect.runPromiseExit(runnable).then(console.log)
// Output:
// Finalizer executed. Exit status: Failure
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Uh oh!' }
// }`
        },
        {
          title: "Adding a Finalizer on Interruption",
          code: "import { Effect, Console } from \"effect\"\n\n//      \u250C\u2500\u2500\u2500 Effect<never, never, Scope>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  yield* Effect.addFinalizer((exit) =>\n    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)\n  )\n  return yield* Effect.interrupt\n})\n\n// Wrapping the effect in a scope\n//\n//      \u250C\u2500\u2500\u2500 Effect<never, never, never>\n//      \u25BC\nconst runnable = Effect.scoped(program)\n\nEffect.runPromiseExit(runnable).then(console.log)\n// Output:\n// Finalizer executed. Exit status: Failure\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Interrupt',\n//     fiberId: {\n//       _id: 'FiberId',\n//       _tag: 'Runtime',\n//       id: 0,\n//       startTimeMillis: ...\n//     }\n//   }\n// }"
        }
      ],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 10278,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L10278"
    },
    {
      id: "Effect.ensuring",
      name: "ensuring",
      module: "Effect",
      package: "effect",
      signature: "{ <X, R1>(finalizer: Effect<X, never, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R1 | R>; <A, E, R, X, R1>(self: Effect<A, E, R>, finalizer: Effect<X, never, R1>): Effect<A, E, R | R1>; }",
      description: "/\n * Guarantees the execution of a finalizer when an effect starts execution.\n *\n *",
      documentation: '/**\n * Guarantees the execution of a finalizer when an effect starts execution.\n *\n * **Details**\n *\n * This function allows you to specify a `finalizer` effect that will always be\n * run once the effect starts execution, regardless of whether the effect\n * succeeds, fails, or is interrupted.\n *\n * **When to Use**\n *\n * This is useful when you need to ensure that certain cleanup or final steps\n * are executed in all cases, such as releasing resources or performing\n * necessary logging.\n *\n * While this function provides strong guarantees about executing the finalizer,\n * it is considered a low-level tool, which may not be ideal for more complex\n * resource management. For higher-level resource management with automatic\n * acquisition and release, see the {@link acquireRelease}family of functions.\n * For use cases where you need access to the result of an effect, consider\n * using {@link onExit}.\n *\n * **Example** (Running a Finalizer in All Outcomes)\n *\n * ```ts\n * import { Console, Effect } from "effect"\n *\n * // Define a cleanup effect\n * const handler = Effect.ensuring(Console.log("Cleanup completed"))\n *\n * // Define a successful effect\n * const success = Console.log("Task completed").pipe(\n *   Effect.as("some result"),\n *   handler\n * )\n *\n * Effect.runFork(success)\n * // Output:\n * // Task completed\n * // Cleanup completed\n *\n * // Define a failing effect\n * const failure = Console.log("Task failed").pipe(\n *   Effect.andThen(Effect.fail("some error")),\n *   handler\n * )\n *\n * Effect.runFork(failure)\n * // Output:\n * // Task failed\n * // Cleanup completed\n *\n * // Define an interrupted effect\n * const interruption = Console.log("Task interrupted").pipe(\n *   Effect.andThen(Effect.interrupt),\n *   handler\n * )\n *\n * Effect.runFork(interruption)\n * // Output:\n * // Task interrupted\n * // Cleanup completed\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Console, Effect } from "effect"\n *\n * // Define a cleanup effect\n * const handler = Effect.ensuring(Console.log("Cleanup completed"))\n *\n * // Define a successful effect\n * const success = Console.log("Task completed").pipe(\n *   Effect.as("some result"),\n *   handler\n * )\n *\n * Effect.runFork(success)\n * // Output:\n * // Task completed\n * // Cleanup completed\n *\n * // Define a failing effect\n * const failure = Console.log("Task failed").pipe(\n *   Effect.andThen(Effect.fail("some error")),\n *   handler\n * )\n *\n * Effect.runFork(failure)\n * // Output:\n * // Task failed\n * // Cleanup completed\n *\n * // Define an interrupted effect\n * const interruption = Console.log("Task interrupted").pipe(\n *   Effect.andThen(Effect.interrupt),\n *   handler\n * )\n *\n * Effect.runFork(interruption)\n * // Output:\n * // Task interrupted\n * // Cleanup completed\n *'
        }
      ],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 10349,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L10349"
    },
    {
      id: "Effect.onError",
      name: "onError",
      module: "Effect",
      package: "effect",
      signature: "{ <E, X, R2>(cleanup: (cause: Cause<E>) => Effect<X, never, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, cleanup: (cause: Cause<E>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }",
      description: "Ensures a cleanup effect runs whenever the calling effect fails, providing\nthe failure cause to the cleanup effect.",
      documentation: 'Ensures a cleanup effect runs whenever the calling effect fails, providing\nthe failure cause to the cleanup effect.\n\n**Details**\n\nThis function allows you to attach a cleanup effect that runs whenever the\ncalling effect fails. The cleanup effect receives the cause of the failure,\nallowing you to perform actions such as logging, releasing resources, or\nexecuting additional recovery logic based on the error. The cleanup effect\nwill execute even if the failure is due to interruption.\n\nImportantly, the cleanup effect itself is uninterruptible, ensuring that it\ncompletes regardless of external interruptions.\n\n**Example** (Running Cleanup Only on Failure)\n\n```ts\nimport { Console, Effect } from "effect"\n\n// This handler logs the failure cause when the effect fails\nconst handler = Effect.onError((cause) =>\n  Console.log(`Cleanup completed: ${cause}`)\n)\n\n// Define a successful effect\nconst success = Console.log("Task completed").pipe(\n  Effect.as("some result"),\n  handler\n)\n\nEffect.runFork(success)\n// Output:\n// Task completed\n\n// Define a failing effect\nconst failure = Console.log("Task failed").pipe(\n  Effect.andThen(Effect.fail("some error")),\n  handler\n)\n\nEffect.runFork(failure)\n// Output:\n// Task failed\n// Cleanup completed: Error: some error\n\n// Define a failing effect\nconst defect = Console.log("Task failed with defect").pipe(\n  Effect.andThen(Effect.die("Boom!")),\n  handler\n)\n\nEffect.runFork(defect)\n// Output:\n// Task failed with defect\n// Cleanup completed: Error: Boom!\n\n// Define an interrupted effect\nconst interruption = Console.log("Task interrupted").pipe(\n  Effect.andThen(Effect.interrupt),\n  handler\n)\n\nEffect.runFork(interruption)\n// Output:\n// Task interrupted\n// Cleanup completed: All fibers interrupted without errors.\n```',
      examples: [
        {
          title: "Running Cleanup Only on Failure",
          code: 'import { Console, Effect } from "effect"\n\n// This handler logs the failure cause when the effect fails\nconst handler = Effect.onError((cause) =>\n  Console.log(`Cleanup completed: ${cause}`)\n)\n\n// Define a successful effect\nconst success = Console.log("Task completed").pipe(\n  Effect.as("some result"),\n  handler\n)\n\nEffect.runFork(success)\n// Output:\n// Task completed\n\n// Define a failing effect\nconst failure = Console.log("Task failed").pipe(\n  Effect.andThen(Effect.fail("some error")),\n  handler\n)\n\nEffect.runFork(failure)\n// Output:\n// Task failed\n// Cleanup completed: Error: some error\n\n// Define a failing effect\nconst defect = Console.log("Task failed with defect").pipe(\n  Effect.andThen(Effect.die("Boom!")),\n  handler\n)\n\nEffect.runFork(defect)\n// Output:\n// Task failed with defect\n// Cleanup completed: Error: Boom!\n\n// Define an interrupted effect\nconst interruption = Console.log("Task interrupted").pipe(\n  Effect.andThen(Effect.interrupt),\n  handler\n)\n\nEffect.runFork(interruption)\n// Output:\n// Task interrupted\n// Cleanup completed: All fibers interrupted without errors.'
        }
      ],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 10568,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L10568"
    },
    {
      id: "Effect.onExit",
      name: "onExit",
      module: "Effect",
      package: "effect",
      signature: "{ <A, E, X, R2>(cleanup: (exit: Exit<A, E>) => Effect<X, never, R2>): <R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, cleanup: (exit: Exit<A, E>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }",
      description: "Guarantees that a cleanup function runs regardless of whether the effect\nsucceeds, fails, or is interrupted.",
      documentation: 'Guarantees that a cleanup function runs regardless of whether the effect\nsucceeds, fails, or is interrupted.\n\n**Details**\n\nThis function ensures that a provided cleanup function is executed after the\neffect completes, regardless of the outcome. The cleanup function is given\nthe `Exit` value of the effect, which provides detailed information about the\nresult:\n- If the effect succeeds, the `Exit` contains the success value.\n- If the effect fails, the `Exit` contains the error or failure cause.\n- If the effect is interrupted, the `Exit` reflects the interruption.\n\nThe cleanup function is guaranteed to run uninterruptibly, ensuring reliable\nresource management even in complex or high-concurrency scenarios.\n\n**Example** (Running a Cleanup Function with the Effect\u2019s Result)\n\n```ts\nimport { Console, Effect, Exit } from "effect"\n\n// Define a cleanup effect that logs the result\nconst handler = Effect.onExit((exit) =>\n  Console.log(`Cleanup completed: ${Exit.getOrElse(exit, String)}`)\n)\n\n// Define a successful effect\nconst success = Console.log("Task completed").pipe(\n  Effect.as("some result"),\n  handler\n)\n\nEffect.runFork(success)\n// Output:\n// Task completed\n// Cleanup completed: some result\n\n// Define a failing effect\nconst failure = Console.log("Task failed").pipe(\n  Effect.andThen(Effect.fail("some error")),\n  handler\n)\n\nEffect.runFork(failure)\n// Output:\n// Task failed\n// Cleanup completed: Error: some error\n\n// Define an interrupted effect\nconst interruption = Console.log("Task interrupted").pipe(\n  Effect.andThen(Effect.interrupt),\n  handler\n)\n\nEffect.runFork(interruption)\n// Output:\n// Task interrupted\n// Cleanup completed: All fibers interrupted without errors.\n```',
      examples: [
        {
          title: "Running a Cleanup Function with the Effect\u2019s Result",
          code: 'import { Console, Effect, Exit } from "effect"\n\n// Define a cleanup effect that logs the result\nconst handler = Effect.onExit((exit) =>\n  Console.log(`Cleanup completed: ${Exit.getOrElse(exit, String)}`)\n)\n\n// Define a successful effect\nconst success = Console.log("Task completed").pipe(\n  Effect.as("some result"),\n  handler\n)\n\nEffect.runFork(success)\n// Output:\n// Task completed\n// Cleanup completed: some result\n\n// Define a failing effect\nconst failure = Console.log("Task failed").pipe(\n  Effect.andThen(Effect.fail("some error")),\n  handler\n)\n\nEffect.runFork(failure)\n// Output:\n// Task failed\n// Cleanup completed: Error: some error\n\n// Define an interrupted effect\nconst interruption = Console.log("Task interrupted").pipe(\n  Effect.andThen(Effect.interrupt),\n  handler\n)\n\nEffect.runFork(interruption)\n// Output:\n// Task interrupted\n// Cleanup completed: All fibers interrupted without errors.'
        }
      ],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 10786,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L10786"
    },
    {
      id: "Effect.parallelFinalizers",
      name: "parallelFinalizers",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>",
      description: "Ensures that finalizers are run concurrently when the scope of an effect is\nclosed.",
      documentation: 'Ensures that finalizers are run concurrently when the scope of an effect is\nclosed.\n\n**Details**\n\nThis function modifies the behavior of finalizers within a scoped workflow to\nallow them to run concurrently when the scope is closed.\n\nBy default, finalizers are executed sequentially in reverse order of their\naddition, but this function changes that behavior to execute all finalizers\nconcurrently.\n\n**When to Use**\n\nRunning finalizers concurrently can improve performance when multiple\nindependent cleanup tasks need to be performed. However, it requires that\nthese tasks do not depend on the order of execution or introduce race\nconditions.\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\n// Define a program that adds multiple finalizers\nconst program = Effect.gen(function*() {\n  yield* Effect.addFinalizer(() => Console.log("Finalizer 1 executed").pipe(Effect.delay("300 millis")))\n  yield* Effect.addFinalizer(() => Console.log("Finalizer 2 executed").pipe(Effect.delay("100 millis")))\n  yield* Effect.addFinalizer(() => Console.log("Finalizer 3 executed").pipe(Effect.delay("200 millis")))\n  return "some result"\n})\n\n// Modify the program to ensure finalizers run in parallel\nconst modified = program.pipe(Effect.parallelFinalizers)\n\nconst runnable = Effect.scoped(modified)\n\nEffect.runFork(runnable)\n// Output:\n// Finalizer 2 executed\n// Finalizer 3 executed\n// Finalizer 1 executed\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\n// Define a program that adds multiple finalizers\nconst program = Effect.gen(function*() {\n  yield* Effect.addFinalizer(() => Console.log("Finalizer 1 executed").pipe(Effect.delay("300 millis")))\n  yield* Effect.addFinalizer(() => Console.log("Finalizer 2 executed").pipe(Effect.delay("100 millis")))\n  yield* Effect.addFinalizer(() => Console.log("Finalizer 3 executed").pipe(Effect.delay("200 millis")))\n  return "some result"\n})\n\n// Modify the program to ensure finalizers run in parallel\nconst modified = program.pipe(Effect.parallelFinalizers)\n\nconst runnable = Effect.scoped(modified)\n\nEffect.runFork(runnable)\n// Output:\n// Finalizer 2 executed\n// Finalizer 3 executed\n// Finalizer 1 executed'
        }
      ],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 10968,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L10968"
    },
    {
      id: "Effect.sequentialFinalizers",
      name: "sequentialFinalizers",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>",
      description: "Ensures that finalizers are run sequentially in reverse order of their\naddition.",
      documentation: "Ensures that finalizers are run sequentially in reverse order of their\naddition.\n\n**Details**\n\nThis function modifies the behavior of finalizers within a scoped workflow to\nensure they are run sequentially in reverse order when the scope is closed.\n\nBy default, finalizers are executed sequentially, so this only changes the\nbehavior if the scope is configured to run finalizers concurrently.",
      examples: [],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 10986,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L10986"
    },
    {
      id: "Effect.finalizersMask",
      name: "finalizersMask",
      module: "Effect",
      package: "effect",
      signature: "(strategy: ExecutionStrategy) => <A, E, R>(self: (restore: <A1, E1, R1>(self: Effect<A1, E1, R1>) => Effect<A1, E1, R1>) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "Applies a custom execution strategy to finalizers within a scoped workflow.",
      documentation: "Applies a custom execution strategy to finalizers within a scoped workflow.\n\n**Details**\n\nThis function allows you to control how finalizers are executed in a scope by\napplying a specified `ExecutionStrategy`. The `strategy` can dictate whether\nfinalizers run (e.g., sequentially or in parallel).\n\nAdditionally, the function provides a `restore` operation, which ensures that\nthe effect passed to it is executed under the default execution strategy.",
      examples: [],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11002,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11002"
    },
    {
      id: "Effect.scope",
      name: "scope",
      module: "Effect",
      package: "effect",
      signature: "Effect<Scope, never, Scope>",
      description: "Provides access to the current scope in a scoped workflow.",
      documentation: "Provides access to the current scope in a scoped workflow.",
      examples: [],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11009,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11009"
    },
    {
      id: "Effect.scopeWith",
      name: "scopeWith",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(f: (scope: Scope) => Effect<A, E, R>) => Effect<A, E, Scope | R>",
      description: "Accesses the current scope and uses it to perform the specified effect.",
      documentation: "Accesses the current scope and uses it to perform the specified effect.",
      examples: [],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11016,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11016"
    },
    {
      id: "Effect.scopedWith",
      name: "scopedWith",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(f: (scope: Scope) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "Creates a `Scope`, passes it to the specified effectful function, and closes\nthe scope when the effect completes (whether through success, failure, or\ninterruption).",
      documentation: "Creates a `Scope`, passes it to the specified effectful function, and closes\nthe scope when the effect completes (whether through success, failure, or\ninterruption).",
      examples: [],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "3.11.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11025,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11025"
    },
    {
      id: "Effect.scoped",
      name: "scoped",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, Exclude<R, Scope>>",
      description: "Scopes all resources used in an effect to the lifetime of the effect.",
      documentation: "Scopes all resources used in an effect to the lifetime of the effect.\n\n**Details**\n\nThis function ensures that all resources used within an effect are tied to\nits lifetime. Finalizers for these resources are executed automatically when\nthe effect completes, whether through success, failure, or interruption. This\nguarantees proper resource cleanup without requiring explicit management.",
      examples: [],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11039,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11039"
    },
    {
      id: "Effect.using",
      name: "using",
      module: "Effect",
      package: "effect",
      signature: "{ <A, A2, E2, R2>(use: (a: A) => Effect<A2, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | Exclude<R, Scope>>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, use: (a: A) => Effect<A2, E2, R2>): Effect<A2, E | E2, R2 | Exclude<R, Scope>>; }",
      description: "Scopes all resources acquired by one effect to the lifetime of another\neffect.",
      documentation: 'Scopes all resources acquired by one effect to the lifetime of another\neffect.\n\n**Details**\n\nThis function allows you to scope the resources acquired by one effect\n(`self`) to the lifetime of another effect (`use`). This ensures that the\nresources are cleaned up as soon as the `use` effect completes, regardless of\nhow the `use` effect ends (success, failure, or interruption).\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\nconst acquire = Console.log("Acquiring resource").pipe(\n  Effect.as(1),\n  Effect.tap(Effect.addFinalizer(() => Console.log("Releasing resource")))\n)\nconst use = (resource: number) => Console.log(`Using resource: ${resource}`)\n\nconst program = acquire.pipe(Effect.using(use))\n\nEffect.runFork(program)\n// Output:\n// Acquiring resource\n// Using resource: 1\n// Releasing resource\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\nconst acquire = Console.log("Acquiring resource").pipe(\n  Effect.as(1),\n  Effect.tap(Effect.addFinalizer(() => Console.log("Releasing resource")))\n)\nconst use = (resource: number) => Console.log(`Using resource: ${resource}`)\n\nconst program = acquire.pipe(Effect.using(use))\n\nEffect.runFork(program)\n// Output:\n// Acquiring resource\n// Using resource: 1\n// Releasing resource'
        }
      ],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11076,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11076"
    },
    {
      id: "Effect.withEarlyRelease",
      name: "withEarlyRelease",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<[finalizer: Effect<void, never, never>, result: A], E, Scope | R>",
      description: "Returns the result of the effect and a finalizer to close its scope.",
      documentation: 'Returns the result of the effect and a finalizer to close its scope.\n\n**Details**\n\nThis function allows you to retrieve both the result of an effect and a\nfinalizer that can be used to manually close its scope. This is useful for\nworkflows where you need early access to the result while retaining control\nover the resource cleanup process.\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\nconst acquire = Console.log("Acquiring resource").pipe(\n  Effect.as(1),\n  Effect.tap(Effect.addFinalizer(() => Console.log("Releasing resource")))\n)\nconst program = Effect.gen(function*() {\n  const [finalizer, resource] = yield* Effect.withEarlyRelease(acquire)\n  console.log(`Using resource: ${resource}`)\n  yield* Effect.sleep("1 second")\n  yield* finalizer\n})\n\nEffect.runFork(program.pipe(Effect.scoped))\n// Output:\n// Acquiring resource\n// Using resource: 1\n// Releasing resource\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\nconst acquire = Console.log("Acquiring resource").pipe(\n  Effect.as(1),\n  Effect.tap(Effect.addFinalizer(() => Console.log("Releasing resource")))\n)\nconst program = Effect.gen(function*() {\n  const [finalizer, resource] = yield* Effect.withEarlyRelease(acquire)\n  console.log(`Using resource: ${resource}`)\n  yield* Effect.sleep("1 second")\n  yield* finalizer\n})\n\nEffect.runFork(program.pipe(Effect.scoped))\n// Output:\n// Acquiring resource\n// Using resource: 1\n// Releasing resource'
        }
      ],
      tags: [
        "Scoping, Resources & Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11188,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11188"
    },
    {
      id: "Effect.awaitAllChildren",
      name: "awaitAllChildren",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>",
      description: "Returns a new effect that will not succeed with its value before first\nwaiting for the end of all child fibers forked by the effect.",
      documentation: "Returns a new effect that will not succeed with its value before first\nwaiting for the end of all child fibers forked by the effect.",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11196,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11196"
    },
    {
      id: "Effect.daemonChildren",
      name: "daemonChildren",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>",
      description: "Returns a new workflow that will not supervise any fibers forked by this\nworkflow.",
      documentation: "Returns a new workflow that will not supervise any fibers forked by this\nworkflow.",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11204,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11204"
    },
    {
      id: "Effect.descriptor",
      name: "descriptor",
      module: "Effect",
      package: "effect",
      signature: "Effect<Fiber.Descriptor, never, never>",
      description: "Constructs an effect with information about the current `Fiber`.",
      documentation: "Constructs an effect with information about the current `Fiber`.",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11211,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11211"
    },
    {
      id: "Effect.descriptorWith",
      name: "descriptorWith",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(f: (descriptor: Fiber.Descriptor) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "Constructs an effect based on information about the current `Fiber`.",
      documentation: "Constructs an effect based on information about the current `Fiber`.",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11218,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11218"
    },
    {
      id: "Effect.diffFiberRefs",
      name: "diffFiberRefs",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<[FiberRefsPatch, A], E, R>",
      description: "Returns a new workflow that executes this one and captures the changes in\n`FiberRef` values.",
      documentation: "Returns a new workflow that executes this one and captures the changes in\n`FiberRef` values.",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11226,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11226"
    },
    {
      id: "Effect.ensuringChild",
      name: "ensuringChild",
      module: "Effect",
      package: "effect",
      signature: "{ <X, R2>(f: (fiber: Fiber<readonly unknown[], any>) => Effect<X, never, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, f: (fiber: Fiber<readonly unknown[], any>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }",
      description: "Acts on the children of this fiber (collected into a single fiber),\nguaranteeing the specified callback will be invoked, whether or not this\neffect succeeds.",
      documentation: "Acts on the children of this fiber (collected into a single fiber),\nguaranteeing the specified callback will be invoked, whether or not this\neffect succeeds.",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11235,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11235"
    },
    {
      id: "Effect.ensuringChildren",
      name: "ensuringChildren",
      module: "Effect",
      package: "effect",
      signature: "{ <X, R2>(children: (fibers: readonly RuntimeFiber<any, any>[]) => Effect<X, never, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, children: (fibers: readonly RuntimeFiber<any, any>[]) => Effect<X, never, R2>): Effect<A, E, R | R2>; }",
      description: "Acts on the children of this fiber, guaranteeing the specified callback\nwill be invoked, whether or not this effect succeeds.",
      documentation: "Acts on the children of this fiber, guaranteeing the specified callback\nwill be invoked, whether or not this effect succeeds.",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11262,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11262"
    },
    {
      id: "Effect.fiberId",
      name: "fiberId",
      module: "Effect",
      package: "effect",
      signature: "Effect<FiberId, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11284,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11284"
    },
    {
      id: "Effect.fiberIdWith",
      name: "fiberIdWith",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(f: (descriptor: Runtime) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11289,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11289"
    },
    {
      id: "Effect.fork",
      name: "fork",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<RuntimeFiber<A, E>, never, R>",
      description: "/\n * Creates a new fiber to run an effect concurrently.\n *\n *",
      documentation: '/**\n * Creates a new fiber to run an effect concurrently.\n *\n * **Details**\n *\n * This function takes an effect and forks it into a separate fiber, allowing it\n * to run concurrently without blocking the original effect. The new fiber\n * starts execution immediately after being created, and the fiber object is\n * returned immediately without waiting for the effect to begin. This is useful\n * when you want to run tasks concurrently while continuing other tasks in the\n * parent fiber.\n *\n * The forked fiber is attached to the parent fiber\'s scope. This means that\n * when the parent fiber terminates, the child fiber will also be terminated\n * automatically. This feature, known as "auto supervision," ensures that no\n * fibers are left running unintentionally. If you prefer not to have this auto\n * supervision behavior, you can use {@link forkDaemon}or {@link forkIn}.\n *\n * **When to Use**\n *\n * Use this function when you need to run an effect concurrently without\n * blocking the current execution flow. For example, you might use it to launch\n * background tasks or concurrent computations. However, working with fibers can\n * be complex, so before using this function directly, you might want to explore\n * higher-level functions like {@link raceWith}, {@link zip}, or others that can\n * manage concurrency for you.\n *\n * **Example**\n *\n * ```ts\n * import { Effect } from "effect"\n *\n * const fib = (n: number): Effect.Effect<number> =>\n *   n < 2\n *     ? Effect.succeed(n)\n *     : Effect.zipWith(fib(n - 1), fib(n - 2), (a, b) => a + b)\n *\n * //      \u250C\u2500\u2500\u2500 Effect<RuntimeFiber<number, never>, never, never>\n * //      \u25BC\n * const fib10Fiber = Effect.fork(fib(10))\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect } from "effect"\n *\n * const fib = (n: number): Effect.Effect<number> =>\n *   n < 2\n *     ? Effect.succeed(n)\n *     : Effect.zipWith(fib(n - 1), fib(n - 2), (a, b) => a + b)\n *\n * //      \u250C\u2500\u2500\u2500 Effect<RuntimeFiber<number, never>, never, never>\n * //      \u25BC\n * const fib10Fiber = Effect.fork(fib(10))\n *'
        }
      ],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11337,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11337"
    },
    {
      id: "Effect.forkDaemon",
      name: "forkDaemon",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<RuntimeFiber<A, E>, never, R>",
      description: "Creates a long-running background fiber that is independent of its parent.",
      documentation: 'Creates a long-running background fiber that is independent of its parent.\n\n**Details**\n\nThis function creates a "daemon" fiber that runs in the background and is not\ntied to the lifecycle of its parent fiber. Unlike normal fibers that stop\nwhen the parent fiber terminates, a daemon fiber will continue running until\nthe global scope closes or the fiber completes naturally. This makes it\nuseful for tasks that need to run in the background independently, such as\nperiodic logging, monitoring, or background data processing.\n\n**Example** (Creating a Daemon Fiber)\n\n```ts\nimport { Effect, Console, Schedule } from "effect"\n\n// Daemon fiber that logs a message repeatedly every second\nconst daemon = Effect.repeat(\n  Console.log("daemon: still running!"),\n  Schedule.fixed("1 second")\n)\n\nconst parent = Effect.gen(function* () {\n  console.log("parent: started!")\n  // Daemon fiber running independently\n  yield* Effect.forkDaemon(daemon)\n  yield* Effect.sleep("3 seconds")\n  console.log("parent: finished!")\n})\n\nEffect.runFork(parent)\n// Output:\n// parent: started!\n// daemon: still running!\n// daemon: still running!\n// daemon: still running!\n// parent: finished!\n// daemon: still running!\n// daemon: still running!\n// daemon: still running!\n// daemon: still running!\n// daemon: still running!\n// ...etc...\n```',
      examples: [
        {
          title: "Creating a Daemon Fiber",
          code: 'import { Effect, Console, Schedule } from "effect"\n\n// Daemon fiber that logs a message repeatedly every second\nconst daemon = Effect.repeat(\n  Console.log("daemon: still running!"),\n  Schedule.fixed("1 second")\n)\n\nconst parent = Effect.gen(function* () {\n  console.log("parent: started!")\n  // Daemon fiber running independently\n  yield* Effect.forkDaemon(daemon)\n  yield* Effect.sleep("3 seconds")\n  console.log("parent: finished!")\n})\n\nEffect.runFork(parent)\n// Output:\n// parent: started!\n// daemon: still running!\n// daemon: still running!\n// daemon: still running!\n// parent: finished!\n// daemon: still running!\n// daemon: still running!\n// daemon: still running!\n// daemon: still running!\n// daemon: still running!\n// ...etc...'
        }
      ],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11387,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11387"
    },
    {
      id: "Effect.forkAll",
      name: "forkAll",
      module: "Effect",
      package: "effect",
      signature: "{ (options?: { readonly discard?: false; }): <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>) => Effect<Fiber<Effect.Success<Eff>[], Effect.Error<Eff>>, never, Effect.Context<Eff>>; (options: { readonly discard: true; }): <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>) => Effect<void, never, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>, options?: { readonly discard?: false; }): Effect<Fiber<Effect.Success<Eff>[], Effect.Error<Eff>>, never, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>, options: { readonly discard: true; }): Effect<void, never, Effect.Context<Eff>>; }",
      description: "Returns an effect that forks all of the specified values, and returns a\ncomposite fiber that produces a list of their results, in order.",
      documentation: "Returns an effect that forks all of the specified values, and returns a\ncomposite fiber that produces a list of their results, in order.",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11395,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11395"
    },
    {
      id: "Effect.forkIn",
      name: "forkIn",
      module: "Effect",
      package: "effect",
      signature: "{ (scope: Scope): <A, E, R>(self: Effect<A, E, R>) => Effect<RuntimeFiber<A, E>, never, R>; <A, E, R>(self: Effect<A, E, R>, scope: Scope): Effect<RuntimeFiber<A, E>, never, R>; }",
      description: "Forks an effect in a specific scope, allowing finer control over its\nexecution.",
      documentation: 'Forks an effect in a specific scope, allowing finer control over its\nexecution.\n\n**Details**\n\nThere are some cases where we need more fine-grained control, so we want to\nfork a fiber in a specific scope. We can use the `Effect.forkIn` operator\nwhich takes the target scope as an argument.\n\nThe fiber will be interrupted when the scope is closed.\n\n**Example** (Forking a Fiber in a Specific Scope)\n\nIn this example, the child fiber is forked into the outerScope,\nallowing it to outlive the inner scope but still be terminated\nwhen the outerScope is closed.\n\n```ts\nimport { Console, Effect, Schedule } from "effect"\n\n// Child fiber that logs a message repeatedly every second\nconst child = Effect.repeat(\n  Console.log("child: still running!"),\n  Schedule.fixed("1 second")\n)\n\nconst program = Effect.scoped(\n  Effect.gen(function* () {\n    yield* Effect.addFinalizer(() =>\n      Console.log("The outer scope is about to be closed!")\n    )\n\n    // Capture the outer scope\n    const outerScope = yield* Effect.scope\n\n    // Create an inner scope\n    yield* Effect.scoped(\n      Effect.gen(function* () {\n        yield* Effect.addFinalizer(() =>\n          Console.log("The inner scope is about to be closed!")\n        )\n        // Fork the child fiber in the outer scope\n        yield* Effect.forkIn(child, outerScope)\n        yield* Effect.sleep("3 seconds")\n      })\n    )\n\n    yield* Effect.sleep("5 seconds")\n  })\n)\n\nEffect.runFork(program)\n// Output:\n// child: still running!\n// child: still running!\n// child: still running!\n// The inner scope is about to be closed!\n// child: still running!\n// child: still running!\n// child: still running!\n// child: still running!\n// child: still running!\n// child: still running!\n// The outer scope is about to be closed!\n```',
      examples: [
        {
          code: 'import { Console, Effect, Schedule } from "effect"\n\n// Child fiber that logs a message repeatedly every second\nconst child = Effect.repeat(\n  Console.log("child: still running!"),\n  Schedule.fixed("1 second")\n)\n\nconst program = Effect.scoped(\n  Effect.gen(function* () {\n    yield* Effect.addFinalizer(() =>\n      Console.log("The outer scope is about to be closed!")\n    )\n\n    // Capture the outer scope\n    const outerScope = yield* Effect.scope\n\n    // Create an inner scope\n    yield* Effect.scoped(\n      Effect.gen(function* () {\n        yield* Effect.addFinalizer(() =>\n          Console.log("The inner scope is about to be closed!")\n        )\n        // Fork the child fiber in the outer scope\n        yield* Effect.forkIn(child, outerScope)\n        yield* Effect.sleep("3 seconds")\n      })\n    )\n\n    yield* Effect.sleep("5 seconds")\n  })\n)\n\nEffect.runFork(program)\n// Output:\n// child: still running!\n// child: still running!\n// child: still running!\n// The inner scope is about to be closed!\n// child: still running!\n// child: still running!\n// child: still running!\n// child: still running!\n// child: still running!\n// child: still running!\n// The outer scope is about to be closed!'
        }
      ],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11507,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11507"
    },
    {
      id: "Effect.forkScoped",
      name: "forkScoped",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<RuntimeFiber<A, E>, never, Scope | R>",
      description: "/\n * Forks a fiber in a local scope, ensuring it outlives its parent.\n *\n *",
      documentation: '/**\n * Forks a fiber in a local scope, ensuring it outlives its parent.\n *\n * **Details**\n *\n * This function is used to create fibers that are tied to a local scope,\n * meaning they are not dependent on their parent fiber\'s lifecycle. Instead,\n * they will continue running until the scope they were created in is closed.\n * This is particularly useful when you need a fiber to run independently of the\n * parent fiber, but still want it to be terminated when the scope ends.\n *\n * Fibers created with this function are isolated from the parent fiber\u2019s\n * termination, so they can run for a longer period. This behavior is different\n * from fibers created with {@link fork}, which are terminated when the parent fiber\n * terminates. With `forkScoped`, the child fiber will keep running until the\n * local scope ends, regardless of the state of the parent fiber.\n *\n * **Example** (Forking a Fiber in a Local Scope)\n *\n * In this example, the child fiber continues to run beyond the lifetime of the parent fiber.\n * The child fiber is tied to the local scope and will be terminated only when the scope ends.\n *\n * ```ts\n * import { Effect, Console, Schedule } from "effect"\n *\n * // Child fiber that logs a message repeatedly every second\n * const child = Effect.repeat(\n *   Console.log("child: still running!"),\n *   Schedule.fixed("1 second")\n * )\n *\n * //      \u250C\u2500\u2500\u2500 Effect<void, never, Scope>\n * //      \u25BC\n * const parent = Effect.gen(function* () {\n *   console.log("parent: started!")\n *   // Child fiber attached to local scope\n *   yield* Effect.forkScoped(child)\n *   yield* Effect.sleep("3 seconds")\n *   console.log("parent: finished!")\n * })\n *\n * // Program runs within a local scope\n * const program = Effect.scoped(\n *   Effect.gen(function* () {\n *     console.log("Local scope started!")\n *     yield* Effect.fork(parent)\n *     // Scope lasts for 5 seconds\n *     yield* Effect.sleep("5 seconds")\n *     console.log("Leaving the local scope!")\n *   })\n * )\n *\n * Effect.runFork(program)\n * // Output:\n * // Local scope started!\n * // parent: started!\n * // child: still running!\n * // child: still running!\n * // child: still running!\n * // parent: finished!\n * // child: still running!\n * // child: still running!\n * // Leaving the local scope!\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect, Console, Schedule } from "effect"\n *\n * // Child fiber that logs a message repeatedly every second\n * const child = Effect.repeat(\n *   Console.log("child: still running!"),\n *   Schedule.fixed("1 second")\n * )\n *\n * //      \u250C\u2500\u2500\u2500 Effect<void, never, Scope>\n * //      \u25BC\n * const parent = Effect.gen(function* () {\n *   console.log("parent: started!")\n *   // Child fiber attached to local scope\n *   yield* Effect.forkScoped(child)\n *   yield* Effect.sleep("3 seconds")\n *   console.log("parent: finished!")\n * })\n *\n * // Program runs within a local scope\n * const program = Effect.scoped(\n *   Effect.gen(function* () {\n *     console.log("Local scope started!")\n *     yield* Effect.fork(parent)\n *     // Scope lasts for 5 seconds\n *     yield* Effect.sleep("5 seconds")\n *     console.log("Leaving the local scope!")\n *   })\n * )\n *\n * Effect.runFork(program)\n * // Output:\n * // Local scope started!\n * // parent: started!\n * // child: still running!\n * // child: still running!\n * // child: still running!\n * // parent: finished!\n * // child: still running!\n * // child: still running!\n * // Leaving the local scope!\n *'
        }
      ],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11719,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11719"
    },
    {
      id: "Effect.forkWithErrorHandler",
      name: "forkWithErrorHandler",
      module: "Effect",
      package: "effect",
      signature: "{ <E, X>(handler: (e: E) => Effect<X, never, never>): <A, R>(self: Effect<A, E, R>) => Effect<RuntimeFiber<A, E>, never, R>; <A, E, R, X>(self: Effect<A, E, R>, handler: (e: E) => Effect<X, never, never>): Effect<RuntimeFiber<A, E>, never, R>; }",
      description: "/\n * Like {@link fork}but handles an error with the provided handler.\n *\n *",
      documentation: "/**\n * Like {@link fork}but handles an error with the provided handler.\n *\n *",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11726,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11726"
    },
    {
      id: "Effect.fromFiber",
      name: "fromFiber",
      module: "Effect",
      package: "effect",
      signature: "<A, E>(fiber: Fiber<A, E>) => Effect<A, E, never>",
      description: "Creates an `Effect` value that represents the exit value of the specified\nfiber.",
      documentation: "Creates an `Effect` value that represents the exit value of the specified\nfiber.",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11751,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11751"
    },
    {
      id: "Effect.fromFiberEffect",
      name: "fromFiberEffect",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(fiber: Effect<Fiber<A, E>, E, R>) => Effect<A, E, R>",
      description: "Creates an `Effect` value that represents the exit value of a fiber obtained\nfrom an effect.",
      documentation: "Creates an `Effect` value that represents the exit value of a fiber obtained\nfrom an effect.",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11761,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11761"
    },
    {
      id: "Effect.supervised",
      name: "supervised",
      module: "Effect",
      package: "effect",
      signature: "{ <X>(supervisor: Supervisor<X>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, X>(self: Effect<A, E, R>, supervisor: Supervisor<X>): Effect<A, E, R>; }",
      description: "Supervises child fibers by reporting them to a specified supervisor.",
      documentation: 'Supervises child fibers by reporting them to a specified supervisor.\n\n**Details**\n\nThis function takes a supervisor as an argument and returns an effect where\nall child fibers forked within it are supervised by the provided supervisor.\nThis enables you to capture detailed information about these child fibers,\nsuch as their status, through the supervisor.\n\n**Example** (Monitoring Fiber Count)\n\n```ts\nimport { Effect, Supervisor, Schedule, Fiber, FiberStatus } from "effect"\n\n// Main program that monitors fibers while calculating a Fibonacci number\nconst program = Effect.gen(function* () {\n  // Create a supervisor to track child fibers\n  const supervisor = yield* Supervisor.track\n\n  // Start a Fibonacci calculation, supervised by the supervisor\n  const fibFiber = yield* fib(20).pipe(\n    Effect.supervised(supervisor),\n    // Fork the Fibonacci effect into a fiber\n    Effect.fork\n  )\n\n  // Define a schedule to periodically monitor the fiber count every 500ms\n  const policy = Schedule.spaced("500 millis").pipe(\n    Schedule.whileInputEffect((_) =>\n      Fiber.status(fibFiber).pipe(\n        // Continue while the Fibonacci fiber is not done\n        Effect.andThen((status) => status !== FiberStatus.done)\n      )\n    )\n  )\n\n  // Start monitoring the fibers, using the supervisor to track the count\n  const monitorFiber = yield* monitorFibers(supervisor).pipe(\n    // Repeat the monitoring according to the schedule\n    Effect.repeat(policy),\n    // Fork the monitoring into its own fiber\n    Effect.fork\n  )\n\n  // Join the monitor and Fibonacci fibers to ensure they complete\n  yield* Fiber.join(monitorFiber)\n  const result = yield* Fiber.join(fibFiber)\n\n  console.log(`fibonacci result: ${result}`)\n})\n\n// Function to monitor and log the number of active fibers\nconst monitorFibers = (\n  supervisor: Supervisor.Supervisor<Array<Fiber.RuntimeFiber<any, any>>>\n): Effect.Effect<void> =>\n  Effect.gen(function* () {\n    const fibers = yield* supervisor.value // Get the current set of fibers\n    console.log(`number of fibers: ${fibers.length}`)\n  })\n\n// Recursive Fibonacci calculation, spawning fibers for each recursive step\nconst fib = (n: number): Effect.Effect<number> =>\n  Effect.gen(function* () {\n    if (n <= 1) {\n      return 1\n    }\n    yield* Effect.sleep("500 millis") // Simulate work by delaying\n\n    // Fork two fibers for the recursive Fibonacci calls\n    const fiber1 = yield* Effect.fork(fib(n - 2))\n    const fiber2 = yield* Effect.fork(fib(n - 1))\n\n    // Join the fibers to retrieve their results\n    const v1 = yield* Fiber.join(fiber1)\n    const v2 = yield* Fiber.join(fiber2)\n\n    return v1 + v2 // Combine the results\n  })\n\nEffect.runPromise(program)\n// Output:\n// number of fibers: 0\n// number of fibers: 2\n// number of fibers: 6\n// number of fibers: 14\n// number of fibers: 30\n// number of fibers: 62\n// number of fibers: 126\n// number of fibers: 254\n// number of fibers: 510\n// number of fibers: 1022\n// number of fibers: 2034\n// number of fibers: 3795\n// number of fibers: 5810\n// number of fibers: 6474\n// number of fibers: 4942\n// number of fibers: 2515\n// number of fibers: 832\n// number of fibers: 170\n// number of fibers: 18\n// number of fibers: 0\n// fibonacci result: 10946\n```',
      examples: [
        {
          title: "Monitoring Fiber Count",
          code: 'import { Effect, Supervisor, Schedule, Fiber, FiberStatus } from "effect"\n\n// Main program that monitors fibers while calculating a Fibonacci number\nconst program = Effect.gen(function* () {\n  // Create a supervisor to track child fibers\n  const supervisor = yield* Supervisor.track\n\n  // Start a Fibonacci calculation, supervised by the supervisor\n  const fibFiber = yield* fib(20).pipe(\n    Effect.supervised(supervisor),\n    // Fork the Fibonacci effect into a fiber\n    Effect.fork\n  )\n\n  // Define a schedule to periodically monitor the fiber count every 500ms\n  const policy = Schedule.spaced("500 millis").pipe(\n    Schedule.whileInputEffect((_) =>\n      Fiber.status(fibFiber).pipe(\n        // Continue while the Fibonacci fiber is not done\n        Effect.andThen((status) => status !== FiberStatus.done)\n      )\n    )\n  )\n\n  // Start monitoring the fibers, using the supervisor to track the count\n  const monitorFiber = yield* monitorFibers(supervisor).pipe(\n    // Repeat the monitoring according to the schedule\n    Effect.repeat(policy),\n    // Fork the monitoring into its own fiber\n    Effect.fork\n  )\n\n  // Join the monitor and Fibonacci fibers to ensure they complete\n  yield* Fiber.join(monitorFiber)\n  const result = yield* Fiber.join(fibFiber)\n\n  console.log(`fibonacci result: ${result}`)\n})\n\n// Function to monitor and log the number of active fibers\nconst monitorFibers = (\n  supervisor: Supervisor.Supervisor<Array<Fiber.RuntimeFiber<any, any>>>\n): Effect.Effect<void> =>\n  Effect.gen(function* () {\n    const fibers = yield* supervisor.value // Get the current set of fibers\n    console.log(`number of fibers: ${fibers.length}`)\n  })\n\n// Recursive Fibonacci calculation, spawning fibers for each recursive step\nconst fib = (n: number): Effect.Effect<number> =>\n  Effect.gen(function* () {\n    if (n <= 1) {\n      return 1\n    }\n    yield* Effect.sleep("500 millis") // Simulate work by delaying\n\n    // Fork two fibers for the recursive Fibonacci calls\n    const fiber1 = yield* Effect.fork(fib(n - 2))\n    const fiber2 = yield* Effect.fork(fib(n - 1))\n\n    // Join the fibers to retrieve their results\n    const v1 = yield* Fiber.join(fiber1)\n    const v2 = yield* Fiber.join(fiber2)\n\n    return v1 + v2 // Combine the results\n  })\n\nEffect.runPromise(program)\n// Output:\n// number of fibers: 0\n// number of fibers: 2\n// number of fibers: 6\n// number of fibers: 14\n// number of fibers: 30\n// number of fibers: 62\n// number of fibers: 126\n// number of fibers: 254\n// number of fibers: 510\n// number of fibers: 1022\n// number of fibers: 2034\n// number of fibers: 3795\n// number of fibers: 5810\n// number of fibers: 6474\n// number of fibers: 4942\n// number of fibers: 2515\n// number of fibers: 832\n// number of fibers: 170\n// number of fibers: 18\n// number of fibers: 0\n// fibonacci result: 10946'
        }
      ],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 11870,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11870"
    },
    {
      id: "Effect.transplant",
      name: "transplant",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(f: (grafter: <A2, E2, R2>(effect: Effect<A2, E2, R2>) => Effect<A2, E2, R2>) => Effect<A, E, R>) => Effect<A, E, R>",
      description: 'Transplants specified effects so that when those effects fork other\neffects, the forked effects will be governed by the scope of the fiber that\nexecutes this effect. This can be used to "graft" deep grandchildren onto a higher-level scope,\neffectively extending their lifespans into the parent scope.',
      documentation: 'Transplants specified effects so that when those effects fork other\neffects, the forked effects will be governed by the scope of the fiber that\nexecutes this effect.\n\nThis can be used to "graft" deep grandchildren onto a higher-level scope,\neffectively extending their lifespans into the parent scope.',
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12101,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12101"
    },
    {
      id: "Effect.withConcurrency",
      name: "withConcurrency",
      module: "Effect",
      package: "effect",
      signature: '{ (concurrency: number | "unbounded"): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, concurrency: number | "unbounded"): Effect<A, E, R>; }',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Supervision & Fibers"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12106,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12106"
    },
    {
      id: "Effect.withScheduler",
      name: "withScheduler",
      module: "Effect",
      package: "effect",
      signature: "{ (scheduler: Scheduler): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, scheduler: Scheduler): Effect<A, E, R>; }",
      description: "Sets the provided scheduler for usage in the wrapped effect",
      documentation: "Sets the provided scheduler for usage in the wrapped effect",
      examples: [],
      tags: [
        "Scheduler"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12124,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12124"
    },
    {
      id: "Effect.withSchedulingPriority",
      name: "withSchedulingPriority",
      module: "Effect",
      package: "effect",
      signature: "{ (priority: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, priority: number): Effect<A, E, R>; }",
      description: "Sets the scheduling priority used when yielding",
      documentation: "Sets the scheduling priority used when yielding",
      examples: [],
      tags: [
        "Scheduler"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12146,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12146"
    },
    {
      id: "Effect.withMaxOpsBeforeYield",
      name: "withMaxOpsBeforeYield",
      module: "Effect",
      package: "effect",
      signature: "{ (priority: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, priority: number): Effect<A, E, R>; }",
      description: "Sets the maximum number of operations before yield by the default schedulers",
      documentation: "Sets the maximum number of operations before yield by the default schedulers",
      examples: [],
      tags: [
        "Scheduler"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12168,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12168"
    },
    {
      id: "Effect.clock",
      name: "clock",
      module: "Effect",
      package: "effect",
      signature: "Effect<Clock, never, never>",
      description: "Retrieves the `Clock` service from the context.",
      documentation: 'Retrieves the `Clock` service from the context.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  const clock = yield* Effect.clock\n  const currentTime = yield* clock.currentTimeMillis\n  console.log(`Current time in milliseconds: ${currentTime}`)\n})\n\nEffect.runFork(program)\n// Example Output:\n// Current time in milliseconds: 1735484796134\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  const clock = yield* Effect.clock\n  const currentTime = yield* clock.currentTimeMillis\n  console.log(`Current time in milliseconds: ${currentTime}`)\n})\n\nEffect.runFork(program)\n// Example Output:\n// Current time in milliseconds: 1735484796134'
        }
      ],
      tags: [
        "Clock"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12206,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12206"
    },
    {
      id: "Effect.clockWith",
      name: "clockWith",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(f: (clock: Clock) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "Retrieves the `Clock` service from the context and provides it to the\nspecified effectful function.",
      documentation: 'Retrieves the `Clock` service from the context and provides it to the\nspecified effectful function.\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\nconst program = Effect.clockWith((clock) =>\n  clock.currentTimeMillis.pipe(\n    Effect.map((currentTime) => `Current time is: ${currentTime}`),\n    Effect.tap(Console.log)\n  )\n)\n\nEffect.runFork(program)\n// Example Output:\n// Current time is: 1735484929744\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\nconst program = Effect.clockWith((clock) =>\n  clock.currentTimeMillis.pipe(\n    Effect.map((currentTime) => `Current time is: ${currentTime}`),\n    Effect.tap(Console.log)\n  )\n)\n\nEffect.runFork(program)\n// Example Output:\n// Current time is: 1735484929744'
        }
      ],
      tags: [
        "Clock"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12231,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12231"
    },
    {
      id: "Effect.withClockScoped",
      name: "withClockScoped",
      module: "Effect",
      package: "effect",
      signature: "<C extends Clock.Clock>(clock: C) => Effect<void, never, Scope>",
      description: "Sets the implementation of the `Clock` service to the specified value and\nrestores it to its original value when the scope is closed.",
      documentation: "Sets the implementation of the `Clock` service to the specified value and\nrestores it to its original value when the scope is closed.",
      examples: [],
      tags: [
        "Clock"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12239,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12239"
    },
    {
      id: "Effect.withClock",
      name: "withClock",
      module: "Effect",
      package: "effect",
      signature: "{ <C extends Clock.Clock>(clock: C): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <C extends Clock.Clock, A, E, R>(effect: Effect<A, E, R>, clock: C): Effect<A, E, R>; }",
      description: "Executes the specified workflow with the specified implementation of the\n`Clock` service.",
      documentation: "Executes the specified workflow with the specified implementation of the\n`Clock` service.",
      examples: [],
      tags: [
        "Clock"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12247,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12247"
    },
    {
      id: "Effect.console",
      name: "console",
      module: "Effect",
      package: "effect",
      signature: "Effect<Console, never, never>",
      description: "Retreives the `Console` service from the context",
      documentation: "Retreives the `Console` service from the context",
      examples: [],
      tags: [
        "Console"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12271,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12271"
    },
    {
      id: "Effect.consoleWith",
      name: "consoleWith",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(f: (console: Console) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "Retreives the `Console` service from the context and provides it to the\nspecified effectful function.",
      documentation: "Retreives the `Console` service from the context and provides it to the\nspecified effectful function.",
      examples: [],
      tags: [
        "Console"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12279,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12279"
    },
    {
      id: "Effect.withConsoleScoped",
      name: "withConsoleScoped",
      module: "Effect",
      package: "effect",
      signature: "<A extends Console>(console: A) => Effect<void, never, Scope>",
      description: "Sets the implementation of the console service to the specified value and\nrestores it to its original value when the scope is closed.",
      documentation: "Sets the implementation of the console service to the specified value and\nrestores it to its original value when the scope is closed.",
      examples: [],
      tags: [
        "Creating Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12287,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12287"
    },
    {
      id: "Effect.withConsole",
      name: "withConsole",
      module: "Effect",
      package: "effect",
      signature: "{ <C extends Console>(console: C): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, C extends Console>(effect: Effect<A, E, R>, console: C): Effect<A, E, R>; }",
      description: "Executes the specified workflow with the specified implementation of the\nconsole service.",
      documentation: "Executes the specified workflow with the specified implementation of the\nconsole service.",
      examples: [],
      tags: [
        "Console"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12295,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12295"
    },
    {
      id: "Effect.delay",
      name: "delay",
      module: "Effect",
      package: "effect",
      signature: "{ (duration: DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, duration: DurationInput): Effect<A, E, R>; }",
      description: "Delays the execution of an effect by a specified `Duration`. Details This function postpones the execution of the provided effect by the specified\nduration. The duration can be provided in various formats supported by the\n`Duration` module. Internally, this function does not block the thread; instead, it uses an\nefficient, non-blocking mechanism to introduce the delay.",
      documentation: 'Delays the execution of an effect by a specified `Duration`.\n\n**Details\n\nThis function postpones the execution of the provided effect by the specified\nduration. The duration can be provided in various formats supported by the\n`Duration` module.\n\nInternally, this function does not block the thread; instead, it uses an\nefficient, non-blocking mechanism to introduce the delay.\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\nconst task = Console.log("Task executed")\n\nconst program = Console.log("start").pipe(\n  Effect.andThen(\n    // Delays the log message by 2 seconds\n    task.pipe(Effect.delay("2 seconds"))\n  )\n)\n\nEffect.runFork(program)\n// Output:\n// start\n// Task executed\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\nconst task = Console.log("Task executed")\n\nconst program = Console.log("start").pipe(\n  Effect.andThen(\n    // Delays the log message by 2 seconds\n    task.pipe(Effect.delay("2 seconds"))\n  )\n)\n\nEffect.runFork(program)\n// Output:\n// start\n// Task executed'
        }
      ],
      tags: [
        "Delays & Timeouts"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12348,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12348"
    },
    {
      id: "Effect.sleep",
      name: "sleep",
      module: "Effect",
      package: "effect",
      signature: "(duration: DurationInput) => Effect<void, never, never>",
      description: "Suspends the execution of an effect for a specified `Duration`.",
      documentation: 'Suspends the execution of an effect for a specified `Duration`.\n\n**Details**\n\nThis function pauses the execution of an effect for a given duration. It is\nasynchronous, meaning that it does not block the fiber executing the effect.\nInstead, the fiber is suspended during the delay period and can resume once\nthe specified time has passed.\n\nThe duration can be specified using various formats supported by the\n`Duration` module, such as a string (`"2 seconds"`) or numeric value\nrepresenting milliseconds.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  console.log("Starting task...")\n  yield* Effect.sleep("3 seconds") // Waits for 3 seconds\n  console.log("Task completed!")\n})\n\nEffect.runFork(program)\n// Output:\n// Starting task...\n// Task completed!\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  console.log("Starting task...")\n  yield* Effect.sleep("3 seconds") // Waits for 3 seconds\n  console.log("Task completed!")\n})\n\nEffect.runFork(program)\n// Output:\n// Starting task...\n// Task completed!'
        }
      ],
      tags: [
        "Delays & Timeouts"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12456,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12456"
    },
    {
      id: "Effect.timed",
      name: "timed",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<[duration: Duration, result: A], E, R>",
      description: "Executes an effect and measures the time it takes to complete.",
      documentation: 'Executes an effect and measures the time it takes to complete.\n\n**Details**\n\nThis function wraps the provided effect and returns a new effect that, when\nexecuted, performs the original effect and calculates its execution duration.\n\nThe result of the new effect includes both the execution time (as a\n`Duration`) and the original effect\'s result. This is useful for monitoring\nperformance or gaining insights into the time taken by specific operations.\n\nThe original effect\'s behavior (success, failure, or interruption) remains\nunchanged, and the timing information is provided alongside the result in a\ntuple.\n\n**Example**\n\n```ts\nimport { Duration, Effect } from "effect"\n\nconst task = Effect.gen(function*() {\n  yield* Effect.sleep("2 seconds") // Simulates some work\n  return "some result"\n})\n\nconst timedTask = task.pipe(Effect.timed)\n\nconst program = Effect.gen(function*() {\n  const [duration, result] = yield* timedTask\n  console.log(`Task completed in ${Duration.toMillis(duration)} ms with result: ${result}`)\n})\n\nEffect.runFork(program)\n// Output: Task completed in 2003.749125 ms with result: some result\n```',
      examples: [
        {
          code: 'import { Duration, Effect } from "effect"\n\nconst task = Effect.gen(function*() {\n  yield* Effect.sleep("2 seconds") // Simulates some work\n  return "some result"\n})\n\nconst timedTask = task.pipe(Effect.timed)\n\nconst program = Effect.gen(function*() {\n  const [duration, result] = yield* timedTask\n  console.log(`Task completed in ${Duration.toMillis(duration)} ms with result: ${result}`)\n})\n\nEffect.runFork(program)\n// Output: Task completed in 2003.749125 ms with result: some result'
        }
      ],
      tags: [
        "Delays & Timeouts"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12497,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12497"
    },
    {
      id: "Effect.timedWith",
      name: "timedWith",
      module: "Effect",
      package: "effect",
      signature: "{ <E1, R1>(nanoseconds: Effect<bigint, E1, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<[Duration, A], E1 | E, R1 | R>; <A, E, R, E1, R1>(self: Effect<A, E, R>, nanoseconds: Effect<bigint, E1, R1>): Effect<[Duration, A], E | E1, R | R1>; }",
      description: "/\n * Executes an effect and measures its execution time using a custom clock.\n *\n *",
      documentation: "/**\n * Executes an effect and measures its execution time using a custom clock.\n *\n * **Details**\n *\n * This function extends the functionality of {@link timed}by allowing you to\n * specify a custom clock for measuring the execution duration. The provided\n * effect (`nanoseconds`) represents the clock and should return the current\n * time in nanoseconds. The timing information is computed using this custom\n * clock instead of the default system clock.\n *\n *",
      examples: [],
      tags: [
        "Delays & Timeouts"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12512,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12512"
    },
    {
      id: "Effect.timeout",
      name: "timeout",
      module: "Effect",
      package: "effect",
      signature: "{ (duration: DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | TimeoutException, R>; <A, E, R>(self: Effect<A, E, R>, duration: DurationInput): Effect<A, E | TimeoutException, R>; }",
      description: "Adds a time limit to an effect, triggering a timeout if the effect exceeds\nthe duration.",
      documentation: `Adds a time limit to an effect, triggering a timeout if the effect exceeds
the duration.

**Details**

This function allows you to enforce a time limit on the execution of an
effect. If the effect does not complete within the given duration, it fails
with a \`TimeoutException\`. This is useful for preventing tasks from hanging
indefinitely, especially in scenarios where responsiveness or resource limits
are critical.

The returned effect will either:
- Succeed with the original effect's result if it completes within the
  specified duration.
- Fail with a \`TimeoutException\` if the time limit is exceeded.

**Example**

\`\`\`ts
import { Effect } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

// Output will show a TimeoutException as the task takes longer
// than the specified timeout duration
const timedEffect = task.pipe(Effect.timeout("1 second"))

Effect.runPromiseExit(timedEffect).then(console.log)
// Output:
// Start processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: { _tag: 'TimeoutException' }
//   }
// }
\`\`\``,
      examples: [
        {
          code: `import { Effect } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

// Output will show a TimeoutException as the task takes longer
// than the specified timeout duration
const timedEffect = task.pipe(Effect.timeout("1 second"))

Effect.runPromiseExit(timedEffect).then(console.log)
// Output:
// Start processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: { _tag: 'TimeoutException' }
//   }
// }`
        }
      ],
      tags: [
        "Delays & Timeouts"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12599,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12599"
    },
    {
      id: "Effect.timeoutOption",
      name: "timeoutOption",
      module: "Effect",
      package: "effect",
      signature: "{ (duration: DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, duration: DurationInput): Effect<Option<A>, E, R>; }",
      description: "Gracefully handles timeouts by returning an `Option` that represents either\nthe result or a timeout.",
      documentation: 'Gracefully handles timeouts by returning an `Option` that represents either\nthe result or a timeout.\n\n**Details**\n\nThis function wraps the outcome of an effect in an `Option` type. If the\neffect completes within the specified duration, it returns a `Some`\ncontaining the result. If the effect times out, it returns a `None`. Unlike\nother timeout methods, this approach does not raise errors or exceptions;\ninstead, it allows you to treat timeouts as a regular outcome, simplifying\nthe logic for handling delays.\n\n**When to Use**\n\nThis is useful when you want to handle timeouts without causing the program\nto fail, making it easier to manage situations where you expect tasks might\ntake too long but want to continue executing other tasks.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst task = Effect.gen(function* () {\n  console.log("Start processing...")\n  yield* Effect.sleep("2 seconds") // Simulates a delay in processing\n  console.log("Processing complete.")\n  return "Result"\n})\n\nconst timedOutEffect = Effect.all([\n  task.pipe(Effect.timeoutOption("3 seconds")),\n  task.pipe(Effect.timeoutOption("1 second"))\n])\n\nEffect.runPromise(timedOutEffect).then(console.log)\n// Output:\n// Start processing...\n// Processing complete.\n// Start processing...\n// [\n//   { _id: \'Option\', _tag: \'Some\', value: \'Result\' },\n//   { _id: \'Option\', _tag: \'None\' }\n// ]\n```',
      examples: [
        {
          code: `import { Effect } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

const timedOutEffect = Effect.all([
  task.pipe(Effect.timeoutOption("3 seconds")),
  task.pipe(Effect.timeoutOption("1 second"))
])

Effect.runPromise(timedOutEffect).then(console.log)
// Output:
// Start processing...
// Processing complete.
// Start processing...
// [
//   { _id: 'Option', _tag: 'Some', value: 'Result' },
//   { _id: 'Option', _tag: 'None' }
// ]`
        }
      ],
      tags: [
        "Delays & Timeouts"
      ],
      since: "3.1.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12769,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12769"
    },
    {
      id: "Effect.timeoutFail",
      name: "timeoutFail",
      module: "Effect",
      package: "effect",
      signature: "{ <E1>(options: { readonly onTimeout: LazyArg<E1>; readonly duration: DurationInput; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R>; <A, E, R, E1>(self: Effect<A, E, R>, options: { readonly onTimeout: LazyArg<E1>; readonly duration: DurationInput; }): Effect<A, E | E1, R>; }",
      description: "Specifies a custom error to be produced when a timeout occurs.",
      documentation: 'Specifies a custom error to be produced when a timeout occurs.\n\n**Details**\n\nThis function allows you to handle timeouts in a customized way by defining a\nspecific error to be raised when an effect exceeds the given duration. Unlike\ndefault timeout behaviors that use generic exceptions, this function gives\nyou the flexibility to specify a meaningful error type that aligns with your\napplication\'s needs.\n\nWhen you apply this function, you provide:\n- A `duration`: The time limit for the effect.\n- An `onTimeout` function: A lazy evaluation function that generates the\n  custom error if the timeout occurs.\n\nIf the effect completes within the time limit, its result is returned\nnormally. Otherwise, the `onTimeout` function is triggered, and its output is\nused as the error for the effect.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst task = Effect.gen(function* () {\n  console.log("Start processing...")\n  yield* Effect.sleep("2 seconds") // Simulates a delay in processing\n  console.log("Processing complete.")\n  return "Result"\n})\n\nclass MyTimeoutError {\n  readonly _tag = "MyTimeoutError"\n}\n\nconst program = task.pipe(\n  Effect.timeoutFail({\n    duration: "1 second",\n    onTimeout: () => new MyTimeoutError() // Custom timeout error\n  })\n)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// Start processing...\n// {\n//   _id: \'Exit\',\n//   _tag: \'Failure\',\n//   cause: {\n//     _id: \'Cause\',\n//     _tag: \'Fail\',\n//     failure: MyTimeoutError { _tag: \'MyTimeoutError\' }\n//   }\n// }\n```',
      examples: [
        {
          code: `import { Effect } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

class MyTimeoutError {
  readonly _tag = "MyTimeoutError"
}

const program = task.pipe(
  Effect.timeoutFail({
    duration: "1 second",
    onTimeout: () => new MyTimeoutError() // Custom timeout error
  })
)

Effect.runPromiseExit(program).then(console.log)
// Output:
// Start processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: MyTimeoutError { _tag: 'MyTimeoutError' }
//   }
// }`
        }
      ],
      tags: [
        "Delays & Timeouts"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 12950,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L12950"
    },
    {
      id: "Effect.timeoutFailCause",
      name: "timeoutFailCause",
      module: "Effect",
      package: "effect",
      signature: "{ <E1>(options: { readonly onTimeout: LazyArg<Cause<E1>>; readonly duration: DurationInput; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R>; <A, E, R, E1>(self: Effect<A, E, R>, options: { readonly onTimeout: LazyArg<Cause<E1>>; readonly duration: DurationInput; }): Effect<A, E | E1, R>; }",
      description: "Specifies a custom defect to be thrown when a timeout occurs.",
      documentation: 'Specifies a custom defect to be thrown when a timeout occurs.\n\n**Details**\n\nThis function allows you to handle timeouts as exceptional cases by\ngenerating a custom defect when an effect exceeds the specified duration. You\nprovide:\n- A `duration`: The time limit for the effect.\n- An `onTimeout` function: A lazy evaluation function that generates the\n  custom defect (typically created using `Cause.die`).\n\nIf the effect completes within the time limit, its result is returned\nnormally. Otherwise, the custom defect is triggered, and the effect fails\nwith that defect.\n\n**When to Use**\n\nThis is especially useful when you need to treat timeouts as critical\nfailures in your application and wish to include meaningful information in\nthe defect.\n\n**Example**\n\n```ts\nimport { Effect, Cause } from "effect"\n\nconst task = Effect.gen(function* () {\n  console.log("Start processing...")\n  yield* Effect.sleep("2 seconds") // Simulates a delay in processing\n  console.log("Processing complete.")\n  return "Result"\n})\n\nconst program = task.pipe(\n  Effect.timeoutFailCause({\n    duration: "1 second",\n    onTimeout: () => Cause.die("Timed out!") // Custom defect for timeout\n  })\n)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// Start processing...\n// {\n//   _id: \'Exit\',\n//   _tag: \'Failure\',\n//   cause: { _id: \'Cause\', _tag: \'Die\', defect: \'Timed out!\' }\n// }\n```',
      examples: [
        {
          code: `import { Effect, Cause } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

const program = task.pipe(
  Effect.timeoutFailCause({
    duration: "1 second",
    onTimeout: () => Cause.die("Timed out!") // Custom defect for timeout
  })
)

Effect.runPromiseExit(program).then(console.log)
// Output:
// Start processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Die', defect: 'Timed out!' }
// }`
        }
      ],
      tags: [
        "Delays & Timeouts"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 13149,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L13149"
    },
    {
      id: "Effect.timeoutTo",
      name: "timeoutTo",
      module: "Effect",
      package: "effect",
      signature: "{ <A, B, B1>(options: { readonly onTimeout: LazyArg<B1>; readonly onSuccess: (a: A) => B; readonly duration: DurationInput; }): <E, R>(self: Effect<A, E, R>) => Effect<B | B1, E, R>; <A, E, R, B1, B>(self: Effect<A, E, R>, options: { readonly onTimeout: LazyArg<B1>; readonly onSuccess: (a: A) => B; readonly duration: DurationInput; }): Effect<B1 | B, E, R>; }",
      description: "/\n * Provides custom behavior for successful and timed-out operations.\n *\n *",
      documentation: '/**\n * Provides custom behavior for successful and timed-out operations.\n *\n * **Details**\n *\n * This function allows you to define distinct outcomes for an effect depending\n * on whether it completes within a specified time frame or exceeds the timeout\n * duration. You can provide:\n * - `onSuccess`: A handler for processing the result of the effect if it\n *   completes successfully within the time limit.\n * - `onTimeout`: A handler for generating a result when the effect times out.\n * - `duration`: The maximum allowed time for the effect to complete.\n *\n * **When to Use**\n *\n * Unlike {@link timeout}, which raises an exception for timeouts, this function\n * gives you full control over the behavior for both success and timeout\n * scenarios. It is particularly useful when you want to encapsulate timeouts\n * and successes into a specific data structure, like an `Either` type, to\n * represent these outcomes in a meaningful way.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Either } from "effect"\n *\n * const task = Effect.gen(function* () {\n *   console.log("Start processing...")\n *   yield* Effect.sleep("2 seconds") // Simulates a delay in processing\n *   console.log("Processing complete.")\n *   return "Result"\n * })\n *\n * const program = task.pipe(\n *   Effect.timeoutTo({\n *     duration: "1 second",\n *     onSuccess: (result): Either.Either<string, string> =>\n *       Either.right(result),\n *     onTimeout: (): Either.Either<string, string> =>\n *       Either.left("Timed out!")\n *   })\n * )\n *\n * Effect.runPromise(program).then(console.log)\n * // Output:\n * // Start processing...\n * // {\n * //   _id: "Either",\n * //   _tag: "Left",\n * //   left: "Timed out!"\n * // }\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect, Either } from "effect"\n *\n * const task = Effect.gen(function* () {\n *   console.log("Start processing...")\n *   yield* Effect.sleep("2 seconds") // Simulates a delay in processing\n *   console.log("Processing complete.")\n *   return "Result"\n * })\n *\n * const program = task.pipe(\n *   Effect.timeoutTo({\n *     duration: "1 second",\n *     onSuccess: (result): Either.Either<string, string> =>\n *       Either.right(result),\n *     onTimeout: (): Either.Either<string, string> =>\n *       Either.left("Timed out!")\n *   })\n * )\n *\n * Effect.runPromise(program).then(console.log)\n * // Output:\n * // Start processing...\n * // {\n * //   _id: "Either",\n * //   _tag: "Left",\n * //   left: "Timed out!"\n * // }\n *'
        }
      ],
      tags: [
        "Delays & Timeouts"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 13337,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L13337"
    },
    {
      id: "Effect.configProviderWith",
      name: "configProviderWith",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(f: (provider: ConfigProvider) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "Allows working with the default configuration provider.",
      documentation: "Allows working with the default configuration provider.\n\n**Details**\n\nThis function retrieves the default configuration provider and passes it to\nthe provided function, which can use it to perform computations or retrieve\nconfiguration values. The function can return an effect that leverages the\nconfiguration provider for its operations.",
      examples: [],
      tags: [
        "Config"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 13482,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L13482"
    },
    {
      id: "Effect.withConfigProvider",
      name: "withConfigProvider",
      module: "Effect",
      package: "effect",
      signature: "{ (provider: ConfigProvider): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, provider: ConfigProvider): Effect<A, E, R>; }",
      description: "Executes an effect using a specific configuration provider.",
      documentation: 'Executes an effect using a specific configuration provider.\n\n**Details**\n\nThis function lets you run an effect with a specified configuration provider.\nThe custom provider will override the default configuration provider for the\nduration of the effect\'s execution.\n\n**When to Use**\n\nThis is particularly useful when you need to use a different set of\nconfiguration values or sources for specific parts of your application.\n\n**Example**\n\n```ts\nimport { Config, ConfigProvider, Effect } from "effect"\n\nconst customProvider: ConfigProvider.ConfigProvider = ConfigProvider.fromMap(\n  new Map([["custom-key", "custom-value"]])\n)\n\nconst program = Effect.withConfigProvider(customProvider)(\n  Effect.gen(function*() {\n    const value = yield* Config.string("custom-key")\n    console.log(`Config value: ${value}`)\n  })\n)\n\nEffect.runPromise(program)\n// Output:\n// Config value: custom-value\n```',
      examples: [
        {
          code: 'import { Config, ConfigProvider, Effect } from "effect"\n\nconst customProvider: ConfigProvider.ConfigProvider = ConfigProvider.fromMap(\n  new Map([["custom-key", "custom-value"]])\n)\n\nconst program = Effect.withConfigProvider(customProvider)(\n  Effect.gen(function*() {\n    const value = yield* Config.string("custom-key")\n    console.log(`Config value: ${value}`)\n  })\n)\n\nEffect.runPromise(program)\n// Output:\n// Config value: custom-value'
        }
      ],
      tags: [
        "Config"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 13521,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L13521"
    },
    {
      id: "Effect.withConfigProviderScoped",
      name: "withConfigProviderScoped",
      module: "Effect",
      package: "effect",
      signature: "(provider: ConfigProvider) => Effect<void, never, Scope>",
      description: "Sets a configuration provider within a scope.",
      documentation: "Sets a configuration provider within a scope.\n\n**Details**\n\nThis function sets the configuration provider to a specified value and\nensures that it is restored to its original value when the scope is closed.",
      examples: [],
      tags: [
        "Config"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 13612,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L13612"
    },
    {
      id: "Effect.context",
      name: "context",
      module: "Effect",
      package: "effect",
      signature: "<R>() => Effect<Context<R>, never, R>",
      description: "Accesses the full context of the effect.",
      documentation: "Accesses the full context of the effect.\n\n**Details**\n\nThis function provides the ability to access the entire context required by\nan effect. The context is a container that holds dependencies or environment\nvalues needed by an effect to run. By using this function, you can retrieve\nand work with the context directly within an effect.",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 13626,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L13626"
    },
    {
      id: "Effect.contextWith",
      name: "contextWith",
      module: "Effect",
      package: "effect",
      signature: "<R, A>(f: (context: Context<R>) => A) => Effect<A, never, R>",
      description: "Accesses the context and applies a transformation function.",
      documentation: "Accesses the context and applies a transformation function.\n\n**Details**\n\nThis function retrieves the context of the effect and applies a pure\ntransformation function to it. The result of the transformation is then\nreturned within the effect.",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 13641,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L13641"
    },
    {
      id: "Effect.contextWithEffect",
      name: "contextWithEffect",
      module: "Effect",
      package: "effect",
      signature: "<R2, A, E, R>(f: (context: Context<R2>) => Effect<A, E, R>) => Effect<A, E, R2 | R>",
      description: "Accesses the context and performs an effectful transformation.",
      documentation: "Accesses the context and performs an effectful transformation.\n\n**Details**\n\nThis function retrieves the context and allows you to transform it\neffectually using another effect. It is useful when the transformation\ninvolves asynchronous or effectful operations.",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 13656,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L13656"
    },
    {
      id: "Effect.mapInputContext",
      name: "mapInputContext",
      module: "Effect",
      package: "effect",
      signature: "{ <R2, R>(f: (context: Context<R2>) => Context<R>): <A, E>(self: Effect<A, E, R>) => Effect<A, E, R2>; <A, E, R, R2>(self: Effect<A, E, R>, f: (context: Context<R2>) => Context<R>): Effect<A, E, R2>; }",
      description: "Provides part of the required context while leaving the rest unchanged.",
      documentation: 'Provides part of the required context while leaving the rest unchanged.\n\n**Details**\n\nThis function allows you to transform the context required by an effect,\nproviding part of the context and leaving the rest to be fulfilled later.\n\n**Example**\n\n```ts\nimport { Context, Effect } from "effect"\n\nclass Service1 extends Context.Tag("Service1")<Service1, { readonly port: number }>() {}\nclass Service2 extends Context.Tag("Service2")<Service2, { readonly connection: string }>() {}\n\nconst program = Effect.gen(function*() {\n  const service1 = yield* Service1\n  console.log(service1.port)\n  const service2 = yield* Service2\n  console.log(service2.connection)\n  return "some result"\n})\n\n//      \u250C\u2500\u2500\u2500 Effect<string, never, Service2>\n//      \u25BC\nconst programWithService1 = Effect.mapInputContext(\n  program,\n  (ctx: Context.Context<Service2>) => Context.add(ctx, Service1, { port: 3000 })\n)\n\nconst runnable = programWithService1.pipe(\n  Effect.provideService(Service2, { connection: "localhost" }),\n  Effect.provideService(Service1, { port: 3001 })\n)\n\nEffect.runPromise(runnable)\n// Output:\n// 3000\n// localhost\n```',
      examples: [
        {
          code: 'import { Context, Effect } from "effect"\n\nclass Service1 extends Context.Tag("Service1")<Service1, { readonly port: number }>() {}\nclass Service2 extends Context.Tag("Service2")<Service2, { readonly connection: string }>() {}\n\nconst program = Effect.gen(function*() {\n  const service1 = yield* Service1\n  console.log(service1.port)\n  const service2 = yield* Service2\n  console.log(service2.connection)\n  return "some result"\n})\n\n//      \u250C\u2500\u2500\u2500 Effect<string, never, Service2>\n//      \u25BC\nconst programWithService1 = Effect.mapInputContext(\n  program,\n  (ctx: Context.Context<Service2>) => Context.add(ctx, Service1, { port: 3000 })\n)\n\nconst runnable = programWithService1.pipe(\n  Effect.provideService(Service2, { connection: "localhost" }),\n  Effect.provideService(Service1, { port: 3001 })\n)\n\nEffect.runPromise(runnable)\n// Output:\n// 3000\n// localhost'
        }
      ],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 13702,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L13702"
    },
    {
      id: "Effect.provide",
      name: "provide",
      module: "Effect",
      package: "effect",
      signature: "{ <const Layers extends readonly [Layer.Layer.Any, ...Array<Layer.Layer.Any>]>(layers: Layers): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | { [k in keyof Layers]: Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Success<Layers[k]>; }[number]>>; <ROut, E2, RIn>(layer: Layer<ROut, E2, RIn>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, RIn | Exclude<R, ROut>>; <R2>(context: Context<R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, R2>>; <R2>(runtime: Runtime<R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, R2>>; <E2, R2>(managedRuntime: ManagedRuntime<R2, E2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, Exclude<R, R2>>; <A, E, R, const Layers extends readonly [Layer.Layer.Any, ...Array<Layer.Layer.Any>]>(self: Effect<A, E, R>, layers: Layers): Effect<A, E | { [k in keyof Layers]: Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Success<Layers[k]>; }[number]>>; <A, E, R, ROut, E2, RIn>(self: Effect<A, E, R>, layer: Layer<ROut, E2, RIn>): Effect<A, E | E2, RIn | Exclude<R, ROut>>; <A, E, R, R2>(self: Effect<A, E, R>, context: Context<R2>): Effect<A, E, Exclude<R, R2>>; <A, E, R, R2>(self: Effect<A, E, R>, runtime: Runtime<R2>): Effect<A, E, Exclude<R, R2>>; <A, E, E2, R, R2>(self: Effect<A, E, R>, runtime: ManagedRuntime<R2, E2>): Effect<A, E | E2, Exclude<R, R2>>; }",
      description: "Provides necessary dependencies to an effect, removing its environmental\nrequirements.",
      documentation: 'Provides necessary dependencies to an effect, removing its environmental\nrequirements.\n\n**Details**\n\nThis function allows you to supply the required environment for an effect.\nThe environment can be provided in the form of one or more `Layer`s, a\n`Context`, a `Runtime`, or a `ManagedRuntime`. Once the environment is\nprovided, the effect can run without requiring external dependencies.\n\nYou can compose layers to create a modular and reusable way of setting up the\nenvironment for effects. For example, layers can be used to configure\ndatabases, logging services, or any other required dependencies.\n\n**Example**\n\n```ts\nimport { Context, Effect, Layer } from "effect"\n\nclass Database extends Context.Tag("Database")<\n  Database,\n  { readonly query: (sql: string) => Effect.Effect<Array<unknown>> }\n>() {}\n\nconst DatabaseLive = Layer.succeed(\n  Database,\n  {\n    // Simulate a database query\n    query: (sql: string) => Effect.log(`Executing query: ${sql}`).pipe(Effect.as([]))\n  }\n)\n\n//      \u250C\u2500\u2500\u2500 Effect<unknown[], never, Database>\n//      \u25BC\nconst program = Effect.gen(function*() {\n  const database = yield* Database\n  const result = yield* database.query("SELECT * FROM users")\n  return result\n})\n\n//      \u250C\u2500\u2500\u2500 Effect<unknown[], never, never>\n//      \u25BC\nconst runnable = Effect.provide(program, DatabaseLive)\n\nEffect.runPromise(runnable).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message="Executing query: SELECT * FROM users"\n// []\n```',
      examples: [
        {
          code: 'import { Context, Effect, Layer } from "effect"\n\nclass Database extends Context.Tag("Database")<\n  Database,\n  { readonly query: (sql: string) => Effect.Effect<Array<unknown>> }\n>() {}\n\nconst DatabaseLive = Layer.succeed(\n  Database,\n  {\n    // Simulate a database query\n    query: (sql: string) => Effect.log(`Executing query: ${sql}`).pipe(Effect.as([]))\n  }\n)\n\n//      \u250C\u2500\u2500\u2500 Effect<unknown[], never, Database>\n//      \u25BC\nconst program = Effect.gen(function*() {\n  const database = yield* Database\n  const result = yield* database.query("SELECT * FROM users")\n  return result\n})\n\n//      \u250C\u2500\u2500\u2500 Effect<unknown[], never, never>\n//      \u25BC\nconst runnable = Effect.provide(program, DatabaseLive)\n\nEffect.runPromise(runnable).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message="Executing query: SELECT * FROM users"\n// []'
        }
      ],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 13852,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L13852"
    },
    {
      id: "Effect.provideService",
      name: "provideService",
      module: "Effect",
      package: "effect",
      signature: "{ <I, S>(tag: Tag<I, S>, service: NoInfer<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, I>>; <A, E, R, I, S>(self: Effect<A, E, R>, tag: Tag<I, S>, service: NoInfer<S>): Effect<A, E, Exclude<R, I>>; }",
      description: "Provides an implementation for a service in the context of an effect.",
      documentation: 'Provides an implementation for a service in the context of an effect.\n\n**Details**\n\nThis function allows you to supply a specific implementation for a service\nrequired by an effect. Services are typically defined using `Context.Tag`,\nwhich acts as a unique identifier for the service. By using this function,\nyou link the service to its concrete implementation, enabling the effect to\nexecute successfully without additional requirements.\n\nFor example, you can use this function to provide a random number generator,\na logger, or any other service your effect depends on. Once the service is\nprovided, all parts of the effect that rely on the service will automatically\nuse the implementation you supplied.\n\n**Example**\n\n```ts\nimport { Effect, Context } from "effect"\n\n// Declaring a tag for a service that generates random numbers\nclass Random extends Context.Tag("MyRandomService")<\n  Random,\n  { readonly next: Effect.Effect<number> }\n>() {}\n\n// Using the service\nconst program = Effect.gen(function* () {\n  const random = yield* Random\n  const randomNumber = yield* random.next\n  console.log(`random number: ${randomNumber}`)\n})\n\n// Providing the implementation\n//\n//      \u250C\u2500\u2500\u2500 Effect<void, never, never>\n//      \u25BC\nconst runnable = Effect.provideService(program, Random, {\n  next: Effect.sync(() => Math.random())\n})\n\n// Run successfully\nEffect.runPromise(runnable)\n// Example Output:\n// random number: 0.8241872233134417\n```',
      examples: [
        {
          code: 'import { Effect, Context } from "effect"\n\n// Declaring a tag for a service that generates random numbers\nclass Random extends Context.Tag("MyRandomService")<\n  Random,\n  { readonly next: Effect.Effect<number> }\n>() {}\n\n// Using the service\nconst program = Effect.gen(function* () {\n  const random = yield* Random\n  const randomNumber = yield* random.next\n  console.log(`random number: ${randomNumber}`)\n})\n\n// Providing the implementation\n//\n//      \u250C\u2500\u2500\u2500 Effect<void, never, never>\n//      \u25BC\nconst runnable = Effect.provideService(program, Random, {\n  next: Effect.sync(() => Math.random())\n})\n\n// Run successfully\nEffect.runPromise(runnable)\n// Example Output:\n// random number: 0.8241872233134417'
        }
      ],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14489,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14489"
    },
    {
      id: "Effect.provideServiceEffect",
      name: "provideServiceEffect",
      module: "Effect",
      package: "effect",
      signature: "{ <I, S, E1, R1>(tag: Tag<I, S>, effect: Effect<NoInfer<S>, E1, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R1 | Exclude<R, I>>; <A, E, R, I, S, E1, R1>(self: Effect<A, E, R>, tag: Tag<I, S>, effect: Effect<NoInfer<S>, E1, R1>): Effect<A, E | E1, R1 | Exclude<R, I>>; }",
      description: "Dynamically provides an implementation for a service using an effect.",
      documentation: "Dynamically provides an implementation for a service using an effect.\n\n**Details**\n\nThis function allows you to provide an implementation for a service\ndynamically by using another effect. The provided effect is executed to\nproduce the service implementation, which is then made available to the\nconsuming effect. This is particularly useful when the service implementation\nitself requires asynchronous or resource-intensive initialization.\n\nFor example, you can use this function to lazily initialize a database\nconnection or fetch configuration values from an external source before\nmaking the service available to your effect.",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14617,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14617"
    },
    {
      id: "Effect.serviceFunction",
      name: "serviceFunction",
      module: "Effect",
      package: "effect",
      signature: "<T extends Effect<any, any, any>, Args extends Array<any>, A>(getService: T, f: (_: Effect.Success<T>) => (...args: Args) => A) => (...args: Args) => Effect<A, Effect.Error<T>, Effect.Context<T>>",
      description: "Creates a function that uses a service from the context to produce a value.",
      documentation: "Creates a function that uses a service from the context to produce a value.",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14665,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14665"
    },
    {
      id: "Effect.serviceFunctionEffect",
      name: "serviceFunctionEffect",
      module: "Effect",
      package: "effect",
      signature: "<T extends Effect<any, any, any>, Args extends Array<any>, A, E, R>(getService: T, f: (_: Effect.Success<T>) => (...args: Args) => Effect<A, E, R>) => (...args: Args) => Effect<A, E | Effect.Error<T>, R | Effect.Context<T>>",
      description: "Creates a function that uses a service from the context to produce an effect.",
      documentation: "Creates a function that uses a service from the context to produce an effect.",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14674,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14674"
    },
    {
      id: "Effect.serviceFunctions",
      name: "serviceFunctions",
      module: "Effect",
      package: "effect",
      signature: "<S, SE, SR>(getService: Effect<S, SE, SR>) => { [k in keyof S as S[k] extends (...args: any[]) => Effect<any, any, any> ? k : never]: S[k] extends (...args: infer Args) => Effect<infer A, infer E, infer R> ? (...args: Args) => Effect<A, SE | E, SR | R> : never; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14679,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14679"
    },
    {
      id: "Effect.serviceConstants",
      name: "serviceConstants",
      module: "Effect",
      package: "effect",
      signature: "<S, SE, SR>(getService: Effect<S, SE, SR>) => { [k in { [k in keyof S]: k; }[keyof S]]: S[k] extends Effect<infer A, infer E, infer R> ? Effect<A, SE | E, SR | R> : Effect<S[k], SE, SR>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14686,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14686"
    },
    {
      id: "Effect.serviceMembers",
      name: "serviceMembers",
      module: "Effect",
      package: "effect",
      signature: "<S, SE, SR>(getService: Effect<S, SE, SR>) => { functions: { [k in keyof S as S[k] extends (...args: any[]) => Effect<any, any, any> ? k : never]: S[k] extends (...args: infer Args) => Effect<infer A, infer E, infer R> ? (...args: Args) => Effect<A, SE | E, SR | R> : never; }; constants: { [k in { [k in keyof S]: k; }[keyof S]]: S[k] extends Effect<infer A, infer E, infer R> ? Effect<A, SE | E, SR | R> : Effect<S[k], SE, SR>; }; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14695,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14695"
    },
    {
      id: "Effect.serviceOption",
      name: "serviceOption",
      module: "Effect",
      package: "effect",
      signature: "<I, S>(tag: Tag<I, S>) => Effect<Option<S>, never, never>",
      description: "Retrieves an optional service from the context as an `Option`.",
      documentation: "Retrieves an optional service from the context as an `Option`.\n\n**Details**\n\nThis function retrieves a service from the context and wraps it in an\n`Option`. If the service is available, it returns a `Some` containing the\nservice. If the service is not found, it returns a `None`. This approach is\nuseful when you want to handle the absence of a service gracefully without\ncausing an error.\n\n**When to Use**\n\nUse this function when:\n- You need to access a service that may or may not be present in the context.\n- You want to handle the absence of a service using the `Option` type instead\n  of throwing an error.",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14728,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14728"
    },
    {
      id: "Effect.serviceOptional",
      name: "serviceOptional",
      module: "Effect",
      package: "effect",
      signature: "<I, S>(tag: Tag<I, S>) => Effect<S, NoSuchElementException, never>",
      description: "Retrieves a service from the context, throwing an error if it is missing.",
      documentation: "Retrieves a service from the context, throwing an error if it is missing.\n\n**Details**\n\nThis function retrieves a required service from the context. If the service\nis available, it returns the service. If the service is missing, it throws a\n`NoSuchElementException`, which can be handled using Effect's error-handling\nmechanisms. This is useful for services that are critical to the execution of\nyour effect.",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14745,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14745"
    },
    {
      id: "Effect.updateService",
      name: "updateService",
      module: "Effect",
      package: "effect",
      signature: "{ <I, S>(tag: Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, I | R>; <A, E, R, I, S>(self: Effect<A, E, R>, tag: Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): Effect<A, E, R | I>; }",
      description: "Updates a service in the context with a new implementation.",
      documentation: "Updates a service in the context with a new implementation.\n\n**Details**\n\nThis function modifies the existing implementation of a service in the\ncontext. It retrieves the current service, applies the provided\ntransformation function `f`, and replaces the old service with the\ntransformed one.\n\n**When to Use**\n\nThis is useful for adapting or extending a service's behavior during the\nexecution of an effect.",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14764,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14764"
    },
    {
      id: "Effect.Do",
      name: "Do",
      module: "Effect",
      package: "effect",
      signature: "Effect<{}, never, never>",
      description: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`. Here\'s how the do simulation works: 1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values',
      documentation: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere\'s how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n\n**Example**\n\n```ts\nimport * as assert from "node:assert"\nimport { Effect, pipe } from "effect"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind("x", () => Effect.succeed(2)),\n  Effect.bind("y", () => Effect.succeed(3)),\n  Effect.let("sum", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })\n```',
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Effect, pipe } from "effect"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind("x", () => Effect.succeed(2)),\n  Effect.bind("y", () => Effect.succeed(3)),\n  Effect.let("sum", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })'
        }
      ],
      tags: [
        "Do notation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14836,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14836"
    },
    {
      id: "Effect.bind",
      name: "bind",
      module: "Effect",
      package: "effect",
      signature: "{ <N extends string, A extends object, B, E2, R2>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Effect<B, E2, R2>): <E1, R1>(self: Effect<A, E1, R1>) => Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E2 | E1, R2 | R1>; <A extends object, N extends string, E1, R1, B, E2, R2>(self: Effect<A, E1, R1>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Effect<B, E2, R2>): Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E1 | E2, R1 | R2>; }",
      description: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`. Here\'s how the do simulation works: 1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values',
      documentation: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere\'s how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n\n**Example**\n\n```ts\nimport * as assert from "node:assert"\nimport { Effect, pipe } from "effect"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind("x", () => Effect.succeed(2)),\n  Effect.bind("y", () => Effect.succeed(3)),\n  Effect.let("sum", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })\n```',
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Effect, pipe } from "effect"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind("x", () => Effect.succeed(2)),\n  Effect.bind("y", () => Effect.succeed(3)),\n  Effect.let("sum", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })'
        }
      ],
      tags: [
        "Do notation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14869,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14869"
    },
    {
      id: "Effect.bindAll",
      name: "bindAll",
      module: "Effect",
      package: "effect",
      signature: '{ <A extends object, X extends Record<string, Effect<any, any, any>>, O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly mode?: "default" | "validate" | "either" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, O>>(f: (a: NoInfer<A>) => [Extract<keyof X, keyof A>] extends [never] ? X : "Duplicate keys", options?: O): <E1, R1>(self: Effect<A, E1, R1>) => [All.ReturnObject<X, false, All.ExtractMode<O>>] extends [Effect<infer Success, infer Error, infer Context>] ? Effect<{ [K in keyof A | keyof Success]: K extends keyof A ? A[K] : K extends keyof Success ? Success[K] : never; }, E1 | Error, R1 | Context> : never; <A extends object, X extends Record<string, Effect<any, any, any>>, O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly mode?: "default" | "validate" | "either" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, O>, E1, R1>(self: Effect<A, E1, R1>, f: (a: NoInfer<A>) => [Extract<keyof X, keyof A>] extends [never] ? X : "Duplicate keys", options?: { readonly concurrency?: Concurrency; readonly batching?: boolean | "inherit"; readonly mode?: "default" | "validate" | "either"; readonly concurrentFinalizers?: boolean; }): [All.ReturnObject<X, false, All.ExtractMode<O>>] extends [Effect<infer Success, infer Error, infer Context>] ? Effect<{ [K in keyof A | keyof Success]: K extends keyof A ? A[K] : K extends keyof Success ? Success[K] : never; }, E1 | Error, R1 | Context> : never; }',
      description: "`bindAll` combines `all` with `bind`. It is useful\nwhen you want to concurrently run multiple effects and then combine their\nresults in a Do notation pipeline.",
      documentation: '`bindAll` combines `all` with `bind`. It is useful\nwhen you want to concurrently run multiple effects and then combine their\nresults in a Do notation pipeline.\n\n**Example**\n\n```ts\nimport * as assert from "node:assert"\nimport { Effect, Either, pipe } from "effect"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind("x", () => Effect.succeed(2)),\n  Effect.bindAll(({ x }) => ({\n    a: Effect.succeed(x),\n    b: Effect.fail("oops"),\n  }), { concurrency: 2, mode: "either" })\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, a: Either.right(2), b: Either.left("oops") })\n```',
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Effect, Either, pipe } from "effect"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind("x", () => Effect.succeed(2)),\n  Effect.bindAll(({ x }) => ({\n    a: Effect.succeed(x),\n    b: Effect.fail("oops"),\n  }), { concurrency: 2, mode: "either" })\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, a: Either.right(2), b: Either.left("oops") })'
        }
      ],
      tags: [
        "Do notation"
      ],
      since: "3.7.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 14966,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L14966"
    },
    {
      id: "Effect.bindTo",
      name: "bindTo",
      module: "Effect",
      package: "effect",
      signature: "{ <N extends string>(name: N): <A, E, R>(self: Effect<A, E, R>) => Effect<{ [K in N]: A; }, E, R>; <A, E, R, N extends string>(self: Effect<A, E, R>, name: N): Effect<{ [K in N]: A; }, E, R>; }",
      description: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`. Here\'s how the do simulation works: 1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values',
      documentation: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere\'s how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n\n**Example**\n\n```ts\nimport * as assert from "node:assert"\nimport { Effect, pipe } from "effect"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind("x", () => Effect.succeed(2)),\n  Effect.bind("y", () => Effect.succeed(3)),\n  Effect.let("sum", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })\n```',
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Effect, pipe } from "effect"\n\nconst result = pipe(\n  Effect.Do,\n  Effect.bind("x", () => Effect.succeed(2)),\n  Effect.bind("y", () => Effect.succeed(3)),\n  Effect.let("sum", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })'
        }
      ],
      tags: [
        "Do notation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 15071,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L15071"
    },
    {
      id: "Effect.option",
      name: "option",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<Option<A>, never, R>",
      description: "Encapsulates the result of an effect in an `Option`.",
      documentation: "Encapsulates the result of an effect in an `Option`.\n\n**Details**\n\nThis function wraps the outcome of an effect in an `Option` type. If the\noriginal effect succeeds, the success value is wrapped in `Option.some`. If\nthe effect fails, the failure is converted to `Option.none`.\n\nThis is particularly useful for scenarios where you want to represent the\nabsence of a value explicitly, without causing the resulting effect to fail.\nThe resulting effect has an error type of `never`, meaning it cannot fail\ndirectly. However, unrecoverable errors, also referred to as defects, are\nnot captured and will still result in failure.\n\n**Example** (Using Effect.option to Handle Errors)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst maybe1 = Effect.option(Effect.succeed(1))\n\nEffect.runPromiseExit(maybe1).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Success',\n//   value: { _id: 'Option', _tag: 'Some', value: 1 }\n// }\n\nconst maybe2 = Effect.option(Effect.fail(\"Uh oh!\"))\n\nEffect.runPromiseExit(maybe2).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Success',\n//   value: { _id: 'Option', _tag: 'None' }\n// }\n\nconst maybe3 = Effect.option(Effect.die(\"Boom!\"))\n\nEffect.runPromiseExit(maybe3).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Die', defect: 'Boom!' }\n// }\n```",
      examples: [
        {
          title: "Using Effect.option to Handle Errors",
          code: `import { Effect } from "effect"

const maybe1 = Effect.option(Effect.succeed(1))

Effect.runPromiseExit(maybe1).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Success',
//   value: { _id: 'Option', _tag: 'Some', value: 1 }
// }

const maybe2 = Effect.option(Effect.fail("Uh oh!"))

Effect.runPromiseExit(maybe2).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Success',
//   value: { _id: 'Option', _tag: 'None' }
// }

const maybe3 = Effect.option(Effect.die("Boom!"))

Effect.runPromiseExit(maybe3).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Die', defect: 'Boom!' }
// }`
        }
      ],
      tags: [
        "Outcome Encapsulation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 15243,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L15243"
    },
    {
      id: "Effect.either",
      name: "either",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<Either<A, E>, never, R>",
      description: "Encapsulates both success and failure of an `Effect` into an `Either` type.",
      documentation: 'Encapsulates both success and failure of an `Effect` into an `Either` type.\n\n**Details**\n\nThis function converts an effect that may fail into an effect that always\nsucceeds, wrapping the outcome in an `Either` type. The result will be\n`Either.Left` if the effect fails, containing the recoverable error, or\n`Either.Right` if it succeeds, containing the result.\n\nUsing this function, you can handle recoverable errors explicitly without\ncausing the effect to fail. This is particularly useful in scenarios where\nyou want to chain effects and manage both success and failure in the same\nlogical flow.\n\nIt\'s important to note that unrecoverable errors, often referred to as\n"defects," are still thrown and not captured within the `Either` type. Only\nfailures that are explicitly represented as recoverable errors in the effect\nare encapsulated.\n\nThe resulting effect cannot fail directly because all recoverable failures\nare represented inside the `Either` type.\n\n**Example**\n\n```ts\nimport { Effect, Either, Random } from "effect"\n\nclass HttpError {\n  readonly _tag = "HttpError"\n}\n\nclass ValidationError {\n  readonly _tag = "ValidationError"\n}\n\n//      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return "some result"\n})\n\n//      \u250C\u2500\u2500\u2500 Effect<string, never, never>\n//      \u25BC\nconst recovered = Effect.gen(function* () {\n  //      \u250C\u2500\u2500\u2500 Either<string, HttpError | ValidationError>\n  //      \u25BC\n  const failureOrSuccess = yield* Effect.either(program)\n  return Either.match(failureOrSuccess, {\n    onLeft: (error) => `Recovering from ${error._tag}`,\n    onRight: (value) => value // Do nothing in case of success\n  })\n})\n```',
      examples: [
        {
          code: 'import { Effect, Either, Random } from "effect"\n\nclass HttpError {\n  readonly _tag = "HttpError"\n}\n\nclass ValidationError {\n  readonly _tag = "ValidationError"\n}\n\n//      \u250C\u2500\u2500\u2500 Effect<string, HttpError | ValidationError, never>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  const n1 = yield* Random.next\n  const n2 = yield* Random.next\n  if (n1 < 0.5) {\n    yield* Effect.fail(new HttpError())\n  }\n  if (n2 < 0.5) {\n    yield* Effect.fail(new ValidationError())\n  }\n  return "some result"\n})\n\n//      \u250C\u2500\u2500\u2500 Effect<string, never, never>\n//      \u25BC\nconst recovered = Effect.gen(function* () {\n  //      \u250C\u2500\u2500\u2500 Either<string, HttpError | ValidationError>\n  //      \u25BC\n  const failureOrSuccess = yield* Effect.either(program)\n  return Either.match(failureOrSuccess, {\n    onLeft: (error) => `Recovering from ${error._tag}`,\n    onRight: (value) => value // Do nothing in case of success\n  })\n})'
        }
      ],
      tags: [
        "Outcome Encapsulation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 15313,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L15313"
    },
    {
      id: "Effect.exit",
      name: "exit",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<Exit<A, E>, never, R>",
      description: "/\n * Encapsulates both success and failure of an `Effect` using the `Exit` type.\n *\n *",
      documentation: '/**\n * Encapsulates both success and failure of an `Effect` using the `Exit` type.\n *\n * **Details**\n *\n * This function converts an effect into one that always succeeds, wrapping its\n * outcome in the `Exit` type. The `Exit` type provides explicit handling of\n * both success (`Exit.Success`) and failure (`Exit.Failure`) cases, including\n * defects (unrecoverable errors).\n *\n * Unlike {@link either}or {@link option}, this function also encapsulates\n * defects, which are typically unrecoverable and would otherwise terminate the\n * effect. With the `Exit` type, defects are represented in `Exit.Failure`,\n * allowing for detailed introspection and structured error handling.\n *\n * This makes the resulting effect robust and incapable of direct failure (its\n * error type is `never`). It is particularly useful for workflows where all\n * outcomes, including unexpected defects, must be managed and analyzed.\n *\n * **Example**\n *\n * ```ts\n * import { Effect, Cause, Console, Exit } from "effect"\n *\n * // Simulating a runtime error\n * const task = Effect.dieMessage("Boom!")\n *\n * const program = Effect.gen(function* () {\n *   const exit = yield* Effect.exit(task)\n *   if (Exit.isFailure(exit)) {\n *     const cause = exit.cause\n *     if (\n *       Cause.isDieType(cause) &&\n *       Cause.isRuntimeException(cause.defect)\n *     ) {\n *       yield* Console.log(\n *         `RuntimeException defect caught: ${cause.defect.message}`\n *       )\n *     } else {\n *       yield* Console.log("Unknown failure caught.")\n *     }\n *   }\n * })\n *\n * // We get an Exit.Success because we caught all failures\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // RuntimeException defect caught: Boom!\n * // {\n * //   _id: "Exit",\n * //   _tag: "Success",\n * //   value: undefined\n * // }\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect, Cause, Console, Exit } from "effect"\n *\n * // Simulating a runtime error\n * const task = Effect.dieMessage("Boom!")\n *\n * const program = Effect.gen(function* () {\n *   const exit = yield* Effect.exit(task)\n *   if (Exit.isFailure(exit)) {\n *     const cause = exit.cause\n *     if (\n *       Cause.isDieType(cause) &&\n *       Cause.isRuntimeException(cause.defect)\n *     ) {\n *       yield* Console.log(\n *         `RuntimeException defect caught: ${cause.defect.message}`\n *       )\n *     } else {\n *       yield* Console.log("Unknown failure caught.")\n *     }\n *   }\n * })\n *\n * // We get an Exit.Success because we caught all failures\n * Effect.runPromiseExit(program).then(console.log)\n * // Output:\n * // RuntimeException defect caught: Boom!\n * // {\n * //   _id: "Exit",\n * //   _tag: "Success",\n * //   value: undefined\n * // }\n *'
        }
      ],
      tags: [
        "Outcome Encapsulation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 15375,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L15375"
    },
    {
      id: "Effect.intoDeferred",
      name: "intoDeferred",
      module: "Effect",
      package: "effect",
      signature: "{ <A, E>(deferred: Deferred<A, E>): <R>(self: Effect<A, E, R>) => Effect<boolean, never, R>; <A, E, R>(self: Effect<A, E, R>, deferred: Deferred<A, E>): Effect<boolean, never, R>; }",
      description: "Converts an `Effect` into an operation that completes a `Deferred` with its result.",
      documentation: 'Converts an `Effect` into an operation that completes a `Deferred` with its result.\n\n**Details**\n\nThe `intoDeferred` function takes an effect and a `Deferred` and ensures that the `Deferred`\nis completed based on the outcome of the effect. If the effect succeeds, the `Deferred` is\ncompleted with the success value. If the effect fails, the `Deferred` is completed with the\nfailure. Additionally, if the effect is interrupted, the `Deferred` will also be interrupted.\n\n**Example**\n\n```ts\nimport { Deferred, Effect } from "effect"\n\n// Define an effect that succeeds\nconst successEffect = Effect.succeed(42)\n\nconst program = Effect.gen(function*() {\n  // Create a deferred\n  const deferred = yield* Deferred.make<number, string>()\n\n  // Complete the deferred using the successEffect\n  const isCompleted = yield* Effect.intoDeferred(successEffect, deferred)\n\n  // Access the value of the deferred\n  const value = yield* Deferred.await(deferred)\n  console.log(value)\n\n  return isCompleted\n})\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// 42\n// true\n```',
      examples: [
        {
          code: 'import { Deferred, Effect } from "effect"\n\n// Define an effect that succeeds\nconst successEffect = Effect.succeed(42)\n\nconst program = Effect.gen(function*() {\n  // Create a deferred\n  const deferred = yield* Deferred.make<number, string>()\n\n  // Complete the deferred using the successEffect\n  const isCompleted = yield* Effect.intoDeferred(successEffect, deferred)\n\n  // Access the value of the deferred\n  const value = yield* Deferred.await(deferred)\n  console.log(value)\n\n  return isCompleted\n})\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// 42\n// true'
        }
      ],
      tags: [
        "Synchronization Utilities"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 15417,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L15417"
    },
    {
      id: "Effect.filterOrDie",
      name: "filterOrDie",
      module: "Effect",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, orDieWith: (a: EqualsWith<A, B, A, Exclude<A, B>>) => unknown): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>, orDieWith: (a: NoInfer<A>) => unknown): <E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>, orDieWith: (a: EqualsWith<A, B, A, Exclude<A, B>>) => unknown): Effect<B, E, R>; <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>, orDieWith: (a: A) => unknown): Effect<A, E, R>; }",
      description: "Filters an effect, dying with a custom defect if the predicate fails.",
      documentation: "Filters an effect, dying with a custom defect if the predicate fails.\n\n**Details**\n\nThis function applies a predicate to the result of an effect. If the\npredicate evaluates to `false`, the effect dies with a custom defect\ngenerated by the `orDieWith` function.\n\n**When to Use**\n\nThis is useful for enforcing constraints on values and treating violations as\nfatal program errors.",
      examples: [],
      tags: [
        "Filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 15555,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L15555"
    },
    {
      id: "Effect.filterOrDieMessage",
      name: "filterOrDieMessage",
      module: "Effect",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, message: string): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>, message: string): <E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>, message: string): Effect<B, E, R>; <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>, message: string): Effect<A, E, R>; }",
      description: "/\n * Filters an effect, dying with a custom message if the predicate fails.\n *\n *",
      documentation: "/**\n * Filters an effect, dying with a custom message if the predicate fails.\n *\n * **Details**\n *\n * This function works like {@link filterOrDie}but allows you to specify a\n * custom error message to describe the reason for the failure. The message is\n * included in the defect when the predicate evaluates to `false`.\n *\n *",
      examples: [],
      tags: [
        "Filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 15641,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L15641"
    },
    {
      id: "Effect.filterOrElse",
      name: "filterOrElse",
      module: "Effect",
      package: "effect",
      signature: "{ <A, C, E2, R2, B extends A>(refinement: Refinement<NoInfer<A>, B>, orElse: (a: EqualsWith<A, B, NoInfer<A>, Exclude<NoInfer<A>, B>>) => Effect<C, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<C | B, E2 | E, R2 | R>; <A, C, E2, R2>(predicate: Predicate<NoInfer<A>>, orElse: (a: NoInfer<A>) => Effect<C, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<A | C, E2 | E, R2 | R>; <A, E, R, C, E2, R2, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>, orElse: (a: EqualsWith<A, B, A, Exclude<A, B>>) => Effect<C, E2, R2>): Effect<C | B, E | E2, R | R2>; <A, E, R, C, E2, R2>(self: Effect<A, E, R>, predicate: Predicate<A>, orElse: (a: A) => Effect<C, E2, R2>): Effect<A | C, E | E2, R | R2>; }",
      description: "Filters an effect, providing an alternative effect if the predicate fails.",
      documentation: "Filters an effect, providing an alternative effect if the predicate fails.\n\n**Details**\n\nThis function applies a predicate to the result of an effect. If the\npredicate evaluates to `false`, it executes the `orElse` effect instead. The\n`orElse` effect can produce an alternative value or perform additional\ncomputations.",
      examples: [],
      tags: [
        "Filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 15708,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L15708"
    },
    {
      id: "Effect.filterOrFail",
      name: "filterOrFail",
      module: "Effect",
      package: "effect",
      signature: "{ <A, E2, B extends A>(refinement: Refinement<NoInfer<A>, B>, orFailWith: (a: EqualsWith<A, B, NoInfer<A>, Exclude<NoInfer<A>, B>>) => E2): <E, R>(self: Effect<A, E, R>) => Effect<NoInfer<B>, E2 | E, R>; <A, E2>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R>; <A, E, R, E2, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>, orFailWith: (a: EqualsWith<A, B, A, Exclude<A, B>>) => E2): Effect<NoInfer<B>, E | E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => E2): Effect<A, E | E2, R>; <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Effect<A, E, R>) => Effect<NoInfer<B>, NoSuchElementException | E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Effect<A, E, R>) => Effect<A, NoSuchElementException | E, R>; <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>): Effect<NoInfer<B>, NoSuchElementException | E, R>; <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>): Effect<A, NoSuchElementException | E, R>; }",
      description: "Filters an effect, failing with a custom error if the predicate fails.",
      documentation: 'Filters an effect, failing with a custom error if the predicate fails.\n\n**Details**\n\nThis function applies a predicate to the result of an effect. If the\npredicate evaluates to `false`, the effect fails with a custom error\ngenerated by the `orFailWith` function.\n\n**When to Use**\n\nThis is useful for enforcing constraints and treating violations as\nrecoverable errors.\n\n**Providing a Guard**\n\nIn addition to the filtering capabilities discussed earlier, you have the\noption to further refine and narrow down the type of the success channel by\nproviding a [user-defined type\nguard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates).\nLet\'s explore this concept through an example:\n\n**Example**\n\n```ts\nimport { Effect, pipe } from "effect"\n\n// Define a user interface\ninterface User {\n  readonly name: string\n}\n\n// Simulate an asynchronous authentication function\ndeclare const auth: () => Promise<User | null>\n\nconst program = pipe(\n  Effect.promise(() => auth()),\n  // Use filterOrFail with a custom type guard to ensure user is not null\n  Effect.filterOrFail(\n    (user): user is User => user !== null, // Type guard\n    () => new Error("Unauthorized")\n  ),\n  // \'user\' now has the type `User` (not `User | null`)\n  Effect.andThen((user) => user.name)\n)\n```',
      examples: [
        {
          code: 'import { Effect, pipe } from "effect"\n\n// Define a user interface\ninterface User {\n  readonly name: string\n}\n\n// Simulate an asynchronous authentication function\ndeclare const auth: () => Promise<User | null>\n\nconst program = pipe(\n  Effect.promise(() => auth()),\n  // Use filterOrFail with a custom type guard to ensure user is not null\n  Effect.filterOrFail(\n    (user): user is User => user !== null, // Type guard\n    () => new Error("Unauthorized")\n  ),\n  // \'user\' now has the type `User` (not `User | null`)\n  Effect.andThen((user) => user.name)\n)'
        }
      ],
      tags: [
        "Filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 15816,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L15816"
    },
    {
      id: "Effect.filterEffectOrElse",
      name: "filterEffectOrElse",
      module: "Effect",
      package: "effect",
      signature: "{ <A, E2, R2, A2, E3, R3>(options: { readonly predicate: (a: NoInfer<A>) => Effect<boolean, E2, R2>; readonly orElse: (a: NoInfer<A>) => Effect<A2, E3, R3>; }): <E, R>(self: Effect<A, E, R>) => Effect<A | A2, E2 | E3 | E, R2 | R3 | R>; <A, E, R, E2, R2, A2, E3, R3>(self: Effect<A, E, R>, options: { readonly predicate: (a: A) => Effect<boolean, E2, R2>; readonly orElse: (a: A) => Effect<A2, E3, R3>; }): Effect<A | A2, E | E2 | E3, R | R2 | R3>; }",
      description: "Filters an effect with an effectful predicate, falling back to an alternative\neffect if the predicate fails.",
      documentation: 'Filters an effect with an effectful predicate, falling back to an alternative\neffect if the predicate fails.\n\n**Details**\n\nThis function applies a predicate to the result of an effect. If the\npredicate evaluates to `false`, the effect falls back to the `orElse`\neffect. The `orElse` effect can produce an alternative value or perform\nadditional computations.\n\n**Example**\n\n```ts\nimport { Effect, pipe } from "effect"\n\n// Define a user interface\ninterface User {\n  readonly name: string\n}\n\n// Simulate an asynchronous authentication function\ndeclare const auth: () => Promise<User | null>\n\nconst program = pipe(\n  Effect.promise(() => auth()),\n  // Use filterEffectOrElse with an effectful predicate\n  Effect.filterEffectOrElse({\n    predicate: (user) => Effect.succeed(user !== null),\n    orElse: (user) => Effect.fail(new Error(`Unauthorized user: ${user}`))\n  }),\n)\n```',
      examples: [
        {
          code: 'import { Effect, pipe } from "effect"\n\n// Define a user interface\ninterface User {\n  readonly name: string\n}\n\n// Simulate an asynchronous authentication function\ndeclare const auth: () => Promise<User | null>\n\nconst program = pipe(\n  Effect.promise(() => auth()),\n  // Use filterEffectOrElse with an effectful predicate\n  Effect.filterEffectOrElse({\n    predicate: (user) => Effect.succeed(user !== null),\n    orElse: (user) => Effect.fail(new Error(`Unauthorized user: ${user}`))\n  }),\n)'
        }
      ],
      tags: [
        "Filtering"
      ],
      since: "3.13.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 16263,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L16263"
    },
    {
      id: "Effect.filterEffectOrFail",
      name: "filterEffectOrFail",
      module: "Effect",
      package: "effect",
      signature: "{ <A, E2, R2, E3>(options: { readonly predicate: (a: NoInfer<A>) => Effect<boolean, E2, R2>; readonly orFailWith: (a: NoInfer<A>) => E3; }): <E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E3 | E, R2 | R>; <A, E, R, E2, R2, E3>(self: Effect<A, E, R>, options: { readonly predicate: (a: A) => Effect<boolean, E2, R2>; readonly orFailWith: (a: A) => E3; }): Effect<A, E | E2 | E3, R | R2>; }",
      description: "Filters an effect with an effectful predicate, failing with a custom error if the predicate fails.",
      documentation: 'Filters an effect with an effectful predicate, failing with a custom error if the predicate fails.\n\n**Details**\n\nThis function applies a predicate to the result of an effect. If the\npredicate evaluates to `false`, the effect fails with a custom error\ngenerated by the `orFailWith` function.\n\n**When to Use**\n\nThis is useful for enforcing constraints and treating violations as\nrecoverable errors.\n\n**Example**\n\n```ts\nimport { Effect, pipe } from "effect"\n\n// Define a user interface\ninterface User {\n  readonly name: string\n}\n\n// Simulate an asynchronous authentication function\ndeclare const auth: () => Promise<User | null>\n\nconst program = pipe(\n  Effect.promise(() => auth()),\n  // Use filterEffectOrFail with an effectful predicate\n  Effect.filterEffectOrFail({\n    predicate: (user) => Effect.succeed(user !== null),\n    orFailWith: () => new Error("Unauthorized")\n  }),\n)\n```',
      examples: [
        {
          code: 'import { Effect, pipe } from "effect"\n\n// Define a user interface\ninterface User {\n  readonly name: string\n}\n\n// Simulate an asynchronous authentication function\ndeclare const auth: () => Promise<User | null>\n\nconst program = pipe(\n  Effect.promise(() => auth()),\n  // Use filterEffectOrFail with an effectful predicate\n  Effect.filterEffectOrFail({\n    predicate: (user) => Effect.succeed(user !== null),\n    orFailWith: () => new Error("Unauthorized")\n  }),\n)'
        }
      ],
      tags: [
        "Filtering"
      ],
      since: "3.13.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 16387,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L16387"
    },
    {
      id: "Effect.unless",
      name: "unless",
      module: "Effect",
      package: "effect",
      signature: "{ (condition: LazyArg<boolean>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, condition: LazyArg<boolean>): Effect<Option<A>, E, R>; }",
      description: "Executes an effect only if the condition is `false`.",
      documentation: "Executes an effect only if the condition is `false`.",
      examples: [],
      tags: [
        "Conditional Operators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 16486,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L16486"
    },
    {
      id: "Effect.unlessEffect",
      name: "unlessEffect",
      module: "Effect",
      package: "effect",
      signature: "{ <E2, R2>(condition: Effect<boolean, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option<A>, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Effect<A, E, R>, condition: Effect<boolean, E2, R2>): Effect<Option<A>, E | E2, R | R2>; }",
      description: "Conditionally execute an effect based on the result of another effect.",
      documentation: "Conditionally execute an effect based on the result of another effect.",
      examples: [],
      tags: [
        "Conditional Operators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 16517,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L16517"
    },
    {
      id: "Effect.when",
      name: "when",
      module: "Effect",
      package: "effect",
      signature: "{ (condition: LazyArg<boolean>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, condition: LazyArg<boolean>): Effect<Option<A>, E, R>; }",
      description: "Conditionally executes an effect based on a boolean condition.",
      documentation: 'Conditionally executes an effect based on a boolean condition.\n\n**Details**\n\nThis function allows you to run an effect only if a given condition evaluates\nto `true`. If the condition is `true`, the effect is executed, and its result\nis wrapped in an `Option.some`. If the condition is `false`, the effect is\nskipped, and the result is `Option.none`.\n\n**When to Use**\n\nThis function is useful for scenarios where you need to dynamically decide\nwhether to execute an effect based on runtime logic, while also representing\nthe skipped case explicitly.\n\n**Example** (Conditional Effect Execution)\n\n```ts\nimport { Effect, Option } from "effect"\n\nconst validateWeightOption = (\n  weight: number\n): Effect.Effect<Option.Option<number>> =>\n  // Conditionally execute the effect if the weight is non-negative\n  Effect.succeed(weight).pipe(Effect.when(() => weight >= 0))\n\n// Run with a valid weight\nEffect.runPromise(validateWeightOption(100)).then(console.log)\n// Output:\n// {\n//   _id: "Option",\n//   _tag: "Some",\n//   value: 100\n// }\n\n// Run with an invalid weight\nEffect.runPromise(validateWeightOption(-5)).then(console.log)\n// Output:\n// {\n//   _id: "Option",\n//   _tag: "None"\n// }\n```',
      examples: [
        {
          title: "Conditional Effect Execution",
          code: 'import { Effect, Option } from "effect"\n\nconst validateWeightOption = (\n  weight: number\n): Effect.Effect<Option.Option<number>> =>\n  // Conditionally execute the effect if the weight is non-negative\n  Effect.succeed(weight).pipe(Effect.when(() => weight >= 0))\n\n// Run with a valid weight\nEffect.runPromise(validateWeightOption(100)).then(console.log)\n// Output:\n// {\n//   _id: "Option",\n//   _tag: "Some",\n//   value: 100\n// }\n\n// Run with an invalid weight\nEffect.runPromise(validateWeightOption(-5)).then(console.log)\n// Output:\n// {\n//   _id: "Option",\n//   _tag: "None"\n// }'
        }
      ],
      tags: [
        "Conditional Operators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 16590,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L16590"
    },
    {
      id: "Effect.whenEffect",
      name: "whenEffect",
      module: "Effect",
      package: "effect",
      signature: "{ <E, R>(condition: Effect<boolean, E, R>): <A, E2, R2>(effect: Effect<A, E2, R2>) => Effect<Option<A>, E | E2, R | R2>; <A, E2, R2, E, R>(self: Effect<A, E2, R2>, condition: Effect<boolean, E, R>): Effect<Option<A>, E2 | E, R2 | R>; }",
      description: "Conditionally executes an effect based on the result of another effect.",
      documentation: "Conditionally executes an effect based on the result of another effect.\n\n**Details**\n\nThis function allows you to run an effect only if a conditional effect\nevaluating to a boolean resolves to `true`. If the conditional effect\nevaluates to `true`, the specified effect is executed, and its result is\nwrapped in `Option.some`. If the conditional effect evaluates to `false`, the\neffect is skipped, and the result is `Option.none`.\n\n**When to Use**\n\nThis function is particularly useful when the decision to execute an effect\ndepends on the result of another effect, such as a random value, a\nuser-provided input, or a network request result.\n\n**Example** (Using an Effect as a Condition)\n\n```ts\nimport { Effect, Random } from \"effect\"\n\nconst randomIntOption = Random.nextInt.pipe(\n  Effect.whenEffect(Random.nextBoolean)\n)\n\nconsole.log(Effect.runSync(randomIntOption))\n// Example Output:\n// { _id: 'Option', _tag: 'Some', value: 8609104974198840 }\n```",
      examples: [
        {
          title: "Using an Effect as a Condition",
          code: `import { Effect, Random } from "effect"

const randomIntOption = Random.nextInt.pipe(
  Effect.whenEffect(Random.nextBoolean)
)

console.log(Effect.runSync(randomIntOption))
// Example Output:
// { _id: 'Option', _tag: 'Some', value: 8609104974198840 }`
        }
      ],
      tags: [
        "Conditional Operators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 16733,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L16733"
    },
    {
      id: "Effect.whenFiberRef",
      name: "whenFiberRef",
      module: "Effect",
      package: "effect",
      signature: "{ <S>(fiberRef: FiberRef<S>, predicate: Predicate<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<[S, Option<A>], E, R>; <A, E, R, S>(self: Effect<A, E, R>, fiberRef: FiberRef<S>, predicate: Predicate<S>): Effect<[S, Option<A>], E, R>; }",
      description: "Executes an effect conditionally based on the value of a `FiberRef` that\nsatisfies a predicate.",
      documentation: "Executes an effect conditionally based on the value of a `FiberRef` that\nsatisfies a predicate.\n\n**Details**\n\nThis function enables you to execute an effect only when the value of a\nspecified `FiberRef` meets a certain condition defined by a predicate. If the\nvalue satisfies the predicate, the effect is executed, and the result is\nwrapped in an `Option.some`. If the predicate is not satisfied, the effect is\nskipped, and the result is `Option.none`. In both cases, the current value of\nthe `FiberRef` is included in the result.",
      examples: [],
      tags: [
        "Conditional Operators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 16827,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L16827"
    },
    {
      id: "Effect.whenRef",
      name: "whenRef",
      module: "Effect",
      package: "effect",
      signature: "{ <S>(ref: Ref<S>, predicate: Predicate<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<[S, Option<A>], E, R>; <A, E, R, S>(self: Effect<A, E, R>, ref: Ref<S>, predicate: Predicate<S>): Effect<[S, Option<A>], E, R>; }",
      description: "Executes an effect conditionally based on the value of a `Ref` that satisfies\na predicate.",
      documentation: "Executes an effect conditionally based on the value of a `Ref` that satisfies\na predicate.\n\n**Details**\n\nThis function allows you to execute an effect only when the value of a\nspecified `Ref` meets a condition defined by a predicate. If the value\nsatisfies the predicate, the effect is executed, and the result is wrapped in\nan `Option.some`. If the predicate is not satisfied, the effect is skipped,\nand the result is `Option.none`. In both cases, the current value of the\n`Ref` is included in the result.",
      examples: [],
      tags: [
        "Conditional Operators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 16879,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L16879"
    },
    {
      id: "Effect.flatMap",
      name: "flatMap",
      module: "Effect",
      package: "effect",
      signature: "{ <A, B, E1, R1>(f: (a: A) => Effect<B, E1, R1>): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R1 | R>; <A, E, R, B, E1, R1>(self: Effect<A, E, R>, f: (a: A) => Effect<B, E1, R1>): Effect<B, E | E1, R | R1>; }",
      description: "Chains effects to produce new `Effect` instances, useful for combining\noperations that depend on previous results.",
      documentation: 'Chains effects to produce new `Effect` instances, useful for combining\noperations that depend on previous results.\n\n**Syntax**\n\n```ts skip-type-checking\nconst flatMappedEffect = pipe(myEffect, Effect.flatMap(transformation))\n// or\nconst flatMappedEffect = Effect.flatMap(myEffect, transformation)\n// or\nconst flatMappedEffect = myEffect.pipe(Effect.flatMap(transformation))\n```\n\n**Details**\n\n`flatMap` lets you sequence effects so that the result of one effect can be\nused in the next step. It is similar to `flatMap` used with arrays but works\nspecifically with `Effect` instances, allowing you to avoid deeply nested\neffect structures.\n\nSince effects are immutable, `flatMap` always returns a new effect instead of\nchanging the original one.\n\n**When to Use**\n\nUse `flatMap` when you need to chain multiple effects, ensuring that each\nstep produces a new `Effect` while flattening any nested effects that may\noccur.\n\n**Example**\n\n```ts\nimport { pipe, Effect } from "effect"\n\n// Function to apply a discount safely to a transaction amount\nconst applyDiscount = (\n  total: number,\n  discountRate: number\n): Effect.Effect<number, Error> =>\n  discountRate === 0\n    ? Effect.fail(new Error("Discount rate cannot be zero"))\n    : Effect.succeed(total - (total * discountRate) / 100)\n\n// Simulated asynchronous task to fetch a transaction amount from database\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\n// Chaining the fetch and discount application using `flatMap`\nconst finalAmount = pipe(\n  fetchTransactionAmount,\n  Effect.flatMap((amount) => applyDiscount(amount, 5))\n)\n\nEffect.runPromise(finalAmount).then(console.log)\n// Output: 95\n```',
      examples: [
        {
          code: 'import { pipe, Effect } from "effect"\n\n// Function to apply a discount safely to a transaction amount\nconst applyDiscount = (\n  total: number,\n  discountRate: number\n): Effect.Effect<number, Error> =>\n  discountRate === 0\n    ? Effect.fail(new Error("Discount rate cannot be zero"))\n    : Effect.succeed(total - (total * discountRate) / 100)\n\n// Simulated asynchronous task to fetch a transaction amount from database\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\n// Chaining the fetch and discount application using `flatMap`\nconst finalAmount = pipe(\n  fetchTransactionAmount,\n  Effect.flatMap((amount) => applyDiscount(amount, 5))\n)\n\nEffect.runPromise(finalAmount).then(console.log)\n// Output: 95'
        }
      ],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 16977,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L16977"
    },
    {
      id: "Effect.andThen",
      name: "andThen",
      module: "Effect",
      package: "effect",
      signature: "{ <A, X>(f: (a: NoInfer<A>) => X): <E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, UnknownException | E, R> : Effect<X, E, R>; <X>(f: NotFunction<X>): <A, E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, UnknownException | E, R> : Effect<X, E, R>; <A, E, R, X>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => X): [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, UnknownException | E, R> : Effect<X, E, R>; <A, E, R, X>(self: Effect<A, E, R>, f: NotFunction<X>): [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, UnknownException | E, R> : Effect<X, E, R>; }",
      description: "/\n * Chains two actions, where the second action can depend on the result of the\n * first.\n *\n * Syntax\n *\n * \n *\n *",
      documentation: '/**\n * Chains two actions, where the second action can depend on the result of the\n * first.\n *\n * **Syntax**\n *\n * ```ts skip-type-checking\n * const transformedEffect = pipe(myEffect, Effect.andThen(anotherEffect))\n * // or\n * const transformedEffect = Effect.andThen(myEffect, anotherEffect)\n * // or\n * const transformedEffect = myEffect.pipe(Effect.andThen(anotherEffect))\n * ```\n *\n * **When to Use**\n *\n * Use `andThen` when you need to run multiple actions in sequence, with the\n * second action depending on the result of the first. This is useful for\n * combining effects or handling computations that must happen in order.\n *\n * **Details**\n *\n * The second action can be:\n *\n * - A constant value (similar to {@link as})\n * - A function returning a value (similar to {@link map})\n * - A `Promise`\n * - A function returning a `Promise`\n * - An `Effect`\n * - A function returning an `Effect` (similar to {@link flatMap})\n *\n * **Note:** `andThen` works well with both `Option` and `Either` types,\n * treating them as effects.\n *\n * **Example** (Applying a Discount Based on Fetched Amount)\n *\n * ```ts\n * import { pipe, Effect } from "effect"\n *\n * // Function to apply a discount safely to a transaction amount\n * const applyDiscount = (\n *   total: number,\n *   discountRate: number\n * ): Effect.Effect<number, Error> =>\n *   discountRate === 0\n *     ? Effect.fail(new Error("Discount rate cannot be zero"))\n *     : Effect.succeed(total - (total * discountRate) / 100)\n *\n * // Simulated asynchronous task to fetch a transaction amount from database\n * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n *\n * // Using Effect.map and Effect.flatMap\n * const result1 = pipe(\n *   fetchTransactionAmount,\n *   Effect.map((amount) => amount * 2),\n *   Effect.flatMap((amount) => applyDiscount(amount, 5))\n * )\n *\n * Effect.runPromise(result1).then(console.log)\n * // Output: 190\n *\n * // Using Effect.andThen\n * const result2 = pipe(\n *   fetchTransactionAmount,\n *   Effect.andThen((amount) => amount * 2),\n *   Effect.andThen((amount) => applyDiscount(amount, 5))\n * )\n *\n * Effect.runPromise(result2).then(console.log)\n * // Output: 190\n * ```\n *\n *',
      examples: [
        {
          code: '* import { pipe, Effect } from "effect"\n *\n * // Function to apply a discount safely to a transaction amount\n * const applyDiscount = (\n *   total: number,\n *   discountRate: number\n * ): Effect.Effect<number, Error> =>\n *   discountRate === 0\n *     ? Effect.fail(new Error("Discount rate cannot be zero"))\n *     : Effect.succeed(total - (total * discountRate) / 100)\n *\n * // Simulated asynchronous task to fetch a transaction amount from database\n * const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n *\n * // Using Effect.map and Effect.flatMap\n * const result1 = pipe(\n *   fetchTransactionAmount,\n *   Effect.map((amount) => amount * 2),\n *   Effect.flatMap((amount) => applyDiscount(amount, 5))\n * )\n *\n * Effect.runPromise(result1).then(console.log)\n * // Output: 190\n *\n * // Using Effect.andThen\n * const result2 = pipe(\n *   fetchTransactionAmount,\n *   Effect.andThen((amount) => amount * 2),\n *   Effect.andThen((amount) => applyDiscount(amount, 5))\n * )\n *\n * Effect.runPromise(result2).then(console.log)\n * // Output: 190\n *'
        }
      ],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 17180,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L17180"
    },
    {
      id: "Effect.flatten",
      name: "flatten",
      module: "Effect",
      package: "effect",
      signature: "<A, E1, R1, E, R>(self: Effect<Effect<A, E1, R1>, E, R>) => Effect<A, E1 | E, R1 | R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 17490,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L17490"
    },
    {
      id: "Effect.race",
      name: "race",
      module: "Effect",
      package: "effect",
      signature: "{ <A2, E2, R2>(that: Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }",
      description: "Races two effects and returns the result of the first successful one.",
      documentation: 'Races two effects and returns the result of the first successful one.\n\n**Details**\n\nThis function takes two effects and runs them concurrently. The first effect\nthat successfully completes will determine the result of the race, and the\nother effect will be interrupted.\n\nIf neither effect succeeds, the function will fail with a `Cause`\ncontaining all the errors.\n\n**When to Use**\n\nThis is useful when you want to run two effects concurrently, but only care\nabout the first one to succeed. It is commonly used in cases like timeouts,\nretries, or when you want to optimize for the faster response without\nworrying about the other effect.\n\n**Handling Success or Failure with Either**\n\nIf you want to handle the result of whichever task completes first, whether\nit succeeds or fails, you can use the `Effect.either` function. This function\nwraps the result in an `Either` type, allowing you to see if the result\nwas a success (`Right`) or a failure (`Left`).\n\n**Example** (Both Tasks Succeed)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst task1 = Effect.succeed("task1").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() => Console.log("task1 interrupted"))\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() => Console.log("task2 interrupted"))\n)\n\nconst program = Effect.race(task1, task2)\n\nEffect.runFork(program)\n// Output:\n// task1 done\n// task2 interrupted\n```\n\n**Example** (One Task Fails, One Succeeds)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst task1 = Effect.fail("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() => Console.log("task1 interrupted"))\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() => Console.log("task2 interrupted"))\n)\n\nconst program = Effect.race(task1, task2)\n\nEffect.runFork(program)\n// Output:\n// task2 done\n```\n\n**Example** (Both Tasks Fail)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst task1 = Effect.fail("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() => Console.log("task1 interrupted"))\n)\nconst task2 = Effect.fail("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() => Console.log("task2 interrupted"))\n)\n\nconst program = Effect.race(task1, task2)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// {\n//   _id: \'Exit\',\n//   _tag: \'Failure\',\n//   cause: {\n//     _id: \'Cause\',\n//     _tag: \'Parallel\',\n//     left: { _id: \'Cause\', _tag: \'Fail\', failure: \'task1\' },\n//     right: { _id: \'Cause\', _tag: \'Fail\', failure: \'task2\' }\n//   }\n// }\n```\n\n**Example** (Handling Success or Failure with Either)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst task1 = Effect.fail("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() => Console.log("task1 interrupted"))\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() => Console.log("task2 interrupted"))\n)\n\n// Run both tasks concurrently, wrapping the result\n// in Either to capture success or failure\nconst program = Effect.race(Effect.either(task1), Effect.either(task2))\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// task2 interrupted\n// { _id: \'Either\', _tag: \'Left\', left: \'task1\' }\n```',
      examples: [
        {
          title: "Both Tasks Succeed",
          code: 'import { Effect, Console } from "effect"\n\nconst task1 = Effect.succeed("task1").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() => Console.log("task1 interrupted"))\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() => Console.log("task2 interrupted"))\n)\n\nconst program = Effect.race(task1, task2)\n\nEffect.runFork(program)\n// Output:\n// task1 done\n// task2 interrupted'
        },
        {
          title: "One Task Fails, One Succeeds",
          code: 'import { Effect, Console } from "effect"\n\nconst task1 = Effect.fail("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() => Console.log("task1 interrupted"))\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() => Console.log("task2 interrupted"))\n)\n\nconst program = Effect.race(task1, task2)\n\nEffect.runFork(program)\n// Output:\n// task2 done'
        },
        {
          title: "Both Tasks Fail",
          code: `import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.fail("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const program = Effect.race(task1, task2)

Effect.runPromiseExit(program).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Parallel',
//     left: { _id: 'Cause', _tag: 'Fail', failure: 'task1' },
//     right: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }
//   }
// }`
        },
        {
          title: "Handling Success or Failure with Either",
          code: `import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

// Run both tasks concurrently, wrapping the result
// in Either to capture success or failure
const program = Effect.race(Effect.either(task1), Effect.either(task2))

Effect.runPromise(program).then(console.log)
// Output:
// task2 interrupted
// { _id: 'Either', _tag: 'Left', left: 'task1' }`
        }
      ],
      tags: [
        "Racing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 17628,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L17628"
    },
    {
      id: "Effect.raceAll",
      name: "raceAll",
      module: "Effect",
      package: "effect",
      signature: "<Eff extends Effect<any, any, any>>(all: Iterable<Eff>) => Effect<Effect.Success<Eff>, Effect.Error<Eff>, Effect.Context<Eff>>",
      description: "Races multiple effects and returns the first successful result.",
      documentation: 'Races multiple effects and returns the first successful result.\n\n**Details**\n\nThis function runs multiple effects concurrently and returns the result of\nthe first one to succeed. If one effect succeeds, the others will be\ninterrupted.\n\nIf none of the effects succeed, the function will fail with the last error\nencountered.\n\n**When to Use**\n\nThis is useful when you want to race multiple effects, but only care about\nthe first one to succeed. It is commonly used in cases like timeouts,\nretries, or when you want to optimize for the faster response without\nworrying about the other effects.\n\n**Example** (All Tasks Succeed)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst task1 = Effect.succeed("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() => Console.log("task1 interrupted"))\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() => Console.log("task2 interrupted"))\n)\n\nconst task3 = Effect.succeed("task3").pipe(\n  Effect.delay("150 millis"),\n  Effect.tap(Console.log("task3 done")),\n  Effect.onInterrupt(() => Console.log("task3 interrupted"))\n)\n\nconst program = Effect.raceAll([task1, task2, task3])\n\nEffect.runFork(program)\n// Output:\n// task1 done\n// task2 interrupted\n// task3 interrupted\n```\n\n**Example** (One Task Fails, Two Tasks Succeed)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst task1 = Effect.fail("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() => Console.log("task1 interrupted"))\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() => Console.log("task2 interrupted"))\n)\n\nconst task3 = Effect.succeed("task3").pipe(\n  Effect.delay("150 millis"),\n  Effect.tap(Console.log("task3 done")),\n  Effect.onInterrupt(() => Console.log("task3 interrupted"))\n)\n\nconst program = Effect.raceAll([task1, task2, task3])\n\nEffect.runFork(program)\n// Output:\n// task3 done\n// task2 interrupted\n```\n\n**Example** (All Tasks Fail)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst task1 = Effect.fail("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() => Console.log("task1 interrupted"))\n)\nconst task2 = Effect.fail("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() => Console.log("task2 interrupted"))\n)\n\nconst task3 = Effect.fail("task3").pipe(\n  Effect.delay("150 millis"),\n  Effect.tap(Console.log("task3 done")),\n  Effect.onInterrupt(() => Console.log("task3 interrupted"))\n)\n\nconst program = Effect.raceAll([task1, task2, task3])\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// {\n//   _id: \'Exit\',\n//   _tag: \'Failure\',\n//   cause: { _id: \'Cause\', _tag: \'Fail\', failure: \'task2\' }\n// }\n```',
      examples: [
        {
          title: "All Tasks Succeed",
          code: 'import { Effect, Console } from "effect"\n\nconst task1 = Effect.succeed("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() => Console.log("task1 interrupted"))\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() => Console.log("task2 interrupted"))\n)\n\nconst task3 = Effect.succeed("task3").pipe(\n  Effect.delay("150 millis"),\n  Effect.tap(Console.log("task3 done")),\n  Effect.onInterrupt(() => Console.log("task3 interrupted"))\n)\n\nconst program = Effect.raceAll([task1, task2, task3])\n\nEffect.runFork(program)\n// Output:\n// task1 done\n// task2 interrupted\n// task3 interrupted'
        },
        {
          title: "One Task Fails, Two Tasks Succeed",
          code: 'import { Effect, Console } from "effect"\n\nconst task1 = Effect.fail("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() => Console.log("task1 interrupted"))\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() => Console.log("task2 interrupted"))\n)\n\nconst task3 = Effect.succeed("task3").pipe(\n  Effect.delay("150 millis"),\n  Effect.tap(Console.log("task3 done")),\n  Effect.onInterrupt(() => Console.log("task3 interrupted"))\n)\n\nconst program = Effect.raceAll([task1, task2, task3])\n\nEffect.runFork(program)\n// Output:\n// task3 done\n// task2 interrupted'
        },
        {
          title: "All Tasks Fail",
          code: `import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.fail("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const task3 = Effect.fail("task3").pipe(
  Effect.delay("150 millis"),
  Effect.tap(Console.log("task3 done")),
  Effect.onInterrupt(() => Console.log("task3 interrupted"))
)

const program = Effect.raceAll([task1, task2, task3])

Effect.runPromiseExit(program).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }
// }`
        }
      ],
      tags: [
        "Racing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 18024,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L18024"
    },
    {
      id: "Effect.raceFirst",
      name: "raceFirst",
      module: "Effect",
      package: "effect",
      signature: "{ <A2, E2, R2>(that: Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }",
      description: "Races two effects and returns the result of the first one to complete.",
      documentation: 'Races two effects and returns the result of the first one to complete.\n\n**Details**\n\nThis function takes two effects and runs them concurrently, returning the\nresult of the first one that completes, regardless of whether it succeeds or\nfails.\n\n**When to Use**\n\nThis function is useful when you want to race two operations, and you want to\nproceed with whichever one finishes first, regardless of whether it succeeds\nor fails.\n\n**Disconnecting Effects**\n\nThe `Effect.raceFirst` function safely interrupts the \u201Closer\u201D effect once the other completes, but it will not resume until the loser is cleanly terminated.\n\nIf you want a quicker return, you can disconnect the interrupt signal for both effects. Instead of calling:\n\n```ts skip-type-checking\nEffect.raceFirst(task1, task2)\n```\n\nYou can use:\n\n```ts skip-type-checking\nEffect.raceFirst(Effect.disconnect(task1), Effect.disconnect(task2))\n```\n\nThis allows both effects to complete independently while still terminating the losing effect in the background.\n\n**Example** (Both Tasks Succeed)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst task1 = Effect.succeed("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() =>\n    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))\n  )\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() =>\n    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))\n  )\n)\n\nconst program = Effect.raceFirst(task1, task2).pipe(\n  Effect.tap(Console.log("more work..."))\n)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// task1 done\n// task2 interrupted\n// more work...\n// { _id: \'Exit\', _tag: \'Success\', value: \'task1\' }\n```\n\n**Example** (One Task Fails, One Succeeds)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst task1 = Effect.fail("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() =>\n    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))\n  )\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() =>\n    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))\n  )\n)\n\nconst program = Effect.raceFirst(task1, task2).pipe(\n  Effect.tap(Console.log("more work..."))\n)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// task2 interrupted\n// {\n//   _id: \'Exit\',\n//   _tag: \'Failure\',\n//   cause: { _id: \'Cause\', _tag: \'Fail\', failure: \'task1\' }\n// }\n```\n\n**Example** (Using Effect.disconnect for Quicker Return)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst task1 = Effect.succeed("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() =>\n    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))\n  )\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() =>\n    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))\n  )\n)\n\n// Race the two tasks with disconnect to allow quicker return\nconst program = Effect.raceFirst(\n  Effect.disconnect(task1),\n  Effect.disconnect(task2)\n).pipe(Effect.tap(Console.log("more work...")))\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// task1 done\n// more work...\n// { _id: \'Exit\', _tag: \'Success\', value: \'task1\' }\n// task2 interrupted\n```',
      examples: [
        {
          title: "Both Tasks Succeed",
          code: `import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() =>
    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
  )
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() =>
    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
  )
)

const program = Effect.raceFirst(task1, task2).pipe(
  Effect.tap(Console.log("more work..."))
)

Effect.runPromiseExit(program).then(console.log)
// Output:
// task1 done
// task2 interrupted
// more work...
// { _id: 'Exit', _tag: 'Success', value: 'task1' }`
        },
        {
          title: "One Task Fails, One Succeeds",
          code: `import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() =>
    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
  )
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() =>
    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
  )
)

const program = Effect.raceFirst(task1, task2).pipe(
  Effect.tap(Console.log("more work..."))
)

Effect.runPromiseExit(program).then(console.log)
// Output:
// task2 interrupted
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'task1' }
// }`
        },
        {
          title: "Using Effect.disconnect for Quicker Return",
          code: `import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() =>
    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
  )
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() =>
    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
  )
)

// Race the two tasks with disconnect to allow quicker return
const program = Effect.raceFirst(
  Effect.disconnect(task1),
  Effect.disconnect(task2)
).pipe(Effect.tap(Console.log("more work...")))

Effect.runPromiseExit(program).then(console.log)
// Output:
// task1 done
// more work...
// { _id: 'Exit', _tag: 'Success', value: 'task1' }
// task2 interrupted`
        }
      ],
      tags: [
        "Racing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 18161,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L18161"
    },
    {
      id: "Effect.raceWith",
      name: "raceWith",
      module: "Effect",
      package: "effect",
      signature: "{ <A1, E1, R1, E, A, A2, E2, R2, A3, E3, R3>(other: Effect<A1, E1, R1>, options: { readonly onSelfDone: (exit: Exit<A, E>, fiber: Fiber<A1, E1>) => Effect<A2, E2, R2>; readonly onOtherDone: (exit: Exit<A1, E1>, fiber: Fiber<A, E>) => Effect<A3, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R1 | R2 | R3 | R>; <A, E, R, A1, E1, R1, A2, E2, R2, A3, E3, R3>(self: Effect<A, E, R>, other: Effect<A1, E1, R1>, options: { readonly onSelfDone: (exit: Exit<A, E>, fiber: Fiber<A1, E1>) => Effect<A2, E2, R2>; readonly onOtherDone: (exit: Exit<A1, E1>, fiber: Fiber<A, E>) => Effect<A3, E3, R3>; }): Effect<A2 | A3, E2 | E3, R | R1 | R2 | R3>; }",
      description: "Races two effects and calls a finisher when the first one completes.",
      documentation: 'Races two effects and calls a finisher when the first one completes.\n\n**Details**\n\nThis function runs two effects concurrently and calls a specified \u201Cfinisher\u201D\nfunction once one of the effects completes, regardless of whether it succeeds\nor fails.\n\nThe finisher functions for each effect allow you to handle the results of\neach effect as soon as they complete.\n\nThe function takes two finisher callbacks, one for each effect, and allows\nyou to specify how to handle the result of the race.\n\n**When to Use**\n\nThis function is useful when you need to react to the completion of either\neffect without waiting for both to finish. It can be used whenever you want\nto take action based on the first available result.\n\n**Example** (Handling Results of Concurrent Tasks)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst task1 = Effect.succeed("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() =>\n    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))\n  )\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() =>\n    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))\n  )\n)\n\nconst program = Effect.raceWith(task1, task2, {\n  onSelfDone: (exit) => Console.log(`task1 exited with ${exit}`),\n  onOtherDone: (exit) => Console.log(`task2 exited with ${exit}`)\n})\n\nEffect.runFork(program)\n// Output:\n// task1 done\n// task1 exited with {\n//   "_id": "Exit",\n//   "_tag": "Success",\n//   "value": "task1"\n// }\n// task2 interrupted\n```',
      examples: [
        {
          title: "Handling Results of Concurrent Tasks",
          code: 'import { Effect, Console } from "effect"\n\nconst task1 = Effect.succeed("task1").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Console.log("task1 done")),\n  Effect.onInterrupt(() =>\n    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))\n  )\n)\nconst task2 = Effect.succeed("task2").pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Console.log("task2 done")),\n  Effect.onInterrupt(() =>\n    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))\n  )\n)\n\nconst program = Effect.raceWith(task1, task2, {\n  onSelfDone: (exit) => Console.log(`task1 exited with ${exit}`),\n  onOtherDone: (exit) => Console.log(`task2 exited with ${exit}`)\n})\n\nEffect.runFork(program)\n// Output:\n// task1 done\n// task1 exited with {\n//   "_id": "Exit",\n//   "_tag": "Success",\n//   "value": "task1"\n// }\n// task2 interrupted'
        }
      ],
      tags: [
        "Racing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 18497,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L18497"
    },
    {
      id: "Effect.summarized",
      name: "summarized",
      module: "Effect",
      package: "effect",
      signature: "{ <B, E2, R2, C>(summary: Effect<B, E2, R2>, f: (start: B, end: B) => C): <A, E, R>(self: Effect<A, E, R>) => Effect<[C, A], E2 | E, R2 | R>; <A, E, R, B, E2, R2, C>(self: Effect<A, E, R>, summary: Effect<B, E2, R2>, f: (start: B, end: B) => C): Effect<[C, A], E | E2, R | R2>; }",
      description: "Summarizes a effect by computing some value before and after execution, and\nthen combining the values to produce a summary, together with the result of\nexecution.",
      documentation: "Summarizes a effect by computing some value before and after execution, and\nthen combining the values to produce a summary, together with the result of\nexecution.",
      examples: [],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 18635,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L18635"
    },
    {
      id: "Effect.tap",
      name: "tap",
      module: "Effect",
      package: "effect",
      signature: "{ <A, X>(f: (a: NoInfer<A>) => X): <E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, UnknownException | E, R> : Effect<A, E, R>; <A, X, E1, R1>(f: (a: NoInfer<A>) => Effect<X, E1, R1>, options: { onlyEffect: true; }): <E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R1 | R>; <X>(f: NotFunction<X>): <A, E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, UnknownException | E, R> : Effect<A, E, R>; <X, E1, R1>(f: Effect<X, E1, R1>, options: { onlyEffect: true; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R1 | R>; <A, E, R, X>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => X): [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, UnknownException | E, R> : Effect<A, E, R>; <A, E, R, X, E1, R1>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => Effect<X, E1, R1>, options: { onlyEffect: true; }): Effect<A, E | E1, R | R1>; <A, E, R, X>(self: Effect<A, E, R>, f: NotFunction<X>): [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, UnknownException | E, R> : Effect<A, E, R>; <A, E, R, X, E1, R1>(self: Effect<A, E, R>, f: Effect<X, E1, R1>, options: { onlyEffect: true; }): Effect<A, E | E1, R | R1>; }",
      description: "Runs a side effect with the result of an effect without changing the original\nvalue.",
      documentation: 'Runs a side effect with the result of an effect without changing the original\nvalue.\n\n**Details**\n\nThis function works similarly to `flatMap`, but it ignores the result of the\nfunction passed to it. The value from the previous effect remains available\nfor the next part of the chain. Note that if the side effect fails, the\nentire chain will fail too.\n\n**When to Use**\n\nUse this function when you want to perform a side effect, like logging or\ntracking, without modifying the main value. This is useful when you need to\nobserve or record an action but want the original value to be passed to the\nnext step.\n\n**Example** (Logging a step in a pipeline)\n\n```ts\nimport { Console, Effect, pipe } from "effect"\n\n// Function to apply a discount safely to a transaction amount\nconst applyDiscount = (\n  total: number,\n  discountRate: number\n): Effect.Effect<number, Error> =>\n  discountRate === 0\n    ? Effect.fail(new Error("Discount rate cannot be zero"))\n    : Effect.succeed(total - (total * discountRate) / 100)\n\n// Simulated asynchronous task to fetch a transaction amount from database\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\nconst finalAmount = pipe(\n  fetchTransactionAmount,\n  // Log the fetched transaction amount\n  Effect.tap((amount) => Console.log(`Apply a discount to: ${amount}`)),\n  // `amount` is still available!\n  Effect.flatMap((amount) => applyDiscount(amount, 5))\n)\n\nEffect.runPromise(finalAmount).then(console.log)\n// Output:\n// Apply a discount to: 100\n// 95\n```',
      examples: [
        {
          title: "Logging a step in a pipeline",
          code: 'import { Console, Effect, pipe } from "effect"\n\n// Function to apply a discount safely to a transaction amount\nconst applyDiscount = (\n  total: number,\n  discountRate: number\n): Effect.Effect<number, Error> =>\n  discountRate === 0\n    ? Effect.fail(new Error("Discount rate cannot be zero"))\n    : Effect.succeed(total - (total * discountRate) / 100)\n\n// Simulated asynchronous task to fetch a transaction amount from database\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\nconst finalAmount = pipe(\n  fetchTransactionAmount,\n  // Log the fetched transaction amount\n  Effect.tap((amount) => Console.log(`Apply a discount to: ${amount}`)),\n  // `amount` is still available!\n  Effect.flatMap((amount) => applyDiscount(amount, 5))\n)\n\nEffect.runPromise(finalAmount).then(console.log)\n// Output:\n// Apply a discount to: 100\n// 95'
        }
      ],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 18709,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L18709"
    },
    {
      id: "Effect.tapBoth",
      name: "tapBoth",
      module: "Effect",
      package: "effect",
      signature: "{ <E, X, E2, R2, A, X1, E3, R3>(options: { readonly onFailure: (e: NoInfer<E>) => Effect<X, E2, R2>; readonly onSuccess: (a: NoInfer<A>) => Effect<X1, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A, E | E2 | E3, R2 | R3 | R>; <A, E, R, X, E2, R2, X1, E3, R3>(self: Effect<A, E, R>, options: { readonly onFailure: (e: E) => Effect<X, E2, R2>; readonly onSuccess: (a: A) => Effect<X1, E3, R3>; }): Effect<A, E | E2 | E3, R | R2 | R3>; }",
      description: "Allows you to inspect both success and failure outcomes of an effect and\nperform side effects for each.",
      documentation: 'Allows you to inspect both success and failure outcomes of an effect and\nperform side effects for each.\n\n**Details**\n\nThis function enables you to handle both success and failure cases\nseparately, without modifying the main effect\'s result. It is particularly\nuseful for scenarios where you need to log, monitor, or perform additional\nactions depending on whether the effect succeeded or failed.\n\nWhen the effect succeeds, the `onSuccess` handler is executed with the\nsuccess value. When the effect fails, the `onFailure` handler is executed\nwith the failure value. Both handlers can include side effects such as\nlogging or analytics, and neither modifies the original effect\'s output.\n\nIf either the success or failure handler fails, the overall effect will also\nfail.\n\n**Example**\n\n```ts\nimport { Effect, Random, Console } from "effect"\n\n// Simulate a task that might fail\nconst task = Effect.filterOrFail(\n  Random.nextRange(-1, 1),\n  (n) => n >= 0,\n  () => "random number is negative"\n)\n\n// Use tapBoth to log both success and failure outcomes\nconst tapping = Effect.tapBoth(task, {\n  onFailure: (error) => Console.log(`failure: ${error}`),\n  onSuccess: (randomNumber) =>\n    Console.log(`random number: ${randomNumber}`)\n})\n\nEffect.runFork(tapping)\n// Example Output:\n// failure: random number is negative\n```',
      examples: [
        {
          code: 'import { Effect, Random, Console } from "effect"\n\n// Simulate a task that might fail\nconst task = Effect.filterOrFail(\n  Random.nextRange(-1, 1),\n  (n) => n >= 0,\n  () => "random number is negative"\n)\n\n// Use tapBoth to log both success and failure outcomes\nconst tapping = Effect.tapBoth(task, {\n  onFailure: (error) => Console.log(`failure: ${error}`),\n  onSuccess: (randomNumber) =>\n    Console.log(`random number: ${randomNumber}`)\n})\n\nEffect.runFork(tapping)\n// Example Output:\n// failure: random number is negative'
        }
      ],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 19205,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L19205"
    },
    {
      id: "Effect.tapDefect",
      name: "tapDefect",
      module: "Effect",
      package: "effect",
      signature: "{ <X, E2, R2>(f: (cause: Cause<never>) => Effect<X, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause<never>) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>; }",
      description: "Inspect severe errors or defects (non-recoverable failures) in an effect.",
      documentation: 'Inspect severe errors or defects (non-recoverable failures) in an effect.\n\n**Details**\n\nThis function is specifically designed to handle and inspect defects, which\nare critical failures in your program, such as unexpected runtime exceptions\nor system-level errors. Unlike normal recoverable errors, defects typically\nindicate serious issues that cannot be addressed through standard error\nhandling.\n\nWhen a defect occurs in an effect, the function you provide to this function\nwill be executed, allowing you to log, monitor, or handle the defect in some\nway. Importantly, this does not alter the main result of the effect. If no\ndefect occurs, the effect behaves as if this function was not used.\n\n**Example**\n\n```ts\nimport { Effect, Console } from "effect"\n\n// Simulate a task that fails with a recoverable error\nconst task1: Effect.Effect<number, string> = Effect.fail("NetworkError")\n\n// tapDefect won\'t log anything because NetworkError is not a defect\nconst tapping1 = Effect.tapDefect(task1, (cause) =>\n  Console.log(`defect: ${cause}`)\n)\n\nEffect.runFork(tapping1)\n// No Output\n\n// Simulate a severe failure in the system\nconst task2: Effect.Effect<number, string> = Effect.dieMessage(\n  "Something went wrong"\n)\n\n// Log the defect using tapDefect\nconst tapping2 = Effect.tapDefect(task2, (cause) =>\n  Console.log(`defect: ${cause}`)\n)\n\nEffect.runFork(tapping2)\n// Output:\n// defect: RuntimeException: Something went wrong\n//   ... stack trace ...\n```',
      examples: [
        {
          code: 'import { Effect, Console } from "effect"\n\n// Simulate a task that fails with a recoverable error\nconst task1: Effect.Effect<number, string> = Effect.fail("NetworkError")\n\n// tapDefect won\'t log anything because NetworkError is not a defect\nconst tapping1 = Effect.tapDefect(task1, (cause) =>\n  Console.log(`defect: ${cause}`)\n)\n\nEffect.runFork(tapping1)\n// No Output\n\n// Simulate a severe failure in the system\nconst task2: Effect.Effect<number, string> = Effect.dieMessage(\n  "Something went wrong"\n)\n\n// Log the defect using tapDefect\nconst tapping2 = Effect.tapDefect(task2, (cause) =>\n  Console.log(`defect: ${cause}`)\n)\n\nEffect.runFork(tapping2)\n// Output:\n// defect: RuntimeException: Something went wrong\n//   ... stack trace ...'
        }
      ],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 19358,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L19358"
    },
    {
      id: "Effect.tapError",
      name: "tapError",
      module: "Effect",
      package: "effect",
      signature: "{ <E, X, E2, R2>(f: (e: NoInfer<E>) => Effect<X, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (e: E) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>; }",
      description: "Execute a side effect on failure without modifying the original effect.",
      documentation: 'Execute a side effect on failure without modifying the original effect.\n\n**Details**\n\nThis function allows you to inspect and react to the failure of an effect by\nexecuting an additional effect. The failure value is passed to the provided\nfunction, enabling you to log it, track it, or perform any other operation.\nImportantly, the original failure remains intact and is re-propagated, so the\neffect\'s behavior is unchanged.\n\nThe side effect you provide is only executed when the effect fails. If the\neffect succeeds, the function is ignored, and the success value is propagated\nas usual.\n\n**Example**\n\n```ts\nimport { Effect, Console } from "effect"\n\n// Simulate a task that fails with an error\nconst task: Effect.Effect<number, string> = Effect.fail("NetworkError")\n\n// Use tapError to log the error message when the task fails\nconst tapping = Effect.tapError(task, (error) =>\n  Console.log(`expected error: ${error}`)\n)\n\nEffect.runFork(tapping)\n// Output:\n// expected error: NetworkError\n```',
      examples: [
        {
          code: 'import { Effect, Console } from "effect"\n\n// Simulate a task that fails with an error\nconst task: Effect.Effect<number, string> = Effect.fail("NetworkError")\n\n// Use tapError to log the error message when the task fails\nconst tapping = Effect.tapError(task, (error) =>\n  Console.log(`expected error: ${error}`)\n)\n\nEffect.runFork(tapping)\n// Output:\n// expected error: NetworkError'
        }
      ],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 19500,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L19500"
    },
    {
      id: "Effect.tapErrorTag",
      name: "tapErrorTag",
      module: "Effect",
      package: "effect",
      signature: '{ <K extends E extends { _tag: string; } ? E["_tag"] : never, E, A1, E1, R1>(k: K, f: (e: NoInfer<Extract<E, { _tag: K; }>>) => Effect<A1, E1, R1>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R1 | R>; <A, E, R, K extends E extends { _tag: string; } ? E["_tag"] : never, A1, E1, R1>(self: Effect<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => Effect<A1, E1, R1>): Effect<A, E | E1, R | R1>; }',
      description: "Inspect errors matching a specific tag without altering the original effect.",
      documentation: 'Inspect errors matching a specific tag without altering the original effect.\n\n**Details**\n\nThis function allows you to inspect and handle specific error types based on\ntheir `_tag` property. It is particularly useful in applications where errors\nare modeled with tagged types (e.g., union types with discriminating tags).\nBy targeting errors with a specific `_tag`, you can log or perform actions on\nthem while leaving the error channel and overall effect unchanged.\n\nIf the error doesn\'t match the specified tag, this function does nothing, and\nthe effect proceeds as usual.\n\n**Example**\n\n```ts\nimport { Effect, Console } from "effect"\n\nclass NetworkError {\n  readonly _tag = "NetworkError"\n  constructor(readonly statusCode: number) {}\n}\n\nclass ValidationError {\n  readonly _tag = "ValidationError"\n  constructor(readonly field: string) {}\n}\n\n// Create a task that fails with a NetworkError\nconst task: Effect.Effect<number, NetworkError | ValidationError> =\n  Effect.fail(new NetworkError(504))\n\n// Use tapErrorTag to inspect only NetworkError types and log the status code\nconst tapping = Effect.tapErrorTag(task, "NetworkError", (error) =>\n  Console.log(`expected error: ${error.statusCode}`)\n)\n\nEffect.runFork(tapping)\n// Output:\n// expected error: 504\n```',
      examples: [
        {
          code: 'import { Effect, Console } from "effect"\n\nclass NetworkError {\n  readonly _tag = "NetworkError"\n  constructor(readonly statusCode: number) {}\n}\n\nclass ValidationError {\n  readonly _tag = "ValidationError"\n  constructor(readonly field: string) {}\n}\n\n// Create a task that fails with a NetworkError\nconst task: Effect.Effect<number, NetworkError | ValidationError> =\n  Effect.fail(new NetworkError(504))\n\n// Use tapErrorTag to inspect only NetworkError types and log the status code\nconst tapping = Effect.tapErrorTag(task, "NetworkError", (error) =>\n  Console.log(`expected error: ${error.statusCode}`)\n)\n\nEffect.runFork(tapping)\n// Output:\n// expected error: 504'
        }
      ],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 19622,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L19622"
    },
    {
      id: "Effect.tapErrorCause",
      name: "tapErrorCause",
      module: "Effect",
      package: "effect",
      signature: "{ <E, X, E2, R2>(f: (cause: Cause<NoInfer<E>>) => Effect<X, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause<E>) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>; }",
      description: "Inspect the complete cause of an error, including failures and defects.",
      documentation: 'Inspect the complete cause of an error, including failures and defects.\n\n**Details**\n\nThis function provides access to the full cause of an error, including both\nrecoverable failures and irrecoverable defects. It allows you to handle, log,\nor monitor specific error causes without modifying the result of the effect.\nThe full `Cause` object encapsulates the error and its contextual\ninformation, making it useful for debugging and understanding failure\nscenarios in complex workflows.\n\nThe effect itself is not modified, and any errors or defects remain in the\nerror channel of the original effect.\n\n**Example**\n\n```ts\nimport { Effect, Console } from "effect"\n\n// Create a task that fails with a NetworkError\nconst task1: Effect.Effect<number, string> = Effect.fail("NetworkError")\n\nconst tapping1 = Effect.tapErrorCause(task1, (cause) =>\n  Console.log(`error cause: ${cause}`)\n)\n\nEffect.runFork(tapping1)\n// Output:\n// error cause: Error: NetworkError\n\n// Simulate a severe failure in the system\nconst task2: Effect.Effect<number, string> = Effect.dieMessage(\n  "Something went wrong"\n)\n\nconst tapping2 = Effect.tapErrorCause(task2, (cause) =>\n  Console.log(`error cause: ${cause}`)\n)\n\nEffect.runFork(tapping2)\n// Output:\n// error cause: RuntimeException: Something went wrong\n//   ... stack trace ...\n```',
      examples: [
        {
          code: 'import { Effect, Console } from "effect"\n\n// Create a task that fails with a NetworkError\nconst task1: Effect.Effect<number, string> = Effect.fail("NetworkError")\n\nconst tapping1 = Effect.tapErrorCause(task1, (cause) =>\n  Console.log(`error cause: ${cause}`)\n)\n\nEffect.runFork(tapping1)\n// Output:\n// error cause: Error: NetworkError\n\n// Simulate a severe failure in the system\nconst task2: Effect.Effect<number, string> = Effect.dieMessage(\n  "Something went wrong"\n)\n\nconst tapping2 = Effect.tapErrorCause(task2, (cause) =>\n  Console.log(`error cause: ${cause}`)\n)\n\nEffect.runFork(tapping2)\n// Output:\n// error cause: RuntimeException: Something went wrong\n//   ... stack trace ...'
        }
      ],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 19775,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L19775"
    },
    {
      id: "Effect.forever",
      name: "forever",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<never, E, R>",
      description: "Repeats an effect indefinitely until an error occurs.",
      documentation: "Repeats an effect indefinitely until an error occurs.\n\n**Details**\n\nThis function executes an effect repeatedly in an infinite loop. Each\niteration is executed sequentially, and the loop continues until the first\nerror occurs. If the effect succeeds, it starts over from the beginning. If\nthe effect fails, the error is propagated, and the loop stops.\n\nBe cautious when using this function, as it will run indefinitely unless an\nerror interrupts it. This makes it suitable for long-running processes or\ncontinuous polling tasks, but you should ensure proper error handling or\ncombine it with other operators like `timeout` or `schedule` to prevent\nunintentional infinite loops.",
      examples: [],
      tags: [
        "Repetition / Recursion"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 19896,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L19896"
    },
    {
      id: "Effect.iterate",
      name: "iterate",
      module: "Effect",
      package: "effect",
      signature: "{ <A, B extends A, R, E>(initial: A, options: { readonly while: Refinement<A, B>; readonly body: (b: B) => Effect<A, E, R>; }): Effect<A, E, R>; <A, R, E>(initial: A, options: { readonly while: Predicate<A>; readonly body: (a: A) => Effect<A, E, R>; }): Effect<A, E, R>; }",
      description: "Repeatedly updates a state through an effectful operation until a condition\nis no longer met.",
      documentation: 'Repeatedly updates a state through an effectful operation until a condition\nis no longer met.\n\n**Details**\n\nThis function provides a way to implement effectful loops, similar to a\n`while` loop in JavaScript.\n\n```ts skip-type-checking\nlet result = initial\n\nwhile (options.while(result)) {\n  result = options.body(result)\n}\n\nreturn result\n```\n\nIt starts with an initial state, checks a\ncondition (`while`), and executes a body operation to update the state if the\ncondition evaluates to `true`. The process repeats until the condition\nreturns `false`.\n\nThe state is passed between iterations, allowing the body operation to modify\nit dynamically. The final state after the loop ends is returned as the result\nof the effect.\n\n**When to Use**\n\nThis is particularly useful for scenarios where looping logic involves\nasynchronous or side-effectful operations, such as polling or iterative\ncomputations that depend on external factors.\n\n**Example** (Effectful Iteration)\n\n```ts\nimport { Effect } from "effect"\n\nconst result = Effect.iterate(\n  // Initial result\n  1,\n  {\n    // Condition to continue iterating\n    while: (result) => result <= 5,\n    // Operation to change the result\n    body: (result) => Effect.succeed(result + 1)\n  }\n)\n\nEffect.runPromise(result).then(console.log)\n// Output: 6\n```',
      examples: [
        {
          title: "Effectful Iteration",
          code: 'import { Effect } from "effect"\n\nconst result = Effect.iterate(\n  // Initial result\n  1,\n  {\n    // Condition to continue iterating\n    while: (result) => result <= 5,\n    // Operation to change the result\n    body: (result) => Effect.succeed(result + 1)\n  }\n)\n\nEffect.runPromise(result).then(console.log)\n// Output: 6'
        }
      ],
      tags: [
        "Looping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 19954,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L19954"
    },
    {
      id: "Effect.loop",
      name: "loop",
      module: "Effect",
      package: "effect",
      signature: "{ <A, B extends A, C, E, R>(initial: A, options: { readonly while: Refinement<A, B>; readonly step: (b: B) => A; readonly body: (b: B) => Effect<C, E, R>; readonly discard?: false; }): Effect<C[], E, R>; <A, C, E, R>(initial: A, options: { readonly while: (a: A) => boolean; readonly step: (a: A) => A; readonly body: (a: A) => Effect<C, E, R>; readonly discard?: false; }): Effect<C[], E, R>; <A, B extends A, C, E, R>(initial: A, options: { readonly while: Refinement<A, B>; readonly step: (b: B) => A; readonly body: (b: B) => Effect<C, E, R>; readonly discard: true; }): Effect<void, E, R>; <A, C, E, R>(initial: A, options: { readonly while: (a: A) => boolean; readonly step: (a: A) => A; readonly body: (a: A) => Effect<C, E, R>; readonly discard: true; }): Effect<void, E, R>; }",
      description: "Repeatedly executes a loop with a state, collecting results or discarding\nthem based on configuration.",
      documentation: 'Repeatedly executes a loop with a state, collecting results or discarding\nthem based on configuration.\n\n**Details**\n\nThis function performs an effectful loop, starting with an initial state and\niterating as long as the `while` condition evaluates to `true`, similar to a\n`while` loop in JavaScript.\n\n```ts skip-type-checking\nlet state = initial\nconst result = []\n\nwhile (options.while(state)) {\n  result.push(options.body(state)) // Perform the effectful operation\n  state = options.step(state) // Update the state\n}\n\nreturn result\n```\n\nDuring each iteration, the `step` function updates the state, and the `body`\neffect is executed.\n\nThe results of the body effect can be collected in an array or discarded\nbased on the `discard` option.\n\n**Discarding Intermediate Results**\n\n- If `discard` is `false` or not provided, the intermediate results are\n  collected into an array and returned as the final result.\n- If `discard` is `true`, the intermediate results are ignored, and the\n  effect returns `void`.\n\n**When to Use**\n\nThis is useful for implementing loops where you need to perform effectful\ncomputations repeatedly, such as processing items in a list, generating\nvalues, or performing iterative updates.\n\n**Example** (Looping with Collected Results)\n\n```ts\nimport { Effect } from "effect"\n\n// A loop that runs 5 times, collecting each iteration\'s result\nconst result = Effect.loop(\n  // Initial state\n  1,\n  {\n    // Condition to continue looping\n    while: (state) => state <= 5,\n    // State update function\n    step: (state) => state + 1,\n    // Effect to be performed on each iteration\n    body: (state) => Effect.succeed(state)\n  }\n)\n\nEffect.runPromise(result).then(console.log)\n// Output: [1, 2, 3, 4, 5]\n```\n\n**Example** (Loop with Discarded Results)\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst result = Effect.loop(\n  // Initial state\n  1,\n  {\n    // Condition to continue looping\n    while: (state) => state <= 5,\n    // State update function\n    step: (state) => state + 1,\n    // Effect to be performed on each iteration\n    body: (state) => Console.log(`Currently at state ${state}`),\n    // Discard intermediate results\n    discard: true\n  }\n)\n\nEffect.runPromise(result).then(console.log)\n// Output:\n// Currently at state 1\n// Currently at state 2\n// Currently at state 3\n// Currently at state 4\n// Currently at state 5\n// undefined\n```',
      examples: [
        {
          title: "Looping with Collected Results",
          code: `import { Effect } from "effect"

// A loop that runs 5 times, collecting each iteration's result
const result = Effect.loop(
  // Initial state
  1,
  {
    // Condition to continue looping
    while: (state) => state <= 5,
    // State update function
    step: (state) => state + 1,
    // Effect to be performed on each iteration
    body: (state) => Effect.succeed(state)
  }
)

Effect.runPromise(result).then(console.log)
// Output: [1, 2, 3, 4, 5]`
        },
        {
          title: "Loop with Discarded Results",
          code: 'import { Effect, Console } from "effect"\n\nconst result = Effect.loop(\n  // Initial state\n  1,\n  {\n    // Condition to continue looping\n    while: (state) => state <= 5,\n    // State update function\n    step: (state) => state + 1,\n    // Effect to be performed on each iteration\n    body: (state) => Console.log(`Currently at state ${state}`),\n    // Discard intermediate results\n    discard: true\n  }\n)\n\nEffect.runPromise(result).then(console.log)\n// Output:\n// Currently at state 1\n// Currently at state 2\n// Currently at state 3\n// Currently at state 4\n// Currently at state 5\n// undefined'
        }
      ],
      tags: [
        "Looping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 20175,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L20175"
    },
    {
      id: "Effect.repeat",
      name: "repeat",
      module: "Effect",
      package: "effect",
      signature: "{ <O extends NoExcessProperties<Repeat.Options<A>, O>, A>(options: O): <E, R>(self: Effect<A, E, R>) => Effect<O extends { schedule: Schedule<infer Out, infer _I, infer _R>; } ? Out : O extends { until: Refinement<A, infer B extends A>; } ? B : A, E | (O extends { while: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never), R | (O extends { schedule: Schedule<infer _O, infer _I, infer R>; } ? R : never) | (O extends { while: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never)>; <B, A, R1>(schedule: Schedule<B, A, R1>): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R1 | R>; <A, E, R, O extends NoExcessProperties<Repeat.Options<A>, O>>(self: Effect<A, E, R>, options: O): Effect<O extends { schedule: Schedule<infer Out, infer _I, infer _R>; } ? Out : O extends { until: Refinement<A, infer B extends A>; } ? B : A, E | (O extends { while: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never), R | (O extends { schedule: Schedule<infer _O, infer _I, infer R>; } ? R : never) | (O extends { while: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never)>; <A, E, R, B, R1>(self: Effect<A, E, R>, schedule: Schedule<B, A, R1>): Effect<B, E, R | R1>; }",
      description: "Repeats an effect based on a specified schedule or until the first failure.",
      documentation: 'Repeats an effect based on a specified schedule or until the first failure.\n\n**Details**\n\nThis function executes an effect repeatedly according to the given schedule.\nEach repetition occurs after the initial execution of the effect, meaning\nthat the schedule determines the number of additional repetitions. For\nexample, using `Schedule.once` will result in the effect being executed twice\n(once initially and once as part of the repetition).\n\nIf the effect succeeds, it is repeated according to the schedule. If it\nfails, the repetition stops immediately, and the failure is returned.\n\nThe schedule can also specify delays between repetitions, making it useful\nfor tasks like retrying operations with backoff, periodic execution, or\nperforming a series of dependent actions.\n\nYou can combine schedules for more advanced repetition logic, such as adding\ndelays, limiting recursions, or dynamically adjusting based on the outcome of\neach execution.\n\n**Example** (Success Example)\n\n```ts\nimport { Effect, Schedule, Console } from "effect"\n\nconst action = Console.log("success")\nconst policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")\nconst program = Effect.repeat(action, policy)\n\nEffect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))\n```\n\n**Example** (Failure Example)\n\n```ts\nimport { Effect, Schedule } from "effect"\n\nlet count = 0\n\n// Define an async effect that simulates an action with possible failures\nconst action = Effect.async<string, string>((resume) => {\n  if (count > 1) {\n    console.log("failure")\n    resume(Effect.fail("Uh oh!"))\n  } else {\n    count++\n    console.log("success")\n    resume(Effect.succeed("yay!"))\n  }\n})\n\nconst policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")\nconst program = Effect.repeat(action, policy)\n\nEffect.runPromiseExit(program).then(console.log)\n```',
      examples: [
        {
          title: "Success Example",
          code: 'import { Effect, Schedule, Console } from "effect"\n\nconst action = Console.log("success")\nconst policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")\nconst program = Effect.repeat(action, policy)\n\nEffect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))'
        },
        {
          title: "Failure Example",
          code: 'import { Effect, Schedule } from "effect"\n\nlet count = 0\n\n// Define an async effect that simulates an action with possible failures\nconst action = Effect.async<string, string>((resume) => {\n  if (count > 1) {\n    console.log("failure")\n    resume(Effect.fail("Uh oh!"))\n  } else {\n    count++\n    console.log("success")\n    resume(Effect.succeed("yay!"))\n  }\n})\n\nconst policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")\nconst program = Effect.repeat(action, policy)\n\nEffect.runPromiseExit(program).then(console.log)'
        }
      ],
      tags: [
        "Repetition / Recursion"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 20686,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L20686"
    },
    {
      id: "Effect.repeatN",
      name: "repeatN",
      module: "Effect",
      package: "effect",
      signature: "{ (n: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, n: number): Effect<A, E, R>; }",
      description: "Repeats an effect a specified number of times or until the first failure.",
      documentation: 'Repeats an effect a specified number of times or until the first failure.\n\n**Details**\n\nThis function executes an effect initially and then repeats it the specified\nnumber of times, as long as it succeeds. For example, calling\n`repeatN(action, 2)` will execute `action` once initially and then repeat it\ntwo additional times if there are no failures.\n\nIf the effect fails during any repetition, the failure is returned, and no\nfurther repetitions are attempted.\n\n**When to Use**\n\nThis function is useful for tasks that need to be retried a fixed number of\ntimes or for performing repeated actions without requiring a schedule.\n\n**Example**\n\n```ts\nimport { Effect, Console } from "effect"\n\nconst action = Console.log("success")\nconst program = Effect.repeatN(action, 2)\n\nEffect.runPromise(program)\n```',
      examples: [
        {
          code: 'import { Effect, Console } from "effect"\n\nconst action = Console.log("success")\nconst program = Effect.repeatN(action, 2)\n\nEffect.runPromise(program)'
        }
      ],
      tags: [
        "Repetition / Recursion"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 20972,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L20972"
    },
    {
      id: "Effect.repeatOrElse",
      name: "repeatOrElse",
      module: "Effect",
      package: "effect",
      signature: "{ <R2, A, B, E, E2, R3>(schedule: Schedule<B, A, R2>, orElse: (error: E, option: Option<B>) => Effect<B, E2, R3>): <R>(self: Effect<A, E, R>) => Effect<B, E2, R2 | R3 | R>; <A, E, R, R2, B, E2, R3>(self: Effect<A, E, R>, schedule: Schedule<B, A, R2>, orElse: (error: E, option: Option<B>) => Effect<B, E2, R3>): Effect<B, E2, R | R2 | R3>; }",
      description: "Repeats an effect with a schedule, handling failures using a custom handler.",
      documentation: 'Repeats an effect with a schedule, handling failures using a custom handler.\n\n**Details**\n\nThis function allows you to execute an effect repeatedly based on a specified\nschedule. If the effect fails at any point, a custom failure handler is\ninvoked. The handler is provided with both the failure value and the output\nof the schedule at the time of failure. This enables advanced error recovery\nor alternative fallback logic while maintaining flexibility in how\nrepetitions are handled.\n\nFor example, using a schedule with `recurs(2)` will allow for two additional\nrepetitions after the initial execution, provided the effect succeeds. If a\nfailure occurs during any iteration, the failure handler is invoked to handle\nthe situation.\n\n**Example**\n\n```ts\nimport { Effect, Schedule } from "effect"\n\nlet count = 0\n\n// Define an async effect that simulates an action with possible failures\nconst action = Effect.async<string, string>((resume) => {\n  if (count > 1) {\n    console.log("failure")\n    resume(Effect.fail("Uh oh!"))\n  } else {\n    count++\n    console.log("success")\n    resume(Effect.succeed("yay!"))\n  }\n})\n\nconst policy = Schedule.addDelay(\n  Schedule.recurs(2), // Repeat for a maximum of 2 times\n  () => "100 millis" // Add a delay of 100 milliseconds between repetitions\n)\n\nconst program = Effect.repeatOrElse(action, policy, () =>\n  Effect.sync(() => {\n    console.log("orElse")\n    return count - 1\n  })\n)\n\nEffect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))\n```',
      examples: [
        {
          code: 'import { Effect, Schedule } from "effect"\n\nlet count = 0\n\n// Define an async effect that simulates an action with possible failures\nconst action = Effect.async<string, string>((resume) => {\n  if (count > 1) {\n    console.log("failure")\n    resume(Effect.fail("Uh oh!"))\n  } else {\n    count++\n    console.log("success")\n    resume(Effect.succeed("yay!"))\n  }\n})\n\nconst policy = Schedule.addDelay(\n  Schedule.recurs(2), // Repeat for a maximum of 2 times\n  () => "100 millis" // Add a delay of 100 milliseconds between repetitions\n)\n\nconst program = Effect.repeatOrElse(action, policy, () =>\n  Effect.sync(() => {\n    console.log("orElse")\n    return count - 1\n  })\n)\n\nEffect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))'
        }
      ],
      tags: [
        "Repetition / Recursion"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21094,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21094"
    },
    {
      id: "Effect.schedule",
      name: "schedule",
      module: "Effect",
      package: "effect",
      signature: "{ <A, R2, Out>(schedule: Schedule<Out, NoInfer<A>, R2>): <E, R>(self: Effect<A, E, R>) => Effect<Out, E, R2 | R>; <A, E, R, R2, Out>(self: Effect<A, E, R>, schedule: Schedule<Out, A, R2>): Effect<Out, E, R | R2>; }",
      description: "Repeats an effect based on a specified schedule.",
      documentation: "Repeats an effect based on a specified schedule.\n\n**Details**\n\nThis function allows you to execute an effect repeatedly according to a given\nschedule. The schedule determines the timing and number of repetitions. Each\nrepetition can also depend on the decision of the schedule, providing\nflexibility for complex workflows. This function does not modify the effect's\nsuccess or failure; it only controls its repetition.\n\nFor example, you can use a schedule that recurs a specific number of times,\nadds delays between repetitions, or customizes repetition behavior based on\nexternal inputs. The effect runs initially and is repeated according to the\nschedule.",
      examples: [],
      tags: [
        "Repetition / Recursion"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21228,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21228"
    },
    {
      id: "Effect.scheduleForked",
      name: "scheduleForked",
      module: "Effect",
      package: "effect",
      signature: "{ <Out, R2>(schedule: Schedule<Out, unknown, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<RuntimeFiber<Out, E>, never, Scope | R2 | R>; <A, E, R, Out, R2>(self: Effect<A, E, R>, schedule: Schedule<Out, unknown, R2>): Effect<RuntimeFiber<Out, E>, never, Scope | R | R2>; }",
      description: "Runs an effect repeatedly on a new fiber according to a given schedule.",
      documentation: "Runs an effect repeatedly on a new fiber according to a given schedule.\n\n**Details**\n\nThis function starts the provided effect on a new fiber and runs it\nrepeatedly based on the specified schedule. The repetitions are managed by\nthe schedule's rules, which define the timing and number of iterations. The\nfiber is attached to the current scope, meaning it is automatically managed\nand cleaned up when the scope is closed.\n\nThe function returns a `RuntimeFiber` that allows you to monitor or interact\nwith the running fiber.\n\n**When to Use**\n\nThis is particularly useful for concurrent execution of scheduled tasks or\nwhen you want to continue processing without waiting for the repetitions to\ncomplete.",
      examples: [],
      tags: [
        "Repetition / Recursion"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21299,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21299"
    },
    {
      id: "Effect.scheduleFrom",
      name: "scheduleFrom",
      module: "Effect",
      package: "effect",
      signature: "{ <R2, In, Out>(initial: In, schedule: Schedule<Out, In, R2>): <E, R>(self: Effect<In, E, R>) => Effect<Out, E, R2 | R>; <In, E, R, R2, Out>(self: Effect<In, E, R>, initial: In, schedule: Schedule<Out, In, R2>): Effect<Out, E, R | R2>; }",
      description: "Runs an effect repeatedly according to a schedule, starting from a specified\ninput value.",
      documentation: "Runs an effect repeatedly according to a schedule, starting from a specified\ninput value.\n\n**Details**\n\nThis function allows you to repeatedly execute an effect based on a schedule.\nThe schedule starts with the given `initial` input value, which is passed to\nthe first execution. Subsequent executions of the effect are controlled by\nthe schedule's rules, using the output of the previous iteration as the input\nfor the next one.\n\nThe returned effect will complete when the schedule ends or the effect fails,\npropagating the error.",
      examples: [],
      tags: [
        "Repetition / Recursion"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21367,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21367"
    },
    {
      id: "Effect.whileLoop",
      name: "whileLoop",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(options: { readonly while: LazyArg<boolean>; readonly body: LazyArg<Effect<A, E, R>>; readonly step: (a: A) => void; }) => Effect<void, E, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Repetition / Recursion"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21411,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21411"
    },
    {
      id: "Effect.getFiberRefs",
      name: "getFiberRefs",
      module: "Effect",
      package: "effect",
      signature: "Effect<FiberRefs, never, never>",
      description: "Returns a collection of all `FiberRef` values for the fiber running this\neffect.",
      documentation: "Returns a collection of all `FiberRef` values for the fiber running this\neffect.",
      examples: [],
      tags: [
        "Fiber Refs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21423,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21423"
    },
    {
      id: "Effect.inheritFiberRefs",
      name: "inheritFiberRefs",
      module: "Effect",
      package: "effect",
      signature: "(childFiberRefs: FiberRefs) => Effect<void, never, never>",
      description: "Inherits values from all `FiberRef` instances into current fiber.",
      documentation: "Inherits values from all `FiberRef` instances into current fiber.",
      examples: [],
      tags: [
        "Fiber Refs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21430,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21430"
    },
    {
      id: "Effect.locally",
      name: "locally",
      module: "Effect",
      package: "effect",
      signature: "{ <A>(self: FiberRef<A>, value: A): <B, E, R>(use: Effect<B, E, R>) => Effect<B, E, R>; <B, E, R, A>(use: Effect<B, E, R>, self: FiberRef<A>, value: A): Effect<B, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Fiber Refs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21435,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21435"
    },
    {
      id: "Effect.locallyWith",
      name: "locallyWith",
      module: "Effect",
      package: "effect",
      signature: "{ <A>(self: FiberRef<A>, f: (a: A) => A): <B, E, R>(use: Effect<B, E, R>) => Effect<B, E, R>; <B, E, R, A>(use: Effect<B, E, R>, self: FiberRef<A>, f: (a: A) => A): Effect<B, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Fiber Refs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21451,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21451"
    },
    {
      id: "Effect.locallyScoped",
      name: "locallyScoped",
      module: "Effect",
      package: "effect",
      signature: "{ <A>(value: A): (self: FiberRef<A>) => Effect<void, never, Scope>; <A>(self: FiberRef<A>, value: A): Effect<void, never, Scope>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Fiber Refs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21467,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21467"
    },
    {
      id: "Effect.locallyScopedWith",
      name: "locallyScopedWith",
      module: "Effect",
      package: "effect",
      signature: "{ <A>(f: (a: A) => A): (self: FiberRef<A>) => Effect<void, never, Scope>; <A>(self: FiberRef<A>, f: (a: A) => A): Effect<void, never, Scope>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Fiber Refs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21483,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21483"
    },
    {
      id: "Effect.patchFiberRefs",
      name: "patchFiberRefs",
      module: "Effect",
      package: "effect",
      signature: "(patch: FiberRefsPatch) => Effect<void, never, never>",
      description: "Applies the specified changes to the `FiberRef` values for the fiber\nrunning this workflow.",
      documentation: "Applies the specified changes to the `FiberRef` values for the fiber\nrunning this workflow.",
      examples: [],
      tags: [
        "Fiber Refs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21502,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21502"
    },
    {
      id: "Effect.setFiberRefs",
      name: "setFiberRefs",
      module: "Effect",
      package: "effect",
      signature: "(fiberRefs: FiberRefs) => Effect<void, never, never>",
      description: "Sets the `FiberRef` values for the fiber running this effect to the values\nin the specified collection of `FiberRef` values.",
      documentation: "Sets the `FiberRef` values for the fiber running this effect to the values\nin the specified collection of `FiberRef` values.",
      examples: [],
      tags: [
        "Fiber Refs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21510,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21510"
    },
    {
      id: "Effect.updateFiberRefs",
      name: "updateFiberRefs",
      module: "Effect",
      package: "effect",
      signature: "(f: (fiberId: Runtime, fiberRefs: FiberRefs) => FiberRefs) => Effect<void, never, never>",
      description: "Updates the `FiberRef` values for the fiber running this effect using the\nspecified function.",
      documentation: "Updates the `FiberRef` values for the fiber running this effect using the\nspecified function.",
      examples: [],
      tags: [
        "Fiber Refs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21518,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21518"
    },
    {
      id: "Effect.isFailure",
      name: "isFailure",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<boolean, never, R>",
      description: "Checks if an effect has failed.",
      documentation: 'Checks if an effect has failed.\n\n**Details**\n\nThis function evaluates whether an effect has resulted in a failure. It\nreturns a boolean value wrapped in an effect, with `true` indicating the\neffect failed and `false` otherwise.\n\nThe resulting effect cannot fail (`never` in the error channel) but retains\nthe context of the original effect.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst failure = Effect.fail("Uh oh!")\n\nconsole.log(Effect.runSync(Effect.isFailure(failure)))\n// Output: true\n\nconst defect = Effect.dieMessage("BOOM!")\n\nEffect.runSync(Effect.isFailure(defect))\n// throws: BOOM!\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst failure = Effect.fail("Uh oh!")\n\nconsole.log(Effect.runSync(Effect.isFailure(failure)))\n// Output: true\n\nconst defect = Effect.dieMessage("BOOM!")\n\nEffect.runSync(Effect.isFailure(defect))\n// throws: BOOM!'
        }
      ],
      tags: [
        "Condition Checking"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21550,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21550"
    },
    {
      id: "Effect.isSuccess",
      name: "isSuccess",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<boolean, never, R>",
      description: "Checks if an effect has succeeded.",
      documentation: "Checks if an effect has succeeded.\n\n**Details**\n\nThis function evaluates whether an effect has resulted in a success. It\nreturns a boolean value wrapped in an effect, with `true` indicating the\neffect succeeded and `false` otherwise.\n\nThe resulting effect cannot fail (`never` in the error channel) but retains\nthe context of the original effect.",
      examples: [],
      tags: [
        "Condition Checking"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21566,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21566"
    },
    {
      id: "Effect.match",
      name: "match",
      module: "Effect",
      package: "effect",
      signature: "{ <E, A2, A, A3>(options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, never, R>; <A, E, R, A2, A3>(self: Effect<A, E, R>, options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): Effect<A2 | A3, never, R>; }",
      description: "Handles both success and failure cases of an effect without performing side\neffects.",
      documentation: 'Handles both success and failure cases of an effect without performing side\neffects.\n\n**Details**\n\n`match` lets you define custom handlers for both success and failure\nscenarios. You provide separate functions to handle each case, allowing you\nto process the result if the effect succeeds, or handle the error if the\neffect fails.\n\n**When to Use**\n\nThis is useful for structuring your code to respond differently to success or\nfailure without triggering side effects.\n\n**Example** (Handling Both Success and Failure Cases)\n\n```ts\nimport { Effect } from "effect"\n\nconst success: Effect.Effect<number, Error> = Effect.succeed(42)\n\nconst program1 = Effect.match(success, {\n  onFailure: (error) => `failure: ${error.message}`,\n  onSuccess: (value) => `success: ${value}`\n})\n\n// Run and log the result of the successful effect\nEffect.runPromise(program1).then(console.log)\n// Output: "success: 42"\n\nconst failure: Effect.Effect<number, Error> = Effect.fail(\n  new Error("Uh oh!")\n)\n\nconst program2 = Effect.match(failure, {\n  onFailure: (error) => `failure: ${error.message}`,\n  onSuccess: (value) => `success: ${value}`\n})\n\n// Run and log the result of the failed effect\nEffect.runPromise(program2).then(console.log)\n// Output: "failure: Uh oh!"\n```',
      examples: [
        {
          title: "Handling Both Success and Failure Cases",
          code: 'import { Effect } from "effect"\n\nconst success: Effect.Effect<number, Error> = Effect.succeed(42)\n\nconst program1 = Effect.match(success, {\n  onFailure: (error) => `failure: ${error.message}`,\n  onSuccess: (value) => `success: ${value}`\n})\n\n// Run and log the result of the successful effect\nEffect.runPromise(program1).then(console.log)\n// Output: "success: 42"\n\nconst failure: Effect.Effect<number, Error> = Effect.fail(\n  new Error("Uh oh!")\n)\n\nconst program2 = Effect.match(failure, {\n  onFailure: (error) => `failure: ${error.message}`,\n  onSuccess: (value) => `success: ${value}`\n})\n\n// Run and log the result of the failed effect\nEffect.runPromise(program2).then(console.log)\n// Output: "failure: Uh oh!"'
        }
      ],
      tags: [
        "Matching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21618,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21618"
    },
    {
      id: "Effect.matchCause",
      name: "matchCause",
      module: "Effect",
      package: "effect",
      signature: "{ <E, A2, A, A3>(options: { readonly onFailure: (cause: Cause<E>) => A2; readonly onSuccess: (a: A) => A3; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, never, R>; <A, E, R, A2, A3>(self: Effect<A, E, R>, options: { readonly onFailure: (cause: Cause<E>) => A2; readonly onSuccess: (a: A) => A3; }): Effect<A2 | A3, never, R>; }",
      description: "Handles failures by matching the cause of failure.",
      documentation: 'Handles failures by matching the cause of failure.\n\n**Details**\n\nThe `matchCause` function allows you to handle failures with access to the\nfull cause of the failure within a fiber.\n\n**When to Use**\n\nThis is useful for differentiating between different types of errors, such as\nregular failures, defects, or interruptions. You can provide specific\nhandling logic for each failure type based on the cause.\n\n**Example** (Handling Different Failure Causes)\n\n```ts\nimport { Effect } from "effect"\n\nconst task: Effect.Effect<number, Error> = Effect.die("Uh oh!")\n\nconst program = Effect.matchCause(task, {\n  onFailure: (cause) => {\n    switch (cause._tag) {\n      case "Fail":\n        // Handle standard failure\n        return `Fail: ${cause.error.message}`\n      case "Die":\n        // Handle defects (unexpected errors)\n        return `Die: ${cause.defect}`\n      case "Interrupt":\n        // Handle interruption\n        return `${cause.fiberId} interrupted!`\n    }\n    // Fallback for other causes\n    return "failed due to other causes"\n  },\n  onSuccess: (value) =>\n    // task completes successfully\n    `succeeded with ${value} value`\n})\n\nEffect.runPromise(program).then(console.log)\n// Output: "Die: Uh oh!"\n```',
      examples: [
        {
          title: "Handling Different Failure Causes",
          code: 'import { Effect } from "effect"\n\nconst task: Effect.Effect<number, Error> = Effect.die("Uh oh!")\n\nconst program = Effect.matchCause(task, {\n  onFailure: (cause) => {\n    switch (cause._tag) {\n      case "Fail":\n        // Handle standard failure\n        return `Fail: ${cause.error.message}`\n      case "Die":\n        // Handle defects (unexpected errors)\n        return `Die: ${cause.defect}`\n      case "Interrupt":\n        // Handle interruption\n        return `${cause.fiberId} interrupted!`\n    }\n    // Fallback for other causes\n    return "failed due to other causes"\n  },\n  onSuccess: (value) =>\n    // task completes successfully\n    `succeeded with ${value} value`\n})\n\nEffect.runPromise(program).then(console.log)\n// Output: "Die: Uh oh!"'
        }
      ],
      tags: [
        "Matching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21783,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21783"
    },
    {
      id: "Effect.matchCauseEffect",
      name: "matchCauseEffect",
      module: "Effect",
      package: "effect",
      signature: "{ <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (cause: Cause<E>) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Effect<A, E, R>, options: { readonly onFailure: (cause: Cause<E>) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): Effect<A2 | A3, E2 | E3, R | R2 | R3>; }",
      description: "/\n * Handles failures with access to the cause and allows performing side effects.\n *\n *",
      documentation: '/**\n * Handles failures with access to the cause and allows performing side effects.\n *\n * **Details**\n *\n * The `matchCauseEffect` function works similarly to {@link matchCause}, but it\n * also allows you to perform additional side effects based on the failure\n * cause. This function provides access to the complete cause of the failure,\n * making it possible to differentiate between various failure types, and allows\n * you to respond accordingly while performing side effects (like logging or\n * other operations).\n *\n * **Example** (Handling Different Failure Causes with Side Effects)\n *\n * ```ts\n * import { Effect, Console } from "effect"\n *\n * const task: Effect.Effect<number, Error> = Effect.die("Uh oh!")\n *\n * const program = Effect.matchCauseEffect(task, {\n *   onFailure: (cause) => {\n *     switch (cause._tag) {\n *       case "Fail":\n *         // Handle standard failure with a logged message\n *         return Console.log(`Fail: ${cause.error.message}`)\n *       case "Die":\n *         // Handle defects (unexpected errors) by logging the defect\n *         return Console.log(`Die: ${cause.defect}`)\n *       case "Interrupt":\n *         // Handle interruption and log the fiberId that was interrupted\n *         return Console.log(`${cause.fiberId} interrupted!`)\n *     }\n *     // Fallback for other causes\n *     return Console.log("failed due to other causes")\n *   },\n *   onSuccess: (value) =>\n *     // Log success if the task completes successfully\n *     Console.log(`succeeded with ${value} value`)\n * })\n *\n * Effect.runPromise(program)\n * // Output: "Die: Uh oh!"\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect, Console } from "effect"\n *\n * const task: Effect.Effect<number, Error> = Effect.die("Uh oh!")\n *\n * const program = Effect.matchCauseEffect(task, {\n *   onFailure: (cause) => {\n *     switch (cause._tag) {\n *       case "Fail":\n *         // Handle standard failure with a logged message\n *         return Console.log(`Fail: ${cause.error.message}`)\n *       case "Die":\n *         // Handle defects (unexpected errors) by logging the defect\n *         return Console.log(`Die: ${cause.defect}`)\n *       case "Interrupt":\n *         // Handle interruption and log the fiberId that was interrupted\n *         return Console.log(`${cause.fiberId} interrupted!`)\n *     }\n *     // Fallback for other causes\n *     return Console.log("failed due to other causes")\n *   },\n *   onSuccess: (value) =>\n *     // Log success if the task completes successfully\n *     Console.log(`succeeded with ${value} value`)\n * })\n *\n * Effect.runPromise(program)\n * // Output: "Die: Uh oh!"\n *'
        }
      ],
      tags: [
        "Matching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 21949,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21949"
    },
    {
      id: "Effect.matchEffect",
      name: "matchEffect",
      module: "Effect",
      package: "effect",
      signature: "{ <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (e: E) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Effect<A, E, R>, options: { readonly onFailure: (e: E) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): Effect<A2 | A3, E2 | E3, R | R2 | R3>; }",
      description: "/\n * Handles both success and failure cases of an effect, allowing for additional\n * side effects.\n *\n *",
      documentation: '/**\n * Handles both success and failure cases of an effect, allowing for additional\n * side effects.\n *\n * **Details**\n *\n * The `matchEffect` function is similar to {@link match}, but it enables you to\n * perform side effects in the handlers for both success and failure outcomes.\n *\n * **When to Use**\n *\n * This is useful when you need to execute additional actions, like logging or\n * notifying users, based on whether an effect succeeds or fails.\n *\n * **Example** (Handling Both Success and Failure Cases with Side Effects)\n *\n * ```ts\n * import { Effect } from "effect"\n *\n * const success: Effect.Effect<number, Error> = Effect.succeed(42)\n * const failure: Effect.Effect<number, Error> = Effect.fail(\n *   new Error("Uh oh!")\n * )\n *\n * const program1 = Effect.matchEffect(success, {\n *   onFailure: (error) =>\n *     Effect.succeed(`failure: ${error.message}`).pipe(\n *       Effect.tap(Effect.log)\n *     ),\n *   onSuccess: (value) =>\n *     Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))\n * })\n *\n * console.log(Effect.runSync(program1))\n * // Output:\n * // timestamp=... level=INFO fiber=#0 message="success: 42"\n * // success: 42\n *\n * const program2 = Effect.matchEffect(failure, {\n *   onFailure: (error) =>\n *     Effect.succeed(`failure: ${error.message}`).pipe(\n *       Effect.tap(Effect.log)\n *     ),\n *   onSuccess: (value) =>\n *     Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))\n * })\n *\n * console.log(Effect.runSync(program2))\n * // Output:\n * // timestamp=... level=INFO fiber=#1 message="failure: Uh oh!"\n * // failure: Uh oh!\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect } from "effect"\n *\n * const success: Effect.Effect<number, Error> = Effect.succeed(42)\n * const failure: Effect.Effect<number, Error> = Effect.fail(\n *   new Error("Uh oh!")\n * )\n *\n * const program1 = Effect.matchEffect(success, {\n *   onFailure: (error) =>\n *     Effect.succeed(`failure: ${error.message}`).pipe(\n *       Effect.tap(Effect.log)\n *     ),\n *   onSuccess: (value) =>\n *     Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))\n * })\n *\n * console.log(Effect.runSync(program1))\n * // Output:\n * // timestamp=... level=INFO fiber=#0 message="success: 42"\n * // success: 42\n *\n * const program2 = Effect.matchEffect(failure, {\n *   onFailure: (error) =>\n *     Effect.succeed(`failure: ${error.message}`).pipe(\n *       Effect.tap(Effect.log)\n *     ),\n *   onSuccess: (value) =>\n *     Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))\n * })\n *\n * console.log(Effect.runSync(program2))\n * // Output:\n * // timestamp=... level=INFO fiber=#1 message="failure: Uh oh!"\n * // failure: Uh oh!\n *'
        }
      ],
      tags: [
        "Matching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22118,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22118"
    },
    {
      id: "Effect.log",
      name: "log",
      module: "Effect",
      package: "effect",
      signature: "(...message: readonly any[]) => Effect<void, never, never>",
      description: "Logs one or more messages or error causes at the current log level.",
      documentation: 'Logs one or more messages or error causes at the current log level.\n\n**Details**\n\nThis function provides a simple way to log messages or error causes during\nthe execution of your effects. By default, logs are recorded at the `INFO`\nlevel, but this can be adjusted using other logging utilities\n(`Logger.withMinimumLogLevel`). Multiple items, including `Cause` instances,\ncan be logged in a single call. When logging `Cause` instances, detailed\nerror information is included in the log output.\n\nThe log output includes useful metadata like the current timestamp, log\nlevel, and fiber ID, making it suitable for debugging and tracking purposes.\nThis function does not interrupt or alter the effect\'s execution flow.\n\n**Example**\n\n```ts\nimport { Cause, Effect } from "effect"\n\nconst program = Effect.log(\n  "message1",\n  "message2",\n  Cause.die("Oh no!"),\n  Cause.die("Oh uh!")\n)\n\nEffect.runFork(program)\n// Output:\n// timestamp=... level=INFO fiber=#0 message=message1 message=message2 cause="Error: Oh no!\n// Error: Oh uh!"\n```',
      examples: [
        {
          code: 'import { Cause, Effect } from "effect"\n\nconst program = Effect.log(\n  "message1",\n  "message2",\n  Cause.die("Oh no!"),\n  Cause.die("Oh uh!")\n)\n\nEffect.runFork(program)\n// Output:\n// timestamp=... level=INFO fiber=#0 message=message1 message=message2 cause="Error: Oh no!\n// Error: Oh uh!"'
        }
      ],
      tags: [
        "Logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22283,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22283"
    },
    {
      id: "Effect.logWithLevel",
      name: "logWithLevel",
      module: "Effect",
      package: "effect",
      signature: "(level: LogLevel, ...message: readonly any[]) => Effect<void, never, never>",
      description: "Logs messages or error causes at a specified log level.",
      documentation: 'Logs messages or error causes at a specified log level.\n\n**Details**\n\nThis function allows you to log one or more messages or error causes while\nspecifying the desired log level (e.g., DEBUG, INFO, ERROR). It provides\nflexibility in categorizing logs based on their importance or severity,\nmaking it easier to filter logs during debugging or production monitoring.\n\n**Example**\n\n```ts\nimport { Cause, Effect, LogLevel } from "effect"\n\nconst program = Effect.logWithLevel(\n  LogLevel.Error,\n  "Critical error encountered",\n  Cause.die("System failure!")\n)\n\nEffect.runFork(program)\n// Output:\n// timestamp=... level=ERROR fiber=#0 message=Critical error encountered cause="Error: System failure!"\n```',
      examples: [
        {
          code: 'import { Cause, Effect, LogLevel } from "effect"\n\nconst program = Effect.logWithLevel(\n  LogLevel.Error,\n  "Critical error encountered",\n  Cause.die("System failure!")\n)\n\nEffect.runFork(program)\n// Output:\n// timestamp=... level=ERROR fiber=#0 message=Critical error encountered cause="Error: System failure!"'
        }
      ],
      tags: [
        "Logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22313,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22313"
    },
    {
      id: "Effect.logTrace",
      name: "logTrace",
      module: "Effect",
      package: "effect",
      signature: "(...message: readonly any[]) => Effect<void, never, never>",
      description: "Logs messages at the TRACE log level.",
      documentation: 'Logs messages at the TRACE log level.\n\n**Details**\n\nThis function logs the specified messages at the TRACE level. TRACE logs are\ntypically used for very detailed diagnostic information. These messages are\nnot displayed by default. To view them, you must adjust the logging\nconfiguration by setting the minimum log level to `LogLevel.Trace` using\n`Logger.withMinimumLogLevel`.\n\n**Example**\n\n```ts\nimport { Effect, Logger, LogLevel } from "effect"\n\nconst program = Effect.logTrace("message1").pipe(Logger.withMinimumLogLevel(LogLevel.Trace))\n\nEffect.runFork(program)\n// timestamp=... level=TRACE fiber=#0 message=message1\n```',
      examples: [
        {
          code: 'import { Effect, Logger, LogLevel } from "effect"\n\nconst program = Effect.logTrace("message1").pipe(Logger.withMinimumLogLevel(LogLevel.Trace))\n\nEffect.runFork(program)\n// timestamp=... level=TRACE fiber=#0 message=message1'
        }
      ],
      tags: [
        "Logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22339,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22339"
    },
    {
      id: "Effect.logDebug",
      name: "logDebug",
      module: "Effect",
      package: "effect",
      signature: "(...message: readonly any[]) => Effect<void, never, never>",
      description: "Logs messages at the DEBUG log level.",
      documentation: 'Logs messages at the DEBUG log level.\n\n**Details**\n\nThis function logs messages at the DEBUG level, which is typically used for\ndiagnosing application behavior during development. DEBUG messages provide\nless detailed information than TRACE logs but are still not shown by default.\nTo view these logs, adjust the log level using `Logger.withMinimumLogLevel`.\n\n**Example**\n\n```ts\nimport { Effect, Logger, LogLevel } from "effect"\n\nconst program = Effect.logDebug("message1").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))\n\nEffect.runFork(program)\n// timestamp=... level=DEBUG fiber=#0 message=message1\n```',
      examples: [
        {
          code: 'import { Effect, Logger, LogLevel } from "effect"\n\nconst program = Effect.logDebug("message1").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))\n\nEffect.runFork(program)\n// timestamp=... level=DEBUG fiber=#0 message=message1'
        }
      ],
      tags: [
        "Logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22364,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22364"
    },
    {
      id: "Effect.logInfo",
      name: "logInfo",
      module: "Effect",
      package: "effect",
      signature: "(...message: readonly any[]) => Effect<void, never, never>",
      description: "Logs messages at the INFO log level.",
      documentation: "Logs messages at the INFO log level.\n\n**Details**\n\nThis function logs messages at the INFO level, suitable for general\napplication events or operational messages. INFO logs are shown by default\nand are commonly used for highlighting normal, non-error operations.",
      examples: [],
      tags: [
        "Logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22377,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22377"
    },
    {
      id: "Effect.logWarning",
      name: "logWarning",
      module: "Effect",
      package: "effect",
      signature: "(...message: readonly any[]) => Effect<void, never, never>",
      description: "Logs messages at the WARNING log level.",
      documentation: "Logs messages at the WARNING log level.\n\n**Details**\n\nThis function logs messages at the WARNING level, suitable for highlighting\npotential issues that are not errors but may require attention. These\nmessages indicate that something unexpected occurred or might lead to errors\nin the future.",
      examples: [],
      tags: [
        "Logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22391,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22391"
    },
    {
      id: "Effect.logError",
      name: "logError",
      module: "Effect",
      package: "effect",
      signature: "(...message: readonly any[]) => Effect<void, never, never>",
      description: "Logs messages at the ERROR log level.",
      documentation: "Logs messages at the ERROR log level.\n\n**Details**\n\nThis function logs messages at the ERROR level, suitable for reporting\napplication errors or failures. These logs are typically used for unexpected\nissues that need immediate attention.",
      examples: [],
      tags: [
        "Logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22404,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22404"
    },
    {
      id: "Effect.logFatal",
      name: "logFatal",
      module: "Effect",
      package: "effect",
      signature: "(...message: readonly any[]) => Effect<void, never, never>",
      description: "Logs messages at the FATAL log level.",
      documentation: "Logs messages at the FATAL log level.\n\n**Details**\n\nThis function logs messages at the FATAL level, suitable for reporting\ncritical errors that cause the application to terminate or stop functioning.\nThese logs are typically used for unrecoverable errors that require immediate\nattention.",
      examples: [],
      tags: [
        "Logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22418,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22418"
    },
    {
      id: "Effect.withLogSpan",
      name: "withLogSpan",
      module: "Effect",
      package: "effect",
      signature: "{ (label: string): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, label: string): Effect<A, E, R>; }",
      description: "Adds a log span to an effect for tracking and logging its execution duration.",
      documentation: 'Adds a log span to an effect for tracking and logging its execution duration.\n\n**Details**\n\nThis function wraps an effect with a log span, providing performance\nmonitoring and debugging capabilities. The log span tracks the duration of\nthe wrapped effect and logs it with the specified label. This is particularly\nuseful when analyzing time-sensitive operations or understanding the\nexecution time of specific tasks in your application.\n\nThe logged output will include the label and the total time taken for the\noperation. The span information is included in the log metadata, making it\neasy to trace performance metrics in logs.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.sleep("1 second")\n  yield* Effect.log("The job is finished!")\n}).pipe(Effect.withLogSpan("myspan"))\n\nEffect.runFork(program)\n// timestamp=... level=INFO fiber=#0 message="The job is finished!" myspan=1011ms\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.sleep("1 second")\n  yield* Effect.log("The job is finished!")\n}).pipe(Effect.withLogSpan("myspan"))\n\nEffect.runFork(program)\n// timestamp=... level=INFO fiber=#0 message="The job is finished!" myspan=1011ms'
        }
      ],
      tags: [
        "Logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22451,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22451"
    },
    {
      id: "Effect.annotateLogs",
      name: "annotateLogs",
      module: "Effect",
      package: "effect",
      signature: "{ (key: string, value: unknown): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; (values: Record<string, unknown>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, key: string, value: unknown): Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, values: Record<string, unknown>): Effect<A, E, R>; }",
      description: "Adds custom annotations to log entries generated within an effect.",
      documentation: 'Adds custom annotations to log entries generated within an effect.\n\n**Details**\n\nThis function allows you to enhance log messages by appending additional\ncontext in the form of key-value pairs. These annotations are included in\nevery log message created during the execution of the effect, making the logs\nmore informative and easier to trace.\n\nThe annotations can be specified as a single key-value pair or as a record of\nmultiple key-value pairs. This is particularly useful for tracking\noperations, debugging, or associating specific metadata with logs for better\nobservability.\n\nThe annotated key-value pairs will appear alongside the log message in the\noutput.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log("message1")\n  yield* Effect.log("message2")\n}).pipe(Effect.annotateLogs("taskId", "1234")) // Annotation as key/value pair\n\nEffect.runFork(program)\n// timestamp=... level=INFO fiber=#0 message=message1 taskId=1234\n// timestamp=... level=INFO fiber=#0 message=message2 taskId=1234\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log("message1")\n  yield* Effect.log("message2")\n}).pipe(Effect.annotateLogs("taskId", "1234")) // Annotation as key/value pair\n\nEffect.runFork(program)\n// timestamp=... level=INFO fiber=#0 message=message1 taskId=1234\n// timestamp=... level=INFO fiber=#0 message=message2 taskId=1234'
        }
      ],
      tags: [
        "Logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22557,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22557"
    },
    {
      id: "Effect.annotateLogsScoped",
      name: "annotateLogsScoped",
      module: "Effect",
      package: "effect",
      signature: "{ (key: string, value: unknown): Effect<void, never, Scope>; (values: Record<string, unknown>): Effect<void, never, Scope>; }",
      description: "Adds log annotations with a limited scope to enhance contextual logging.",
      documentation: 'Adds log annotations with a limited scope to enhance contextual logging.\n\n**Details**\n\nThis function allows you to apply key-value annotations to log entries\ngenerated within a specific scope of your effect computations. The\nannotations are restricted to the defined `Scope`, ensuring that they are\nonly applied to logs produced during that scope. Once the scope ends, the\nannotations are automatically removed, making it easier to manage\ncontext-specific logging without affecting other parts of your application.\n\nThe annotations can be provided as a single key-value pair or as a record of\nmultiple key-value pairs. This flexibility enables fine-grained control over\nthe additional metadata included in logs for specific tasks or operations.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log("no annotations")\n  yield* Effect.annotateLogsScoped({ key: "value" })\n  yield* Effect.log("message1") // Annotation is applied to this log\n  yield* Effect.log("message2") // Annotation is applied to this log\n}).pipe(Effect.scoped, Effect.andThen(Effect.log("no annotations again")))\n\nEffect.runFork(program)\n// timestamp=... level=INFO fiber=#0 message="no annotations"\n// timestamp=... level=INFO fiber=#0 message=message1 key=value\n// timestamp=... level=INFO fiber=#0 message=message2 key=value\n// timestamp=... level=INFO fiber=#0 message="no annotations again"\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log("no annotations")\n  yield* Effect.annotateLogsScoped({ key: "value" })\n  yield* Effect.log("message1") // Annotation is applied to this log\n  yield* Effect.log("message2") // Annotation is applied to this log\n}).pipe(Effect.scoped, Effect.andThen(Effect.log("no annotations again")))\n\nEffect.runFork(program)\n// timestamp=... level=INFO fiber=#0 message="no annotations"\n// timestamp=... level=INFO fiber=#0 message=message1 key=value\n// timestamp=... level=INFO fiber=#0 message=message2 key=value\n// timestamp=... level=INFO fiber=#0 message="no annotations again"'
        }
      ],
      tags: [
        "Logging"
      ],
      since: "3.1.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22755,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22755"
    },
    {
      id: "Effect.logAnnotations",
      name: "logAnnotations",
      module: "Effect",
      package: "effect",
      signature: "Effect<HashMap<string, unknown>, never, never>",
      description: "Retrieves the current log annotations for the current scope.",
      documentation: "Retrieves the current log annotations for the current scope.\n\n**Details**\n\nThis function provides access to the log annotations associated with the\ncurrent scope. Log annotations are key-value pairs that provide additional\ncontext to log entries. They are often used to add metadata such as tags,\nidentifiers, or extra debugging information to logs.\n\nBy using this function, you can inspect or utilize the annotations applied to\nthe current scope, making it easier to trace and debug specific sections of\nyour application.",
      examples: [],
      tags: [
        "Logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22859,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22859"
    },
    {
      id: "Effect.withUnhandledErrorLogLevel",
      name: "withUnhandledErrorLogLevel",
      module: "Effect",
      package: "effect",
      signature: "{ (level: Option<LogLevel>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, level: Option<LogLevel>): Effect<A, E, R>; }",
      description: "Configures whether child fibers will log unhandled errors and at what log\nlevel.",
      documentation: 'Configures whether child fibers will log unhandled errors and at what log\nlevel.\n\n**Details**\n\nThis function allows you to control whether unhandled errors from child\nfibers are logged and to specify the log level for these errors. By default,\nunhandled errors are reported via the logger. However, using this function,\nyou can choose to suppress these logs by passing `Option.none` or adjust the\nlog level to a specific severity, such as `Error`, `Warning`, or `Info`.\n\nThis configuration is scoped to the effect it is applied to, meaning the\nchanges only apply to the child fibers created within that effect\'s context.\nIt is especially useful when you want to reduce noise in logs or prioritize\ncertain types of errors.\n\n**Example**\n\n```ts\nimport { Effect, Fiber, LogLevel, Option } from "effect"\n\nconst program = Effect.gen(function*() {\n  const fiber = yield* Effect.fork(Effect.fail("Unhandled error!"))\n  yield* Fiber.join(fiber)\n})\n\nEffect.runFork(program.pipe(Effect.withUnhandledErrorLogLevel(Option.some(LogLevel.Error))))\n// Output:\n// timestamp=... level=ERROR fiber=#1 message="Fiber terminated with an unhandled error" cause="Error: Unhandled error!"\n```',
      examples: [
        {
          code: 'import { Effect, Fiber, LogLevel, Option } from "effect"\n\nconst program = Effect.gen(function*() {\n  const fiber = yield* Effect.fork(Effect.fail("Unhandled error!"))\n  yield* Fiber.join(fiber)\n})\n\nEffect.runFork(program.pipe(Effect.withUnhandledErrorLogLevel(Option.some(LogLevel.Error))))\n// Output:\n// timestamp=... level=ERROR fiber=#1 message="Fiber terminated with an unhandled error" cause="Error: Unhandled error!"'
        }
      ],
      tags: [
        "Logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 22895,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L22895"
    },
    {
      id: "Effect.whenLogLevel",
      name: "whenLogLevel",
      module: "Effect",
      package: "effect",
      signature: '{ (level: LogLevel | "All" | "Fatal" | "Error" | "Warning" | "Info" | "Debug" | "Trace" | "None"): <A, E, R>(self: Effect<A, E, R>) => Effect<Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, level: LogLevel | "All" | "Fatal" | "Error" | "Warning" | "Info" | "Debug" | "Trace" | "None"): Effect<Option<A>, E, R>; }',
      description: "Conditionally executes an effect based on the specified log level and currently enabled log level.",
      documentation: 'Conditionally executes an effect based on the specified log level and currently enabled log level.\n\n**Details**\n\nThis function runs the provided effect only if the specified log level is\nenabled. If the log level is enabled, the effect is executed and its result\nis wrapped in `Some`. If the log level is not enabled, the effect is not\nexecuted and `None` is returned.\n\nThis function is useful for conditionally executing logging-related effects\nor other operations that depend on the current log level configuration.\n\n**Example**\n\n```ts\nimport { Effect, Logger, LogLevel } from "effect"\n\nconst program = Effect.gen(function* () {\n  yield* Effect.whenLogLevel(Effect.logTrace("message1"), LogLevel.Trace); // returns `None`\n  yield* Effect.whenLogLevel(Effect.logDebug("message2"), LogLevel.Debug); // returns `Some`\n}).pipe(Logger.withMinimumLogLevel(LogLevel.Debug));\n\nEffect.runFork(program)\n// timestamp=... level=DEBUG fiber=#0 message=message2\n```',
      examples: [
        {
          code: 'import { Effect, Logger, LogLevel } from "effect"\n\nconst program = Effect.gen(function* () {\n  yield* Effect.whenLogLevel(Effect.logTrace("message1"), LogLevel.Trace); // returns `None`\n  yield* Effect.whenLogLevel(Effect.logDebug("message2"), LogLevel.Debug); // returns `Some`\n}).pipe(Logger.withMinimumLogLevel(LogLevel.Debug));\n\nEffect.runFork(program)\n// timestamp=... level=DEBUG fiber=#0 message=message2'
        }
      ],
      tags: [
        "Logging"
      ],
      since: "3.13.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23001,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23001"
    },
    {
      id: "Effect.orDie",
      name: "orDie",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, never, R>",
      description: "Converts an effect's failure into a fiber termination, removing the error\nfrom the effect's type.",
      documentation: 'Converts an effect\'s failure into a fiber termination, removing the error\nfrom the effect\'s type.\n\n**Details**\n\nThe `orDie` function is used when you encounter errors that you do not want\nto handle or recover from. It removes the error type from the effect and\nensures that any failure will terminate the fiber. This is useful for\npropagating failures as defects, signaling that they should not be handled\nwithin the effect.\n\n**When to Use*\n\nUse `orDie` when failures should be treated as unrecoverable defects and no\nerror handling is required.\n\n**Example** (Propagating an Error as a Defect)\n\n```ts\nimport { Effect } from "effect"\n\nconst divide = (a: number, b: number) =>\n  b === 0\n    ? Effect.fail(new Error("Cannot divide by zero"))\n    : Effect.succeed(a / b)\n\n//      \u250C\u2500\u2500\u2500 Effect<number, never, never>\n//      \u25BC\nconst program = Effect.orDie(divide(1, 0))\n\nEffect.runPromise(program).catch(console.error)\n// Output:\n// (FiberFailure) Error: Cannot divide by zero\n//   ...stack trace...\n```',
      examples: [
        {
          title: "Propagating an Error as a Defect",
          code: 'import { Effect } from "effect"\n\nconst divide = (a: number, b: number) =>\n  b === 0\n    ? Effect.fail(new Error("Cannot divide by zero"))\n    : Effect.succeed(a / b)\n\n//      \u250C\u2500\u2500\u2500 Effect<number, never, never>\n//      \u25BC\nconst program = Effect.orDie(divide(1, 0))\n\nEffect.runPromise(program).catch(console.error)\n// Output:\n// (FiberFailure) Error: Cannot divide by zero\n//   ...stack trace...'
        }
      ],
      tags: [
        "Converting Failures to Defects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23111,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23111"
    },
    {
      id: "Effect.orDieWith",
      name: "orDieWith",
      module: "Effect",
      package: "effect",
      signature: "{ <E>(f: (error: E) => unknown): <A, R>(self: Effect<A, E, R>) => Effect<A, never, R>; <A, E, R>(self: Effect<A, E, R>, f: (error: E) => unknown): Effect<A, never, R>; }",
      description: "/\n * Converts an effect's failure into a fiber termination with a custom error.\n *\n *",
      documentation: '/**\n * Converts an effect\'s failure into a fiber termination with a custom error.\n *\n * **Details**\n *\n * The `orDieWith` function behaves like {@link orDie}, but it allows you to provide a mapping\n * function to transform the error before terminating the fiber. This is useful for cases where\n * you want to include a more detailed or user-friendly error when the failure is propagated\n * as a defect.\n *\n * **When to Use**\n *\n * Use `orDieWith` when failures should terminate the fiber as defects, and you want to customize\n * the error for clarity or debugging purposes.\n *\n * **Example** (Customizing Defect)\n *\n * ```ts\n * import { Effect } from "effect"\n *\n * const divide = (a: number, b: number) =>\n *   b === 0\n *     ? Effect.fail(new Error("Cannot divide by zero"))\n *     : Effect.succeed(a / b)\n *\n * //      \u250C\u2500\u2500\u2500 Effect<number, never, never>\n * //      \u25BC\n * const program = Effect.orDieWith(\n *   divide(1, 0),\n *   (error) => new Error(`defect: ${error.message}`)\n * )\n *\n * Effect.runPromise(program).catch(console.error)\n * // Output:\n * // (FiberFailure) Error: defect: Cannot divide by zero\n * //   ...stack trace...\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect } from "effect"\n *\n * const divide = (a: number, b: number) =>\n *   b === 0\n *     ? Effect.fail(new Error("Cannot divide by zero"))\n *     : Effect.succeed(a / b)\n *\n * //      \u250C\u2500\u2500\u2500 Effect<number, never, never>\n * //      \u25BC\n * const program = Effect.orDieWith(\n *   divide(1, 0),\n *   (error) => new Error(`defect: ${error.message}`)\n * )\n *\n * Effect.runPromise(program).catch(console.error)\n * // Output:\n * // (FiberFailure) Error: defect: Cannot divide by zero\n * //   ...stack trace...\n *'
        }
      ],
      tags: [
        "Converting Failures to Defects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23155,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23155"
    },
    {
      id: "Effect.orElse",
      name: "orElse",
      module: "Effect",
      package: "effect",
      signature: "{ <A2, E2, R2>(that: LazyArg<Effect<A2, E2, R2>>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: LazyArg<Effect<A2, E2, R2>>): Effect<A | A2, E2, R | R2>; }",
      description: "Attempts one effect, and if it fails, falls back to another effect.",
      documentation: 'Attempts one effect, and if it fails, falls back to another effect.\n\n**Details**\n\nThis function allows you to try executing an effect, and if it fails\n(produces an error), a fallback effect is executed instead. The fallback\neffect is defined as a lazy argument, meaning it will only be evaluated if\nthe first effect fails. This provides a way to recover from errors by\nspecifying an alternative path of execution.\n\nThe error type of the resulting effect will be that of the fallback effect,\nas the first effect\'s error is replaced when the fallback is executed.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst success = Effect.succeed("success")\nconst failure = Effect.fail("failure")\nconst fallback = Effect.succeed("fallback")\n\n// Try the success effect first, fallback is not used\nconst program1 = Effect.orElse(success, () => fallback)\nconsole.log(Effect.runSync(program1))\n// Output: "success"\n\n// Try the failure effect first, fallback is used\nconst program2 = Effect.orElse(failure, () => fallback)\nconsole.log(Effect.runSync(program2))\n// Output: "fallback"\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst success = Effect.succeed("success")\nconst failure = Effect.fail("failure")\nconst fallback = Effect.succeed("fallback")\n\n// Try the success effect first, fallback is not used\nconst program1 = Effect.orElse(success, () => fallback)\nconsole.log(Effect.runSync(program1))\n// Output: "success"\n\n// Try the failure effect first, fallback is used\nconst program2 = Effect.orElse(failure, () => fallback)\nconsole.log(Effect.runSync(program2))\n// Output: "fallback"'
        }
      ],
      tags: [
        "Fallback"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23284,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23284"
    },
    {
      id: "Effect.orElseFail",
      name: "orElseFail",
      module: "Effect",
      package: "effect",
      signature: "{ <E2>(evaluate: LazyArg<E2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, evaluate: LazyArg<E2>): Effect<A, E2, R>; }",
      description: "Replaces the failure of an effect with a custom failure value.",
      documentation: "Replaces the failure of an effect with a custom failure value.\n\n**Details**\n\nThis function allows you to handle the failure of an effect by replacing it\nwith a predefined failure value. If the effect fails, the new failure value\nprovided by the `evaluate` function will be returned instead of the original\nfailure. If the effect succeeds, the original success value is returned\nunchanged.\n\n**When to Use**\n\nThis is particularly useful when you want to standardize error handling or\nprovide a consistent failure value for specific operations. It simplifies\nerror management by ensuring that all failures are replaced with a controlled\nalternative.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst validate = (age: number): Effect.Effect<number, string> => {\n  if (age < 0) {\n    return Effect.fail(\"NegativeAgeError\")\n  } else if (age < 18) {\n    return Effect.fail(\"IllegalAgeError\")\n  } else {\n    return Effect.succeed(age)\n  }\n}\n\nconst program = Effect.orElseFail(validate(-1), () => \"invalid age\")\n\nconsole.log(Effect.runSyncExit(program))\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'invalid age' }\n// }\n```",
      examples: [
        {
          code: `import { Effect } from "effect"

const validate = (age: number): Effect.Effect<number, string> => {
  if (age < 0) {
    return Effect.fail("NegativeAgeError")
  } else if (age < 18) {
    return Effect.fail("IllegalAgeError")
  } else {
    return Effect.succeed(age)
  }
}

const program = Effect.orElseFail(validate(-1), () => "invalid age")

console.log(Effect.runSyncExit(program))
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'invalid age' }
// }`
        }
      ],
      tags: [
        "Fallback"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23415,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23415"
    },
    {
      id: "Effect.orElseSucceed",
      name: "orElseSucceed",
      module: "Effect",
      package: "effect",
      signature: "{ <A2>(evaluate: LazyArg<A2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, never, R>; <A, E, R, A2>(self: Effect<A, E, R>, evaluate: LazyArg<A2>): Effect<A | A2, never, R>; }",
      description: "Ensures the effect always succeeds by replacing failures with a default\nsuccess value.",
      documentation: 'Ensures the effect always succeeds by replacing failures with a default\nsuccess value.\n\n**Details**\n\nThis function transforms an effect that may fail into one that cannot fail by\nreplacing any failure with a provided success value. If the original effect\nfails, the failure is "swallowed," and the specified success value is\nreturned instead. If the original effect succeeds, its value remains\nunchanged.\n\n**When to Use**\n\nThis is especially useful for providing default values in case of failure,\nensuring that an effect always completes successfully. By using this\nfunction, you can avoid the need for complex error handling and guarantee a\nfallback result.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst validate = (age: number): Effect.Effect<number, string> => {\n  if (age < 0) {\n    return Effect.fail("NegativeAgeError")\n  } else if (age < 18) {\n    return Effect.fail("IllegalAgeError")\n  } else {\n    return Effect.succeed(age)\n  }\n}\n\nconst program = Effect.orElseSucceed(validate(-1), () => 18)\n\nconsole.log(Effect.runSyncExit(program))\n// Output:\n// { _id: \'Exit\', _tag: \'Success\', value: 18 }\n```',
      examples: [
        {
          code: `import { Effect } from "effect"

const validate = (age: number): Effect.Effect<number, string> => {
  if (age < 0) {
    return Effect.fail("NegativeAgeError")
  } else if (age < 18) {
    return Effect.fail("IllegalAgeError")
  } else {
    return Effect.succeed(age)
  }
}

const program = Effect.orElseSucceed(validate(-1), () => 18)

console.log(Effect.runSyncExit(program))
// Output:
// { _id: 'Exit', _tag: 'Success', value: 18 }`
        }
      ],
      tags: [
        "Fallback"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23561,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23561"
    },
    {
      id: "Effect.firstSuccessOf",
      name: "firstSuccessOf",
      module: "Effect",
      package: "effect",
      signature: "<Eff extends Effect<any, any, any>>(effects: Iterable<Eff>) => Effect<Effect.Success<Eff>, Effect.Error<Eff>, Effect.Context<Eff>>",
      description: "Runs a sequence of effects and returns the result of the first successful\none.",
      documentation: 'Runs a sequence of effects and returns the result of the first successful\none.\n\n**Details**\n\nThis function allows you to execute a collection of effects in sequence,\nstopping at the first success. If an effect succeeds, its result is\nimmediately returned, and no further effects in the sequence are executed.\nHowever, if all the effects fail, the function will return the error of the\nlast effect.\n\nThe execution is sequential, meaning that effects are evaluated one at a time\nin the order they are provided. This ensures predictable behavior and avoids\nunnecessary computations.\n\nIf the collection of effects is empty, an `IllegalArgumentException` is\nthrown, indicating that the operation is invalid without any effects to try.\n\n**When to Use**\n\nThis is particularly useful when you have multiple fallback strategies or\nalternative sources to obtain a result, such as attempting multiple APIs,\nretrieving configurations, or accessing resources in a prioritized manner.\n\n**Example**\n\n```ts\nimport { Effect, Console } from "effect"\n\ninterface Config {\n  host: string\n  port: number\n  apiKey: string\n}\n\n// Create a configuration object with sample values\nconst makeConfig = (name: string): Config => ({\n  host: `${name}.example.com`,\n  port: 8080,\n  apiKey: "12345-abcde"\n})\n\n// Simulate retrieving configuration from a remote node\nconst remoteConfig = (name: string): Effect.Effect<Config, Error> =>\n  Effect.gen(function* () {\n    // Simulate node3 being the only one with available config\n    if (name === "node3") {\n      yield* Console.log(`Config for ${name} found`)\n      return makeConfig(name)\n    } else {\n      yield* Console.log(`Unavailable config for ${name}`)\n      return yield* Effect.fail(new Error(`Config not found for ${name}`))\n    }\n  })\n\n// Define the master configuration and potential fallback nodes\nconst masterConfig = remoteConfig("master")\nconst nodeConfigs = ["node1", "node2", "node3", "node4"].map(remoteConfig)\n\n// Attempt to find a working configuration,\n// starting with the master and then falling back to other nodes\nconst config = Effect.firstSuccessOf([masterConfig, ...nodeConfigs])\n\n// Run the effect to retrieve the configuration\nconst result = Effect.runSync(config)\n\nconsole.log(result)\n// Output:\n// Unavailable config for master\n// Unavailable config for node1\n// Unavailable config for node2\n// Config for node3 found\n// { host: \'node3.example.com\', port: 8080, apiKey: \'12345-abcde\' }\n```',
      examples: [
        {
          code: 'import { Effect, Console } from "effect"\n\ninterface Config {\n  host: string\n  port: number\n  apiKey: string\n}\n\n// Create a configuration object with sample values\nconst makeConfig = (name: string): Config => ({\n  host: `${name}.example.com`,\n  port: 8080,\n  apiKey: "12345-abcde"\n})\n\n// Simulate retrieving configuration from a remote node\nconst remoteConfig = (name: string): Effect.Effect<Config, Error> =>\n  Effect.gen(function* () {\n    // Simulate node3 being the only one with available config\n    if (name === "node3") {\n      yield* Console.log(`Config for ${name} found`)\n      return makeConfig(name)\n    } else {\n      yield* Console.log(`Unavailable config for ${name}`)\n      return yield* Effect.fail(new Error(`Config not found for ${name}`))\n    }\n  })\n\n// Define the master configuration and potential fallback nodes\nconst masterConfig = remoteConfig("master")\nconst nodeConfigs = ["node1", "node2", "node3", "node4"].map(remoteConfig)\n\n// Attempt to find a working configuration,\n// starting with the master and then falling back to other nodes\nconst config = Effect.firstSuccessOf([masterConfig, ...nodeConfigs])\n\n// Run the effect to retrieve the configuration\nconst result = Effect.runSync(config)\n\nconsole.log(result)\n// Output:\n// Unavailable config for master\n// Unavailable config for node1\n// Unavailable config for node2\n// Config for node3 found\n// { host: \'node3.example.com\', port: 8080, apiKey: \'12345-abcde\' }'
        }
      ],
      tags: [
        "Fallback"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23732,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23732"
    },
    {
      id: "Effect.random",
      name: "random",
      module: "Effect",
      package: "effect",
      signature: "Effect<Random, never, never>",
      description: "Retrieves the `Random` service from the context.",
      documentation: "Retrieves the `Random` service from the context.",
      examples: [],
      tags: [
        "Random"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23739,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23739"
    },
    {
      id: "Effect.randomWith",
      name: "randomWith",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(f: (random: Random) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "Retrieves the `Random` service from the context and uses it to run the\nspecified effect.",
      documentation: "Retrieves the `Random` service from the context and uses it to run the\nspecified effect.",
      examples: [],
      tags: [
        "Random"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23747,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23747"
    },
    {
      id: "Effect.withRandom",
      name: "withRandom",
      module: "Effect",
      package: "effect",
      signature: "{ <X extends Random.Random>(value: X): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <X extends Random.Random, A, E, R>(effect: Effect<A, E, R>, value: X): Effect<A, E, R>; }",
      description: "Executes the specified effect with the specified implementation of the\n`Random` service.",
      documentation: "Executes the specified effect with the specified implementation of the\n`Random` service.",
      examples: [],
      tags: [
        "Random"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23755,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23755"
    },
    {
      id: "Effect.withRandomFixed",
      name: "withRandomFixed",
      module: "Effect",
      package: "effect",
      signature: "{ <T extends RA.NonEmptyArray<any>>(values: T): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <T extends RA.NonEmptyArray<any>, A, E, R>(effect: Effect<A, E, R>, values: T): Effect<A, E, R>; }",
      description: "Executes the specified effect with a `Random` service that cycles through\na provided array of values.",
      documentation: "Executes the specified effect with a `Random` service that cycles through\na provided array of values.",
      examples: [
        {
          code: 'import { Effect, Random } from "effect"\n\nEffect.gen(function*() {\n  console.log(yield* Random.next) // 0.2\n  console.log(yield* Random.next) // 0.5\n  console.log(yield* Random.next) // 0.8\n}).pipe(Effect.withRandomFixed([0.2, 0.5, 0.8]))'
        }
      ],
      tags: [
        "Random"
      ],
      since: "3.11.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23791,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23791"
    },
    {
      id: "Effect.withRandomScoped",
      name: "withRandomScoped",
      module: "Effect",
      package: "effect",
      signature: "<A extends Random.Random>(value: A) => Effect<void, never, Scope>",
      description: "Sets the implementation of the `Random` service to the specified value and\nrestores it to its original value when the scope is closed.",
      documentation: "Sets the implementation of the `Random` service to the specified value and\nrestores it to its original value when the scope is closed.",
      examples: [],
      tags: [
        "Random"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23838,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23838"
    },
    {
      id: "Effect.runtime",
      name: "runtime",
      module: "Effect",
      package: "effect",
      signature: "<R = never>() => Effect<Runtime<R>, never, R>",
      description: "Returns an effect that accesses the runtime, which can be used to (unsafely)\nexecute tasks.",
      documentation: "Returns an effect that accesses the runtime, which can be used to (unsafely)\nexecute tasks.\n\n**When to Use**\n\nThis is useful for integration with legacy code that must call back into\nEffect code.",
      examples: [],
      tags: [
        "Runtime"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23851,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23851"
    },
    {
      id: "Effect.getRuntimeFlags",
      name: "getRuntimeFlags",
      module: "Effect",
      package: "effect",
      signature: "Effect<RuntimeFlags, never, never>",
      description: "Retrieves an effect that succeeds with the current runtime flags, which\ngovern behavior and features of the runtime system.",
      documentation: "Retrieves an effect that succeeds with the current runtime flags, which\ngovern behavior and features of the runtime system.",
      examples: [],
      tags: [
        "Runtime"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23859,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23859"
    },
    {
      id: "Effect.patchRuntimeFlags",
      name: "patchRuntimeFlags",
      module: "Effect",
      package: "effect",
      signature: "(patch: RuntimeFlagsPatch) => Effect<void, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Runtime"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23864,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23864"
    },
    {
      id: "Effect.withRuntimeFlagsPatch",
      name: "withRuntimeFlagsPatch",
      module: "Effect",
      package: "effect",
      signature: "{ (update: RuntimeFlagsPatch): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, update: RuntimeFlagsPatch): Effect<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Runtime"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23869,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23869"
    },
    {
      id: "Effect.withRuntimeFlagsPatchScoped",
      name: "withRuntimeFlagsPatchScoped",
      module: "Effect",
      package: "effect",
      signature: "(update: RuntimeFlagsPatch) => Effect<void, never, Scope>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Runtime"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23885,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23885"
    },
    {
      id: "Effect.tagMetrics",
      name: "tagMetrics",
      module: "Effect",
      package: "effect",
      signature: "{ (key: string, value: string): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; (values: Record<string, string>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, key: string, value: string): Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, values: Record<string, string>): Effect<A, E, R>; }",
      description: "Tags each metric in an effect with specific key-value pairs.",
      documentation: "Tags each metric in an effect with specific key-value pairs.\n\n**Details**\n\nThis function allows you to tag all metrics in an effect with a set of\nkey-value pairs or a single key-value pair. Tags help you add metadata to\nmetrics, making it easier to filter and categorize them in monitoring\nsystems. The provided tags will apply to all metrics generated within the\neffect's scope.",
      examples: [],
      tags: [
        "Metrics"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23900,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23900"
    },
    {
      id: "Effect.labelMetrics",
      name: "labelMetrics",
      module: "Effect",
      package: "effect",
      signature: "{ (labels: Iterable<MetricLabel>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, labels: Iterable<MetricLabel>): Effect<A, E, R>; }",
      description: "Adds labels to metrics within an effect using `MetricLabel` objects.",
      documentation: "Adds labels to metrics within an effect using `MetricLabel` objects.\n\n**Details**\n\nThis function allows you to label metrics using `MetricLabel` objects. Labels\nhelp add structured metadata to metrics for categorization and filtering in\nmonitoring systems. The provided labels will apply to all metrics within the\neffect's execution.",
      examples: [],
      tags: [
        "Metrics"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 23975,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23975"
    },
    {
      id: "Effect.tagMetricsScoped",
      name: "tagMetricsScoped",
      module: "Effect",
      package: "effect",
      signature: "(key: string, value: string) => Effect<void, never, Scope>",
      description: "Tags metrics within a scope with a specific key-value pair.",
      documentation: "Tags metrics within a scope with a specific key-value pair.\n\n**Details**\n\nThis function tags all metrics within a scope with the provided key-value\npair. Once the scope is closed, the tag is automatically removed. This is\nuseful for applying temporary context-specific tags to metrics during scoped\noperations.",
      examples: [],
      tags: [
        "Metrics"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24018,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24018"
    },
    {
      id: "Effect.labelMetricsScoped",
      name: "labelMetricsScoped",
      module: "Effect",
      package: "effect",
      signature: "(labels: readonly MetricLabel[]) => Effect<void, never, Scope>",
      description: "Adds labels to metrics within a scope using `MetricLabel` objects.",
      documentation: "Adds labels to metrics within a scope using `MetricLabel` objects.\n\n**Details**\n\nThis function allows you to apply labels to all metrics generated within a\nspecific scope using an array of `MetricLabel` objects. These labels provide\nadditional metadata to metrics, which can be used for categorization,\nfiltering, or monitoring purposes. The labels are scoped and will be removed\nautomatically once the scope is closed, ensuring they are only applied\ntemporarily within the defined context.",
      examples: [],
      tags: [
        "Metrics"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24034,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24034"
    },
    {
      id: "Effect.metricLabels",
      name: "metricLabels",
      module: "Effect",
      package: "effect",
      signature: "Effect<readonly MetricLabel[], never, never>",
      description: "Retrieves the metric labels associated with the current scope.",
      documentation: "Retrieves the metric labels associated with the current scope.",
      examples: [],
      tags: [
        "Metrics"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24041,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24041"
    },
    {
      id: "Effect.withMetric",
      name: "withMetric",
      module: "Effect",
      package: "effect",
      signature: "{ <Type, In, Out>(metric: Metric<Type, In, Out>): <A extends In, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A extends In, E, R, Type, In, Out>(self: Effect<A, E, R>, metric: Metric<Type, In, Out>): Effect<A, E, R>; }",
      description: "Associates a metric with the current effect, updating it as the effect progresses.",
      documentation: "Associates a metric with the current effect, updating it as the effect progresses.",
      examples: [],
      tags: [
        "Metrics"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24048,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24048"
    },
    {
      id: "Effect.unsafeMakeSemaphore",
      name: "unsafeMakeSemaphore",
      module: "Effect",
      package: "effect",
      signature: "(permits: number) => Semaphore",
      description: "Unsafely creates a new Semaphore.",
      documentation: "Unsafely creates a new Semaphore.",
      examples: [],
      tags: [
        "Semaphore"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24135,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24135"
    },
    {
      id: "Effect.makeSemaphore",
      name: "makeSemaphore",
      module: "Effect",
      package: "effect",
      signature: "(permits: number) => Effect<Semaphore, never, never>",
      description: "Creates a new semaphore with the specified number of permits.",
      documentation: 'Creates a new semaphore with the specified number of permits.\n\n**Details**\n\nThis function initializes a semaphore that controls concurrent access to a\nshared resource. The number of permits determines how many tasks can access\nthe resource concurrently.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\n// Create a semaphore with 3 permits\nconst mutex = Effect.makeSemaphore(3)\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\n// Create a semaphore with 3 permits\nconst mutex = Effect.makeSemaphore(3)'
        }
      ],
      tags: [
        "Semaphore"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24157,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24157"
    },
    {
      id: "Effect.unsafeMakeLatch",
      name: "unsafeMakeLatch",
      module: "Effect",
      package: "effect",
      signature: "(open?: boolean) => Latch",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Latch"
      ],
      since: "3.8.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24265,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24265"
    },
    {
      id: "Effect.makeLatch",
      name: "makeLatch",
      module: "Effect",
      package: "effect",
      signature: "(open?: boolean) => Effect<Latch, never, never>",
      description: "Creates a new `Latch`, starting in the specified state.",
      documentation: 'Creates a new `Latch`, starting in the specified state.\n\n**Details**\n\nThis function initializes a `Latch` safely, ensuring proper runtime\nguarantees. By default, the latch starts in the closed state.\n\n**Example**\n\n```ts\nimport { Console, Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  // Create a latch, starting in the closed state\n  const latch = yield* Effect.makeLatch(false)\n\n  // Fork a fiber that logs "open sesame" when the latch is opened\n  const fiber = yield* Console.log("open sesame").pipe(\n    latch.whenOpen,\n    Effect.fork\n  )\n\n  yield* Effect.sleep("1 second")\n\n  // Open the latch\n  yield* latch.open\n  yield* fiber.await\n})\n\nEffect.runFork(program)\n// Output: open sesame (after 1 second)\n```',
      examples: [
        {
          code: 'import { Console, Effect } from "effect"\n\nconst program = Effect.gen(function*() {\n  // Create a latch, starting in the closed state\n  const latch = yield* Effect.makeLatch(false)\n\n  // Fork a fiber that logs "open sesame" when the latch is opened\n  const fiber = yield* Console.log("open sesame").pipe(\n    latch.whenOpen,\n    Effect.fork\n  )\n\n  yield* Effect.sleep("1 second")\n\n  // Open the latch\n  yield* latch.open\n  yield* fiber.await\n})\n\nEffect.runFork(program)\n// Output: open sesame (after 1 second)'
        }
      ],
      tags: [
        "Latch"
      ],
      since: "3.8.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24303,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24303"
    },
    {
      id: "Effect.runFork",
      name: "runFork",
      module: "Effect",
      package: "effect",
      signature: "<A, E>(effect: Effect<A, E, never>, options?: RunForkOptions) => RuntimeFiber<A, E>",
      description: "Runs an effect in the background, returning a fiber that can be observed or\ninterrupted. Unless you specifically need a `Promise` or synchronous operation, `runFork`\nis a good default choice.",
      documentation: 'Runs an effect in the background, returning a fiber that can be observed or\ninterrupted.\n\nUnless you specifically need a `Promise` or synchronous operation, `runFork`\nis a good default choice.\n\n**Details**\n\nThis function is the foundational way to execute an effect in the background.\nIt creates a "fiber," a lightweight, cooperative thread of execution that can\nbe observed (to access its result), interrupted, or joined. Fibers are useful\nfor concurrent programming and allow effects to run independently of the main\nprogram flow.\n\nOnce the effect is running in a fiber, you can monitor its progress, cancel\nit if necessary, or retrieve its result when it completes. If the effect\nfails, the fiber will propagate the failure, which you can observe and\nhandle.\n\n**When to Use**\n\nUse this function when you need to run an effect in the background,\nespecially if the effect is long-running or performs periodic tasks. It\'s\nsuitable for tasks that need to run independently but might still need\nobservation or management, like logging, monitoring, or scheduled tasks.\n\nThis function is ideal if you don\'t need the result immediately or if the\neffect is part of a larger concurrent workflow.\n\n**Example** (Running an Effect in the Background)\n\n```ts\nimport { Effect, Console, Schedule, Fiber } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, never, never>\n//      \u25BC\nconst program = Effect.repeat(\n  Console.log("running..."),\n  Schedule.spaced("200 millis")\n)\n\n//      \u250C\u2500\u2500\u2500 RuntimeFiber<number, never>\n//      \u25BC\nconst fiber = Effect.runFork(program)\n\nsetTimeout(() => {\n  Effect.runFork(Fiber.interrupt(fiber))\n}, 500)\n```',
      examples: [
        {
          title: "Running an Effect in the Background",
          code: 'import { Effect, Console, Schedule, Fiber } from "effect"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, never, never>\n//      \u25BC\nconst program = Effect.repeat(\n  Console.log("running..."),\n  Schedule.spaced("200 millis")\n)\n\n//      \u250C\u2500\u2500\u2500 RuntimeFiber<number, never>\n//      \u25BC\nconst fiber = Effect.runFork(program)\n\nsetTimeout(() => {\n  Effect.runFork(Fiber.interrupt(fiber))\n}, 500)'
        }
      ],
      tags: [
        "Running Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24358,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24358"
    },
    {
      id: "Effect.runCallback",
      name: "runCallback",
      module: "Effect",
      package: "effect",
      signature: "<A, E>(effect: Effect<A, E, never>, options?: RunCallbackOptions<A, E>) => Cancel<A, E>",
      description: "Executes an effect asynchronously and handles the result using a callback.",
      documentation: "Executes an effect asynchronously and handles the result using a callback.\n\n**Details**\n\nThis function runs an effect asynchronously and passes the result (`Exit`) to\na specified callback. The callback is invoked with the outcome of the effect:\n- On success, the callback receives the successful result.\n- On failure, the callback receives the failure information.\n\n**When to Use**\n\nThis function is effectful and should only be invoked at the edges of your\nprogram.",
      examples: [],
      tags: [
        "Running Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24377,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24377"
    },
    {
      id: "Effect.runPromise",
      name: "runPromise",
      module: "Effect",
      package: "effect",
      signature: "<A, E>(effect: Effect<A, E, never>, options?: { readonly signal?: AbortSignal; }) => Promise<A>",
      description: "Executes an effect and returns the result as a `Promise`.",
      documentation: 'Executes an effect and returns the result as a `Promise`.\n\n**Details**\n\nThis function runs an effect and converts its result into a `Promise`. If the\neffect succeeds, the `Promise` will resolve with the successful result. If\nthe effect fails, the `Promise` will reject with an error, which includes the\nfailure details of the effect.\n\nThe optional `options` parameter allows you to pass an `AbortSignal` for\ncancellation, enabling more fine-grained control over asynchronous tasks.\n\n**When to Use**\n\nUse this function when you need to execute an effect and work with its result\nin a promise-based system, such as when integrating with third-party\nlibraries that expect `Promise` results.\n\n**Example** (Running a Successful Effect as a Promise)\n\n```ts\nimport { Effect } from "effect"\n\nEffect.runPromise(Effect.succeed(1)).then(console.log)\n// Output: 1\n```\n\n**Example** (Handling a Failing Effect as a Rejected Promise)\n\n```ts\nimport { Effect } from "effect"\n\nEffect.runPromise(Effect.fail("my error")).catch(console.error)\n// Output:\n// (FiberFailure) Error: my error\n```',
      examples: [
        {
          title: "Running a Successful Effect as a Promise",
          code: 'import { Effect } from "effect"\n\nEffect.runPromise(Effect.succeed(1)).then(console.log)\n// Output: 1'
        },
        {
          title: "Handling a Failing Effect as a Rejected Promise",
          code: 'import { Effect } from "effect"\n\nEffect.runPromise(Effect.fail("my error")).catch(console.error)\n// Output:\n// (FiberFailure) Error: my error'
        }
      ],
      tags: [
        "Running Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24422,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24422"
    },
    {
      id: "Effect.runPromiseExit",
      name: "runPromiseExit",
      module: "Effect",
      package: "effect",
      signature: "<A, E>(effect: Effect<A, E, never>, options?: { readonly signal?: AbortSignal; }) => Promise<Exit<A, E>>",
      description: "Runs an effect and returns a `Promise` that resolves to an `Exit`,\nrepresenting the outcome.",
      documentation: 'Runs an effect and returns a `Promise` that resolves to an `Exit`,\nrepresenting the outcome.\n\n**Details**\n\nThis function executes an effect and resolves to an `Exit` object. The `Exit`\ntype provides detailed information about the result of the effect:\n- If the effect succeeds, the `Exit` will be of type `Success` and include\n  the value produced by the effect.\n- If the effect fails, the `Exit` will be of type `Failure` and contain a\n  `Cause` object, detailing the failure.\n\nUsing this function allows you to examine both successful results and failure\ncases in a unified way, while still leveraging `Promise` for handling the\nasynchronous behavior of the effect.\n\n**When to Use**\n\nUse this function when you need to understand the outcome of an effect,\nwhether it succeeded or failed, and want to work with this result using\n`Promise` syntax. This is particularly useful when integrating with systems\nthat rely on promises but need more detailed error handling than a simple\nrejection.\n\n**Example** (Handling Results as Exit)\n\n```ts\nimport { Effect } from "effect"\n\n// Execute a successful effect and get the Exit result as a Promise\nEffect.runPromiseExit(Effect.succeed(1)).then(console.log)\n// Output:\n// {\n//   _id: "Exit",\n//   _tag: "Success",\n//   value: 1\n// }\n\n// Execute a failing effect and get the Exit result as a Promise\nEffect.runPromiseExit(Effect.fail("my error")).then(console.log)\n// Output:\n// {\n//   _id: "Exit",\n//   _tag: "Failure",\n//   cause: {\n//     _id: "Cause",\n//     _tag: "Fail",\n//     failure: "my error"\n//   }\n// }\n```',
      examples: [
        {
          title: "Handling Results as Exit",
          code: 'import { Effect } from "effect"\n\n// Execute a successful effect and get the Exit result as a Promise\nEffect.runPromiseExit(Effect.succeed(1)).then(console.log)\n// Output:\n// {\n//   _id: "Exit",\n//   _tag: "Success",\n//   value: 1\n// }\n\n// Execute a failing effect and get the Exit result as a Promise\nEffect.runPromiseExit(Effect.fail("my error")).then(console.log)\n// Output:\n// {\n//   _id: "Exit",\n//   _tag: "Failure",\n//   cause: {\n//     _id: "Cause",\n//     _tag: "Fail",\n//     failure: "my error"\n//   }\n// }'
        }
      ],
      tags: [
        "Running Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24481,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24481"
    },
    {
      id: "Effect.runSync",
      name: "runSync",
      module: "Effect",
      package: "effect",
      signature: "<A, E>(effect: Effect<A, E, never>) => A",
      description: "/\n * Executes an effect synchronously, running it immediately and returning the\n * result.\n *\n *",
      documentation: '/**\n * Executes an effect synchronously, running it immediately and returning the\n * result.\n *\n * **Details**\n *\n * This function evaluates the provided effect synchronously, returning its\n * result directly. It is ideal for effects that do not fail or include\n * asynchronous operations. If the effect does fail or involves async tasks, it\n * will throw an error. Execution stops at the point of failure or asynchronous\n * operation, making it unsuitable for effects that require asynchronous\n * handling.\n *\n * **Important**: Attempting to run effects that involve asynchronous operations\n * or failures will result in exceptions being thrown, so use this function with\n * care for purely synchronous and error-free effects.\n *\n * **When to Use**\n *\n * Use this function when:\n * - You are sure that the effect will not fail or involve asynchronous\n *   operations.\n * - You need a direct, synchronous result from the effect.\n * - You are working within a context where asynchronous effects are not\n *   allowed.\n *\n * Avoid using this function for effects that can fail or require asynchronous\n * handling. For such cases, consider using {@link runPromise}or\n * {@link runSyncExit}.\n *\n * **Example** (Synchronous Logging)\n *\n * ```ts\n * import { Effect } from "effect"\n *\n * const program = Effect.sync(() => {\n *   console.log("Hello, World!")\n *   return 1\n * })\n *\n * const result = Effect.runSync(program)\n * // Output: Hello, World!\n *\n * console.log(result)\n * // Output: 1\n * ```\n *\n * **Example** (Incorrect Usage with Failing or Async Effects)\n *\n * ```ts\n * import { Effect } from "effect"\n *\n * try {\n *   // Attempt to run an effect that fails\n *   Effect.runSync(Effect.fail("my error"))\n * } catch (e) {\n *   console.error(e)\n * }\n * // Output:\n * // (FiberFailure) Error: my error\n *\n * try {\n *   // Attempt to run an effect that involves async work\n *   Effect.runSync(Effect.promise(() => Promise.resolve(1)))\n * } catch (e) {\n *   console.error(e)\n * }\n * // Output:\n * // (FiberFailure) AsyncFiberException: Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect } from "effect"\n *\n * const program = Effect.sync(() => {\n *   console.log("Hello, World!")\n *   return 1\n * })\n *\n * const result = Effect.runSync(program)\n * // Output: Hello, World!\n *\n * console.log(result)\n * // Output: 1\n *'
        },
        {
          code: '* import { Effect } from "effect"\n *\n * try {\n *   // Attempt to run an effect that fails\n *   Effect.runSync(Effect.fail("my error"))\n * } catch (e) {\n *   console.error(e)\n * }\n * // Output:\n * // (FiberFailure) Error: my error\n *\n * try {\n *   // Attempt to run an effect that involves async work\n *   Effect.runSync(Effect.promise(() => Promise.resolve(1)))\n * } catch (e) {\n *   console.error(e)\n * }\n * // Output:\n * // (FiberFailure) AsyncFiberException: Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work\n *'
        }
      ],
      tags: [
        "Running Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24561,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24561"
    },
    {
      id: "Effect.runSyncExit",
      name: "runSyncExit",
      module: "Effect",
      package: "effect",
      signature: "<A, E>(effect: Effect<A, E, never>) => Exit<A, E>",
      description: "Runs an effect synchronously and returns the result as an `Exit` type.",
      documentation: 'Runs an effect synchronously and returns the result as an `Exit` type.\n\n**Details**\n\nThis function executes the provided effect synchronously and returns an `Exit`\ntype that encapsulates the outcome of the effect:\n- If the effect succeeds, the result is wrapped in a `Success`.\n- If the effect fails, it returns a `Failure` containing a `Cause` that explains\n  the failure.\n\nIf the effect involves asynchronous operations, this function will return a `Failure`\nwith a `Die` cause, indicating that it cannot resolve the effect synchronously.\nThis makes the function suitable for use only with effects that are synchronous\nin nature.\n\n**When to Use**\n\nUse this function when:\n- You want to handle both success and failure outcomes in a structured way using the `Exit` type.\n- You are working with effects that are purely synchronous and do not involve asynchronous operations.\n- You need to debug or inspect failures, including their causes, in a detailed manner.\n\nAvoid using this function for effects that involve asynchronous operations, as it will fail with a `Die` cause.\n\n**Example** (Handling Results as Exit)\n\n```ts\nimport { Effect } from "effect"\n\nconsole.log(Effect.runSyncExit(Effect.succeed(1)))\n// Output:\n// {\n//   _id: "Exit",\n//   _tag: "Success",\n//   value: 1\n// }\n\nconsole.log(Effect.runSyncExit(Effect.fail("my error")))\n// Output:\n// {\n//   _id: "Exit",\n//   _tag: "Failure",\n//   cause: {\n//     _id: "Cause",\n//     _tag: "Fail",\n//     failure: "my error"\n//   }\n// }\n```\n\n**Example** (Asynchronous Operation Resulting in Die)\n\n```ts\nimport { Effect } from "effect"\n\nconsole.log(Effect.runSyncExit(Effect.promise(() => Promise.resolve(1))))\n// Output:\n// {\n//   _id: \'Exit\',\n//   _tag: \'Failure\',\n//   cause: {\n//     _id: \'Cause\',\n//     _tag: \'Die\',\n//     defect: [Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work] {\n//       fiber: [FiberRuntime],\n//       _tag: \'AsyncFiberException\',\n//       name: \'AsyncFiberException\'\n//     }\n//   }\n// }\n```',
      examples: [
        {
          title: "Handling Results as Exit",
          code: 'import { Effect } from "effect"\n\nconsole.log(Effect.runSyncExit(Effect.succeed(1)))\n// Output:\n// {\n//   _id: "Exit",\n//   _tag: "Success",\n//   value: 1\n// }\n\nconsole.log(Effect.runSyncExit(Effect.fail("my error")))\n// Output:\n// {\n//   _id: "Exit",\n//   _tag: "Failure",\n//   cause: {\n//     _id: "Cause",\n//     _tag: "Fail",\n//     failure: "my error"\n//   }\n// }'
        },
        {
          title: "Asynchronous Operation Resulting in Die",
          code: `import { Effect } from "effect"

console.log(Effect.runSyncExit(Effect.promise(() => Promise.resolve(1))))
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Die',
//     defect: [Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work] {
//       fiber: [FiberRuntime],
//       _tag: 'AsyncFiberException',
//       name: 'AsyncFiberException'
//     }
//   }
// }`
        }
      ],
      tags: [
        "Running Effects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24638,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24638"
    },
    {
      id: "Effect.validate",
      name: "validate",
      module: "Effect",
      package: "effect",
      signature: '{ <B, E1, R1>(that: Effect<B, E1, R1>, options?: { readonly concurrent?: boolean; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): <A, E, R>(self: Effect<A, E, R>) => Effect<[A, B], E1 | E, R1 | R>; <A, E, R, B, E1, R1>(self: Effect<A, E, R>, that: Effect<B, E1, R1>, options?: { readonly concurrent?: boolean; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): Effect<[A, B], E | E1, R | R1>; }',
      description: "Combines multiple effects and accumulates both successes and failures.",
      documentation: "Combines multiple effects and accumulates both successes and failures.\n\n**Details**\n\nThis function allows you to combine multiple effects, continuing through all\neffects even if some of them fail. Unlike other functions that stop execution\nupon encountering an error, this function collects all errors into a `Cause`.\nThe final result includes all successes and the accumulated failures.\n\nBy default, effects are executed sequentially, but you can control\nconcurrency and batching behavior using the `options` parameter. This\nprovides flexibility in scenarios where you want to maximize performance or\nensure specific ordering.\n\n**Example**\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Console.log(\"task1\").pipe(Effect.as(1))\nconst task2 = Effect.fail(\"Oh uh!\").pipe(Effect.as(2))\nconst task3 = Console.log(\"task2\").pipe(Effect.as(3))\nconst task4 = Effect.fail(\"Oh no!\").pipe(Effect.as(4))\n\nconst program = task1.pipe(\n  Effect.validate(task2),\n  Effect.validate(task3),\n  Effect.validate(task4)\n)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// task1\n// task2\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Sequential',\n//     left: { _id: 'Cause', _tag: 'Fail', failure: 'Oh uh!' },\n//     right: { _id: 'Cause', _tag: 'Fail', failure: 'Oh no!' }\n//   }\n// }\n```",
      examples: [
        {
          code: `import { Effect, Console } from "effect"

const task1 = Console.log("task1").pipe(Effect.as(1))
const task2 = Effect.fail("Oh uh!").pipe(Effect.as(2))
const task3 = Console.log("task2").pipe(Effect.as(3))
const task4 = Effect.fail("Oh no!").pipe(Effect.as(4))

const program = task1.pipe(
  Effect.validate(task2),
  Effect.validate(task3),
  Effect.validate(task4)
)

Effect.runPromiseExit(program).then(console.log)
// Output:
// task1
// task2
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Sequential',
//     left: { _id: 'Cause', _tag: 'Fail', failure: 'Oh uh!' },
//     right: { _id: 'Cause', _tag: 'Fail', failure: 'Oh no!' }
//   }
// }`
        }
      ],
      tags: [
        "Error Accumulation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24691,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24691"
    },
    {
      id: "Effect.validateWith",
      name: "validateWith",
      module: "Effect",
      package: "effect",
      signature: '{ <B, E1, R1, A, C>(that: Effect<B, E1, R1>, f: (a: A, b: B) => C, options?: { readonly concurrent?: boolean; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): <E, R>(self: Effect<A, E, R>) => Effect<C, E1 | E, R1 | R>; <A, E, R, B, E1, R1, C>(self: Effect<A, E, R>, that: Effect<B, E1, R1>, f: (a: A, b: B) => C, options?: { readonly concurrent?: boolean; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): Effect<C, E | E1, R | R1>; }',
      description: "Sequentially combines two effects using a specified combiner function while\naccumulating errors.",
      documentation: "Sequentially combines two effects using a specified combiner function while\naccumulating errors.\n\n**Details**\n\nThis function combines two effects, `self` and `that`, into a single effect\nby applying the provided combiner function to their results. If both effects\nsucceed, the combiner function is applied to their results to produce the\nfinal value. If either effect fails, the failures are accumulated into a\ncombined `Cause`.\n\nBy default, effects are executed sequentially. However, the execution mode\ncan be controlled using the `options` parameter to enable concurrency,\nbatching, or customized finalizer behavior.",
      examples: [],
      tags: [
        "Error Accumulation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24826,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24826"
    },
    {
      id: "Effect.zip",
      name: "zip",
      module: "Effect",
      package: "effect",
      signature: '{ <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): <A, E, R>(self: Effect<A, E, R>) => Effect<[A, A2], E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): Effect<[A, A2], E | E2, R | R2>; }',
      description: "Combines two effects into a single effect, producing a tuple of their\nresults.",
      documentation: 'Combines two effects into a single effect, producing a tuple of their\nresults.\n\n**Details**\n\nThis function combines two effects, `self` and `that`, into one. It executes\nthe first effect (`self`) and then the second effect (`that`), collecting\ntheir results into a tuple. Both effects must succeed for the resulting\neffect to succeed. If either effect fails, the entire operation fails.\n\nBy default, the effects are executed sequentially. If the `concurrent` option\nis set to `true`, the effects will run concurrently, potentially improving\nperformance for independent operations.\n\n**Example** (Combining Two Effects Sequentially)\n\n```ts\nimport { Effect } from "effect"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Effect.log("task1 done"))\n)\nconst task2 = Effect.succeed("hello").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Effect.log("task2 done"))\n)\n\n// Combine the two effects together\n//\n//      \u250C\u2500\u2500\u2500 Effect<[number, string], never, never>\n//      \u25BC\nconst program = Effect.zip(task1, task2)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message="task1 done"\n// timestamp=... level=INFO fiber=#0 message="task2 done"\n// [ 1, \'hello\' ]\n```\n\n**Example** (Combining Two Effects Concurrently)\n\n```ts\nimport { Effect } from "effect"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Effect.log("task1 done"))\n)\nconst task2 = Effect.succeed("hello").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Effect.log("task2 done"))\n)\n\n// Run both effects concurrently using the concurrent option\nconst program = Effect.zip(task1, task2, { concurrent: true })\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message="task2 done"\n// timestamp=... level=INFO fiber=#0 message="task1 done"\n// [ 1, \'hello\' ]\n```',
      examples: [
        {
          title: "Combining Two Effects Sequentially",
          code: `import { Effect } from "effect"

const task1 = Effect.succeed(1).pipe(
  Effect.delay("200 millis"),
  Effect.tap(Effect.log("task1 done"))
)
const task2 = Effect.succeed("hello").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Effect.log("task2 done"))
)

// Combine the two effects together
//
//      \u250C\u2500\u2500\u2500 Effect<[number, string], never, never>
//      \u25BC
const program = Effect.zip(task1, task2)

Effect.runPromise(program).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#0 message="task1 done"
// timestamp=... level=INFO fiber=#0 message="task2 done"
// [ 1, 'hello' ]`
        },
        {
          title: "Combining Two Effects Concurrently",
          code: `import { Effect } from "effect"

const task1 = Effect.succeed(1).pipe(
  Effect.delay("200 millis"),
  Effect.tap(Effect.log("task1 done"))
)
const task2 = Effect.succeed("hello").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Effect.log("task2 done"))
)

// Run both effects concurrently using the concurrent option
const program = Effect.zip(task1, task2, { concurrent: true })

Effect.runPromise(program).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#0 message="task2 done"
// timestamp=... level=INFO fiber=#0 message="task1 done"
// [ 1, 'hello' ]`
        }
      ],
      tags: [
        "Zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 24949,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24949"
    },
    {
      id: "Effect.zipLeft",
      name: "zipLeft",
      module: "Effect",
      package: "effect",
      signature: '{ <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): Effect<A, E | E2, R | R2>; }',
      description: "Executes two effects sequentially, returning the result of the first effect\nand ignoring the result of the second.",
      documentation: 'Executes two effects sequentially, returning the result of the first effect\nand ignoring the result of the second.\n\n**Details**\n\nThis function allows you to run two effects in sequence, where the result of\nthe first effect is preserved, and the result of the second effect is\ndiscarded. By default, the two effects are executed sequentially. If you need\nthem to run concurrently, you can pass the `{ concurrent: true }` option.\n\nThe second effect will always be executed, even though its result is ignored.\nThis makes it useful for cases where you want to execute an effect for its\nside effects while keeping the result of another effect.\n\n**When to Use**\n\nUse this function when you are only interested in the result of the first\neffect but still need to run the second effect for its side effects, such as\nlogging or performing a cleanup action.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Effect.log("task1 done"))\n)\nconst task2 = Effect.succeed("hello").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Effect.log("task2 done"))\n)\n\nconst program = Effect.zipLeft(task1, task2)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message="task1 done"\n// timestamp=... level=INFO fiber=#0 message="task2 done"\n// 1\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Effect.log("task1 done"))\n)\nconst task2 = Effect.succeed("hello").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Effect.log("task2 done"))\n)\n\nconst program = Effect.zipLeft(task1, task2)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message="task1 done"\n// timestamp=... level=INFO fiber=#0 message="task2 done"\n// 1'
        }
      ],
      tags: [
        "Zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25157,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25157"
    },
    {
      id: "Effect.zipRight",
      name: "zipRight",
      module: "Effect",
      package: "effect",
      signature: '{ <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): Effect<A2, E | E2, R | R2>; }',
      description: "Executes two effects sequentially, returning the result of the second effect\nwhile ignoring the result of the first.",
      documentation: 'Executes two effects sequentially, returning the result of the second effect\nwhile ignoring the result of the first.\n\n**Details**\n\nThis function allows you to run two effects in sequence, keeping the result\nof the second effect and discarding the result of the first. By default, the\ntwo effects are executed sequentially. If you need them to run concurrently,\nyou can pass the `{ concurrent: true }` option.\n\nThe first effect will always be executed, even though its result is ignored.\nThis makes it useful for scenarios where the first effect is needed for its\nside effects, but only the result of the second effect is important.\n\n**When to Use**\n\nUse this function when you are only interested in the result of the second\neffect but still need to run the first effect for its side effects, such as\ninitialization or setup tasks.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Effect.log("task1 done"))\n)\nconst task2 = Effect.succeed("hello").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Effect.log("task2 done"))\n)\n\nconst program = Effect.zipRight(task1, task2)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message="task1 done"\n// timestamp=... level=INFO fiber=#0 message="task2 done"\n// hello\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst task1 = Effect.succeed(1).pipe(\n  Effect.delay("200 millis"),\n  Effect.tap(Effect.log("task1 done"))\n)\nconst task2 = Effect.succeed("hello").pipe(\n  Effect.delay("100 millis"),\n  Effect.tap(Effect.log("task2 done"))\n)\n\nconst program = Effect.zipRight(task1, task2)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message="task1 done"\n// timestamp=... level=INFO fiber=#0 message="task2 done"\n// hello'
        }
      ],
      tags: [
        "Zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25319,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25319"
    },
    {
      id: "Effect.zipWith",
      name: "zipWith",
      module: "Effect",
      package: "effect",
      signature: '{ <A2, E2, R2, A, B>(that: Effect<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): <E, R>(self: Effect<A, E, R>) => Effect<B, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, B>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean; readonly batching?: boolean | "inherit"; readonly concurrentFinalizers?: boolean; }): Effect<B, E | E2, R | R2>; }',
      description: "/\n * Combines two effects sequentially and applies a function to their results to\n * produce a single value.\n *\n *",
      documentation: '/**\n * Combines two effects sequentially and applies a function to their results to\n * produce a single value.\n *\n * **Details**\n *\n * This function runs two effects in sequence (or concurrently, if the `{\n * concurrent: true }` option is provided) and combines their results using a\n * provided function. Unlike {@link zip}, which returns a tuple of the results,\n * this function processes the results with a custom function to produce a\n * single output.\n *\n * **Example** (Combining Effects with a Custom Function)\n *\n * ```ts\n * import { Effect } from "effect"\n *\n * const task1 = Effect.succeed(1).pipe(\n *   Effect.delay("200 millis"),\n *   Effect.tap(Effect.log("task1 done"))\n * )\n * const task2 = Effect.succeed("hello").pipe(\n *   Effect.delay("100 millis"),\n *   Effect.tap(Effect.log("task2 done"))\n * )\n *\n * const task3 = Effect.zipWith(\n *   task1,\n *   task2,\n *   // Combines results into a single value\n *   (number, string) => number + string.length\n * )\n *\n * Effect.runPromise(task3).then(console.log)\n * // Output:\n * // timestamp=... level=INFO fiber=#3 message="task1 done"\n * // timestamp=... level=INFO fiber=#2 message="task2 done"\n * // 6\n * ```\n *\n *',
      examples: [
        {
          code: '* import { Effect } from "effect"\n *\n * const task1 = Effect.succeed(1).pipe(\n *   Effect.delay("200 millis"),\n *   Effect.tap(Effect.log("task1 done"))\n * )\n * const task2 = Effect.succeed("hello").pipe(\n *   Effect.delay("100 millis"),\n *   Effect.tap(Effect.log("task2 done"))\n * )\n *\n * const task3 = Effect.zipWith(\n *   task1,\n *   task2,\n *   // Combines results into a single value\n *   (number, string) => number + string.length\n * )\n *\n * Effect.runPromise(task3).then(console.log)\n * // Output:\n * // timestamp=... level=INFO fiber=#3 message="task1 done"\n * // timestamp=... level=INFO fiber=#2 message="task2 done"\n * // 6\n *'
        }
      ],
      tags: [
        "Zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25474,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25474"
    },
    {
      id: "Effect.ap",
      name: "ap",
      module: "Effect",
      package: "effect",
      signature: "{ <A, E2, R2>(that: Effect<A, E2, R2>): <B, R, E>(self: Effect<(a: A) => B, E, R>) => Effect<B, E2 | E, R2 | R>; <A, B, E, R, E2, R2>(self: Effect<(a: A) => B, E, R>, that: Effect<A, E2, R2>): Effect<B, E | E2, R | R2>; }",
      description: "Applies the function produced by one effect to the value produced by another effect.",
      documentation: "Applies the function produced by one effect to the value produced by another effect.\n\n**Details**\n\nThis function combines two effects:\n- The first effect produces a function of type `(a: A) => B`.\n- The second effect produces a value of type `A`.\n\nOnce both effects complete successfully, the function is applied to the value, resulting in an effect that produces a value of type `B`.",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25585,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25585"
    },
    {
      id: "Effect.blocked",
      name: "blocked",
      module: "Effect",
      package: "effect",
      signature: "<A, E>(blockedRequests: RequestBlock, _continue: Effect<A, E, never>) => Blocked<A, E>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Requests & Batching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25619,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25619"
    },
    {
      id: "Effect.runRequestBlock",
      name: "runRequestBlock",
      module: "Effect",
      package: "effect",
      signature: "(blockedRequests: RequestBlock) => Effect<void, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Requests & Batching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25624,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25624"
    },
    {
      id: "Effect.step",
      name: "step",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<Exit<A, E> | Blocked<A, E>, never, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Requests & Batching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25629,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25629"
    },
    {
      id: "Effect.request",
      name: "request",
      module: "Effect",
      package: "effect",
      signature: "{ <A extends Request.Request<any, any>, Ds extends RequestResolver<A> | Effect<RequestResolver<A>, any, any>>(dataSource: Ds): (self: A) => Effect<Request.Success<A>, Request.Error<A>, [Ds] extends [Effect<any, any, any>] ? Effect.Context<Ds> : never>; <Ds extends RequestResolver<A> | Effect<RequestResolver<A>, any, any>, A extends Request.Request<any, any>>(self: A, dataSource: Ds): Effect<Request.Success<A>, Request.Error<A>, [Ds] extends [Effect<any, any, any>] ? Effect.Context<Ds> : never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Requests & Batching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25634,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25634"
    },
    {
      id: "Effect.cacheRequestResult",
      name: "cacheRequestResult",
      module: "Effect",
      package: "effect",
      signature: "<A extends Request.Request<any, any>>(request: A, result: Request.Result<A>) => Effect<void, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Requests & Batching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25654,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25654"
    },
    {
      id: "Effect.withRequestBatching",
      name: "withRequestBatching",
      module: "Effect",
      package: "effect",
      signature: "{ (requestBatching: boolean): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, requestBatching: boolean): Effect<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Requests & Batching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25659,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25659"
    },
    {
      id: "Effect.withRequestCaching",
      name: "withRequestCaching",
      module: "Effect",
      package: "effect",
      signature: "{ (strategy: boolean): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, strategy: boolean): Effect<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Requests & Batching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25675,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25675"
    },
    {
      id: "Effect.withRequestCache",
      name: "withRequestCache",
      module: "Effect",
      package: "effect",
      signature: "{ (cache: Cache): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, cache: Cache): Effect<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Requests & Batching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25691,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25691"
    },
    {
      id: "Effect.tracer",
      name: "tracer",
      module: "Effect",
      package: "effect",
      signature: "Effect<Tracer, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25707,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25707"
    },
    {
      id: "Effect.tracerWith",
      name: "tracerWith",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(f: (tracer: Tracer) => Effect<A, E, R>) => Effect<A, E, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25712,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25712"
    },
    {
      id: "Effect.withTracer",
      name: "withTracer",
      module: "Effect",
      package: "effect",
      signature: "{ (value: Tracer): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, value: Tracer): Effect<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25717,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25717"
    },
    {
      id: "Effect.withTracerScoped",
      name: "withTracerScoped",
      module: "Effect",
      package: "effect",
      signature: "(value: Tracer) => Effect<void, never, Scope>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25733,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25733"
    },
    {
      id: "Effect.withTracerEnabled",
      name: "withTracerEnabled",
      module: "Effect",
      package: "effect",
      signature: "{ (enabled: boolean): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, enabled: boolean): Effect<A, E, R>; }",
      description: "Disable the tracer for the given Effect.",
      documentation: 'Disable the tracer for the given Effect.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nEffect.succeed(42).pipe(\n  Effect.withSpan("my-span"),\n  // the span will not be registered with the tracer\n  Effect.withTracerEnabled(false)\n)\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nEffect.succeed(42).pipe(\n  Effect.withSpan("my-span"),\n  // the span will not be registered with the tracer\n  Effect.withTracerEnabled(false)\n)'
        }
      ],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25752,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25752"
    },
    {
      id: "Effect.withTracerTiming",
      name: "withTracerTiming",
      module: "Effect",
      package: "effect",
      signature: "{ (enabled: boolean): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, enabled: boolean): Effect<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25796,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25796"
    },
    {
      id: "Effect.annotateSpans",
      name: "annotateSpans",
      module: "Effect",
      package: "effect",
      signature: "{ (key: string, value: unknown): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; (values: Record<string, unknown>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, key: string, value: unknown): Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, values: Record<string, unknown>): Effect<A, E, R>; }",
      description: "Adds annotations to each span in the effect for enhanced traceability.",
      documentation: "Adds annotations to each span in the effect for enhanced traceability.\n\n**Details**\n\nThis function lets you attach key-value annotations to all spans generated\nduring the execution of an effect. Annotations provide additional context,\nsuch as metadata or labels, which can help you understand and debug\nasynchronous workflows more effectively.\n\nYou can either pass a single key-value pair or a record of key-value pairs to\nannotate the spans. These annotations can then be visualized in tracing tools\nthat support span annotations.",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25825,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25825"
    },
    {
      id: "Effect.annotateCurrentSpan",
      name: "annotateCurrentSpan",
      module: "Effect",
      package: "effect",
      signature: "{ (key: string, value: unknown): Effect<void, never, never>; (values: Record<string, unknown>): Effect<void, never, never>; }",
      description: "/\n * Adds annotations to the currently active span for traceability.\n *\n *",
      documentation: "/**\n * Adds annotations to the currently active span for traceability.\n *\n * **Details**\n *\n * This function adds key-value annotations to the currently active span in the\n * effect's trace. These annotations help provide more context about the\n * operation being executed at a specific point in time. Unlike\n * {@link annotateSpans}, which applies to all spans in an effect, this function\n * focuses solely on the active span.\n *\n * You can either pass a single key-value pair or a record of key-value pairs to\n * annotate the span. These annotations are useful for adding metadata to\n * operations, especially in systems with detailed observability requirements.\n *\n *",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25917,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25917"
    },
    {
      id: "Effect.currentSpan",
      name: "currentSpan",
      module: "Effect",
      package: "effect",
      signature: "Effect<Span, NoSuchElementException, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25961,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25961"
    },
    {
      id: "Effect.currentParentSpan",
      name: "currentParentSpan",
      module: "Effect",
      package: "effect",
      signature: "Effect<AnySpan, NoSuchElementException, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25966,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25966"
    },
    {
      id: "Effect.spanAnnotations",
      name: "spanAnnotations",
      module: "Effect",
      package: "effect",
      signature: "Effect<HashMap<string, unknown>, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25971,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25971"
    },
    {
      id: "Effect.spanLinks",
      name: "spanLinks",
      module: "Effect",
      package: "effect",
      signature: "Effect<Chunk<SpanLink>, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25976,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25976"
    },
    {
      id: "Effect.linkSpans",
      name: "linkSpans",
      module: "Effect",
      package: "effect",
      signature: "{ (span: AnySpan, attributes?: Record<string, unknown>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, span: AnySpan, attributes?: Record<string, unknown>): Effect<A, E, R>; }",
      description: "For all spans in this effect, add a link with the provided span.",
      documentation: "For all spans in this effect, add a link with the provided span.",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 25983,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25983"
    },
    {
      id: "Effect.linkSpanCurrent",
      name: "linkSpanCurrent",
      module: "Effect",
      package: "effect",
      signature: "{ (span: AnySpan, attributes?: Readonly<Record<string, unknown>>): Effect<void, never, never>; (links: readonly SpanLink[]): Effect<void, never, never>; }",
      description: "Add span links to the current span.",
      documentation: "Add span links to the current span.",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "3.14.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26005,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26005"
    },
    {
      id: "Effect.makeSpan",
      name: "makeSpan",
      module: "Effect",
      package: "effect",
      signature: "(name: string, options?: SpanOptions) => Effect<Span, never, never>",
      description: "Create a new span for tracing.",
      documentation: "Create a new span for tracing.",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26027,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26027"
    },
    {
      id: "Effect.makeSpanScoped",
      name: "makeSpanScoped",
      module: "Effect",
      package: "effect",
      signature: "(name: string, options?: SpanOptions) => Effect<Span, never, Scope>",
      description: "Create a new span for tracing, and automatically close it when the Scope\nfinalizes. The span is not added to the current span stack, so no child spans will be\ncreated for it.",
      documentation: "Create a new span for tracing, and automatically close it when the Scope\nfinalizes.\n\nThe span is not added to the current span stack, so no child spans will be\ncreated for it.",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26038,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26038"
    },
    {
      id: "Effect.useSpan",
      name: "useSpan",
      module: "Effect",
      package: "effect",
      signature: "{ <A, E, R>(name: string, evaluate: (span: Span) => Effect<A, E, R>): Effect<A, E, R>; <A, E, R>(name: string, options: SpanOptions, evaluate: (span: Span) => Effect<A, E, R>): Effect<A, E, R>; }",
      description: "Create a new span for tracing, and automatically close it when the effect\ncompletes. The span is not added to the current span stack, so no child spans will be\ncreated for it.",
      documentation: "Create a new span for tracing, and automatically close it when the effect\ncompletes.\n\nThe span is not added to the current span stack, so no child spans will be\ncreated for it.",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26049,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26049"
    },
    {
      id: "Effect.withSpan",
      name: "withSpan",
      module: "Effect",
      package: "effect",
      signature: "{ (name: string, options?: SpanOptions): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, ParentSpan>>; <A, E, R>(self: Effect<A, E, R>, name: string, options?: SpanOptions): Effect<A, E, Exclude<R, ParentSpan>>; }",
      description: "Wraps the effect with a new span for tracing.",
      documentation: "Wraps the effect with a new span for tracing.",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26079,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26079"
    },
    {
      id: "Effect.functionWithSpan",
      name: "functionWithSpan",
      module: "Effect",
      package: "effect",
      signature: "<Args extends Array<any>, Ret extends Effect<any, any, any>>(options: { readonly body: (...args: Args) => Ret; readonly options: FunctionWithSpanOptions | ((...args: Args) => FunctionWithSpanOptions); readonly captureStackTrace?: boolean; }) => (...args: Args) => Unify<Ret>",
      description: "Wraps a function that returns an effect with a new span for tracing.",
      documentation: 'Wraps a function that returns an effect with a new span for tracing.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nconst getTodo = Effect.functionWithSpan({\n  body: (id: number) => Effect.succeed(`Got todo ${id}!`),\n  options: (id) => ({\n    name: `getTodo-${id}`,\n    attributes: { id }\n  })\n})\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nconst getTodo = Effect.functionWithSpan({\n  body: (id: number) => Effect.succeed(`Got todo ${id}!`),\n  options: (id) => ({\n    name: `getTodo-${id}`,\n    attributes: { id }\n  })\n})'
        }
      ],
      tags: [
        "Tracing"
      ],
      since: "3.2.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26130,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26130"
    },
    {
      id: "Effect.withSpanScoped",
      name: "withSpanScoped",
      module: "Effect",
      package: "effect",
      signature: "{ (name: string, options?: SpanOptions): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Scope | Exclude<R, ParentSpan>>; <A, E, R>(self: Effect<A, E, R>, name: string, options?: SpanOptions): Effect<A, E, Scope | Exclude<R, ParentSpan>>; }",
      description: "Wraps the effect with a new span for tracing. The span is ended when the Scope is finalized.",
      documentation: "Wraps the effect with a new span for tracing.\n\nThe span is ended when the Scope is finalized.",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26143,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26143"
    },
    {
      id: "Effect.withParentSpan",
      name: "withParentSpan",
      module: "Effect",
      package: "effect",
      signature: "{ (span: AnySpan): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, ParentSpan>>; <A, E, R>(self: Effect<A, E, R>, span: AnySpan): Effect<A, E, Exclude<R, ParentSpan>>; }",
      description: "Adds the provided span to the current span stack.",
      documentation: "Adds the provided span to the current span stack.",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26169,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26169"
    },
    {
      id: "Effect.fromNullable",
      name: "fromNullable",
      module: "Effect",
      package: "effect",
      signature: "<A>(value: A) => Effect<NonNullable<A>, NoSuchElementException, never>",
      description: "Safely handles nullable values by creating an effect that fails for `null` or\n`undefined`.",
      documentation: "Safely handles nullable values by creating an effect that fails for `null` or\n`undefined`.\n\n**Details**\n\nThis function ensures that an input value is non-null and non-undefined\nbefore processing it. If the value is valid, the effect succeeds with the\nvalue. If the value is `null` or `undefined`, the effect fails with a\n`NoSuchElementException`. This is particularly useful for avoiding\nnull-related errors by clearly separating valid values from invalid ones in\neffectful computations.\n\nThe failure with `NoSuchElementException` allows you to explicitly handle\ncases where a value is expected but not provided, leading to safer and more\npredictable code.\n\n**When to Use**\n\nUse this function when working with values that may be `null` or `undefined`\nand you want to ensure that only non-null values are processed. It helps\nenforce null-safety and makes error handling more explicit.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, NoSuchElementException, never>\n//      \u25BC\nconst maybe1 = Effect.fromNullable(1)\n\nEffect.runPromiseExit(maybe1).then(console.log)\n// Output:\n// { _id: 'Exit', _tag: 'Success', value: 1 }\n\n//      \u250C\u2500\u2500\u2500 Effect<number, NoSuchElementException, never>\n//      \u25BC\nconst maybe2 = Effect.fromNullable(null as number | null)\n\nEffect.runPromiseExit(maybe2).then(console.log)\n// Output:\n// {\n//   _id: 'Exit',\n//   _tag: 'Failure',\n//   cause: {\n//     _id: 'Cause',\n//     _tag: 'Fail',\n//     failure: { _tag: 'NoSuchElementException' }\n//   }\n// }\n```",
      examples: [
        {
          code: `import { Effect } from "effect"

//      \u250C\u2500\u2500\u2500 Effect<number, NoSuchElementException, never>
//      \u25BC
const maybe1 = Effect.fromNullable(1)

Effect.runPromiseExit(maybe1).then(console.log)
// Output:
// { _id: 'Exit', _tag: 'Success', value: 1 }

//      \u250C\u2500\u2500\u2500 Effect<number, NoSuchElementException, never>
//      \u25BC
const maybe2 = Effect.fromNullable(null as number | null)

Effect.runPromiseExit(maybe2).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: { _tag: 'NoSuchElementException' }
//   }
// }`
        }
      ],
      tags: [
        "Optional Wrapping & Unwrapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26241,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26241"
    },
    {
      id: "Effect.optionFromOptional",
      name: "optionFromOptional",
      module: "Effect",
      package: "effect",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<Option<A>, Exclude<E, NoSuchElementException>, R>",
      description: "Converts an effect that may fail with a `NoSuchElementException` into an\neffect that succeeds with an `Option`.",
      documentation: "Converts an effect that may fail with a `NoSuchElementException` into an\neffect that succeeds with an `Option`.\n\n**Details**\n\nThis function transforms an effect that might fail with\n`Cause.NoSuchElementException` into an effect that succeeds with an `Option`\ntype. If the original effect succeeds, its value is wrapped in `Option.some`.\nIf it fails specifically due to a `NoSuchElementException`, the failure is\nmapped to `Option.none`. Other types of failures remain unchanged and are\npassed through as they are.\n\nThis is useful when working with effects where you want to gracefully handle\nthe absence of a value while preserving other potential failures.\n\n**When to Use**\n\nUse this function when you need to handle missing values as `Option.none`\nrather than throwing or propagating errors like `NoSuchElementException`.\nIt\u2019s ideal for scenarios where you want to explicitly represent optionality\nin a type-safe way while retaining other failure information.\n\n**Example**\n\n```ts\nimport { Effect } from \"effect\"\n\n//      \u250C\u2500\u2500\u2500 Effect<number, NoSuchElementException, never>\n//      \u25BC\nconst maybe1 = Effect.fromNullable(1)\n\n//      \u250C\u2500\u2500\u2500 Effect<Option<number>, never, never>\n//      \u25BC\nconst option1 = Effect.optionFromOptional(maybe1)\n\nEffect.runPromise(option1).then(console.log)\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n\n//      \u250C\u2500\u2500\u2500 Effect<number, NoSuchElementException, never>\n//      \u25BC\nconst maybe2 = Effect.fromNullable(null as number | null)\n\n//      \u250C\u2500\u2500\u2500 Effect<Option<number>, never, never>\n//      \u25BC\nconst option2 = Effect.optionFromOptional(maybe2)\n\nEffect.runPromise(option2).then(console.log)\n// Output: { _tag: 'None' }\n```",
      examples: [
        {
          code: `import { Effect } from "effect"

//      \u250C\u2500\u2500\u2500 Effect<number, NoSuchElementException, never>
//      \u25BC
const maybe1 = Effect.fromNullable(1)

//      \u250C\u2500\u2500\u2500 Effect<Option<number>, never, never>
//      \u25BC
const option1 = Effect.optionFromOptional(maybe1)

Effect.runPromise(option1).then(console.log)
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

//      \u250C\u2500\u2500\u2500 Effect<number, NoSuchElementException, never>
//      \u25BC
const maybe2 = Effect.fromNullable(null as number | null)

//      \u250C\u2500\u2500\u2500 Effect<Option<number>, never, never>
//      \u25BC
const option2 = Effect.optionFromOptional(maybe2)

Effect.runPromise(option2).then(console.log)
// Output: { _tag: 'None' }`
        }
      ],
      tags: [
        "Optional Wrapping & Unwrapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26296,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26296"
    },
    {
      id: "Effect.transposeOption",
      name: "transposeOption",
      module: "Effect",
      package: "effect",
      signature: "<A = never, E = never, R = never>(self: Option<Effect<A, E, R>>) => Effect<Option<A>, E, R>",
      description: "Converts an `Option` of an `Effect` into an `Effect` of an `Option`.",
      documentation: "Converts an `Option` of an `Effect` into an `Effect` of an `Option`.\n\n**Details**\n\nThis function transforms an `Option<Effect<A, E, R>>` into an\n`Effect<Option<A>, E, R>`. If the `Option` is `None`, the resulting `Effect`\nwill immediately succeed with a `None` value. If the `Option` is `Some`, the\ninner `Effect` will be executed, and its result wrapped in a `Some`.\n\n**Example**\n\n```ts\nimport { Effect, Option } from \"effect\"\n\n//      \u250C\u2500\u2500\u2500 Option<Effect<number, never, never>>\n//      \u25BC\nconst maybe = Option.some(Effect.succeed(42))\n\n//      \u250C\u2500\u2500\u2500 Effect<Option<number>, never, never>\n//      \u25BC\nconst result = Effect.transposeOption(maybe)\n\nconsole.log(Effect.runSync(result))\n// Output: { _id: 'Option', _tag: 'Some', value: 42 }\n```",
      examples: [
        {
          code: `import { Effect, Option } from "effect"

//      \u250C\u2500\u2500\u2500 Option<Effect<number, never, never>>
//      \u25BC
const maybe = Option.some(Effect.succeed(42))

//      \u250C\u2500\u2500\u2500 Effect<Option<number>, never, never>
//      \u25BC
const result = Effect.transposeOption(maybe)

console.log(Effect.runSync(result))
// Output: { _id: 'Option', _tag: 'Some', value: 42 }`
        }
      ],
      tags: [
        "Optional Wrapping & Unwrapping"
      ],
      since: "3.13.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26327,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26327"
    },
    {
      id: "Effect.transposeMapOption",
      name: "transposeMapOption",
      module: "Effect",
      package: "effect",
      signature: "(<A, B, E = never, R = never>(f: (self: A) => Effect<B, E, R>) => (self: Option<A>) => Effect<Option<B>, E, R>) & (<A, B, E = never, R = never>(self: Option<A>, f: (self: A) => Effect<B, E, R>) => Effect<Option<B>, E, R>)",
      description: "Applies an `Effect` on an `Option` and transposes the result.",
      documentation: "Applies an `Effect` on an `Option` and transposes the result.\n\n**Details**\n\nIf the `Option` is `None`, the resulting `Effect` will immediately succeed with a `None` value.\nIf the `Option` is `Some`, the effectful operation will be executed on the inner value, and its result wrapped in a `Some`.",
      examples: [
        {
          code: `import { Effect, Option, pipe } from "effect"

//          \u250C\u2500\u2500\u2500 Effect<Option<number>, never, never>>
//          \u25BC
const noneResult = pipe(
  Option.none(),
  Effect.transposeMapOption(() => Effect.succeed(42)) // will not be executed
)
console.log(Effect.runSync(noneResult))
// Output: { _id: 'Option', _tag: 'None' }

//          \u250C\u2500\u2500\u2500 Effect<Option<number>, never, never>>
//          \u25BC
const someSuccessResult = pipe(
  Option.some(42),
  Effect.transposeMapOption((value) => Effect.succeed(value * 2))
)
console.log(Effect.runSync(someSuccessResult))
// Output: { _id: 'Option', _tag: 'Some', value: 84 }`
        }
      ],
      tags: [
        "Optional Wrapping & Unwrapping"
      ],
      since: "3.14.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26362,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26362"
    },
    {
      id: "Effect.Tag",
      name: "Tag",
      module: "Effect",
      package: "effect",
      signature: "<const Id extends string>(id: Id) => <Self, Type extends Tag.AllowedType>() => TagClass<Self, Id, Type> & (Type extends Record<PropertyKey, any> ? Tag.Proxy<Self, Type> : {}) & { use: <X>(body: (_: Type) => X) => [X] extends [Effect<infer A, infer E, infer R>] ? Effect<A, E, Self | R> : [X] extends [PromiseLike<infer A>] ? Effect<A, UnknownException, Self> : Effect<X, never, Self>; }",
      description: "Creates a unique tag for a dependency, embedding the service's methods as\nstatic properties.",
      documentation: 'Creates a unique tag for a dependency, embedding the service\'s methods as\nstatic properties.\n\n**Details**\n\nThis function allows you to define a `Tag` for a service or dependency in\nyour application. The `Tag` not only acts as an identifier but also provides\ndirect access to the service\'s methods via static properties. This makes it\neasier to access and use the service in your code without manually managing\ncontexts.\n\nIn the example below, the fields of the service (in this case, the `notify`\nmethod) are turned into static properties of the Notifications class, making\nit easier to access them.\n\n**Example**\n\n```ts\nimport { Effect } from "effect"\n\nclass Notifications extends Effect.Tag("Notifications")<\n  Notifications,\n  { readonly notify: (message: string) => Effect.Effect<void> }\n>() {}\n\n// Create an effect that depends on the Notifications service\nconst action = Notifications.notify("Hello, world!")\n```',
      examples: [
        {
          code: 'import { Effect } from "effect"\n\nclass Notifications extends Effect.Tag("Notifications")<\n  Notifications,\n  { readonly notify: (message: string) => Effect.Effect<void> }\n>() {}\n\n// Create an effect that depends on the Notifications service\nconst action = Notifications.notify("Hello, world!")'
        }
      ],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26430,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26430"
    },
    {
      id: "Effect.Service",
      name: "Service",
      module: "Effect",
      package: "effect",
      signature: '<Self = never>() => [Self] extends [never] ? "Missing `Self` generic - use `class Self extends Effect.Service<Self>()...`" : { <const Key extends string, const Make extends { readonly scoped: Effect<Service.AllowedType<Key, Make>, any, any> | ((...args: any) => Effect<Service.AllowedType<Key, Make>, any, any>); readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly \u0CA0_\u0CA0: never; } | { readonly effect: Effect<Service.AllowedType<Key, Make>, any, any> | ((...args: any) => Effect<Service.AllowedType<Key, Make>, any, any>); readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly \u0CA0_\u0CA0: never; } | { readonly sync: LazyArg<Service.AllowedType<Key, Make>>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly \u0CA0_\u0CA0: never; } | { readonly succeed: Service.AllowedType<Key, Make>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly \u0CA0_\u0CA0: never; }>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly scoped: Effect<Service.AllowedType<Key, Make>, any, any> | ((...args: any) => Effect<Service.AllowedType<Key, Make>, any, any>); readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly effect: Effect<Service.AllowedType<Key, Make>, any, any> | ((...args: any) => Effect<Service.AllowedType<Key, Make>, any, any>); readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly sync: LazyArg<Service.AllowedType<Key, Make>>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly succeed: Service.AllowedType<Key, Make>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; }',
      description: "Simplifies the creation and management of services in Effect by defining both\na `Tag` and a `Layer`.",
      documentation: 'Simplifies the creation and management of services in Effect by defining both\na `Tag` and a `Layer`.\n\n**Details**\n\nThis function allows you to streamline the creation of services by combining\nthe definition of a `Context.Tag` and a `Layer` in a single step. It supports\nvarious ways of providing the service implementation:\n- Using an `effect` to define the service dynamically.\n- Using `sync` or `succeed` to define the service statically.\n- Using `scoped` to create services with lifecycle management.\n\nIt also allows you to specify dependencies for the service, which will be\nprovided automatically when the service is used. Accessors can be optionally\ngenerated for the service, making it more convenient to use.\n\n**Example**\n\n```ts\nimport { Effect } from \'effect\';\n\nclass Prefix extends Effect.Service<Prefix>()("Prefix", {\n sync: () => ({ prefix: "PRE" })\n}) {}\n\nclass Logger extends Effect.Service<Logger>()("Logger", {\n accessors: true,\n effect: Effect.gen(function* () {\n   const { prefix } = yield* Prefix\n   return {\n     info: (message: string) =>\n       Effect.sync(() => {\n         console.log(`[${prefix}][${message}]`)\n       })\n   }\n }),\n dependencies: [Prefix.Default]\n}) {}\n```',
      examples: [
        {
          code: 'import { Effect } from \'effect\';\n\nclass Prefix extends Effect.Service<Prefix>()("Prefix", {\n sync: () => ({ prefix: "PRE" })\n}) {}\n\nclass Logger extends Effect.Service<Logger>()("Logger", {\n accessors: true,\n effect: Effect.gen(function* () {\n   const { prefix } = yield* Prefix\n   return {\n     info: (message: string) =>\n       Effect.sync(() => {\n         console.log(`[${prefix}][${message}]`)\n       })\n   }\n }),\n dependencies: [Prefix.Default]\n}) {}'
        }
      ],
      tags: [
        "Context"
      ],
      since: "3.9.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26479,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26479"
    },
    {
      id: "Effect.fn",
      name: "fn",
      module: "Effect",
      package: "effect",
      signature: "fn.Gen & fn.NonGen & ((name: string, options?: SpanOptions) => fn.Gen & fn.NonGen)",
      description: "The `Effect.fn` function allows you to create traced functions that return an\neffect. It provides two key features: - Stack traces with location details if an error occurs.\n- Automatic span creation for tracing when a span name is provided. If a span name is passed as the first argument, the function's execution is\ntracked using that name. If no name is provided, stack tracing still works,\nbut spans are not created. A function can be defined using either: - A generator function, allowing the use of `yield*` for effect composition.\n- A regular function that returns an `Effect`. `Effect.fn` automatically creates spans. The spans capture information about\nthe function execution, including metadata and error details. `Effect.fn` also acts as a pipe function, allowing you to create a pipeline\nafter the function definition using the effect returned by the generator\nfunction as the starting value of the pipeline.",
      documentation: "The `Effect.fn` function allows you to create traced functions that return an\neffect. It provides two key features:\n\n- **Stack traces with location details** if an error occurs.\n- **Automatic span creation** for tracing when a span name is provided.\n\nIf a span name is passed as the first argument, the function's execution is\ntracked using that name. If no name is provided, stack tracing still works,\nbut spans are not created.\n\nA function can be defined using either:\n\n- A generator function, allowing the use of `yield*` for effect composition.\n- A regular function that returns an `Effect`.\n\n**Example** (Creating a Traced Function with a Span Name)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst myfunc = Effect.fn(\"myspan\")(function* <N extends number>(n: N) {\n  yield* Effect.annotateCurrentSpan(\"n\", n) // Attach metadata to the span\n  console.log(`got: ${n}`)\n  yield* Effect.fail(new Error(\"Boom!\")) // Simulate failure\n})\n\nEffect.runFork(myfunc(100).pipe(Effect.catchAllCause(Effect.logError)))\n// Output:\n// got: 100\n// timestamp=... level=ERROR fiber=#0 cause=\"Error: Boom!\n//     at <anonymous> (/.../index.ts:6:22) <= Raise location\n//     at myspan (/.../index.ts:3:23)  <= Definition location\n//     at myspan (/.../index.ts:9:16)\" <= Call location\n```\n\n`Effect.fn` automatically creates spans. The spans capture information about\nthe function execution, including metadata and error details.\n\n**Example** (Exporting Spans to the Console)\n\n```ts skip-type-checking\nimport { Effect } from \"effect\"\nimport { NodeSdk } from \"@effect/opentelemetry\"\nimport {\n  ConsoleSpanExporter,\n  BatchSpanProcessor\n} from \"@opentelemetry/sdk-trace-base\"\n\nconst myfunc = Effect.fn(\"myspan\")(function* <N extends number>(n: N) {\n  yield* Effect.annotateCurrentSpan(\"n\", n)\n  console.log(`got: ${n}`)\n  yield* Effect.fail(new Error(\"Boom!\"))\n})\n\nconst program = myfunc(100)\n\nconst NodeSdkLive = NodeSdk.layer(() => ({\n  resource: { serviceName: \"example\" },\n  // Export span data to the console\n  spanProcessor: new BatchSpanProcessor(new ConsoleSpanExporter())\n}))\n\nEffect.runFork(program.pipe(Effect.provide(NodeSdkLive)))\n// Output:\n// got: 100\n// {\n//   resource: {\n//     attributes: {\n//       'service.name': 'example',\n//       'telemetry.sdk.language': 'nodejs',\n//       'telemetry.sdk.name': '@effect/opentelemetry',\n//       'telemetry.sdk.version': '1.30.1'\n//     }\n//   },\n//   instrumentationScope: { name: 'example', version: undefined, schemaUrl: undefined },\n//   traceId: '22801570119e57a6e2aacda3dec9665b',\n//   parentId: undefined,\n//   traceState: undefined,\n//   name: 'myspan',\n//   id: '7af530c1e01bc0cb',\n//   kind: 0,\n//   timestamp: 1741182277518402.2,\n//   duration: 4300.416,\n//   attributes: {\n//     n: 100,\n//     'code.stacktrace': 'at <anonymous> (/.../index.ts:8:23)\\n' +\n//       'at <anonymous> (/.../index.ts:14:17)'\n//   },\n//   status: { code: 2, message: 'Boom!' },\n//   events: [\n//     {\n//       name: 'exception',\n//       attributes: {\n//         'exception.type': 'Error',\n//         'exception.message': 'Boom!',\n//         'exception.stacktrace': 'Error: Boom!\\n' +\n//           '    at <anonymous> (/.../index.ts:11:22)\\n' +\n//           '    at myspan (/.../index.ts:8:23)\\n' +\n//           '    at myspan (/.../index.ts:14:17)'\n//       },\n//       time: [ 1741182277, 522702583 ],\n//       droppedAttributesCount: 0\n//     }\n//   ],\n//   links: []\n// }\n```\n\n`Effect.fn` also acts as a pipe function, allowing you to create a pipeline\nafter the function definition using the effect returned by the generator\nfunction as the starting value of the pipeline.\n\n**Example** (Creating a Traced Function with a Delay)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst myfunc = Effect.fn(\n  function* (n: number) {\n    console.log(`got: ${n}`)\n    yield* Effect.fail(new Error(\"Boom!\"))\n  },\n  // You can access both the created effect and the original arguments\n  (effect, n) => Effect.delay(effect, `${n / 100} seconds`)\n)\n\nEffect.runFork(myfunc(100).pipe(Effect.catchAllCause(Effect.logError)))\n// Output:\n// got: 100\n// timestamp=... level=ERROR fiber=#0 cause=\"Error: Boom! (<= after 1 second)\n```",
      examples: [
        {
          title: "Creating a Traced Function with a Span Name",
          code: 'import { Effect } from "effect"\n\nconst myfunc = Effect.fn("myspan")(function* <N extends number>(n: N) {\n  yield* Effect.annotateCurrentSpan("n", n) // Attach metadata to the span\n  console.log(`got: ${n}`)\n  yield* Effect.fail(new Error("Boom!")) // Simulate failure\n})\n\nEffect.runFork(myfunc(100).pipe(Effect.catchAllCause(Effect.logError)))\n// Output:\n// got: 100\n// timestamp=... level=ERROR fiber=#0 cause="Error: Boom!\n//     at <anonymous> (/.../index.ts:6:22) <= Raise location\n//     at myspan (/.../index.ts:3:23)  <= Definition location\n//     at myspan (/.../index.ts:9:16)" <= Call location'
        },
        {
          title: "Exporting Spans to the Console",
          code: `import { Effect } from "effect"
import { NodeSdk } from "@effect/opentelemetry"
import {
  ConsoleSpanExporter,
  BatchSpanProcessor
} from "@opentelemetry/sdk-trace-base"

const myfunc = Effect.fn("myspan")(function* <N extends number>(n: N) {
  yield* Effect.annotateCurrentSpan("n", n)
  console.log(\`got: \${n}\`)
  yield* Effect.fail(new Error("Boom!"))
})

const program = myfunc(100)

const NodeSdkLive = NodeSdk.layer(() => ({
  resource: { serviceName: "example" },
  // Export span data to the console
  spanProcessor: new BatchSpanProcessor(new ConsoleSpanExporter())
}))

Effect.runFork(program.pipe(Effect.provide(NodeSdkLive)))
// Output:
// got: 100
// {
//   resource: {
//     attributes: {
//       'service.name': 'example',
//       'telemetry.sdk.language': 'nodejs',
//       'telemetry.sdk.name': '@effect/opentelemetry',
//       'telemetry.sdk.version': '1.30.1'
//     }
//   },
//   instrumentationScope: { name: 'example', version: undefined, schemaUrl: undefined },
//   traceId: '22801570119e57a6e2aacda3dec9665b',
//   parentId: undefined,
//   traceState: undefined,
//   name: 'myspan',
//   id: '7af530c1e01bc0cb',
//   kind: 0,
//   timestamp: 1741182277518402.2,
//   duration: 4300.416,
//   attributes: {
//     n: 100,
//     'code.stacktrace': 'at <anonymous> (/.../index.ts:8:23)\\n' +
//       'at <anonymous> (/.../index.ts:14:17)'
//   },
//   status: { code: 2, message: 'Boom!' },
//   events: [
//     {
//       name: 'exception',
//       attributes: {
//         'exception.type': 'Error',
//         'exception.message': 'Boom!',
//         'exception.stacktrace': 'Error: Boom!\\n' +
//           '    at <anonymous> (/.../index.ts:11:22)\\n' +
//           '    at myspan (/.../index.ts:8:23)\\n' +
//           '    at myspan (/.../index.ts:14:17)'
//       },
//       time: [ 1741182277, 522702583 ],
//       droppedAttributesCount: 0
//     }
//   ],
//   links: []
// }`
        },
        {
          title: "Creating a Traced Function with a Delay",
          code: 'import { Effect } from "effect"\n\nconst myfunc = Effect.fn(\n  function* (n: number) {\n    console.log(`got: ${n}`)\n    yield* Effect.fail(new Error("Boom!"))\n  },\n  // You can access both the created effect and the original arguments\n  (effect, n) => Effect.delay(effect, `${n / 100} seconds`)\n)\n\nEffect.runFork(myfunc(100).pipe(Effect.catchAllCause(Effect.logError)))\n// Output:\n// got: 100\n// timestamp=... level=ERROR fiber=#0 cause="Error: Boom! (<= after 1 second)'
        }
      ],
      tags: [
        "Tracing"
      ],
      since: "3.11.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26934,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26934"
    },
    {
      id: "Effect.fnUntraced",
      name: "fnUntraced",
      module: "Effect",
      package: "effect",
      signature: "fn.Untraced",
      description: "/\n * Same as {@link fn}, but allows you to create a function that is not traced, for when performance is critical.\n *\n *",
      documentation: "/**\n * Same as {@link fn}, but allows you to create a function that is not traced, for when performance is critical.\n *\n *",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "3.12.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26943,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26943"
    },
    {
      id: "Effect.ensureSuccessType",
      name: "ensureSuccessType",
      module: "Effect",
      package: "effect",
      signature: "<A>() => <A2 extends A, E, R>(effect: Effect<A2, E, R>) => Effect<A2, E, R>",
      description: "A no-op type constraint that enforces the success channel of an Effect conforms to\nthe specified success type `A`.",
      documentation: "A no-op type constraint that enforces the success channel of an Effect conforms to\nthe specified success type `A`.",
      examples: [
        {
          code: 'import { Effect } from "effect"\n\n// Ensure that the program does not expose any unhandled errors.\nconst program = Effect.succeed(42).pipe(Effect.ensureSuccessType<number>())'
        }
      ],
      tags: [
        "Type constraints"
      ],
      since: "3.17.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26957,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26957"
    },
    {
      id: "Effect.ensureErrorType",
      name: "ensureErrorType",
      module: "Effect",
      package: "effect",
      signature: "<E>() => <A, E2 extends E, R>(effect: Effect<A, E2, R>) => Effect<A, E2, R>",
      description: "A no-op type constraint that enforces the error channel of an Effect conforms to\nthe specified error type `E`.",
      documentation: "A no-op type constraint that enforces the error channel of an Effect conforms to\nthe specified error type `E`.",
      examples: [
        {
          code: 'import { Effect } from "effect"\n\n// Ensure that the program does not expose any unhandled errors.\nconst program = Effect.succeed(42).pipe(Effect.ensureErrorType<never>())'
        }
      ],
      tags: [
        "Type constraints"
      ],
      since: "3.17.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26971,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26971"
    },
    {
      id: "Effect.ensureRequirementsType",
      name: "ensureRequirementsType",
      module: "Effect",
      package: "effect",
      signature: "<R>() => <A, E, R2 extends R>(effect: Effect<A, E, R2>) => Effect<A, E, R2>",
      description: "A no-op type constraint that enforces the requirements channel of an Effect conforms to\nthe specified requirements type `R`.",
      documentation: "A no-op type constraint that enforces the requirements channel of an Effect conforms to\nthe specified requirements type `R`.",
      examples: [
        {
          code: 'import { Effect } from "effect"\n\n// Ensure that the program does not have any requirements.\nconst program = Effect.succeed(42).pipe(Effect.ensureRequirementsType<never>())'
        }
      ],
      tags: [
        "Type constraints"
      ],
      since: "3.17.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
      sourceLine: 26985,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26985"
    },
    {
      id: "Stream.StreamTypeId",
      name: "StreamTypeId",
      module: "Stream",
      package: "effect",
      signature: "typeof StreamTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 40,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L40"
    },
    {
      id: "Stream.DefaultChunkSize",
      name: "DefaultChunkSize",
      module: "Stream",
      package: "effect",
      signature: "number",
      description: "The default chunk size used by the various combinators and constructors of\n`Stream`.",
      documentation: "The default chunk size used by the various combinators and constructors of\n`Stream`.",
      examples: [],
      tags: [
        "constants"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 157,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L157"
    },
    {
      id: "Stream.accumulate",
      name: "accumulate",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(self: Stream<A, E, R>) => Stream<Chunk<A>, E, R>",
      description: "Collects each underlying Chunk of the stream into a new chunk, and emits it\non each pull.",
      documentation: "Collects each underlying Chunk of the stream into a new chunk, and emits it\non each pull.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 165,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L165"
    },
    {
      id: "Stream.accumulateChunks",
      name: "accumulateChunks",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>",
      description: "Re-chunks the elements of the stream by accumulating each underlying chunk.",
      documentation: "Re-chunks the elements of the stream by accumulating each underlying chunk.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 172,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L172"
    },
    {
      id: "Stream.acquireRelease",
      name: "acquireRelease",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R, R2, X>(acquire: Effect<A, E, R>, release: (resource: A, exit: Exit<unknown, unknown>) => Effect<X, never, R2>) => Stream<A, E, R | R2>",
      description: "Creates a stream from a single value that will get cleaned up after the\nstream is consumed.",
      documentation: "Creates a stream from a single value that will get cleaned up after the\nstream is consumed.",
      examples: [
        {
          code: `import { Console, Effect, Stream } from "effect"

// Simulating File operations
const open = (filename: string) =>
  Effect.gen(function*() {
    yield* Console.log(\`Opening \${filename}\`)
    return {
      getLines: Effect.succeed(["Line 1", "Line 2", "Line 3"]),
      close: Console.log(\`Closing \${filename}\`)
    }
  })

const stream = Stream.acquireRelease(
  open("file.txt"),
  (file) => file.close
).pipe(Stream.flatMap((file) => file.getLines))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// Opening file.txt
// Closing file.txt
// { _id: 'Chunk', values: [ [ 'Line 1', 'Line 2', 'Line 3' ] ] }`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 205,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L205"
    },
    {
      id: "Stream.aggregate",
      name: "aggregate",
      module: "Stream",
      package: "effect",
      signature: "{ <B, A, A2, E2, R2>(sink: Sink<B, A | A2, A2, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<B, E2 | E, R2 | R>; <A, E, R, B, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink<B, A | A2, A2, E2, R2>): Stream<B, E | E2, R | R2>; }",
      description: 'Aggregates elements of this stream using the provided sink for as long as\nthe downstream operators on the stream are busy. This operator divides the stream into two asynchronous "islands". Operators\nupstream of this operator run on one fiber, while downstream operators run\non another. Whenever the downstream fiber is busy processing elements, the\nupstream fiber will feed elements into the sink until it signals\ncompletion. Any sink can be used here, but see `Sink.foldWeightedEffect` and\n`Sink.foldUntilEffect` for sinks that cover the common usecases.',
      documentation: 'Aggregates elements of this stream using the provided sink for as long as\nthe downstream operators on the stream are busy.\n\nThis operator divides the stream into two asynchronous "islands". Operators\nupstream of this operator run on one fiber, while downstream operators run\non another. Whenever the downstream fiber is busy processing elements, the\nupstream fiber will feed elements into the sink until it signals\ncompletion.\n\nAny sink can be used here, but see `Sink.foldWeightedEffect` and\n`Sink.foldUntilEffect` for sinks that cover the common usecases.',
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 222,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L222"
    },
    {
      id: "Stream.aggregateWithin",
      name: "aggregateWithin",
      module: "Stream",
      package: "effect",
      signature: "{ <B, A, A2, E2, R2, C, R3>(sink: Sink<B, A | A2, A2, E2, R2>, schedule: Schedule<C, Option<B>, R3>): <E, R>(self: Stream<A, E, R>) => Stream<B, E2 | E, R2 | R3 | R>; <A, E, R, B, A2, E2, R2, C, R3>(self: Stream<A, E, R>, sink: Sink<B, A | A2, A2, E2, R2>, schedule: Schedule<C, Option<B>, R3>): Stream<B, E | E2, R | R2 | R3>; }",
      description: "/\n * Like {@link aggregateWithinEither}, but only returns the `Right` results.\n *\n *",
      documentation: "/**\n * Like {@link aggregateWithinEither}, but only returns the `Right` results.\n *\n *",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 264,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L264"
    },
    {
      id: "Stream.aggregateWithinEither",
      name: "aggregateWithinEither",
      module: "Stream",
      package: "effect",
      signature: "{ <B, A, A2, E2, R2, C, R3>(sink: Sink<B, A | A2, A2, E2, R2>, schedule: Schedule<C, Option<B>, R3>): <E, R>(self: Stream<A, E, R>) => Stream<Either<B, C>, E2 | E, R2 | R3 | R>; <A, E, R, B, A2, E2, R2, C, R3>(self: Stream<A, E, R>, sink: Sink<B, A | A2, A2, E2, R2>, schedule: Schedule<C, Option<B>, R3>): Stream<Either<B, C>, E | E2, R | R2 | R3>; }",
      description: "Aggregates elements using the provided sink until it completes, or until\nthe delay signalled by the schedule has passed. This operator divides the stream into two asynchronous islands. Operators\nupstream of this operator run on one fiber, while downstream operators run\non another. Elements will be aggregated by the sink until the downstream\nfiber pulls the aggregated value, or until the schedule's delay has passed. Aggregated elements will be fed into the schedule to determine the delays\nbetween pulls.",
      documentation: "Aggregates elements using the provided sink until it completes, or until\nthe delay signalled by the schedule has passed.\n\nThis operator divides the stream into two asynchronous islands. Operators\nupstream of this operator run on one fiber, while downstream operators run\non another. Elements will be aggregated by the sink until the downstream\nfiber pulls the aggregated value, or until the schedule's delay has passed.\n\nAggregated elements will be fed into the schedule to determine the delays\nbetween pulls.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 295,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L295"
    },
    {
      id: "Stream.as",
      name: "as",
      module: "Stream",
      package: "effect",
      signature: "{ <B>(value: B): <A, E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, E, R, B>(self: Stream<A, E, R>, value: B): Stream<B, E, R>; }",
      description: "Maps the success values of this stream to the specified constant value.",
      documentation: "Maps the success values of this stream to the specified constant value.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

const stream = Stream.range(1, 5).pipe(Stream.as(null))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ null, null, null, null, null ] }`
        }
      ],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 345,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L345"
    },
    {
      id: "Stream.asyncEffect",
      name: "asyncEffect",
      module: "Stream",
      package: "effect",
      signature: '<A, E = never, R = never>(register: (emit: Emit<R, E, A, void>) => Effect<unknown, E, R>, bufferSize?: number | "unbounded" | { readonly bufferSize?: number; readonly strategy?: "dropping" | "sliding" | "suspend"; }) => Stream<A, E, R>',
      description: "Creates a stream from an asynchronous callback that can be called multiple\ntimes The registration of the callback itself returns an effect. The\noptionality of the error type `E` can be used to signal the end of the\nstream, by setting it to `None`.",
      documentation: "Creates a stream from an asynchronous callback that can be called multiple\ntimes The registration of the callback itself returns an effect. The\noptionality of the error type `E` can be used to signal the end of the\nstream, by setting it to `None`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 432,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L432"
    },
    {
      id: "Stream.asyncPush",
      name: "asyncPush",
      module: "Stream",
      package: "effect",
      signature: '<A, E = never, R = never>(register: (emit: EmitOpsPush<E, A>) => Effect<unknown, E, Scope | R>, options?: { readonly bufferSize: "unbounded"; } | { readonly bufferSize?: number; readonly strategy?: "dropping" | "sliding"; }) => Stream<A, E, Exclude<R, Scope>>',
      description: 'Creates a stream from an external push-based resource. You can use the `emit` helper to emit values to the stream. The `emit` helper\nreturns a boolean indicating whether the value was emitted or not. You can also use the `emit` helper to signal the end of the stream by\nusing apis such as `emit.end` or `emit.fail`. By default it uses an "unbounded" buffer size.\nYou can customize the buffer size and strategy by passing an object as the\nsecond argument with the `bufferSize` and `strategy` fields.',
      documentation: 'Creates a stream from an external push-based resource.\n\nYou can use the `emit` helper to emit values to the stream. The `emit` helper\nreturns a boolean indicating whether the value was emitted or not.\n\nYou can also use the `emit` helper to signal the end of the stream by\nusing apis such as `emit.end` or `emit.fail`.\n\nBy default it uses an "unbounded" buffer size.\nYou can customize the buffer size and strategy by passing an object as the\nsecond argument with the `bufferSize` and `strategy` fields.',
      examples: [
        {
          code: 'import { Effect, Stream } from "effect"\n\nStream.asyncPush<string>((emit) =>\n  Effect.acquireRelease(\n    Effect.gen(function*() {\n      yield* Effect.log("subscribing")\n      return setInterval(() => emit.single("tick"), 1000)\n    }),\n    (handle) =>\n      Effect.gen(function*() {\n        yield* Effect.log("unsubscribing")\n        clearInterval(handle)\n      })\n  ), { bufferSize: 16, strategy: "dropping" })'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 470,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L470"
    },
    {
      id: "Stream.asyncScoped",
      name: "asyncScoped",
      module: "Stream",
      package: "effect",
      signature: '<A, E = never, R = never>(register: (emit: Emit<R, E, A, void>) => Effect<unknown, E, Scope | R>, bufferSize?: number | "unbounded" | { readonly bufferSize?: number; readonly strategy?: "dropping" | "sliding" | "suspend"; }) => Stream<A, E, Exclude<R, Scope>>',
      description: "Creates a stream from an asynchronous callback that can be called multiple\ntimes. The registration of the callback itself returns an a scoped\nresource. The optionality of the error type `E` can be used to signal the\nend of the stream, by setting it to `None`.",
      documentation: "Creates a stream from an asynchronous callback that can be called multiple\ntimes. The registration of the callback itself returns an a scoped\nresource. The optionality of the error type `E` can be used to signal the\nend of the stream, by setting it to `None`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 485,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L485"
    },
    {
      id: "Stream.branchAfter",
      name: "branchAfter",
      module: "Stream",
      package: "effect",
      signature: "{ <A, A2, E2, R2>(n: number, f: (input: Chunk<A>) => Stream<A2, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, n: number, f: (input: Chunk<A>) => Stream<A2, E2, R2>): Stream<A2, E | E2, R | R2>; }",
      description: "Returns a `Stream` that first collects `n` elements from the input `Stream`,\nand then creates a new `Stream` using the specified function, and sends all\nthe following elements through that.",
      documentation: "Returns a `Stream` that first collects `n` elements from the input `Stream`,\nand then creates a new `Stream` using the specified function, and sends all\nthe following elements through that.",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 497,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L497"
    },
    {
      id: "Stream.broadcast",
      name: "broadcast",
      module: "Stream",
      package: "effect",
      signature: '{ <N extends number>(n: N, maximumLag: number | { readonly capacity: "unbounded"; readonly replay?: number; } | { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend"; readonly replay?: number; }): <A, E, R>(self: Stream<A, E, R>) => Effect<TupleOf<N, Stream<A, E, never>>, never, Scope | R>; <A, E, R, N extends number>(self: Stream<A, E, R>, n: N, maximumLag: number | { readonly capacity: "unbounded"; readonly replay?: number; } | { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend"; readonly replay?: number; }): Effect<TupleOf<N, Stream<A, E, never>>, never, Scope | R>; }',
      description: "Fan out the stream, producing a list of streams that have the same elements\nas this stream. The driver stream will only ever advance the `maximumLag`\nchunks before the slowest downstream stream.",
      documentation: "Fan out the stream, producing a list of streams that have the same elements\nas this stream. The driver stream will only ever advance the `maximumLag`\nchunks before the slowest downstream stream.",
      examples: [
        {
          code: 'import { Console, Effect, Fiber, Schedule, Stream } from "effect"\n\nconst numbers = Effect.scoped(\n  Stream.range(1, 20).pipe(\n    Stream.tap((n) => Console.log(`Emit ${n} element before broadcasting`)),\n    Stream.broadcast(2, 5),\n    Stream.flatMap(([first, second]) =>\n      Effect.gen(function*() {\n        const fiber1 = yield* Stream.runFold(first, 0, (acc, e) => Math.max(acc, e)).pipe(\n          Effect.andThen((max) => Console.log(`Maximum: ${max}`)),\n          Effect.fork\n        )\n        const fiber2 = yield* second.pipe(\n          Stream.schedule(Schedule.spaced("1 second")),\n          Stream.runForEach((n) => Console.log(`Logging to the Console: ${n}`)),\n          Effect.fork\n        )\n        yield* Fiber.join(fiber1).pipe(\n          Effect.zip(Fiber.join(fiber2), { concurrent: true })\n        )\n      })\n    ),\n    Stream.runCollect\n  )\n)\n\nEffect.runPromise(numbers).then(console.log)\n// Emit 1 element before broadcasting\n// Emit 2 element before broadcasting\n// Emit 3 element before broadcasting\n// Emit 4 element before broadcasting\n// Emit 5 element before broadcasting\n// Emit 6 element before broadcasting\n// Emit 7 element before broadcasting\n// Emit 8 element before broadcasting\n// Emit 9 element before broadcasting\n// Emit 10 element before broadcasting\n// Emit 11 element before broadcasting\n// Logging to the Console: 1\n// Logging to the Console: 2\n// Logging to the Console: 3\n// Logging to the Console: 4\n// Logging to the Console: 5\n// Emit 12 element before broadcasting\n// Emit 13 element before broadcasting\n// Emit 14 element before broadcasting\n// Emit 15 element before broadcasting\n// Emit 16 element before broadcasting\n// Logging to the Console: 6\n// Logging to the Console: 7\n// Logging to the Console: 8\n// Logging to the Console: 9\n// Logging to the Console: 10\n// Emit 17 element before broadcasting\n// Emit 18 element before broadcasting\n// Emit 19 element before broadcasting\n// Emit 20 element before broadcasting\n// Logging to the Console: 11\n// Logging to the Console: 12\n// Logging to the Console: 13\n// Logging to the Console: 14\n// Logging to the Console: 15\n// Maximum: 20\n// Logging to the Console: 16\n// Logging to the Console: 17\n// Logging to the Console: 18\n// Logging to the Console: 19\n// Logging to the Console: 20\n// { _id: \'Chunk\', values: [ undefined ] }'
        }
      ],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 598,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L598"
    },
    {
      id: "Stream.share",
      name: "share",
      module: "Stream",
      package: "effect",
      signature: '{ <A, E>(config: { readonly capacity: "unbounded"; readonly replay?: number; readonly idleTimeToLive?: DurationInput; } | { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend"; readonly replay?: number; readonly idleTimeToLive?: DurationInput; }): <R>(self: Stream<A, E, R>) => Effect<Stream<A, E, never>, never, Scope | R>; <A, E, R>(self: Stream<A, E, R>, config: { readonly capacity: "unbounded"; readonly replay?: number; readonly idleTimeToLive?: DurationInput; } | { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend"; readonly replay?: number; readonly idleTimeToLive?: DurationInput; }): Effect<Stream<A, E, never>, never, Scope | R>; }',
      description: "Returns a new Stream that multicasts the original Stream, subscribing to it as soon as the first consumer subscribes.\nAs long as there is at least one consumer, the upstream will continue running and emitting data.\nWhen all consumers have exited, the upstream will be finalized.",
      documentation: "Returns a new Stream that multicasts the original Stream, subscribing to it as soon as the first consumer subscribes.\nAs long as there is at least one consumer, the upstream will continue running and emitting data.\nWhen all consumers have exited, the upstream will be finalized.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "3.8.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 786,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L786"
    },
    {
      id: "Stream.broadcastDynamic",
      name: "broadcastDynamic",
      module: "Stream",
      package: "effect",
      signature: '{ (maximumLag: number | { readonly capacity: "unbounded"; readonly replay?: number; } | { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend"; readonly replay?: number; }): <A, E, R>(self: Stream<A, E, R>) => Effect<Stream<A, E, never>, never, Scope | R>; <A, E, R>(self: Stream<A, E, R>, maximumLag: number | { readonly capacity: "unbounded"; readonly replay?: number; } | { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend"; readonly replay?: number; }): Effect<Stream<A, E, never>, never, Scope | R>; }',
      description: "Fan out the stream, producing a dynamic number of streams that have the\nsame elements as this stream. The driver stream will only ever advance the\n`maximumLag` chunks before the slowest downstream stream.",
      documentation: "Fan out the stream, producing a dynamic number of streams that have the\nsame elements as this stream. The driver stream will only ever advance the\n`maximumLag` chunks before the slowest downstream stream.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 832,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L832"
    },
    {
      id: "Stream.broadcastedQueues",
      name: "broadcastedQueues",
      module: "Stream",
      package: "effect",
      signature: '{ <N extends number>(n: N, maximumLag: number | { readonly capacity: "unbounded"; readonly replay?: number; } | { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend"; readonly replay?: number; }): <A, E, R>(self: Stream<A, E, R>) => Effect<TupleOf<N, Dequeue<Take<A, E>>>, never, Scope | R>; <A, E, R, N extends number>(self: Stream<A, E, R>, n: N, maximumLag: number | { readonly capacity: "unbounded"; readonly replay?: number; } | { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend"; readonly replay?: number; }): Effect<TupleOf<N, Dequeue<Take<A, E>>>, never, Scope | R>; }',
      description: "Converts the stream to a scoped list of queues. Every value will be\nreplicated to every queue with the slowest queue being allowed to buffer\n`maximumLag` chunks before the driver is back pressured. Queues can unsubscribe from upstream by shutting down.",
      documentation: "Converts the stream to a scoped list of queues. Every value will be\nreplicated to every queue with the slowest queue being allowed to buffer\n`maximumLag` chunks before the driver is back pressured.\n\nQueues can unsubscribe from upstream by shutting down.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 876,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L876"
    },
    {
      id: "Stream.broadcastedQueuesDynamic",
      name: "broadcastedQueuesDynamic",
      module: "Stream",
      package: "effect",
      signature: '{ (maximumLag: number | { readonly capacity: "unbounded"; readonly replay?: number; } | { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend"; readonly replay?: number; }): <A, E, R>(self: Stream<A, E, R>) => Effect<Effect<Dequeue<Take<A, E>>, never, Scope>, never, Scope | R>; <A, E, R>(self: Stream<A, E, R>, maximumLag: number | { readonly capacity: "unbounded"; readonly replay?: number; } | { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend"; readonly replay?: number; }): Effect<Effect<Dequeue<Take<A, E>>, never, Scope>, never, Scope | R>; }',
      description: "Converts the stream to a scoped dynamic amount of queues. Every chunk will\nbe replicated to every queue with the slowest queue being allowed to buffer\n`maximumLag` chunks before the driver is back pressured. Queues can unsubscribe from upstream by shutting down.",
      documentation: "Converts the stream to a scoped dynamic amount of queues. Every chunk will\nbe replicated to every queue with the slowest queue being allowed to buffer\n`maximumLag` chunks before the driver is back pressured.\n\nQueues can unsubscribe from upstream by shutting down.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 924,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L924"
    },
    {
      id: "Stream.buffer",
      name: "buffer",
      module: "Stream",
      package: "effect",
      signature: '{ (options: { readonly capacity: "unbounded"; } | { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend"; }): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, options: { readonly capacity: "unbounded"; } | { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend"; }): Stream<A, E, R>; }',
      description: "Allows a faster producer to progress independently of a slower consumer by\nbuffering up to `capacity` elements in a queue. Note: This combinator destroys the chunking structure. It's recommended to\n      use rechunk afterwards. Additionally, prefer capacities that are powers\n      of 2 for better performance.",
      documentation: "Allows a faster producer to progress independently of a slower consumer by\nbuffering up to `capacity` elements in a queue.\n\nNote: This combinator destroys the chunking structure. It's recommended to\n      use rechunk afterwards. Additionally, prefer capacities that are powers\n      of 2 for better performance.",
      examples: [
        {
          code: 'import { Console, Effect, Schedule, Stream } from "effect"\n\nconst stream = Stream.range(1, 10).pipe(\n  Stream.tap((n) => Console.log(`before buffering: ${n}`)),\n  Stream.buffer({ capacity: 4 }),\n  Stream.tap((n) => Console.log(`after buffering: ${n}`)),\n  Stream.schedule(Schedule.spaced("5 seconds"))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// before buffering: 1\n// before buffering: 2\n// before buffering: 3\n// before buffering: 4\n// before buffering: 5\n// before buffering: 6\n// after buffering: 1\n// after buffering: 2\n// before buffering: 7\n// after buffering: 3\n// before buffering: 8\n// after buffering: 4\n// before buffering: 9\n// after buffering: 5\n// before buffering: 10\n// ...'
        }
      ],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1003,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1003"
    },
    {
      id: "Stream.bufferChunks",
      name: "bufferChunks",
      module: "Stream",
      package: "effect",
      signature: '{ (options: { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend"; }): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, options: { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend"; }): Stream<A, E, R>; }',
      description: "Allows a faster producer to progress independently of a slower consumer by\nbuffering up to `capacity` chunks in a queue.",
      documentation: "Allows a faster producer to progress independently of a slower consumer by\nbuffering up to `capacity` chunks in a queue.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1107,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1107"
    },
    {
      id: "Stream.catchAll",
      name: "catchAll",
      module: "Stream",
      package: "effect",
      signature: "{ <E, A2, E2, R2>(f: (error: E) => Stream<A2, E2, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (error: E) => Stream<A2, E2, R2>): Stream<A | A2, E2, R | R2>; }",
      description: "Switches over to the stream produced by the provided function in case this\none fails with a typed error.",
      documentation: "Switches over to the stream produced by the provided function in case this\none fails with a typed error.",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1140,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1140"
    },
    {
      id: "Stream.catchAllCause",
      name: "catchAllCause",
      module: "Stream",
      package: "effect",
      signature: "{ <E, A2, E2, R2>(f: (cause: Cause<E>) => Stream<A2, E2, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (cause: Cause<E>) => Stream<A2, E2, R2>): Stream<A | A2, E2, R | R2>; }",
      description: "Switches over to the stream produced by the provided function in case this\none fails. Allows recovery from all causes of failure, including\ninterruption if the stream is uninterruptible.",
      documentation: "Switches over to the stream produced by the provided function in case this\none fails. Allows recovery from all causes of failure, including\ninterruption if the stream is uninterruptible.",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1166,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1166"
    },
    {
      id: "Stream.catchSome",
      name: "catchSome",
      module: "Stream",
      package: "effect",
      signature: "{ <E, A2, E2, R2>(pf: (error: E) => Option<Stream<A2, E2, R2>>): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, pf: (error: E) => Option<Stream<A2, E2, R2>>): Stream<A | A2, E | E2, R | R2>; }",
      description: "Switches over to the stream produced by the provided function in case this\none fails with some typed error.",
      documentation: "Switches over to the stream produced by the provided function in case this\none fails with some typed error.",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1193,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1193"
    },
    {
      id: "Stream.catchTag",
      name: "catchTag",
      module: "Stream",
      package: "effect",
      signature: '{ <K extends E["_tag"] & string, E extends { _tag: string; }, A1, E1, R1>(k: K, f: (e: Extract<E, { _tag: K; }>) => Stream<A1, E1, R1>): <A, R>(self: Stream<A, E, R>) => Stream<A1 | A, E1 | Exclude<E, { _tag: K; }>, R1 | R>; <A, E extends { _tag: string; }, R, K extends E["_tag"] & string, A1, E1, R1>(self: Stream<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => Stream<A1, E1, R1>): Stream<A | A1, E1 | Exclude<E, { _tag: K; }>, R | R1>; }',
      description: "Switches over to the stream produced by the provided function in case this\none fails with an error matching the given `_tag`.",
      documentation: "Switches over to the stream produced by the provided function in case this\none fails with an error matching the given `_tag`.",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1218,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1218"
    },
    {
      id: "Stream.catchTags",
      name: "catchTags",
      module: "Stream",
      package: "effect",
      signature: '{ <E extends { _tag: string; }, Cases extends { [K in E["_tag"]]+?: (error: Extract<E, { _tag: K; }>) => Stream<any, any, any>; }>(cases: Cases): <A, R>(self: Stream<A, E, R>) => Stream<A | { [K in keyof Cases]: Cases[K] extends (...args: any[]) => Stream.Variance<infer A, infer _E, infer _R> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: any[]) => Stream.Variance<infer _A, infer E, infer _R> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: any[]) => Stream.Variance<infer _A, infer _E, infer R> ? R : never; }[keyof Cases]>; <A, E extends { _tag: string; }, R, Cases extends { [K in E["_tag"]]+?: (error: Extract<E, { _tag: K; }>) => Stream<any, any, any>; }>(self: Stream<A, E, R>, cases: Cases): Stream<A | { [K in keyof Cases]: Cases[K] extends (...args: any[]) => Stream.Variance<infer _R, infer _E, infer A> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: any[]) => Stream.Variance<infer _R, infer E, infer _A> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: any[]) => Stream.Variance<infer R, infer _E, infer _A> ? R : never; }[keyof Cases]>; }',
      description: "Switches over to the stream produced by one of the provided functions, in\ncase this one fails with an error matching one of the given `_tag`'s.",
      documentation: "Switches over to the stream produced by one of the provided functions, in\ncase this one fails with an error matching one of the given `_tag`'s.",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1255,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1255"
    },
    {
      id: "Stream.catchSomeCause",
      name: "catchSomeCause",
      module: "Stream",
      package: "effect",
      signature: "{ <E, A2, E2, R2>(pf: (cause: Cause<E>) => Option<Stream<A2, E2, R2>>): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, pf: (cause: Cause<E>) => Option<Stream<A2, E2, R2>>): Stream<A | A2, E | E2, R | R2>; }",
      description: "Switches over to the stream produced by the provided function in case this\none fails with some errors. Allows recovery from all causes of failure,\nincluding interruption if the stream is uninterruptible.",
      documentation: "Switches over to the stream produced by the provided function in case this\none fails with some errors. Allows recovery from all causes of failure,\nincluding interruption if the stream is uninterruptible.",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1309,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1309"
    },
    {
      id: "Stream.changes",
      name: "changes",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>",
      description: "Returns a new stream that only emits elements that are not equal to the\nprevious element emitted, using natural equality to determine whether two\nelements are equal.",
      documentation: "Returns a new stream that only emits elements that are not equal to the\nprevious element emitted, using natural equality to determine whether two\nelements are equal.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

const stream = Stream.make(1, 1, 1, 2, 2, 3, 4).pipe(Stream.changes)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4 ] }`
        }
      ],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1347,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1347"
    },
    {
      id: "Stream.changesWith",
      name: "changesWith",
      module: "Stream",
      package: "effect",
      signature: "{ <A>(f: (x: A, y: A) => boolean): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, f: (x: A, y: A) => boolean): Stream<A, E, R>; }",
      description: "Returns a new stream that only emits elements that are not equal to the\nprevious element emitted, using the specified function to determine whether\ntwo elements are equal.",
      documentation: "Returns a new stream that only emits elements that are not equal to the\nprevious element emitted, using the specified function to determine whether\ntwo elements are equal.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1356,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1356"
    },
    {
      id: "Stream.changesWithEffect",
      name: "changesWithEffect",
      module: "Stream",
      package: "effect",
      signature: "{ <A, E2, R2>(f: (x: A, y: A) => Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (x: A, y: A) => Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }",
      description: "Returns a new stream that only emits elements that are not equal to the\nprevious element emitted, using the specified effectual function to\ndetermine whether two elements are equal.",
      documentation: "Returns a new stream that only emits elements that are not equal to the\nprevious element emitted, using the specified effectual function to\ndetermine whether two elements are equal.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1384,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1384"
    },
    {
      id: "Stream.chunks",
      name: "chunks",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(self: Stream<A, E, R>) => Stream<Chunk<A>, E, R>",
      description: "Exposes the underlying chunks of the stream as a stream of chunks of\nelements.",
      documentation: "Exposes the underlying chunks of the stream as a stream of chunks of\nelements.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1411,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1411"
    },
    {
      id: "Stream.chunksWith",
      name: "chunksWith",
      module: "Stream",
      package: "effect",
      signature: "{ <A, E, R, A2, E2, R2>(f: (stream: Stream<Chunk<A>, E, R>) => Stream<Chunk<A2>, E2, R2>): (self: Stream<A, E, R>) => Stream<A2, E | E2, R | R2>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (stream: Stream<Chunk<A>, E, R>) => Stream<Chunk<A2>, E2, R2>): Stream<A2, E | E2, R | R2>; }",
      description: "Performs the specified stream transformation with the chunk structure of\nthe stream exposed.",
      documentation: "Performs the specified stream transformation with the chunk structure of\nthe stream exposed.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1419,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1419"
    },
    {
      id: "Stream.combine",
      name: "combine",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, E2, R2, S, R3, E, A, R4, R5, A3>(that: Stream<A2, E2, R2>, s: S, f: (s: S, pullLeft: Effect<A, Option<E>, R3>, pullRight: Effect<A2, Option<E2>, R4>) => Effect<Exit<readonly [A3, S], Option<E2 | E>>, never, R5>): <R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R3 | R4 | R5 | R>; <R, A2, E2, R2, S, R3, E, A, R4, R5, A3>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, s: S, f: (s: S, pullLeft: Effect<A, Option<E>, R3>, pullRight: Effect<A2, Option<E2>, R4>) => Effect<Exit<readonly [A3, S], Option<E2 | E>>, never, R5>): Stream<A3, E2 | E, R | R2 | R3 | R4 | R5>; }",
      description: 'Combines the elements from this stream and the specified stream by\nrepeatedly applying the function `f` to extract an element using both sides\nand conceptually "offer" it to the destination stream. `f` can maintain\nsome internal state to control the combining process, with the initial\nstate being specified by `s`. Where possible, prefer `Stream.combineChunks` for a more efficient\nimplementation.',
      documentation: 'Combines the elements from this stream and the specified stream by\nrepeatedly applying the function `f` to extract an element using both sides\nand conceptually "offer" it to the destination stream. `f` can maintain\nsome internal state to control the combining process, with the initial\nstate being specified by `s`.\n\nWhere possible, prefer `Stream.combineChunks` for a more efficient\nimplementation.',
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1450,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1450"
    },
    {
      id: "Stream.combineChunks",
      name: "combineChunks",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, E2, R2, S, R3, E, A, R4, R5, A3>(that: Stream<A2, E2, R2>, s: S, f: (s: S, pullLeft: Effect<Chunk<A>, Option<E>, R3>, pullRight: Effect<Chunk<A2>, Option<E2>, R4>) => Effect<Exit<readonly [Chunk<A3>, S], Option<E2 | E>>, never, R5>): <R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R3 | R4 | R5 | R>; <R, A2, E2, R2, S, R3, E, A, R4, R5, A3>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, s: S, f: (s: S, pullLeft: Effect<Chunk<A>, Option<E>, R3>, pullRight: Effect<Chunk<A2>, Option<E2>, R4>) => Effect<Exit<readonly [Chunk<A3>, S], Option<E2 | E>>, never, R5>): Stream<A3, E2 | E, R | R2 | R3 | R4 | R5>; }",
      description: 'Combines the chunks from this stream and the specified stream by repeatedly\napplying the function `f` to extract a chunk using both sides and\nconceptually "offer" it to the destination stream. `f` can maintain some\ninternal state to control the combining process, with the initial state\nbeing specified by `s`.',
      documentation: 'Combines the chunks from this stream and the specified stream by repeatedly\napplying the function `f` to extract a chunk using both sides and\nconceptually "offer" it to the destination stream. `f` can maintain some\ninternal state to control the combining process, with the initial state\nbeing specified by `s`.',
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1490,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1490"
    },
    {
      id: "Stream.concat",
      name: "concat",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<A | A2, E | E2, R | R2>; }",
      description: "Concatenates the specified stream with this stream, resulting in a stream\nthat emits the elements from this stream and then the elements from the\nspecified stream.",
      documentation: "Concatenates the specified stream with this stream, resulting in a stream\nthat emits the elements from this stream and then the elements from the\nspecified stream.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

const s1 = Stream.make(1, 2, 3)
const s2 = Stream.make(4, 5)

const stream = Stream.concat(s1, s2)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5 ] }`
        }
      ],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1535,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1535"
    },
    {
      id: "Stream.concatAll",
      name: "concatAll",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(streams: Chunk<Stream<A, E, R>>) => Stream<A, E, R>",
      description: "Concatenates all of the streams in the chunk to one stream.",
      documentation: "Concatenates all of the streams in the chunk to one stream.",
      examples: [
        {
          code: `import { Chunk, Effect, Stream } from "effect"

const s1 = Stream.make(1, 2, 3)
const s2 = Stream.make(4, 5)
const s3 = Stream.make(6, 7, 8)

const stream = Stream.concatAll(Chunk.make(s1, s2, s3))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// {
//   _id: 'Chunk',
//   values: [
//     1, 2, 3, 4,
//     5, 6, 7, 8
//   ]
// }`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1607,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1607"
    },
    {
      id: "Stream.cross",
      name: "cross",
      module: "Stream",
      package: "effect",
      signature: "{ <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<[AL, AR], ER | EL, RR | RL>; <AL, ER, RR, AR, EL, RL>(left: Stream<AL, ER, RR>, right: Stream<AR, EL, RL>): Stream<[AL, AR], ER | EL, RR | RL>; }",
      description: "Composes this stream with the specified stream to create a cartesian\nproduct of elements. The `right` stream would be run multiple times, for\nevery element in the `left` stream. See also `Stream.zip` for the more common point-wise variant.",
      documentation: "Composes this stream with the specified stream to create a cartesian\nproduct of elements. The `right` stream would be run multiple times, for\nevery element in the `left` stream.\n\nSee also `Stream.zip` for the more common point-wise variant.",
      examples: [
        {
          code: 'import { Effect, Stream } from "effect"\n\nconst s1 = Stream.make(1, 2, 3)\nconst s2 = Stream.make("a", "b")\n\nconst product = Stream.cross(s1, s2)\n\nEffect.runPromise(Stream.runCollect(product)).then(console.log)\n// {\n//   _id: "Chunk",\n//   values: [\n//     [ 1, "a" ], [ 1, "b" ], [ 2, "a" ], [ 2, "b" ], [ 3, "a" ], [ 3, "b" ]\n//   ]\n// }'
        }
      ],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1636,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1636"
    },
    {
      id: "Stream.crossLeft",
      name: "crossLeft",
      module: "Stream",
      package: "effect",
      signature: "{ <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL, EL | ER, RL | RR>; }",
      description: "Composes this stream with the specified stream to create a cartesian\nproduct of elements, but keeps only elements from `left` stream. The `right`\nstream would be run multiple times, for every element in the `left` stream. See also `Stream.zipLeft` for the more common point-wise variant.",
      documentation: "Composes this stream with the specified stream to create a cartesian\nproduct of elements, but keeps only elements from `left` stream. The `right`\nstream would be run multiple times, for every element in the `left` stream.\n\nSee also `Stream.zipLeft` for the more common point-wise variant.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1706,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1706"
    },
    {
      id: "Stream.crossRight",
      name: "crossRight",
      module: "Stream",
      package: "effect",
      signature: "{ <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AR, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AR, EL | ER, RL | RR>; }",
      description: "Composes this stream with the specified stream to create a cartesian\nproduct of elements, but keeps only elements from the `right` stream. The\n`left` stream would be run multiple times, for every element in the `right`\nstream. See also `Stream.zipRight` for the more common point-wise variant.",
      documentation: "Composes this stream with the specified stream to create a cartesian\nproduct of elements, but keeps only elements from the `right` stream. The\n`left` stream would be run multiple times, for every element in the `right`\nstream.\n\nSee also `Stream.zipRight` for the more common point-wise variant.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1741,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1741"
    },
    {
      id: "Stream.crossWith",
      name: "crossWith",
      module: "Stream",
      package: "effect",
      signature: "{ <AR, ER, RR, AL, A>(right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): <EL, RL>(left: Stream<AL, EL, RL>) => Stream<A, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR, A>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): Stream<A, EL | ER, RL | RR>; }",
      description: "Composes this stream with the specified stream to create a cartesian\nproduct of elements with a specified function. The `right` stream would be\nrun multiple times, for every element in the `left` stream. See also `Stream.zipWith` for the more common point-wise variant.",
      documentation: "Composes this stream with the specified stream to create a cartesian\nproduct of elements with a specified function. The `right` stream would be\nrun multiple times, for every element in the `left` stream.\n\nSee also `Stream.zipWith` for the more common point-wise variant.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1777,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1777"
    },
    {
      id: "Stream.debounce",
      name: "debounce",
      module: "Stream",
      package: "effect",
      signature: "{ (duration: DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, duration: DurationInput): Stream<A, E, R>; }",
      description: 'Delays the emission of values by holding new values for a set duration. If\nno new values arrive during that time the value is emitted, however if a\nnew value is received during the holding period the previous value is\ndiscarded and the process is repeated with the new value. This operator is useful if you have a stream of "bursty" events which\neventually settle down and you only need the final event of the burst. For\nexample, a search engine may only want to initiate a search after a user\nhas paused typing so as to not prematurely recommend results.',
      documentation: 'Delays the emission of values by holding new values for a set duration. If\nno new values arrive during that time the value is emitted, however if a\nnew value is received during the holding period the previous value is\ndiscarded and the process is repeated with the new value.\n\nThis operator is useful if you have a stream of "bursty" events which\neventually settle down and you only need the final event of the burst. For\nexample, a search engine may only want to initiate a search after a user\nhas paused typing so as to not prematurely recommend results.',
      examples: [
        {
          code: 'import { Effect, Stream } from "effect"\n\nlet last = Date.now()\nconst log = (message: string) =>\n  Effect.sync(() => {\n    const end = Date.now()\n    console.log(`${message} after ${end - last}ms`)\n    last = end\n  })\n\nconst stream = Stream.make(1, 2, 3).pipe(\n  Stream.concat(\n    Stream.fromEffect(Effect.sleep("200 millis").pipe(Effect.as(4))) // Emit 4 after 200 ms\n  ),\n  Stream.concat(Stream.make(5, 6)), // Continue with more rapid values\n  Stream.concat(\n    Stream.fromEffect(Effect.sleep("150 millis").pipe(Effect.as(7))) // Emit 7 after 150 ms\n  ),\n  Stream.concat(Stream.make(8)),\n  Stream.tap((n) => log(`Received ${n}`)),\n  Stream.debounce("100 millis"), // Only emit values after a pause of at least 100 milliseconds,\n  Stream.tap((n) => log(`> Emitted ${n}`))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// Received 1 after 5ms\n// Received 2 after 2ms\n// Received 3 after 0ms\n// > Emitted 3 after 104ms\n// Received 4 after 99ms\n// Received 5 after 1ms\n// Received 6 after 0ms\n// > Emitted 6 after 101ms\n// Received 7 after 50ms\n// Received 8 after 1ms\n// > Emitted 8 after 101ms\n// { _id: \'Chunk\', values: [ 3, 6, 8 ] }'
        }
      ],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1856,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1856"
    },
    {
      id: "Stream.die",
      name: "die",
      module: "Stream",
      package: "effect",
      signature: "(defect: unknown) => Stream<never, never, never>",
      description: "The stream that dies with the specified defect.",
      documentation: "The stream that dies with the specified defect.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1976,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1976"
    },
    {
      id: "Stream.dieSync",
      name: "dieSync",
      module: "Stream",
      package: "effect",
      signature: "(evaluate: LazyArg<unknown>) => Stream<never, never, never>",
      description: "The stream that dies with the specified lazily evaluated defect.",
      documentation: "The stream that dies with the specified lazily evaluated defect.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1983,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1983"
    },
    {
      id: "Stream.dieMessage",
      name: "dieMessage",
      module: "Stream",
      package: "effect",
      signature: "(message: string) => Stream<never, never, never>",
      description: "The stream that dies with an exception described by `message`.",
      documentation: "The stream that dies with an exception described by `message`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1990,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1990"
    },
    {
      id: "Stream.distributedWith",
      name: "distributedWith",
      module: "Stream",
      package: "effect",
      signature: "{ <N extends number, A>(options: { readonly size: N; readonly maximumLag: number; readonly decide: (a: A) => Effect<Predicate<number>, never, never>; }): <E, R>(self: Stream<A, E, R>) => Effect<TupleOf<N, Dequeue<Exit<A, Option<E>>>>, never, Scope | R>; <A, E, R, N extends number>(self: Stream<A, E, R>, options: { readonly size: N; readonly maximumLag: number; readonly decide: (a: A) => Effect<Predicate<number>, never, never>; }): Effect<TupleOf<N, Dequeue<Exit<A, Option<E>>>>, never, Scope | R>; }",
      description: "More powerful version of `Stream.broadcast`. Allows to provide a function\nthat determines what queues should receive which elements. The decide\nfunction will receive the indices of the queues in the resulting list.",
      documentation: "More powerful version of `Stream.broadcast`. Allows to provide a function\nthat determines what queues should receive which elements. The decide\nfunction will receive the indices of the queues in the resulting list.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 1999,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1999"
    },
    {
      id: "Stream.distributedWithDynamic",
      name: "distributedWithDynamic",
      module: "Stream",
      package: "effect",
      signature: "{ <A>(options: { readonly maximumLag: number; readonly decide: (a: A) => Effect<Predicate<number>, never, never>; }): <E, R>(self: Stream<A, E, R>) => Effect<Effect<[number, Dequeue<Exit<A, Option<E>>>], never, never>, never, Scope | R>; <A, E, R>(self: Stream<A, E, R>, options: { readonly maximumLag: number; readonly decide: (a: A) => Effect<Predicate<number>, never, never>; }): Effect<Effect<[number, Dequeue<Exit<A, Option<E>>>], never, never>, never, Scope | R>; }",
      description: "More powerful version of `Stream.distributedWith`. This returns a function\nthat will produce new queues and corresponding indices. You can also\nprovide a function that will be executed after the final events are\nenqueued in all queues. Shutdown of the queues is handled by the driver.\nDownstream users can also shutdown queues manually. In this case the driver\nwill continue but no longer backpressure on them.",
      documentation: "More powerful version of `Stream.distributedWith`. This returns a function\nthat will produce new queues and corresponding indices. You can also\nprovide a function that will be executed after the final events are\nenqueued in all queues. Shutdown of the queues is handled by the driver.\nDownstream users can also shutdown queues manually. In this case the driver\nwill continue but no longer backpressure on them.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2038,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2038"
    },
    {
      id: "Stream.drain",
      name: "drain",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(self: Stream<A, E, R>) => Stream<never, E, R>",
      description: "Converts this stream to a stream that executes its effects but emits no\nelements. Useful for sequencing effects using streams:",
      documentation: "Converts this stream to a stream that executes its effects but emits no\nelements. Useful for sequencing effects using streams:",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

// We create a stream and immediately drain it.
const stream = Stream.range(1, 6).pipe(Stream.drain)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [] }`
        }
      ],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2088,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2088"
    },
    {
      id: "Stream.drainFork",
      name: "drainFork",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<A, E | E2, R | R2>; }",
      description: "Drains the provided stream in the background for as long as this stream is\nrunning. If this stream ends before `other`, `other` will be interrupted.\nIf `other` fails, this stream will fail with that error.",
      documentation: "Drains the provided stream in the background for as long as this stream is\nrunning. If this stream ends before `other`, `other` will be interrupted.\nIf `other` fails, this stream will fail with that error.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2097,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2097"
    },
    {
      id: "Stream.drop",
      name: "drop",
      module: "Stream",
      package: "effect",
      signature: "{ (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }",
      description: "Drops the specified number of elements from this stream.",
      documentation: "Drops the specified number of elements from this stream.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2123,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2123"
    },
    {
      id: "Stream.dropRight",
      name: "dropRight",
      module: "Stream",
      package: "effect",
      signature: "{ (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }",
      description: "Drops the last specified number of elements from this stream.",
      documentation: "Drops the last specified number of elements from this stream.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2147,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2147"
    },
    {
      id: "Stream.dropUntil",
      name: "dropUntil",
      module: "Stream",
      package: "effect",
      signature: "{ <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }",
      description: "Drops all elements of the stream until the specified predicate evaluates to\n`true`.",
      documentation: "Drops all elements of the stream until the specified predicate evaluates to\n`true`.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2174,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2174"
    },
    {
      id: "Stream.dropUntilEffect",
      name: "dropUntilEffect",
      module: "Stream",
      package: "effect",
      signature: "{ <A, E2, R2>(predicate: (a: NoInfer<A>) => Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, predicate: (a: NoInfer<A>) => Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }",
      description: "Drops all elements of the stream until the specified effectful predicate\nevaluates to `true`.",
      documentation: "Drops all elements of the stream until the specified effectful predicate\nevaluates to `true`.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2199,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2199"
    },
    {
      id: "Stream.dropWhile",
      name: "dropWhile",
      module: "Stream",
      package: "effect",
      signature: "{ <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }",
      description: "Drops all elements of the stream for as long as the specified predicate\nevaluates to `true`.",
      documentation: "Drops all elements of the stream for as long as the specified predicate\nevaluates to `true`.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2224,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2224"
    },
    {
      id: "Stream.dropWhileEffect",
      name: "dropWhileEffect",
      module: "Stream",
      package: "effect",
      signature: "{ <A, E2, R2>(predicate: (a: NoInfer<A>) => Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, predicate: (a: A) => Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }",
      description: "Drops all elements of the stream for as long as the specified predicate\nproduces an effect that evalutates to `true`",
      documentation: "Drops all elements of the stream for as long as the specified predicate\nproduces an effect that evalutates to `true`",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2249,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2249"
    },
    {
      id: "Stream.either",
      name: "either",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(self: Stream<A, E, R>) => Stream<Either<A, E>, never, R>",
      description: "Returns a stream whose failures and successes have been lifted into an\n`Either`. The resulting stream cannot fail, because the failures have been\nexposed as part of the `Either` success case.",
      documentation: "Returns a stream whose failures and successes have been lifted into an\n`Either`. The resulting stream cannot fail, because the failures have been\nexposed as part of the `Either` success case.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2277,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2277"
    },
    {
      id: "Stream.empty",
      name: "empty",
      module: "Stream",
      package: "effect",
      signature: "Stream<never, never, never>",
      description: "The empty stream.",
      documentation: "The empty stream.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

const stream = Stream.empty

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [] }`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2294,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2294"
    },
    {
      id: "Stream.ensuring",
      name: "ensuring",
      module: "Stream",
      package: "effect",
      signature: "{ <X, R2>(finalizer: Effect<X, never, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, R2>(self: Stream<A, E, R>, finalizer: Effect<X, never, R2>): Stream<A, E, R | R2>; }",
      description: "Executes the provided finalizer after this stream's finalizers run.",
      documentation: "Executes the provided finalizer after this stream's finalizers run.",
      examples: [
        {
          code: `import { Console, Effect, Stream } from "effect"

const program = Stream.fromEffect(Console.log("Application Logic.")).pipe(
  Stream.concat(Stream.finalizer(Console.log("Finalizing the stream"))),
  Stream.ensuring(
    Console.log("Doing some other works after stream's finalization")
  )
)

Effect.runPromise(Stream.runCollect(program)).then(console.log)
// Application Logic.
// Finalizing the stream
// Doing some other works after stream's finalization
// { _id: 'Chunk', values: [ undefined, undefined ] }`
        }
      ],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2319,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2319"
    },
    {
      id: "Stream.ensuringWith",
      name: "ensuringWith",
      module: "Stream",
      package: "effect",
      signature: "{ <E, R2>(finalizer: (exit: Exit<unknown, E>) => Effect<unknown, never, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, R2>(self: Stream<A, E, R>, finalizer: (exit: Exit<unknown, E>) => Effect<unknown, never, R2>): Stream<A, E, R | R2>; }",
      description: "Executes the provided finalizer after this stream's finalizers run.",
      documentation: "Executes the provided finalizer after this stream's finalizers run.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2377,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2377"
    },
    {
      id: "Stream.context",
      name: "context",
      module: "Stream",
      package: "effect",
      signature: "<R>() => Stream<Context<R>, never, R>",
      description: "Accesses the whole context of the stream.",
      documentation: "Accesses the whole context of the stream.",
      examples: [],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2399,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2399"
    },
    {
      id: "Stream.contextWith",
      name: "contextWith",
      module: "Stream",
      package: "effect",
      signature: "<R, A>(f: (env: Context<R>) => A) => Stream<A, never, R>",
      description: "Accesses the context of the stream.",
      documentation: "Accesses the context of the stream.",
      examples: [],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2406,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2406"
    },
    {
      id: "Stream.contextWithEffect",
      name: "contextWithEffect",
      module: "Stream",
      package: "effect",
      signature: "<R0, A, E, R>(f: (env: Context<R0>) => Effect<A, E, R>) => Stream<A, E, R0 | R>",
      description: "Accesses the context of the stream in the context of an effect.",
      documentation: "Accesses the context of the stream in the context of an effect.",
      examples: [],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2413,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2413"
    },
    {
      id: "Stream.contextWithStream",
      name: "contextWithStream",
      module: "Stream",
      package: "effect",
      signature: "<R0, A, E, R>(f: (env: Context<R0>) => Stream<A, E, R>) => Stream<A, E, R0 | R>",
      description: "Accesses the context of the stream in the context of a stream.",
      documentation: "Accesses the context of the stream in the context of a stream.",
      examples: [],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2420,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2420"
    },
    {
      id: "Stream.execute",
      name: "execute",
      module: "Stream",
      package: "effect",
      signature: "<X, E, R>(effect: Effect<X, E, R>) => Stream<never, E, R>",
      description: "Creates a stream that executes the specified effect but emits no elements.",
      documentation: "Creates a stream that executes the specified effect but emits no elements.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2427,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2427"
    },
    {
      id: "Stream.fail",
      name: "fail",
      module: "Stream",
      package: "effect",
      signature: "<E>(error: E) => Stream<never, E, never>",
      description: "Terminates with the specified error.",
      documentation: "Terminates with the specified error.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

const stream = Stream.fail("Uh oh!")

Effect.runPromiseExit(Stream.runCollect(stream)).then(console.log)
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Uh oh!' }
// }`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2448,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2448"
    },
    {
      id: "Stream.failSync",
      name: "failSync",
      module: "Stream",
      package: "effect",
      signature: "<E>(evaluate: LazyArg<E>) => Stream<never, E, never>",
      description: "Terminates with the specified lazily evaluated error.",
      documentation: "Terminates with the specified lazily evaluated error.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2455,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2455"
    },
    {
      id: "Stream.failCause",
      name: "failCause",
      module: "Stream",
      package: "effect",
      signature: "<E>(cause: Cause<E>) => Stream<never, E, never>",
      description: "The stream that always fails with the specified `Cause`.",
      documentation: "The stream that always fails with the specified `Cause`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2462,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2462"
    },
    {
      id: "Stream.failCauseSync",
      name: "failCauseSync",
      module: "Stream",
      package: "effect",
      signature: "<E>(evaluate: LazyArg<Cause<E>>) => Stream<never, E, never>",
      description: "The stream that always fails with the specified lazily evaluated `Cause`.",
      documentation: "The stream that always fails with the specified lazily evaluated `Cause`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2469,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2469"
    },
    {
      id: "Stream.filter",
      name: "filter",
      module: "Stream",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, B extends A>(predicate: Predicate<B>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<B, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }",
      description: "Filters the elements emitted by this stream using the provided function.",
      documentation: "Filters the elements emitted by this stream using the provided function.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

const stream = Stream.range(1, 11).pipe(Stream.filter((n) => n % 2 === 0))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 2, 4, 6, 8, 10 ] }`
        }
      ],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2486,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2486"
    },
    {
      id: "Stream.filterEffect",
      name: "filterEffect",
      module: "Stream",
      package: "effect",
      signature: "{ <A, E2, R2>(f: (a: NoInfer<A>) => Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }",
      description: "Effectfully filters the elements emitted by this stream.",
      documentation: "Effectfully filters the elements emitted by this stream.",
      examples: [],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2562,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2562"
    },
    {
      id: "Stream.filterMap",
      name: "filterMap",
      module: "Stream",
      package: "effect",
      signature: "{ <A, B>(pf: (a: A) => Option<B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, E, R, B>(self: Stream<A, E, R>, pf: (a: A) => Option<B>): Stream<B, E, R>; }",
      description: "Performs a filter and map in a single step.",
      documentation: "Performs a filter and map in a single step.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2584,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2584"
    },
    {
      id: "Stream.filterMapEffect",
      name: "filterMapEffect",
      module: "Stream",
      package: "effect",
      signature: "{ <A, A2, E2, R2>(pf: (a: A) => Option<Effect<A2, E2, R2>>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, pf: (a: A) => Option<Effect<A2, E2, R2>>): Stream<A2, E | E2, R | R2>; }",
      description: "Performs an effectful filter and map in a single step.",
      documentation: "Performs an effectful filter and map in a single step.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2606,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2606"
    },
    {
      id: "Stream.filterMapWhile",
      name: "filterMapWhile",
      module: "Stream",
      package: "effect",
      signature: "{ <A, A2>(pf: (a: A) => Option<A2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, pf: (a: A) => Option<A2>): Stream<A2, E, R>; }",
      description: "Transforms all elements of the stream for as long as the specified partial\nfunction is defined.",
      documentation: "Transforms all elements of the stream for as long as the specified partial\nfunction is defined.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2629,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2629"
    },
    {
      id: "Stream.filterMapWhileEffect",
      name: "filterMapWhileEffect",
      module: "Stream",
      package: "effect",
      signature: "{ <A, A2, E2, R2>(pf: (a: A) => Option<Effect<A2, E2, R2>>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, pf: (a: A) => Option<Effect<A2, E2, R2>>): Stream<A2, E | E2, R | R2>; }",
      description: "Effectfully transforms all elements of the stream for as long as the\nspecified partial function is defined.",
      documentation: "Effectfully transforms all elements of the stream for as long as the\nspecified partial function is defined.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2654,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2654"
    },
    {
      id: "Stream.finalizer",
      name: "finalizer",
      module: "Stream",
      package: "effect",
      signature: "<R, X>(finalizer: Effect<X, never, R>) => Stream<void, never, R>",
      description: "Creates a one-element stream that never fails and executes the finalizer\nwhen it ends.",
      documentation: "Creates a one-element stream that never fails and executes the finalizer\nwhen it ends.",
      examples: [
        {
          code: 'import { Console, Effect, Stream } from "effect"\n\nconst application = Stream.fromEffect(Console.log("Application Logic."))\n\nconst deleteDir = (dir: string) => Console.log(`Deleting dir: ${dir}`)\n\nconst program = application.pipe(\n  Stream.concat(\n    Stream.finalizer(\n      deleteDir("tmp").pipe(\n        Effect.andThen(Console.log("Temporary directory was deleted."))\n      )\n    )\n  )\n)\n\nEffect.runPromise(Stream.runCollect(program)).then(console.log)\n// Application Logic.\n// Deleting dir: tmp\n// Temporary directory was deleted.\n// { _id: \'Chunk\', values: [ undefined, undefined ] }'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2704,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2704"
    },
    {
      id: "Stream.find",
      name: "find",
      module: "Stream",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<B, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }",
      description: "Finds the first element emitted by this stream that satisfies the provided\npredicate.",
      documentation: "Finds the first element emitted by this stream that satisfies the provided\npredicate.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2712,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2712"
    },
    {
      id: "Stream.findEffect",
      name: "findEffect",
      module: "Stream",
      package: "effect",
      signature: "{ <A, E2, R2>(predicate: (a: NoInfer<A>) => Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, predicate: (a: NoInfer<A>) => Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }",
      description: "Finds the first element emitted by this stream that satisfies the provided\neffectful predicate.",
      documentation: "Finds the first element emitted by this stream that satisfies the provided\neffectful predicate.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2753,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2753"
    },
    {
      id: "Stream.flatMap",
      name: "flatMap",
      module: "Stream",
      package: "effect",
      signature: '{ <A, A2, E2, R2>(f: (a: A) => Stream<A2, E2, R2>, options?: { readonly concurrency?: number | "unbounded"; readonly bufferSize?: number; readonly switch?: boolean; }): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Stream<A2, E2, R2>, options?: { readonly concurrency?: number | "unbounded"; readonly bufferSize?: number; readonly switch?: boolean; }): Stream<A2, E | E2, R | R2>; }',
      description: "Returns a stream made of the concatenation in strict order of all the\nstreams produced by passing each element of this stream to `f0`",
      documentation: "Returns a stream made of the concatenation in strict order of all the\nstreams produced by passing each element of this stream to `f0`",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2778,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2778"
    },
    {
      id: "Stream.flatten",
      name: "flatten",
      module: "Stream",
      package: "effect",
      signature: '{ (options?: { readonly concurrency?: number | "unbounded"; readonly bufferSize?: number; }): <A, E2, R2, E, R>(self: Stream<Stream<A, E2, R2>, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E2, R2, E, R>(self: Stream<Stream<A, E2, R2>, E, R>, options?: { readonly concurrency?: number | "unbounded"; readonly bufferSize?: number; }): Stream<A, E2 | E, R2 | R>; }',
      description: "Flattens this stream-of-streams into a stream made of the concatenation in\nstrict order of all the streams.",
      documentation: "Flattens this stream-of-streams into a stream made of the concatenation in\nstrict order of all the streams.",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2811,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2811"
    },
    {
      id: "Stream.flattenChunks",
      name: "flattenChunks",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(self: Stream<Chunk<A>, E, R>) => Stream<A, E, R>",
      description: "Submerges the chunks carried by this stream into the stream's structure,\nwhile still preserving them.",
      documentation: "Submerges the chunks carried by this stream into the stream's structure,\nwhile still preserving them.",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2842,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2842"
    },
    {
      id: "Stream.flattenEffect",
      name: "flattenEffect",
      module: "Stream",
      package: "effect",
      signature: '{ (options?: { readonly concurrency?: number | "unbounded"; readonly unordered?: boolean; }): <A, E2, R2, E, R>(self: Stream<Effect<A, E2, R2>, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E2, R2, E, R>(self: Stream<Effect<A, E2, R2>, E, R>, options?: { readonly concurrency?: number | "unbounded"; readonly unordered?: boolean; }): Stream<A, E2 | E, R2 | R>; }',
      description: "Flattens `Effect` values into the stream's structure, preserving all\ninformation about the effect.",
      documentation: "Flattens `Effect` values into the stream's structure, preserving all\ninformation about the effect.",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2850,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2850"
    },
    {
      id: "Stream.flattenExitOption",
      name: "flattenExitOption",
      module: "Stream",
      package: "effect",
      signature: "<A, E2, E, R>(self: Stream<Exit<A, Option<E2>>, E, R>) => Stream<A, E2 | E, R>",
      description: "Unwraps `Exit` values that also signify end-of-stream by failing with `None`.",
      documentation: "Unwraps `Exit` values that also signify end-of-stream by failing with `None`.",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2880,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2880"
    },
    {
      id: "Stream.flattenIterables",
      name: "flattenIterables",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(self: Stream<Iterable<A>, E, R>) => Stream<A, E, R>",
      description: "Submerges the iterables carried by this stream into the stream's structure,\nwhile still preserving them.",
      documentation: "Submerges the iterables carried by this stream into the stream's structure,\nwhile still preserving them.",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2888,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2888"
    },
    {
      id: "Stream.flattenTake",
      name: "flattenTake",
      module: "Stream",
      package: "effect",
      signature: "<A, E2, E, R>(self: Stream<Take<A, E2>, E, R>) => Stream<A, E2 | E, R>",
      description: "Unwraps `Exit` values and flatten chunks that also signify end-of-stream\nby failing with `None`.",
      documentation: "Unwraps `Exit` values and flatten chunks that also signify end-of-stream\nby failing with `None`.",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2896,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2896"
    },
    {
      id: "Stream.forever",
      name: "forever",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>",
      description: "Repeats this stream forever.",
      documentation: "Repeats this stream forever.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2903,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2903"
    },
    {
      id: "Stream.fromAsyncIterable",
      name: "fromAsyncIterable",
      module: "Stream",
      package: "effect",
      signature: "<A, E>(iterable: AsyncIterable<A>, onError: (e: unknown) => E) => Stream<A, E, never>",
      description: "Creates a stream from an `AsyncIterable`.",
      documentation: "Creates a stream from an `AsyncIterable`.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

const myAsyncIterable = async function*() {
  yield 1
  yield 2
}

const stream = Stream.fromAsyncIterable(
  myAsyncIterable(),
  (e) => new Error(String(e)) // Error Handling
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2 ] }`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2928,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2928"
    },
    {
      id: "Stream.fromChannel",
      name: "fromChannel",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(channel: Channel<Chunk<A>, unknown, E, unknown, unknown, unknown, R>) => Stream<A, E, R>",
      description: "Creates a stream from a `Channel`.",
      documentation: "Creates a stream from a `Channel`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2935,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2935"
    },
    {
      id: "Stream.toChannel",
      name: "toChannel",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(stream: Stream<A, E, R>) => Channel<Chunk<A>, unknown, E, unknown, unknown, unknown, R>",
      description: "Creates a channel from a `Stream`.",
      documentation: "Creates a channel from a `Stream`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2942,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2942"
    },
    {
      id: "Stream.fromChunk",
      name: "fromChunk",
      module: "Stream",
      package: "effect",
      signature: "<A>(chunk: Chunk<A>) => Stream<A, never, never>",
      description: "Creates a stream from a `Chunk` of values.",
      documentation: "Creates a stream from a `Chunk` of values.",
      examples: [
        {
          code: `import { Chunk, Effect, Stream } from "effect"

// Creating a stream with values from a single Chunk
const stream = Stream.fromChunk(Chunk.make(1, 2, 3))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3 ] }`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2960,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2960"
    },
    {
      id: "Stream.fromChunkPubSub",
      name: "fromChunkPubSub",
      module: "Stream",
      package: "effect",
      signature: "{ <A>(pubsub: PubSub<Chunk<A>>, options: { readonly scoped: true; readonly shutdown?: boolean; }): Effect<Stream<A, never, never>, never, Scope>; <A>(pubsub: PubSub<Chunk<A>>, options?: { readonly scoped?: false; readonly shutdown?: boolean; }): Stream<A, never, never>; }",
      description: "Creates a stream from a subscription to a `PubSub`. Options - `shutdown`: If `true`, the `PubSub` will be shutdown after the stream is evaluated (defaults to `false`)",
      documentation: "Creates a stream from a subscription to a `PubSub`.\n\n**Options**\n\n- `shutdown`: If `true`, the `PubSub` will be shutdown after the stream is evaluated (defaults to `false`)",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 2971,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L2971"
    },
    {
      id: "Stream.fromChunkQueue",
      name: "fromChunkQueue",
      module: "Stream",
      package: "effect",
      signature: "<A>(queue: Dequeue<Chunk<A>>, options?: { readonly shutdown?: boolean; }) => Stream<A, never, never>",
      description: "Creates a stream from a `Queue` of values. Options - `shutdown`: If `true`, the queue will be shutdown after the stream is evaluated (defaults to `false`)",
      documentation: "Creates a stream from a `Queue` of values.\n\n**Options**\n\n- `shutdown`: If `true`, the queue will be shutdown after the stream is evaluated (defaults to `false`)",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3011,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3011"
    },
    {
      id: "Stream.fromChunks",
      name: "fromChunks",
      module: "Stream",
      package: "effect",
      signature: "<A>(...chunks: Chunk<A>[]) => Stream<A, never, never>",
      description: "Creates a stream from an arbitrary number of chunks.",
      documentation: "Creates a stream from an arbitrary number of chunks.",
      examples: [
        {
          code: `import { Chunk, Effect, Stream } from "effect"

// Creating a stream with values from multiple Chunks
const stream = Stream.fromChunks(Chunk.make(1, 2, 3), Chunk.make(4, 5, 6))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5, 6 ] }`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3031,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3031"
    },
    {
      id: "Stream.fromEffect",
      name: "fromEffect",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(effect: Effect<A, E, R>) => Stream<A, E, R>",
      description: "Either emits the success value of this effect or terminates the stream\nwith the failure value of this effect.",
      documentation: "Either emits the success value of this effect or terminates the stream\nwith the failure value of this effect.",
      examples: [
        {
          code: `import { Effect, Random, Stream } from "effect"

const stream = Stream.fromEffect(Random.nextInt)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// Example Output: { _id: 'Chunk', values: [ 922694024 ] }`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3049,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3049"
    },
    {
      id: "Stream.fromEffectOption",
      name: "fromEffectOption",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(effect: Effect<A, Option<E>, R>) => Stream<A, E, R>",
      description: "Creates a stream from an effect producing a value of type `A` or an empty\n`Stream`.",
      documentation: "Creates a stream from an effect producing a value of type `A` or an empty\n`Stream`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3057,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3057"
    },
    {
      id: "Stream.fromPubSub",
      name: "fromPubSub",
      module: "Stream",
      package: "effect",
      signature: "{ <A>(pubsub: PubSub<A>, options: { readonly scoped: true; readonly maxChunkSize?: number; readonly shutdown?: boolean; }): Effect<Stream<A, never, never>, never, Scope>; <A>(pubsub: PubSub<A>, options?: { readonly scoped?: false; readonly maxChunkSize?: number; readonly shutdown?: boolean; }): Stream<A, never, never>; }",
      description: "Creates a stream from a subscription to a `PubSub`. Options - `shutdown`: If `true`, the `PubSub` will be shutdown after the stream is evaluated (defaults to `false`)",
      documentation: "Creates a stream from a subscription to a `PubSub`.\n\n**Options**\n\n- `shutdown`: If `true`, the `PubSub` will be shutdown after the stream is evaluated (defaults to `false`)",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3068,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3068"
    },
    {
      id: "Stream.fromTPubSub",
      name: "fromTPubSub",
      module: "Stream",
      package: "effect",
      signature: "<A>(pubsub: TPubSub<A>) => Stream<A, never, never>",
      description: "Creates a stream from a subscription to a `TPubSub`.",
      documentation: "Creates a stream from a subscription to a `TPubSub`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "3.10.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3106,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3106"
    },
    {
      id: "Stream.fromIterable",
      name: "fromIterable",
      module: "Stream",
      package: "effect",
      signature: "<A>(iterable: Iterable<A>) => Stream<A, never, never>",
      description: "Creates a new `Stream` from an iterable collection of values.",
      documentation: "Creates a new `Stream` from an iterable collection of values.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

const numbers = [1, 2, 3]

const stream = Stream.fromIterable(numbers)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3 ] }`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3125,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3125"
    },
    {
      id: "Stream.fromIterableEffect",
      name: "fromIterableEffect",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(effect: Effect<Iterable<A>, E, R>) => Stream<A, E, R>",
      description: "Creates a stream from an effect producing a value of type `Iterable<A>`.",
      documentation: "Creates a stream from an effect producing a value of type `Iterable<A>`.",
      examples: [
        {
          code: `import { Context, Effect, Stream } from "effect"

class Database extends Context.Tag("Database")<
  Database,
  { readonly getUsers: Effect.Effect<Array<string>> }
>() {}

const getUsers = Database.pipe(Effect.andThen((_) => _.getUsers))

const stream = Stream.fromIterableEffect(getUsers)

Effect.runPromise(
  Stream.runCollect(stream.pipe(Stream.provideService(Database, { getUsers: Effect.succeed(["user1", "user2"]) })))
).then(console.log)
// { _id: 'Chunk', values: [ 'user1', 'user2' ] }`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3151,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3151"
    },
    {
      id: "Stream.fromIteratorSucceed",
      name: "fromIteratorSucceed",
      module: "Stream",
      package: "effect",
      signature: "<A>(iterator: IterableIterator<A>, maxChunkSize?: number) => Stream<A, never, never>",
      description: "Creates a stream from an iterator",
      documentation: "Creates a stream from an iterator",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3158,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3158"
    },
    {
      id: "Stream.fromPull",
      name: "fromPull",
      module: "Stream",
      package: "effect",
      signature: "<R, R2, E, A>(effect: Effect<Effect<Chunk<A>, Option<E>, R2>, never, Scope | R>) => Stream<A, E, R2 | Exclude<R, Scope>>",
      description: "Creates a stream from an effect that pulls elements from another stream. See `Stream.toPull` for reference.",
      documentation: "Creates a stream from an effect that pulls elements from another stream.\n\nSee `Stream.toPull` for reference.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3167,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3167"
    },
    {
      id: "Stream.fromQueue",
      name: "fromQueue",
      module: "Stream",
      package: "effect",
      signature: "<A>(queue: Dequeue<A>, options?: { readonly maxChunkSize?: number; readonly shutdown?: boolean; }) => Stream<A, never, never>",
      description: "Creates a stream from a queue of values Options - `maxChunkSize`: The maximum number of queued elements to put in one chunk in the stream\n- `shutdown`: If `true`, the queue will be shutdown after the stream is evaluated (defaults to `false`)",
      documentation: "Creates a stream from a queue of values\n\n**Options**\n\n- `maxChunkSize`: The maximum number of queued elements to put in one chunk in the stream\n- `shutdown`: If `true`, the queue will be shutdown after the stream is evaluated (defaults to `false`)",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3179,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3179"
    },
    {
      id: "Stream.fromTQueue",
      name: "fromTQueue",
      module: "Stream",
      package: "effect",
      signature: "<A>(queue: TDequeue<A>) => Stream<A, never, never>",
      description: "Creates a stream from a TQueue of values",
      documentation: "Creates a stream from a TQueue of values",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "3.10.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3189,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3189"
    },
    {
      id: "Stream.fromReadableStream",
      name: "fromReadableStream",
      module: "Stream",
      package: "effect",
      signature: "{ <A, E>(options: { readonly evaluate: LazyArg<ReadableStream<A>>; readonly onError: (error: unknown) => E; readonly releaseLockOnEnd?: boolean; }): Stream<A, E, never>; <A, E>(evaluate: LazyArg<ReadableStream<A>>, onError: (error: unknown) => E): Stream<A, E, never>; }",
      description: "Creates a stream from a `ReadableStream`. See https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.",
      documentation: "Creates a stream from a `ReadableStream`.\n\nSee https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3198,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3198"
    },
    {
      id: "Stream.fromReadableStreamByob",
      name: "fromReadableStreamByob",
      module: "Stream",
      package: "effect",
      signature: "{ <E>(options: { readonly evaluate: LazyArg<ReadableStream<Uint8Array>>; readonly onError: (error: unknown) => E; readonly bufferSize?: number; readonly releaseLockOnEnd?: boolean; }): Stream<Uint8Array, E, never>; <E>(evaluate: LazyArg<ReadableStream<Uint8Array>>, onError: (error: unknown) => E, allocSize?: number): Stream<Uint8Array, E, never>; }",
      description: "Creates a stream from a `ReadableStreamBYOBReader`. See https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamBYOBReader.",
      documentation: "Creates a stream from a `ReadableStreamBYOBReader`.\n\nSee https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamBYOBReader.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3230,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3230"
    },
    {
      id: "Stream.fromSchedule",
      name: "fromSchedule",
      module: "Stream",
      package: "effect",
      signature: "<A, R>(schedule: Schedule<A, unknown, R>) => Stream<A, never, R>",
      description: "Creates a stream from a `Schedule` that does not require any further\ninput. The stream will emit an element for each value output from the\nschedule, continuing for as long as the schedule continues.",
      documentation: "Creates a stream from a `Schedule` that does not require any further\ninput. The stream will emit an element for each value output from the\nschedule, continuing for as long as the schedule continues.",
      examples: [
        {
          code: `import { Effect, Schedule, Stream } from "effect"

// Emits values every 1 second for a total of 5 emissions
const schedule = Schedule.spaced("1 second").pipe(
  Schedule.compose(Schedule.recurs(5))
)

const stream = Stream.fromSchedule(schedule)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3280,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3280"
    },
    {
      id: "Stream.groupAdjacentBy",
      name: "groupAdjacentBy",
      module: "Stream",
      package: "effect",
      signature: "{ <A, K>(f: (a: A) => K): <E, R>(self: Stream<A, E, R>) => Stream<[K, NonEmptyChunk<A>], E, R>; <A, E, R, K>(self: Stream<A, E, R>, f: (a: A) => K): Stream<[K, NonEmptyChunk<A>], E, R>; }",
      description: "Creates a pipeline that groups on adjacent keys, calculated by the\nspecified function.",
      documentation: "Creates a pipeline that groups on adjacent keys, calculated by the\nspecified function.",
      examples: [],
      tags: [
        "grouping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3288,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3288"
    },
    {
      id: "Stream.groupBy",
      name: "groupBy",
      module: "Stream",
      package: "effect",
      signature: "{ <A, K, V, E2, R2>(f: (a: A) => Effect<readonly [K, V], E2, R2>, options?: { readonly bufferSize?: number; }): <E, R>(self: Stream<A, E, R>) => GroupBy<K, V, E2 | E, R2 | R>; <A, E, R, K, V, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect<readonly [K, V], E2, R2>, options?: { readonly bufferSize?: number; }): GroupBy<K, V, E | E2, R | R2>; }",
      description: "More powerful version of `Stream.groupByKey`.",
      documentation: "More powerful version of `Stream.groupByKey`.",
      examples: [
        {
          code: `import { Chunk, Effect, GroupBy, Stream } from "effect"

const groupByKeyResult = Stream.fromIterable([
  "Mary",
  "James",
  "Robert",
  "Patricia",
  "John",
  "Jennifer",
  "Rebecca",
  "Peter"
]).pipe(
  Stream.groupBy((name) => Effect.succeed([name.substring(0, 1), name]))
)

const stream = GroupBy.evaluate(groupByKeyResult, (key, stream) =>
  Stream.fromEffect(
    Stream.runCollect(stream).pipe(
      Effect.andThen((chunk) => [key, Chunk.size(chunk)] as const)
    )
  ))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// {
//   _id: 'Chunk',
//   values: [ [ 'M', 1 ], [ 'J', 3 ], [ 'R', 2 ], [ 'P', 2 ] ]
// }`
        }
      ],
      tags: [
        "grouping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3343,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3343"
    },
    {
      id: "Stream.groupByKey",
      name: "groupByKey",
      module: "Stream",
      package: "effect",
      signature: "{ <A, K>(f: (a: A) => K, options?: { readonly bufferSize?: number; }): <E, R>(self: Stream<A, E, R>) => GroupBy<K, A, E, R>; <A, E, R, K>(self: Stream<A, E, R>, f: (a: A) => K, options?: { readonly bufferSize?: number; }): GroupBy<K, A, E, R>; }",
      description: "Partition a stream using a function and process each stream individually.\nThis returns a data structure that can be used to further filter down which\ngroups shall be processed. After calling apply on the GroupBy object, the remaining groups will be\nprocessed in parallel and the resulting streams merged in a\nnondeterministic fashion. Up to `buffer` elements may be buffered in any group stream before the\nproducer is backpressured. Take care to consume from all streams in order\nto prevent deadlocks. For example, to collect the first 2 words for every starting letter from a\nstream of words:",
      documentation: 'Partition a stream using a function and process each stream individually.\nThis returns a data structure that can be used to further filter down which\ngroups shall be processed.\n\nAfter calling apply on the GroupBy object, the remaining groups will be\nprocessed in parallel and the resulting streams merged in a\nnondeterministic fashion.\n\nUp to `buffer` elements may be buffered in any group stream before the\nproducer is backpressured. Take care to consume from all streams in order\nto prevent deadlocks.\n\nFor example, to collect the first 2 words for every starting letter from a\nstream of words:\n\n```ts\nimport { pipe, GroupBy, Stream } from "effect"\n\npipe(\n  Stream.fromIterable(["hello", "world", "hi", "holla"]),\n  Stream.groupByKey((word) => word[0]),\n  GroupBy.evaluate((key, stream) =>\n    pipe(\n      stream,\n      Stream.take(2),\n      Stream.map((words) => [key, words] as const)\n    )\n  )\n)\n```',
      examples: [],
      tags: [
        "grouping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3460,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3460"
    },
    {
      id: "Stream.grouped",
      name: "grouped",
      module: "Stream",
      package: "effect",
      signature: "{ (chunkSize: number): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, chunkSize: number): Stream<Chunk<A>, E, R>; }",
      description: "Partitions the stream with specified `chunkSize`.",
      documentation: "Partitions the stream with specified `chunkSize`.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

const stream = Stream.range(0, 8).pipe(Stream.grouped(3))

Effect.runPromise(Stream.runCollect(stream)).then((chunks) => console.log("%o", chunks))
// {
//   _id: 'Chunk',
//   values: [
//     { _id: 'Chunk', values: [ 0, 1, 2, [length]: 3 ] },
//     { _id: 'Chunk', values: [ 3, 4, 5, [length]: 3 ] },
//     { _id: 'Chunk', values: [ 6, 7, 8, [length]: 3 ] },
//     [length]: 3
//   ]
// }`
        }
      ],
      tags: [
        "grouping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3562,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3562"
    },
    {
      id: "Stream.groupedWithin",
      name: "groupedWithin",
      module: "Stream",
      package: "effect",
      signature: "{ (chunkSize: number, duration: DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, chunkSize: number, duration: DurationInput): Stream<Chunk<A>, E, R>; }",
      description: "Partitions the stream with the specified `chunkSize` or until the specified\n`duration` has passed, whichever is satisfied first.",
      documentation: "Partitions the stream with the specified `chunkSize` or until the specified\n`duration` has passed, whichever is satisfied first.",
      examples: [
        {
          code: `import { Chunk, Effect, Schedule, Stream } from "effect"

const stream = Stream.range(0, 9).pipe(
  Stream.repeat(Schedule.spaced("1 second")),
  Stream.groupedWithin(18, "1.5 seconds"),
  Stream.take(3)
)

Effect.runPromise(Stream.runCollect(stream)).then((chunks) => console.log(Chunk.toArray(chunks)))
// [
//   {
//     _id: 'Chunk',
//     values: [
//       0, 1, 2, 3, 4, 5, 6,
//       7, 8, 9, 0, 1, 2, 3,
//       4, 5, 6, 7
//     ]
//   },
//   {
//     _id: 'Chunk',
//     values: [
//       8, 9, 0, 1, 2,
//       3, 4, 5, 6, 7,
//       8, 9
//     ]
//   },
//   {
//     _id: 'Chunk',
//     values: [
//       0, 1, 2, 3, 4, 5, 6,
//       7, 8, 9, 0, 1, 2, 3,
//       4, 5, 6, 7
//     ]
//   }
// ]`
        }
      ],
      tags: [
        "grouping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3660,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3660"
    },
    {
      id: "Stream.haltAfter",
      name: "haltAfter",
      module: "Stream",
      package: "effect",
      signature: "{ (duration: DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, duration: DurationInput): Stream<A, E, R>; }",
      description: "Specialized version of haltWhen which halts the evaluation of this stream\nafter the given duration. An element in the process of being pulled will not be interrupted when the\ngiven duration completes. See `interruptAfter` for this behavior.",
      documentation: "Specialized version of haltWhen which halts the evaluation of this stream\nafter the given duration.\n\nAn element in the process of being pulled will not be interrupted when the\ngiven duration completes. See `interruptAfter` for this behavior.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3766,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3766"
    },
    {
      id: "Stream.haltWhen",
      name: "haltWhen",
      module: "Stream",
      package: "effect",
      signature: "{ <X, E2, R2>(effect: Effect<X, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, effect: Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }",
      description: "Halts the evaluation of this stream when the provided effect completes. The\ngiven effect will be forked as part of the returned stream, and its success\nwill be discarded. An element in the process of being pulled will not be interrupted when the\neffect completes. See `interruptWhen` for this behavior. If the effect completes with a failure, the stream will emit that failure.",
      documentation: "Halts the evaluation of this stream when the provided effect completes. The\ngiven effect will be forked as part of the returned stream, and its success\nwill be discarded.\n\nAn element in the process of being pulled will not be interrupted when the\neffect completes. See `interruptWhen` for this behavior.\n\nIf the effect completes with a failure, the stream will emit that failure.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3803,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3803"
    },
    {
      id: "Stream.haltWhenDeferred",
      name: "haltWhenDeferred",
      module: "Stream",
      package: "effect",
      signature: "{ <X, E2>(deferred: Deferred<X, E2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>; <A, E, R, X, E2>(self: Stream<A, E, R>, deferred: Deferred<X, E2>): Stream<A, E | E2, R>; }",
      description: "Halts the evaluation of this stream when the provided promise resolves. If the promise completes with a failure, the stream will emit that failure.",
      documentation: "Halts the evaluation of this stream when the provided promise resolves.\n\nIf the promise completes with a failure, the stream will emit that failure.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3841,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3841"
    },
    {
      id: "Stream.identity",
      name: "identity",
      module: "Stream",
      package: "effect",
      signature: "<A, E = never, R = never>() => Stream<A, E, R>",
      description: "The identity pipeline, which does not modify streams in any way.",
      documentation: "The identity pipeline, which does not modify streams in any way.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3867,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3867"
    },
    {
      id: "Stream.interleave",
      name: "interleave",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<A | A2, E | E2, R | R2>; }",
      description: "Interleaves this stream and the specified stream deterministically by\nalternating pulling values from this stream and the specified stream. When\none stream is exhausted all remaining values in the other stream will be\npulled.",
      documentation: "Interleaves this stream and the specified stream deterministically by\nalternating pulling values from this stream and the specified stream. When\none stream is exhausted all remaining values in the other stream will be\npulled.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

const s1 = Stream.make(1, 2, 3)
const s2 = Stream.make(4, 5, 6)

const stream = Stream.interleave(s1, s2)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 4, 2, 5, 3, 6 ] }`
        }
      ],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3889,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3889"
    },
    {
      id: "Stream.interleaveWith",
      name: "interleaveWith",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, E2, R2, E3, R3>(that: Stream<A2, E2, R2>, decider: Stream<boolean, E3, R3>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E3 | E, R2 | R3 | R>; <A, E, R, A2, E2, R2, E3, R3>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, decider: Stream<boolean, E3, R3>): Stream<A | A2, E | E2 | E3, R | R2 | R3>; }",
      description: "Combines this stream and the specified stream deterministically using the\nstream of boolean values `pull` to control which stream to pull from next.\nA value of `true` indicates to pull from this stream and a value of `false`\nindicates to pull from the specified stream. Only consumes as many elements\nas requested by the `pull` stream. If either this stream or the specified\nstream are exhausted further requests for values from that stream will be\nignored.",
      documentation: "Combines this stream and the specified stream deterministically using the\nstream of boolean values `pull` to control which stream to pull from next.\nA value of `true` indicates to pull from this stream and a value of `false`\nindicates to pull from the specified stream. Only consumes as many elements\nas requested by the `pull` stream. If either this stream or the specified\nstream are exhausted further requests for values from that stream will be\nignored.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

const s1 = Stream.make(1, 3, 5, 7, 9)
const s2 = Stream.make(2, 4, 6, 8, 10)

const booleanStream = Stream.make(true, false, false).pipe(Stream.forever)

const stream = Stream.interleaveWith(s1, s2, booleanStream)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// {
//   _id: 'Chunk',
//   values: [
//     1, 2,  4, 3, 6,
//     8, 5, 10, 7, 9
//   ]
// }`
        }
      ],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 3968,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L3968"
    },
    {
      id: "Stream.intersperse",
      name: "intersperse",
      module: "Stream",
      package: "effect",
      signature: "{ <A2>(element: A2): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, element: A2): Stream<A | A2, E, R>; }",
      description: "Intersperse stream with provided `element`.",
      documentation: "Intersperse stream with provided `element`.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

const stream = Stream.make(1, 2, 3, 4, 5).pipe(Stream.intersperse(0))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// {
//   _id: 'Chunk',
//   values: [
//     1, 0, 2, 0, 3,
//     0, 4, 0, 5
//   ]
// }`
        }
      ],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 4060,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L4060"
    },
    {
      id: "Stream.intersperseAffixes",
      name: "intersperseAffixes",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, A3, A4>(options: { readonly start: A2; readonly middle: A3; readonly end: A4; }): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A3 | A4 | A, E, R>; <A, E, R, A2, A3, A4>(self: Stream<A, E, R>, options: { readonly start: A2; readonly middle: A3; readonly end: A4; }): Stream<A | A2 | A3 | A4, E, R>; }",
      description: "Intersperse the specified element, also adding a prefix and a suffix.",
      documentation: "Intersperse the specified element, also adding a prefix and a suffix.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

const stream = Stream.make(1, 2, 3, 4, 5).pipe(
  Stream.intersperseAffixes({
    start: "[",
    middle: "-",
    end: "]"
  })
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// {
//   _id: 'Chunk',
//   values: [
//     '[', 1,   '-', 2,   '-',
//     3,   '-', 4,   '-', 5,
//     ']'
//   ]
// }`
        }
      ],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 4137,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L4137"
    },
    {
      id: "Stream.interruptAfter",
      name: "interruptAfter",
      module: "Stream",
      package: "effect",
      signature: "{ (duration: DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, duration: DurationInput): Stream<A, E, R>; }",
      description: "Specialized version of `Stream.interruptWhen` which interrupts the\nevaluation of this stream after the given `Duration`.",
      documentation: "Specialized version of `Stream.interruptWhen` which interrupts the\nevaluation of this stream after the given `Duration`.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 4214,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L4214"
    },
    {
      id: "Stream.interruptWhen",
      name: "interruptWhen",
      module: "Stream",
      package: "effect",
      signature: "{ <X, E2, R2>(effect: Effect<X, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, effect: Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }",
      description: "Interrupts the evaluation of this stream when the provided effect\ncompletes. The given effect will be forked as part of this stream, and its\nsuccess will be discarded. This combinator will also interrupt any\nin-progress element being pulled from upstream. If the effect completes with a failure before the stream completes, the\nreturned stream will emit that failure.",
      documentation: "Interrupts the evaluation of this stream when the provided effect\ncompletes. The given effect will be forked as part of this stream, and its\nsuccess will be discarded. This combinator will also interrupt any\nin-progress element being pulled from upstream.\n\nIf the effect completes with a failure before the stream completes, the\nreturned stream will emit that failure.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 4244,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L4244"
    },
    {
      id: "Stream.interruptWhenDeferred",
      name: "interruptWhenDeferred",
      module: "Stream",
      package: "effect",
      signature: "{ <X, E2>(deferred: Deferred<X, E2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>; <A, E, R, X, E2>(self: Stream<A, E, R>, deferred: Deferred<X, E2>): Stream<A, E | E2, R>; }",
      description: "Interrupts the evaluation of this stream when the provided promise\nresolves. This combinator will also interrupt any in-progress element being\npulled from upstream. If the promise completes with a failure, the stream will emit that failure.",
      documentation: "Interrupts the evaluation of this stream when the provided promise\nresolves. This combinator will also interrupt any in-progress element being\npulled from upstream.\n\nIf the promise completes with a failure, the stream will emit that failure.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 4282,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L4282"
    },
    {
      id: "Stream.iterate",
      name: "iterate",
      module: "Stream",
      package: "effect",
      signature: "<A>(value: A, next: (value: A) => A) => Stream<A, never, never>",
      description: "The infinite stream of iterative function application: a, f(a), f(f(a)),\nf(f(f(a))), ...",
      documentation: "The infinite stream of iterative function application: a, f(a), f(f(a)),\nf(f(f(a))), ...",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

// An infinite Stream of numbers starting from 1 and incrementing
const stream = Stream.iterate(1, (n) => n + 1)

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(10)))).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ] }`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 4324,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L4324"
    },
    {
      id: "Stream.make",
      name: "make",
      module: "Stream",
      package: "effect",
      signature: "<As extends Array<any>>(...as: As) => Stream<As[number], never, never>",
      description: "Creates a stream from an sequence of values.",
      documentation: "Creates a stream from an sequence of values.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

const stream = Stream.make(1, 2, 3)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3 ] }`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 4341,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L4341"
    },
    {
      id: "Stream.map",
      name: "map",
      module: "Stream",
      package: "effect",
      signature: "{ <A, B>(f: (a: A) => B): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, E, R, B>(self: Stream<A, E, R>, f: (a: A) => B): Stream<B, E, R>; }",
      description: "Transforms the elements of this stream using the supplied function.",
      documentation: "Transforms the elements of this stream using the supplied function.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

const stream = Stream.make(1, 2, 3).pipe(Stream.map((n) => n + 1))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 2, 3, 4 ] }`
        }
      ],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 4358,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L4358"
    },
    {
      id: "Stream.mapAccum",
      name: "mapAccum",
      module: "Stream",
      package: "effect",
      signature: "{ <S, A, A2>(s: S, f: (s: S, a: A) => readonly [S, A2]): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>; <A, E, R, S, A2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => readonly [S, A2]): Stream<A2, E, R>; }",
      description: "Statefully maps over the elements of this stream to produce new elements.",
      documentation: "Statefully maps over the elements of this stream to produce new elements.",
      examples: [
        {
          code: 'import { Effect, Stream } from "effect"\n\nconst runningTotal = (stream: Stream.Stream<number>): Stream.Stream<number> =>\n  stream.pipe(Stream.mapAccum(0, (s, a) => [s + a, s + a]))\n\n// input:  0, 1, 2, 3, 4, 5, 6\nEffect.runPromise(Stream.runCollect(runningTotal(Stream.range(0, 6)))).then(\n  console.log\n)\n// { _id: "Chunk", values: [ 0, 1, 3, 6, 10, 15, 21 ] }'
        }
      ],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 4414,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L4414"
    },
    {
      id: "Stream.mapAccumEffect",
      name: "mapAccumEffect",
      module: "Stream",
      package: "effect",
      signature: "{ <S, A, A2, E2, R2>(s: S, f: (s: S, a: A) => Effect<readonly [S, A2], E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, S, A2, E2, R2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => Effect<readonly [S, A2], E2, R2>): Stream<A2, E | E2, R | R2>; }",
      description: "Statefully and effectfully maps over the elements of this stream to produce\nnew elements.",
      documentation: "Statefully and effectfully maps over the elements of this stream to produce\nnew elements.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 4465,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L4465"
    },
    {
      id: "Stream.mapBoth",
      name: "mapBoth",
      module: "Stream",
      package: "effect",
      signature: "{ <E, E2, A, A2>(options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): <R>(self: Stream<A, E, R>) => Stream<A2, E2, R>; <A, E, R, E2, A2>(self: Stream<A, E, R>, options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): Stream<A2, E2, R>; }",
      description: "Returns a stream whose failure and success channels have been mapped by the\nspecified `onFailure` and `onSuccess` functions.",
      documentation: "Returns a stream whose failure and success channels have been mapped by the\nspecified `onFailure` and `onSuccess` functions.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 4490,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L4490"
    },
    {
      id: "Stream.mapChunks",
      name: "mapChunks",
      module: "Stream",
      package: "effect",
      signature: "{ <A, B>(f: (chunk: Chunk<A>) => Chunk<B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, E, R, B>(self: Stream<A, E, R>, f: (chunk: Chunk<A>) => Chunk<B>): Stream<B, E, R>; }",
      description: "Transforms the chunks emitted by this stream.",
      documentation: "Transforms the chunks emitted by this stream.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 4520,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L4520"
    },
    {
      id: "Stream.mapChunksEffect",
      name: "mapChunksEffect",
      module: "Stream",
      package: "effect",
      signature: "{ <A, B, E2, R2>(f: (chunk: Chunk<A>) => Effect<Chunk<B>, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<B, E2 | E, R2 | R>; <A, E, R, B, E2, R2>(self: Stream<A, E, R>, f: (chunk: Chunk<A>) => Effect<Chunk<B>, E2, R2>): Stream<B, E | E2, R | R2>; }",
      description: "Effectfully transforms the chunks emitted by this stream.",
      documentation: "Effectfully transforms the chunks emitted by this stream.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 4542,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L4542"
    },
    {
      id: "Stream.mapConcat",
      name: "mapConcat",
      module: "Stream",
      package: "effect",
      signature: "{ <A, A2>(f: (a: A) => Iterable<A2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, f: (a: A) => Iterable<A2>): Stream<A2, E, R>; }",
      description: "Maps each element to an iterable, and flattens the iterables into the\noutput of this stream.",
      documentation: "Maps each element to an iterable, and flattens the iterables into the\noutput of this stream.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

const numbers = Stream.make("1-2-3", "4-5", "6").pipe(
  Stream.mapConcat((s) => s.split("-")),
  Stream.map((s) => parseInt(s))
)

Effect.runPromise(Stream.runCollect(numbers)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5, 6 ] }`
        }
      ],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 4578,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L4578"
    },
    {
      id: "Stream.mapConcatChunk",
      name: "mapConcatChunk",
      module: "Stream",
      package: "effect",
      signature: "{ <A, A2>(f: (a: A) => Chunk<A2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, f: (a: A) => Chunk<A2>): Stream<A2, E, R>; }",
      description: "Maps each element to a chunk, and flattens the chunks into the output of\nthis stream.",
      documentation: "Maps each element to a chunk, and flattens the chunks into the output of\nthis stream.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 4629,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L4629"
    },
    {
      id: "Stream.mapConcatChunkEffect",
      name: "mapConcatChunkEffect",
      module: "Stream",
      package: "effect",
      signature: "{ <A, A2, E2, R2>(f: (a: A) => Effect<Chunk<A2>, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect<Chunk<A2>, E2, R2>): Stream<A2, E | E2, R | R2>; }",
      description: "Effectfully maps each element to a chunk, and flattens the chunks into the\noutput of this stream.",
      documentation: "Effectfully maps each element to a chunk, and flattens the chunks into the\noutput of this stream.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 4654,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L4654"
    },
    {
      id: "Stream.mapConcatEffect",
      name: "mapConcatEffect",
      module: "Stream",
      package: "effect",
      signature: "{ <A, A2, E2, R2>(f: (a: A) => Effect<Iterable<A2>, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect<Iterable<A2>, E2, R2>): Stream<A2, E | E2, R | R2>; }",
      description: "Effectfully maps each element to an iterable, and flattens the iterables\ninto the output of this stream.",
      documentation: "Effectfully maps each element to an iterable, and flattens the iterables\ninto the output of this stream.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 4679,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L4679"
    },
    {
      id: "Stream.mapEffect",
      name: "mapEffect",
      module: "Stream",
      package: "effect",
      signature: '{ <A, A2, E2, R2>(f: (a: A) => Effect<A2, E2, R2>, options?: { readonly concurrency?: number | "unbounded"; readonly unordered?: boolean; }): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, A2, E2, R2, K>(f: (a: A) => Effect<A2, E2, R2>, options: { readonly key: (a: A) => K; readonly bufferSize?: number; }): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect<A2, E2, R2>, options?: { readonly concurrency?: number | "unbounded"; readonly unordered?: boolean; }): Stream<A2, E | E2, R | R2>; <A, E, R, A2, E2, R2, K>(self: Stream<A, E, R>, f: (a: A) => Effect<A2, E2, R2>, options: { readonly key: (a: A) => K; readonly bufferSize?: number; }): Stream<A2, E | E2, R | R2>; }',
      description: "Maps over elements of the stream with the specified effectful function.",
      documentation: "Maps over elements of the stream with the specified effectful function.",
      examples: [
        {
          code: `import { Effect, Random, Stream } from "effect"

const stream = Stream.make(10, 20, 30).pipe(
  Stream.mapEffect((n) => Random.nextIntBetween(0, n))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// Example Output: { _id: 'Chunk', values: [ 7, 19, 8 ] }`
        }
      ],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 4715,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L4715"
    },
    {
      id: "Stream.mapError",
      name: "mapError",
      module: "Stream",
      package: "effect",
      signature: "{ <E, E2>(f: (error: E) => E2): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, f: (error: E) => E2): Stream<A, E2, R>; }",
      description: "Transforms the errors emitted by this stream using `f`.",
      documentation: "Transforms the errors emitted by this stream using `f`.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 4811,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L4811"
    },
    {
      id: "Stream.mapErrorCause",
      name: "mapErrorCause",
      module: "Stream",
      package: "effect",
      signature: "{ <E, E2>(f: (cause: Cause<E>) => Cause<E2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, f: (cause: Cause<E>) => Cause<E2>): Stream<A, E2, R>; }",
      description: "Transforms the full causes of failures emitted by this stream.",
      documentation: "Transforms the full causes of failures emitted by this stream.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 4833,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L4833"
    },
    {
      id: "Stream.merge",
      name: "merge",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, E2, R2>(that: Stream<A2, E2, R2>, options?: { readonly haltStrategy?: HaltStrategyInput; }): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, options?: { readonly haltStrategy?: HaltStrategyInput; }): Stream<A | A2, E | E2, R | R2>; }",
      description: "Merges this stream and the specified stream together. New produced stream will terminate when both specified stream terminate if\nno termination strategy is specified.",
      documentation: "Merges this stream and the specified stream together.\n\nNew produced stream will terminate when both specified stream terminate if\nno termination strategy is specified.",
      examples: [
        {
          code: `import { Effect, Schedule, Stream } from "effect"

const s1 = Stream.make(1, 2, 3).pipe(
  Stream.schedule(Schedule.spaced("100 millis"))
)
const s2 = Stream.make(4, 5, 6).pipe(
  Stream.schedule(Schedule.spaced("200 millis"))
)

const stream = Stream.merge(s1, s2)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 4, 2, 3, 5, 6 ] }`
        }
      ],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 4875,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L4875"
    },
    {
      id: "Stream.mergeAll",
      name: "mergeAll",
      module: "Stream",
      package: "effect",
      signature: '{ (options: { readonly concurrency: number | "unbounded"; readonly bufferSize?: number; }): <A, E, R>(streams: Iterable<Stream<A, E, R>>) => Stream<A, E, R>; <A, E, R>(streams: Iterable<Stream<A, E, R>>, options: { readonly concurrency: number | "unbounded"; readonly bufferSize?: number; }): Stream<A, E, R>; }',
      description: "Merges a variable list of streams in a non-deterministic fashion. Up to `n`\nstreams may be consumed in parallel and up to `outputBuffer` chunks may be\nbuffered by this operator.",
      documentation: "Merges a variable list of streams in a non-deterministic fashion. Up to `n`\nstreams may be consumed in parallel and up to `outputBuffer` chunks may be\nbuffered by this operator.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 4943,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L4943"
    },
    {
      id: "Stream.mergeWithTag",
      name: "mergeWithTag",
      module: "Stream",
      package: "effect",
      signature: '{ <S extends { [k in string]: Stream<any, any, any>; }>(streams: S, options: { readonly concurrency: number | "unbounded"; readonly bufferSize?: number; }): Stream<{ [K in keyof S]: { _tag: K; value: Stream.Success<S[K]>; }; }[keyof S], Stream.Error<S[keyof S]>, Stream.Context<S[keyof S]>>; (options: { readonly concurrency: number | "unbounded"; readonly bufferSize?: number; }): <S extends { [k in string]: Stream<any, any, any>; }>(streams: S) => Stream<{ [K in keyof S]: { _tag: K; value: Stream.Success<S[K]>; }; }[keyof S], Stream.Error<S[keyof S]>, Stream.Context<S[keyof S]>>; }',
      description: "Merges a struct of streams into a single stream of tagged values.",
      documentation: "Merges a struct of streams into a single stream of tagged values.",
      examples: [
        {
          code: 'import { Stream } from "effect"\n// Stream.Stream<{ _tag: "a"; value: number; } | { _tag: "b"; value: string; }>\nconst res = Stream.mergeWithTag({\n   a: Stream.make(0),\n   b: Stream.make("")\n}, { concurrency: "unbounded" })'
        }
      ],
      tags: [
        "combinators"
      ],
      since: "3.8.5",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 4984,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L4984"
    },
    {
      id: "Stream.mergeWith",
      name: "mergeWith",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, E2, R2, A, A3, A4>(other: Stream<A2, E2, R2>, options: { readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A4; readonly haltStrategy?: HaltStrategyInput; }): <E, R>(self: Stream<A, E, R>) => Stream<A3 | A4, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, A3, A4>(self: Stream<A, E, R>, other: Stream<A2, E2, R2>, options: { readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A4; readonly haltStrategy?: HaltStrategyInput; }): Stream<A3 | A4, E | E2, R | R2>; }",
      description: "Merges this stream and the specified stream together to a common element\ntype with the specified mapping functions. New produced stream will terminate when both specified stream terminate if\nno termination strategy is specified.",
      documentation: "Merges this stream and the specified stream together to a common element\ntype with the specified mapping functions.\n\nNew produced stream will terminate when both specified stream terminate if\nno termination strategy is specified.",
      examples: [
        {
          code: `import { Effect, Schedule, Stream } from "effect"

const s1 = Stream.make("1", "2", "3").pipe(
  Stream.schedule(Schedule.spaced("100 millis"))
)
const s2 = Stream.make(4.1, 5.3, 6.2).pipe(
  Stream.schedule(Schedule.spaced("200 millis"))
)

const stream = Stream.mergeWith(s1, s2, {
  onSelf: (s) => parseInt(s),
  onOther: (n) => Math.floor(n)
})

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 4, 2, 3, 5, 6 ] }`
        }
      ],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5068,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5068"
    },
    {
      id: "Stream.mergeEither",
      name: "mergeEither",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<Either<A2, A>, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<Either<A2, A>, E | E2, R | R2>; }",
      description: "Merges this stream and the specified stream together to produce a stream of\neithers.",
      documentation: "Merges this stream and the specified stream together to produce a stream of\neithers.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5147,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5147"
    },
    {
      id: "Stream.mergeLeft",
      name: "mergeLeft",
      module: "Stream",
      package: "effect",
      signature: "{ <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL, EL | ER, RL | RR>; }",
      description: "Merges this stream and the specified stream together, discarding the values\nfrom the right stream.",
      documentation: "Merges this stream and the specified stream together, discarding the values\nfrom the right stream.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5172,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5172"
    },
    {
      id: "Stream.mergeRight",
      name: "mergeRight",
      module: "Stream",
      package: "effect",
      signature: "{ <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AR, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AR, EL | ER, RL | RR>; }",
      description: "Merges this stream and the specified stream together, discarding the values\nfrom the left stream.",
      documentation: "Merges this stream and the specified stream together, discarding the values\nfrom the left stream.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5197,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5197"
    },
    {
      id: "Stream.mkString",
      name: "mkString",
      module: "Stream",
      package: "effect",
      signature: "<E, R>(self: Stream<string, E, R>) => Effect<string, E, R>",
      description: "Returns a combined string resulting from concatenating each of the values\nfrom the stream.",
      documentation: "Returns a combined string resulting from concatenating each of the values\nfrom the stream.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5222,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5222"
    },
    {
      id: "Stream.never",
      name: "never",
      module: "Stream",
      package: "effect",
      signature: "Stream<never, never, never>",
      description: "The stream that never produces any value or fails with any error.",
      documentation: "The stream that never produces any value or fails with any error.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5229,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5229"
    },
    {
      id: "Stream.onEnd",
      name: "onEnd",
      module: "Stream",
      package: "effect",
      signature: "{ <_, E2, R2>(effect: Effect<_, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, _, E2, R2>(self: Stream<A, E, R>, effect: Effect<_, E2, R2>): Stream<A, E | E2, R | R2>; }",
      description: "Adds an effect to be executed at the end of the stream.",
      documentation: "Adds an effect to be executed at the end of the stream.",
      examples: [
        {
          code: 'import { Console, Effect, Stream } from "effect"\n\nconst stream = Stream.make(1, 2, 3).pipe(\n  Stream.map((n) => n * 2),\n  Stream.tap((n) => Console.log(`after mapping: ${n}`)),\n  Stream.onEnd(Console.log("Stream ended"))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// after mapping: 2\n// after mapping: 4\n// after mapping: 6\n// Stream ended\n// { _id: \'Chunk\', values: [ 2, 4, 6 ] }'
        }
      ],
      tags: [
        "sequencing"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5254,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5254"
    },
    {
      id: "Stream.onError",
      name: "onError",
      module: "Stream",
      package: "effect",
      signature: "{ <E, X, R2>(cleanup: (cause: Cause<E>) => Effect<X, never, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, R2>(self: Stream<A, E, R>, cleanup: (cause: Cause<E>) => Effect<X, never, R2>): Stream<A, E, R | R2>; }",
      description: "Runs the specified effect if this stream fails, providing the error to the\neffect if it exists. Note: Unlike `Effect.onError` there is no guarantee that the provided\neffect will not be interrupted.",
      documentation: "Runs the specified effect if this stream fails, providing the error to the\neffect if it exists.\n\nNote: Unlike `Effect.onError` there is no guarantee that the provided\neffect will not be interrupted.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5316,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5316"
    },
    {
      id: "Stream.onDone",
      name: "onDone",
      module: "Stream",
      package: "effect",
      signature: "{ <X, R2>(cleanup: () => Effect<X, never, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, R2>(self: Stream<A, E, R>, cleanup: () => Effect<X, never, R2>): Stream<A, E, R | R2>; }",
      description: "Runs the specified effect if this stream ends.",
      documentation: "Runs the specified effect if this stream ends.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5346,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5346"
    },
    {
      id: "Stream.onStart",
      name: "onStart",
      module: "Stream",
      package: "effect",
      signature: "{ <_, E2, R2>(effect: Effect<_, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, _, E2, R2>(self: Stream<A, E, R>, effect: Effect<_, E2, R2>): Stream<A, E | E2, R | R2>; }",
      description: "Adds an effect to be executed at the start of the stream.",
      documentation: "Adds an effect to be executed at the start of the stream.",
      examples: [
        {
          code: 'import { Console, Effect, Stream } from "effect"\n\nconst stream = Stream.make(1, 2, 3).pipe(\n  Stream.onStart(Console.log("Stream started")),\n  Stream.map((n) => n * 2),\n  Stream.tap((n) => Console.log(`after mapping: ${n}`))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// Stream started\n// after mapping: 2\n// after mapping: 4\n// after mapping: 6\n// { _id: \'Chunk\', values: [ 2, 4, 6 ] }'
        }
      ],
      tags: [
        "sequencing"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5386,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5386"
    },
    {
      id: "Stream.orDie",
      name: "orDie",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(self: Stream<A, E, R>) => Stream<A, never, R>",
      description: "Translates any failure into a stream termination, making the stream\ninfallible and all failures unchecked.",
      documentation: "Translates any failure into a stream termination, making the stream\ninfallible and all failures unchecked.",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5445,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5445"
    },
    {
      id: "Stream.orDieWith",
      name: "orDieWith",
      module: "Stream",
      package: "effect",
      signature: "{ <E>(f: (e: E) => unknown): <A, R>(self: Stream<A, E, R>) => Stream<A, never, R>; <A, E, R>(self: Stream<A, E, R>, f: (e: E) => unknown): Stream<A, never, R>; }",
      description: "Keeps none of the errors, and terminates the stream with them, using the\nspecified function to convert the `E` into a defect.",
      documentation: "Keeps none of the errors, and terminates the stream with them, using the\nspecified function to convert the `E` into a defect.",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5453,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5453"
    },
    {
      id: "Stream.orElse",
      name: "orElse",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, E2, R2>(that: LazyArg<Stream<A2, E2, R2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: LazyArg<Stream<A2, E2, R2>>): Stream<A | A2, E2, R | R2>; }",
      description: "Switches to the provided stream in case this one fails with a typed error. See also `Stream.catchAll`.",
      documentation: "Switches to the provided stream in case this one fails with a typed error.\n\nSee also `Stream.catchAll`.",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5479,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5479"
    },
    {
      id: "Stream.orElseEither",
      name: "orElseEither",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, E2, R2>(that: LazyArg<Stream<A2, E2, R2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<Either<A2, A>, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: LazyArg<Stream<A2, E2, R2>>): Stream<Either<A2, A>, E2, R | R2>; }",
      description: "Switches to the provided stream in case this one fails with a typed error. See also `Stream.catchAll`.",
      documentation: "Switches to the provided stream in case this one fails with a typed error.\n\nSee also `Stream.catchAll`.",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5507,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5507"
    },
    {
      id: "Stream.orElseFail",
      name: "orElseFail",
      module: "Stream",
      package: "effect",
      signature: "{ <E2>(error: LazyArg<E2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, error: LazyArg<E2>): Stream<A, E2, R>; }",
      description: "Fails with given error in case this one fails with a typed error. See also `Stream.catchAll`.",
      documentation: "Fails with given error in case this one fails with a typed error.\n\nSee also `Stream.catchAll`.",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5535,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5535"
    },
    {
      id: "Stream.orElseIfEmpty",
      name: "orElseIfEmpty",
      module: "Stream",
      package: "effect",
      signature: "{ <A2>(element: LazyArg<A2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, element: LazyArg<A2>): Stream<A | A2, E, R>; }",
      description: "Produces the specified element if this stream is empty.",
      documentation: "Produces the specified element if this stream is empty.",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5561,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5561"
    },
    {
      id: "Stream.orElseIfEmptyChunk",
      name: "orElseIfEmptyChunk",
      module: "Stream",
      package: "effect",
      signature: "{ <A2>(chunk: LazyArg<Chunk<A2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, chunk: LazyArg<Chunk<A2>>): Stream<A | A2, E, R>; }",
      description: "Produces the specified chunk if this stream is empty.",
      documentation: "Produces the specified chunk if this stream is empty.",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5583,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5583"
    },
    {
      id: "Stream.orElseIfEmptyStream",
      name: "orElseIfEmptyStream",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, E2, R2>(stream: LazyArg<Stream<A2, E2, R2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, stream: LazyArg<Stream<A2, E2, R2>>): Stream<A | A2, E | E2, R | R2>; }",
      description: "Switches to the provided stream in case this one is empty.",
      documentation: "Switches to the provided stream in case this one is empty.",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5605,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5605"
    },
    {
      id: "Stream.orElseSucceed",
      name: "orElseSucceed",
      module: "Stream",
      package: "effect",
      signature: "{ <A2>(value: LazyArg<A2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, never, R>; <A, E, R, A2>(self: Stream<A, E, R>, value: LazyArg<A2>): Stream<A | A2, never, R>; }",
      description: "Succeeds with the specified value if this one fails with a typed error.",
      documentation: "Succeeds with the specified value if this one fails with a typed error.",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5627,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5627"
    },
    {
      id: "Stream.paginate",
      name: "paginate",
      module: "Stream",
      package: "effect",
      signature: "<S, A>(s: S, f: (s: S) => readonly [A, Option<S>]) => Stream<A, never, never>",
      description: "Like `Stream.unfold`, but allows the emission of values to end one step further\nthan the unfolding of the state. This is useful for embedding paginated\nAPIs, hence the name.",
      documentation: "Like `Stream.unfold`, but allows the emission of values to end one step further\nthan the unfolding of the state. This is useful for embedding paginated\nAPIs, hence the name.",
      examples: [
        {
          code: `import { Effect, Option, Stream } from "effect"

const stream = Stream.paginate(0, (n) => [
  n,
  n < 3 ? Option.some(n + 1) : Option.none()
])

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 0, 1, 2, 3 ] }`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5664,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5664"
    },
    {
      id: "Stream.paginateChunk",
      name: "paginateChunk",
      module: "Stream",
      package: "effect",
      signature: "<S, A>(s: S, f: (s: S) => readonly [Chunk<A>, Option<S>]) => Stream<A, never, never>",
      description: "Like `Stream.unfoldChunk`, but allows the emission of values to end one step\nfurther than the unfolding of the state. This is useful for embedding\npaginated APIs, hence the name.",
      documentation: "Like `Stream.unfoldChunk`, but allows the emission of values to end one step\nfurther than the unfolding of the state. This is useful for embedding\npaginated APIs, hence the name.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5673,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5673"
    },
    {
      id: "Stream.paginateChunkEffect",
      name: "paginateChunkEffect",
      module: "Stream",
      package: "effect",
      signature: "<S, A, E, R>(s: S, f: (s: S) => Effect<readonly [Chunk<A>, Option<S>], E, R>) => Stream<A, E, R>",
      description: "Like `Stream.unfoldChunkEffect`, but allows the emission of values to end one step\nfurther than the unfolding of the state. This is useful for embedding\npaginated APIs, hence the name.",
      documentation: "Like `Stream.unfoldChunkEffect`, but allows the emission of values to end one step\nfurther than the unfolding of the state. This is useful for embedding\npaginated APIs, hence the name.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5682,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5682"
    },
    {
      id: "Stream.paginateEffect",
      name: "paginateEffect",
      module: "Stream",
      package: "effect",
      signature: "<S, A, E, R>(s: S, f: (s: S) => Effect<readonly [A, Option<S>], E, R>) => Stream<A, E, R>",
      description: "Like `Stream.unfoldEffect` but allows the emission of values to end one step\nfurther than the unfolding of the state. This is useful for embedding\npaginated APIs, hence the name.",
      documentation: "Like `Stream.unfoldEffect` but allows the emission of values to end one step\nfurther than the unfolding of the state. This is useful for embedding\npaginated APIs, hence the name.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5691,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5691"
    },
    {
      id: "Stream.partition",
      name: "partition",
      module: "Stream",
      package: "effect",
      signature: "{ <C extends A, B extends A, A = C>(refinement: Refinement<NoInfer<A>, B>, options?: { bufferSize?: number; }): <E, R>(self: Stream<C, E, R>) => Effect<[excluded: Stream<Exclude<C, B>, E, never>, satisfying: Stream<B, E, never>], E, Scope | R>; <A>(predicate: Predicate<A>, options?: { bufferSize?: number; }): <E, R>(self: Stream<A, E, R>) => Effect<[excluded: Stream<A, E, never>, satisfying: Stream<A, E, never>], E, Scope | R>; <C extends A, E, R, B extends A, A = C>(self: Stream<C, E, R>, refinement: Refinement<A, B>, options?: { bufferSize?: number; }): Effect<[excluded: Stream<Exclude<C, B>, E, never>, satisfying: Stream<B, E, never>], E, Scope | R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>, options?: { bufferSize?: number; }): Effect<[excluded: Stream<A, E, never>, satisfying: Stream<A, E, never>], E, Scope | R>; }",
      description: "Splits a stream into two substreams based on a predicate.",
      documentation: "Splits a stream into two substreams based on a predicate.\n\n**Details**\n\nThe `Stream.partition` function splits a stream into two parts: one for\nelements that satisfy the predicate (evaluated to `true`) and another for\nthose that do not (evaluated to `false`).\n\nThe faster stream may advance up to `bufferSize` elements ahead of the slower\none.\n\n**Example** (Partitioning a Stream into Even and Odd Numbers)\n\n```ts\nimport { Effect, Stream } from \"effect\"\n\nconst partition = Stream.range(1, 9).pipe(\n  Stream.partition((n) => n % 2 === 0, { bufferSize: 5 })\n)\n\nconst program = Effect.scoped(\n  Effect.gen(function*() {\n    const [odds, evens] = yield* partition\n    console.log(yield* Stream.runCollect(odds))\n    console.log(yield* Stream.runCollect(evens))\n  })\n)\n\nEffect.runPromise(program)\n// { _id: 'Chunk', values: [ 1, 3, 5, 7, 9 ] }\n// { _id: 'Chunk', values: [ 2, 4, 6, 8 ] }\n```",
      examples: [
        {
          title: "Partitioning a Stream into Even and Odd Numbers",
          code: `import { Effect, Stream } from "effect"

const partition = Stream.range(1, 9).pipe(
  Stream.partition((n) => n % 2 === 0, { bufferSize: 5 })
)

const program = Effect.scoped(
  Effect.gen(function*() {
    const [odds, evens] = yield* partition
    console.log(yield* Stream.runCollect(odds))
    console.log(yield* Stream.runCollect(evens))
  })
)

Effect.runPromise(program)
// { _id: 'Chunk', values: [ 1, 3, 5, 7, 9 ] }
// { _id: 'Chunk', values: [ 2, 4, 6, 8 ] }`
        }
      ],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5732,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5732"
    },
    {
      id: "Stream.partitionEither",
      name: "partitionEither",
      module: "Stream",
      package: "effect",
      signature: "{ <A, A3, A2, E2, R2>(predicate: (a: NoInfer<A>) => Effect<Either<A3, A2>, E2, R2>, options?: { readonly bufferSize?: number; }): <E, R>(self: Stream<A, E, R>) => Effect<[left: Stream<A2, E2 | E, never>, right: Stream<A3, E2 | E, never>], E2 | E, Scope | R2 | R>; <A, E, R, A3, A2, E2, R2>(self: Stream<A, E, R>, predicate: (a: A) => Effect<Either<A3, A2>, E2, R2>, options?: { readonly bufferSize?: number; }): Effect<[left: Stream<A2, E | E2, never>, right: Stream<A3, E | E2, never>], E | E2, Scope | R | R2>; }",
      description: "Splits a stream into two substreams based on an effectful condition.",
      documentation: "Splits a stream into two substreams based on an effectful condition.\n\n**Details**\n\nThe `Stream.partitionEither` function is used to divide a stream into two\nparts: one for elements that satisfy a condition producing `Either.left`\nvalues, and another for those that produce `Either.right` values. This\nfunction applies an effectful predicate to each element in the stream to\ndetermine which substream it belongs to.\n\nThe faster stream may advance up to `bufferSize` elements ahead of the slower\none.\n\n**Example** (Partitioning a Stream with an Effectful Predicate)\n\n```ts\nimport { Effect, Either, Stream } from \"effect\"\n\nconst partition = Stream.range(1, 9).pipe(\n  Stream.partitionEither(\n    (n) => Effect.succeed(n % 2 === 0 ? Either.right(n) : Either.left(n)),\n    { bufferSize: 5 }\n  )\n)\n\nconst program = Effect.scoped(\n  Effect.gen(function*() {\n    const [evens, odds] = yield* partition\n    console.log(yield* Stream.runCollect(evens))\n    console.log(yield* Stream.runCollect(odds))\n  })\n)\n\nEffect.runPromise(program)\n// { _id: 'Chunk', values: [ 1, 3, 5, 7, 9 ] }\n// { _id: 'Chunk', values: [ 2, 4, 6, 8 ] }\n```",
      examples: [
        {
          title: "Partitioning a Stream with an Effectful Predicate",
          code: `import { Effect, Either, Stream } from "effect"

const partition = Stream.range(1, 9).pipe(
  Stream.partitionEither(
    (n) => Effect.succeed(n % 2 === 0 ? Either.right(n) : Either.left(n)),
    { bufferSize: 5 }
  )
)

const program = Effect.scoped(
  Effect.gen(function*() {
    const [evens, odds] = yield* partition
    console.log(yield* Stream.runCollect(evens))
    console.log(yield* Stream.runCollect(odds))
  })
)

Effect.runPromise(program)
// { _id: 'Chunk', values: [ 1, 3, 5, 7, 9 ] }
// { _id: 'Chunk', values: [ 2, 4, 6, 8 ] }`
        }
      ],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 5950,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L5950"
    },
    {
      id: "Stream.peel",
      name: "peel",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, A, E2, R2>(sink: Sink<A2, A, A, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect<[A2, Stream<A, E, never>], E2 | E, Scope | R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink<A2, A, A, E2, R2>): Effect<[A2, Stream<A, E, never>], E | E2, Scope | R | R2>; }",
      description: "Peels off enough material from the stream to construct a `Z` using the\nprovided `Sink` and then returns both the `Z` and the rest of the\n`Stream` in a scope. Like all scoped values, the provided stream is\nvalid only within the scope.",
      documentation: "Peels off enough material from the stream to construct a `Z` using the\nprovided `Sink` and then returns both the `Z` and the rest of the\n`Stream` in a scope. Like all scoped values, the provided stream is\nvalid only within the scope.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6055,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6055"
    },
    {
      id: "Stream.pipeThrough",
      name: "pipeThrough",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, A, L, E2, R2>(sink: Sink<A2, A, L, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<L, E2 | E, R2 | R>; <A, E, R, A2, L, E2, R2>(self: Stream<A, E, R>, sink: Sink<A2, A, L, E2, R2>): Stream<L, E | E2, R | R2>; }",
      description: "Pipes all of the values from this stream through the provided sink. See also `Stream.transduce`.",
      documentation: "Pipes all of the values from this stream through the provided sink.\n\nSee also `Stream.transduce`.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6085,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6085"
    },
    {
      id: "Stream.pipeThroughChannel",
      name: "pipeThroughChannel",
      module: "Stream",
      package: "effect",
      signature: "{ <R2, E, E2, A, A2>(channel: Channel<Chunk<A2>, Chunk<A>, E2, E, unknown, unknown, R2>): <R>(self: Stream<A, E, R>) => Stream<A2, E2, R2 | R>; <R, R2, E, E2, A, A2>(self: Stream<A, E, R>, channel: Channel<Chunk<A2>, Chunk<A>, E2, E, unknown, unknown, R2>): Stream<A2, E2, R | R2>; }",
      description: "Pipes all the values from this stream through the provided channel.",
      documentation: "Pipes all the values from this stream through the provided channel.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6111,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6111"
    },
    {
      id: "Stream.pipeThroughChannelOrFail",
      name: "pipeThroughChannelOrFail",
      module: "Stream",
      package: "effect",
      signature: "{ <R2, E, E2, A, A2>(chan: Channel<Chunk<A2>, Chunk<A>, E2, E, unknown, unknown, R2>): <R>(self: Stream<A, E, R>) => Stream<A2, E | E2, R2 | R>; <R, R2, E, E2, A, A2>(self: Stream<A, E, R>, chan: Channel<Chunk<A2>, Chunk<A>, E2, E, unknown, unknown, R2>): Stream<A2, E | E2, R | R2>; }",
      description: "Pipes all values from this stream through the provided channel, passing\nthrough any error emitted by this stream unchanged.",
      documentation: "Pipes all values from this stream through the provided channel, passing\nthrough any error emitted by this stream unchanged.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6134,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6134"
    },
    {
      id: "Stream.prepend",
      name: "prepend",
      module: "Stream",
      package: "effect",
      signature: "{ <B>(values: Chunk<B>): <A, E, R>(self: Stream<A, E, R>) => Stream<B | A, E, R>; <A, E, R, B>(self: Stream<A, E, R>, values: Chunk<B>): Stream<A | B, E, R>; }",
      description: "Emits the provided chunk before emitting any other value.",
      documentation: "Emits the provided chunk before emitting any other value.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6158,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6158"
    },
    {
      id: "Stream.provideContext",
      name: "provideContext",
      module: "Stream",
      package: "effect",
      signature: "{ <R>(context: Context<R>): <A, E>(self: Stream<A, E, R>) => Stream<A, E, never>; <A, E, R>(self: Stream<A, E, R>, context: Context<R>): Stream<A, E, never>; }",
      description: "Provides the stream with its required context, which eliminates its\ndependency on `R`.",
      documentation: "Provides the stream with its required context, which eliminates its\ndependency on `R`.",
      examples: [],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6181,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6181"
    },
    {
      id: "Stream.provideSomeContext",
      name: "provideSomeContext",
      module: "Stream",
      package: "effect",
      signature: "{ <R2>(context: Context<R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, Exclude<R, R2>>; <A, E, R, R2>(self: Stream<A, E, R>, context: Context<R2>): Stream<A, E, Exclude<R, R2>>; }",
      description: "Provides the stream with some of its required context, which eliminates its\ndependency on `R`.",
      documentation: "Provides the stream with some of its required context, which eliminates its\ndependency on `R`.",
      examples: [],
      tags: [
        "context"
      ],
      since: "3.16.9",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6206,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6206"
    },
    {
      id: "Stream.provideLayer",
      name: "provideLayer",
      module: "Stream",
      package: "effect",
      signature: "{ <RIn, E2, ROut>(layer: Layer<ROut, E2, RIn>): <A, E>(self: Stream<A, E, ROut>) => Stream<A, E2 | E, RIn>; <A, E, RIn, E2, ROut>(self: Stream<A, E, ROut>, layer: Layer<ROut, E2, RIn>): Stream<A, E | E2, RIn>; }",
      description: "Provides a `Layer` to the stream, which translates it to another level.",
      documentation: "Provides a `Layer` to the stream, which translates it to another level.",
      examples: [],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6230,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6230"
    },
    {
      id: "Stream.provideService",
      name: "provideService",
      module: "Stream",
      package: "effect",
      signature: "{ <I, S>(tag: Tag<I, S>, resource: NoInfer<S>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, Exclude<R, I>>; <A, E, R, I, S>(self: Stream<A, E, R>, tag: Tag<I, S>, resource: NoInfer<S>): Stream<A, E, Exclude<R, I>>; }",
      description: "Provides the stream with the single service it requires. If the stream\nrequires more than one service use `Stream.provideContext` instead.",
      documentation: "Provides the stream with the single service it requires. If the stream\nrequires more than one service use `Stream.provideContext` instead.",
      examples: [],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6253,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6253"
    },
    {
      id: "Stream.provideServiceEffect",
      name: "provideServiceEffect",
      module: "Stream",
      package: "effect",
      signature: "{ <I, S, E2, R2>(tag: Tag<I, S>, effect: Effect<NoInfer<S>, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | Exclude<R, I>>; <A, E, R, I, S, E2, R2>(self: Stream<A, E, R>, tag: Tag<I, S>, effect: Effect<NoInfer<S>, E2, R2>): Stream<A, E | E2, R2 | Exclude<R, I>>; }",
      description: "Provides the stream with the single service it requires. If the stream\nrequires more than one service use `Stream.provideContext` instead.",
      documentation: "Provides the stream with the single service it requires. If the stream\nrequires more than one service use `Stream.provideContext` instead.",
      examples: [],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6278,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6278"
    },
    {
      id: "Stream.provideServiceStream",
      name: "provideServiceStream",
      module: "Stream",
      package: "effect",
      signature: "{ <I, S, E2, R2>(tag: Tag<I, S>, stream: Stream<NoInfer<S>, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | Exclude<R, I>>; <A, E, R, I, S, E2, R2>(self: Stream<A, E, R>, tag: Tag<I, S>, stream: Stream<NoInfer<S>, E2, R2>): Stream<A, E | E2, R2 | Exclude<R, I>>; }",
      description: "Provides the stream with the single service it requires. If the stream\nrequires more than one service use `Stream.provideContext` instead.",
      documentation: "Provides the stream with the single service it requires. If the stream\nrequires more than one service use `Stream.provideContext` instead.",
      examples: [],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6303,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6303"
    },
    {
      id: "Stream.mapInputContext",
      name: "mapInputContext",
      module: "Stream",
      package: "effect",
      signature: "{ <R0, R>(f: (env: Context<R0>) => Context<R>): <A, E>(self: Stream<A, E, R>) => Stream<A, E, R0>; <A, E, R0, R>(self: Stream<A, E, R>, f: (env: Context<R0>) => Context<R>): Stream<A, E, R0>; }",
      description: "Transforms the context being provided to the stream with the specified\nfunction.",
      documentation: "Transforms the context being provided to the stream with the specified\nfunction.",
      examples: [],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6328,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6328"
    },
    {
      id: "Stream.provideSomeLayer",
      name: "provideSomeLayer",
      module: "Stream",
      package: "effect",
      signature: "{ <RIn, E2, ROut>(layer: Layer<ROut, E2, RIn>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, RIn | Exclude<R, ROut>>; <A, E, R, RIn, E2, ROut>(self: Stream<A, E, R>, layer: Layer<ROut, E2, RIn>): Stream<A, E | E2, RIn | Exclude<R, ROut>>; }",
      description: "Splits the context into two parts, providing one part using the\nspecified layer and leaving the remainder `R0`.",
      documentation: "Splits the context into two parts, providing one part using the\nspecified layer and leaving the remainder `R0`.",
      examples: [],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6353,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6353"
    },
    {
      id: "Stream.race",
      name: "race",
      module: "Stream",
      package: "effect",
      signature: "{ <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AR | AL, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL | AR, EL | ER, RL | RR>; }",
      description: 'Returns a stream that mirrors the first upstream to emit an item.\nAs soon as one of the upstream emits a first value, the other is interrupted.\nThe resulting stream will forward all items from the "winning" source stream.\nAny upstream failures will cause the returned stream to fail.',
      documentation: 'Returns a stream that mirrors the first upstream to emit an item.\nAs soon as one of the upstream emits a first value, the other is interrupted.\nThe resulting stream will forward all items from the "winning" source stream.\nAny upstream failures will cause the returned stream to fail.',
      examples: [
        {
          code: `import { Stream, Schedule, Console, Effect } from "effect"

const stream = Stream.fromSchedule(Schedule.spaced('2 millis')).pipe(
  Stream.race(Stream.fromSchedule(Schedule.spaced('1 millis'))),
  Stream.take(6),
  Stream.tap(Console.log)
)

Effect.runPromise(Stream.runDrain(stream))
// Output each millisecond from the first stream, the rest streams are interrupted
// 0
// 1
// 2
// 3
// 4
// 5`
        }
      ],
      tags: [
        "racing"
      ],
      since: "3.7.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6399,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6399"
    },
    {
      id: "Stream.raceAll",
      name: "raceAll",
      module: "Stream",
      package: "effect",
      signature: "<S extends ReadonlyArray<Stream<any, any, any>>>(...streams: S) => Stream<Stream.Success<S[number]>, Stream.Error<S[number]>, Stream.Context<S[number]>>",
      description: 'Returns a stream that mirrors the first upstream to emit an item.\nAs soon as one of the upstream emits a first value, all the others are interrupted.\nThe resulting stream will forward all items from the "winning" source stream.\nAny upstream failures will cause the returned stream to fail.',
      documentation: 'Returns a stream that mirrors the first upstream to emit an item.\nAs soon as one of the upstream emits a first value, all the others are interrupted.\nThe resulting stream will forward all items from the "winning" source stream.\nAny upstream failures will cause the returned stream to fail.',
      examples: [
        {
          code: `import { Stream, Schedule, Console, Effect } from "effect"

const stream = Stream.raceAll(
  Stream.fromSchedule(Schedule.spaced('1 millis')),
  Stream.fromSchedule(Schedule.spaced('2 millis')),
  Stream.fromSchedule(Schedule.spaced('4 millis')),
).pipe(Stream.take(6), Stream.tap(Console.log))

Effect.runPromise(Stream.runDrain(stream))
// Output each millisecond from the first stream, the rest streams are interrupted
// 0
// 1
// 2
// 3
// 4
// 5`
        }
      ],
      tags: [
        "racing"
      ],
      since: "3.5.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6487,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6487"
    },
    {
      id: "Stream.range",
      name: "range",
      module: "Stream",
      package: "effect",
      signature: "(min: number, max: number, chunkSize?: number) => Stream<number, never, never>",
      description: "Constructs a stream from a range of integers, including both endpoints.",
      documentation: "Constructs a stream from a range of integers, including both endpoints.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

// A Stream with a range of numbers from 1 to 5
const stream = Stream.range(1, 5)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5 ] }`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6505,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6505"
    },
    {
      id: "Stream.rechunk",
      name: "rechunk",
      module: "Stream",
      package: "effect",
      signature: "{ (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }",
      description: "Re-chunks the elements of the stream into chunks of `n` elements each. The\nlast chunk might contain less than `n` elements.",
      documentation: "Re-chunks the elements of the stream into chunks of `n` elements each. The\nlast chunk might contain less than `n` elements.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6513,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6513"
    },
    {
      id: "Stream.refineOrDie",
      name: "refineOrDie",
      module: "Stream",
      package: "effect",
      signature: "{ <E, E2>(pf: (error: E) => Option<E2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, pf: (error: E) => Option<E2>): Stream<A, E2, R>; }",
      description: "Keeps some of the errors, and terminates the fiber with the rest",
      documentation: "Keeps some of the errors, and terminates the fiber with the rest",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6537,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6537"
    },
    {
      id: "Stream.refineOrDieWith",
      name: "refineOrDieWith",
      module: "Stream",
      package: "effect",
      signature: "{ <E, E2>(pf: (error: E) => Option<E2>, f: (error: E) => unknown): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, pf: (error: E) => Option<E2>, f: (error: E) => unknown): Stream<A, E2, R>; }",
      description: "Keeps some of the errors, and terminates the fiber with the rest, using the\nspecified function to convert the `E` into a defect.",
      documentation: "Keeps some of the errors, and terminates the fiber with the rest, using the\nspecified function to convert the `E` into a defect.",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6560,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6560"
    },
    {
      id: "Stream.repeat",
      name: "repeat",
      module: "Stream",
      package: "effect",
      signature: "{ <B, R2>(schedule: Schedule<B, unknown, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, B, R2>(self: Stream<A, E, R>, schedule: Schedule<B, unknown, R2>): Stream<A, E, R | R2>; }",
      description: "Repeats the entire stream using the specified schedule. The stream will\nexecute normally, and then repeat again according to the provided schedule.",
      documentation: "Repeats the entire stream using the specified schedule. The stream will\nexecute normally, and then repeat again according to the provided schedule.",
      examples: [
        {
          code: `import { Effect, Schedule, Stream } from "effect"

const stream = Stream.repeat(Stream.succeed(1), Schedule.forever)

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)
// { _id: 'Chunk', values: [ 1, 1, 1, 1, 1 ] }`
        }
      ],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6595,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6595"
    },
    {
      id: "Stream.repeatEffect",
      name: "repeatEffect",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(effect: Effect<A, E, R>) => Stream<A, E, R>",
      description: "Creates a stream from an effect producing a value of type `A` which repeats\nforever.",
      documentation: "Creates a stream from an effect producing a value of type `A` which repeats\nforever.",
      examples: [
        {
          code: `import { Effect, Random, Stream } from "effect"

const stream = Stream.repeatEffect(Random.nextInt)

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)
// Example Output: { _id: 'Chunk', values: [ 3891571149, 4239494205, 2352981603, 2339111046, 1488052210 ] }`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6650,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6650"
    },
    {
      id: "Stream.repeatEffectChunk",
      name: "repeatEffectChunk",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(effect: Effect<Chunk<A>, E, R>) => Stream<A, E, R>",
      description: "Creates a stream from an effect producing chunks of `A` values which\nrepeats forever.",
      documentation: "Creates a stream from an effect producing chunks of `A` values which\nrepeats forever.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6658,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6658"
    },
    {
      id: "Stream.repeatEffectChunkOption",
      name: "repeatEffectChunkOption",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(effect: Effect<Chunk<A>, Option<E>, R>) => Stream<A, E, R>",
      description: "Creates a stream from an effect producing chunks of `A` values until it\nfails with `None`.",
      documentation: "Creates a stream from an effect producing chunks of `A` values until it\nfails with `None`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6666,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6666"
    },
    {
      id: "Stream.repeatEffectOption",
      name: "repeatEffectOption",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(effect: Effect<A, Option<E>, R>) => Stream<A, E, R>",
      description: "Creates a stream from an effect producing values of type `A` until it fails\nwith `None`.",
      documentation: "Creates a stream from an effect producing values of type `A` until it fails\nwith `None`.",
      examples: [
        {
          code: `// In this example, we're draining an Iterator to create a stream from it
import { Stream, Effect, Option } from "effect"

const drainIterator = <A>(it: Iterator<A>): Stream.Stream<A> =>
  Stream.repeatEffectOption(
    Effect.sync(() => it.next()).pipe(
      Effect.andThen((res) => {
        if (res.done) {
          return Effect.fail(Option.none())
        }
        return Effect.succeed(res.value)
      })
    )
  )`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6692,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6692"
    },
    {
      id: "Stream.repeatEffectWithSchedule",
      name: "repeatEffectWithSchedule",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R, X, A0 extends A, R2>(effect: Effect<A, E, R>, schedule: Schedule<X, A0, R2>) => Stream<A, E, R | R2>",
      description: "Creates a stream from an effect producing a value of type `A`, which is\nrepeated using the specified schedule.",
      documentation: "Creates a stream from an effect producing a value of type `A`, which is\nrepeated using the specified schedule.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6700,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6700"
    },
    {
      id: "Stream.repeatEither",
      name: "repeatEither",
      module: "Stream",
      package: "effect",
      signature: "{ <B, R2>(schedule: Schedule<B, unknown, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<Either<A, B>, E, R2 | R>; <A, E, R, B, R2>(self: Stream<A, E, R>, schedule: Schedule<B, unknown, R2>): Stream<Either<A, B>, E, R | R2>; }",
      description: "Repeats the entire stream using the specified schedule. The stream will\nexecute normally, and then repeat again according to the provided schedule.\nThe schedule output will be emitted at the end of each repetition.",
      documentation: "Repeats the entire stream using the specified schedule. The stream will\nexecute normally, and then repeat again according to the provided schedule.\nThe schedule output will be emitted at the end of each repetition.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6709,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6709"
    },
    {
      id: "Stream.repeatElements",
      name: "repeatElements",
      module: "Stream",
      package: "effect",
      signature: "{ <B, R2>(schedule: Schedule<B, unknown, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, B, R2>(self: Stream<A, E, R>, schedule: Schedule<B, unknown, R2>): Stream<A, E, R | R2>; }",
      description: "Repeats each element of the stream using the provided schedule. Repetitions\nare done in addition to the first execution, which means using\n`Schedule.recurs(1)` actually results in the original effect, plus an\nadditional recurrence, for a total of two repetitions of each value in the\nstream.",
      documentation: "Repeats each element of the stream using the provided schedule. Repetitions\nare done in addition to the first execution, which means using\n`Schedule.recurs(1)` actually results in the original effect, plus an\nadditional recurrence, for a total of two repetitions of each value in the\nstream.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6739,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6739"
    },
    {
      id: "Stream.repeatElementsWith",
      name: "repeatElementsWith",
      module: "Stream",
      package: "effect",
      signature: "{ <B, R2, A, C>(schedule: Schedule<B, unknown, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): <E, R>(self: Stream<A, E, R>) => Stream<C, E, R2 | R>; <A, E, R, B, R2, C>(self: Stream<A, E, R>, schedule: Schedule<B, unknown, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): Stream<C, E, R | R2>; }",
      description: "Repeats each element of the stream using the provided schedule. When the\nschedule is finished, then the output of the schedule will be emitted into\nthe stream. Repetitions are done in addition to the first execution, which\nmeans using `Schedule.recurs(1)` actually results in the original effect,\nplus an additional recurrence, for a total of two repetitions of each value\nin the stream. This function accepts two conversion functions, which allow the output of\nthis stream and the output of the provided schedule to be unified into a\nsingle type. For example, `Either` or similar data type.",
      documentation: "Repeats each element of the stream using the provided schedule. When the\nschedule is finished, then the output of the schedule will be emitted into\nthe stream. Repetitions are done in addition to the first execution, which\nmeans using `Schedule.recurs(1)` actually results in the original effect,\nplus an additional recurrence, for a total of two repetitions of each value\nin the stream.\n\nThis function accepts two conversion functions, which allow the output of\nthis stream and the output of the provided schedule to be unified into a\nsingle type. For example, `Either` or similar data type.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6778,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6778"
    },
    {
      id: "Stream.repeatValue",
      name: "repeatValue",
      module: "Stream",
      package: "effect",
      signature: "<A>(value: A) => Stream<A, never, never>",
      description: "Repeats the provided value infinitely.",
      documentation: "Repeats the provided value infinitely.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

const stream = Stream.repeatValue(0)

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)
// { _id: 'Chunk', values: [ 0, 0, 0, 0, 0 ] }`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6834,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6834"
    },
    {
      id: "Stream.repeatWith",
      name: "repeatWith",
      module: "Stream",
      package: "effect",
      signature: "{ <B, R2, A, C>(schedule: Schedule<B, unknown, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): <E, R>(self: Stream<A, E, R>) => Stream<C, E, R2 | R>; <A, E, R, B, R2, C>(self: Stream<A, E, R>, schedule: Schedule<B, unknown, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): Stream<C, E, R | R2>; }",
      description: "Repeats the entire stream using the specified schedule. The stream will\nexecute normally, and then repeat again according to the provided schedule.\nThe schedule output will be emitted at the end of each repetition and can\nbe unified with the stream elements using the provided functions.",
      documentation: "Repeats the entire stream using the specified schedule. The stream will\nexecute normally, and then repeat again according to the provided schedule.\nThe schedule output will be emitted at the end of each repetition and can\nbe unified with the stream elements using the provided functions.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6844,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6844"
    },
    {
      id: "Stream.retry",
      name: "retry",
      module: "Stream",
      package: "effect",
      signature: "{ <E, R2, X>(policy: Schedule<X, NoInfer<E>, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, R2>(self: Stream<A, E, R>, policy: Schedule<X, NoInfer<E>, R2>): Stream<A, E, R | R2>; }",
      description: "When the stream fails, retry it according to the given schedule This retries the entire stream, so will re-execute all of the stream's\nacquire operations. The schedule is reset as soon as the first element passes through the\nstream again.",
      documentation: "When the stream fails, retry it according to the given schedule\n\nThis retries the entire stream, so will re-execute all of the stream's\nacquire operations.\n\nThe schedule is reset as soon as the first element passes through the\nstream again.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6884,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6884"
    },
    {
      id: "Stream.withExecutionPlan",
      name: "withExecutionPlan",
      module: "Stream",
      package: "effect",
      signature: "{ <Input, R2, Provides, PolicyE>(policy: ExecutionPlan<{ provides: Provides; input: Input; error: PolicyE; requirements: R2; }>, options?: { readonly preventFallbackOnPartialStream?: boolean; }): <A, E extends Input, R>(self: Stream<A, E, R>) => Stream<A, PolicyE | E, R2 | Exclude<R, Provides>>; <A, E extends Input, R, R2, Input, Provides, PolicyE>(self: Stream<A, E, R>, policy: ExecutionPlan<{ provides: Provides; input: Input; error: PolicyE; requirements: R2; }>, options?: { readonly preventFallbackOnPartialStream?: boolean; }): Stream<A, E | PolicyE, R2 | Exclude<R, Provides>>; }",
      description: "Apply an `ExecutionPlan` to the stream, which allows you to fallback to\ndifferent resources in case of failure. If you have a stream that could fail with partial results, you can use\nthe `preventFallbackOnPartialStream` option to prevent contamination of\nthe final stream with partial results.",
      documentation: "Apply an `ExecutionPlan` to the stream, which allows you to fallback to\ndifferent resources in case of failure.\n\nIf you have a stream that could fail with partial results, you can use\nthe `preventFallbackOnPartialStream` option to prevent contamination of\nthe final stream with partial results.",
      examples: [],
      tags: [
        "Error handling"
      ],
      since: "3.16.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6924,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6924"
    },
    {
      id: "Stream.run",
      name: "run",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, A, E2, R2>(sink: Sink<A2, A, unknown, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect<A2, E2 | E, Exclude<R2, Scope> | Exclude<R, Scope>>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink<A2, A, unknown, E2, R2>): Effect<A2, E | E2, Exclude<R, Scope> | Exclude<R2, Scope>>; }",
      description: "Runs the sink on the stream to produce either the sink's result or an error.",
      documentation: "Runs the sink on the stream to produce either the sink's result or an error.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6972,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6972"
    },
    {
      id: "Stream.runCollect",
      name: "runCollect",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(self: Stream<A, E, R>) => Effect<Chunk<A>, E, R>",
      description: "Runs the stream and collects all of its elements to a chunk.",
      documentation: "Runs the stream and collects all of its elements to a chunk.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 6994,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L6994"
    },
    {
      id: "Stream.runCount",
      name: "runCount",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(self: Stream<A, E, R>) => Effect<number, E, R>",
      description: "Runs the stream and emits the number of elements processed",
      documentation: "Runs the stream and emits the number of elements processed",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7001,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7001"
    },
    {
      id: "Stream.runDrain",
      name: "runDrain",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(self: Stream<A, E, R>) => Effect<void, E, R>",
      description: "Runs the stream only for its effects. The emitted elements are discarded.",
      documentation: "Runs the stream only for its effects. The emitted elements are discarded.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7008,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7008"
    },
    {
      id: "Stream.runFold",
      name: "runFold",
      module: "Stream",
      package: "effect",
      signature: "{ <S, A>(s: S, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect<S, E, R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => S): Effect<S, E, R>; }",
      description: "Executes a pure fold over the stream of values - reduces all elements in\nthe stream to a value of type `S`.",
      documentation: "Executes a pure fold over the stream of values - reduces all elements in\nthe stream to a value of type `S`.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7016,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7016"
    },
    {
      id: "Stream.runFoldEffect",
      name: "runFoldEffect",
      module: "Stream",
      package: "effect",
      signature: "{ <S, A, E2, R2>(s: S, f: (s: S, a: A) => Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect<S, E2 | E, Exclude<R2, Scope> | Exclude<R, Scope>>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => Effect<S, E2, R2>): Effect<S, E | E2, Exclude<R, Scope> | Exclude<R2, Scope>>; }",
      description: "Executes an effectful fold over the stream of values.",
      documentation: "Executes an effectful fold over the stream of values.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7040,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7040"
    },
    {
      id: "Stream.runFoldScoped",
      name: "runFoldScoped",
      module: "Stream",
      package: "effect",
      signature: "{ <S, A>(s: S, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect<S, E, Scope | R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => S): Effect<S, E, Scope | R>; }",
      description: "Executes a pure fold over the stream of values. Returns a scoped value that\nrepresents the scope of the stream.",
      documentation: "Executes a pure fold over the stream of values. Returns a scoped value that\nrepresents the scope of the stream.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7063,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7063"
    },
    {
      id: "Stream.runFoldScopedEffect",
      name: "runFoldScopedEffect",
      module: "Stream",
      package: "effect",
      signature: "{ <S, A, E2, R2>(s: S, f: (s: S, a: A) => Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect<S, E2 | E, Scope | R2 | R>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => Effect<S, E2, R2>): Effect<S, E | E2, Scope | R | R2>; }",
      description: "Executes an effectful fold over the stream of values. Returns a scoped\nvalue that represents the scope of the stream.",
      documentation: "Executes an effectful fold over the stream of values. Returns a scoped\nvalue that represents the scope of the stream.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7088,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7088"
    },
    {
      id: "Stream.runFoldWhile",
      name: "runFoldWhile",
      module: "Stream",
      package: "effect",
      signature: "{ <S, A>(s: S, cont: Predicate<S>, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect<S, E, R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => S): Effect<S, E, R>; }",
      description: "Reduces the elements in the stream to a value of type `S`. Stops the fold\nearly when the condition is not fulfilled. Example:",
      documentation: "Reduces the elements in the stream to a value of type `S`. Stops the fold\nearly when the condition is not fulfilled. Example:",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7113,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7113"
    },
    {
      id: "Stream.runFoldWhileEffect",
      name: "runFoldWhileEffect",
      module: "Stream",
      package: "effect",
      signature: "{ <S, A, E2, R2>(s: S, cont: Predicate<S>, f: (s: S, a: A) => Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect<S, E2 | E, Exclude<R2, Scope> | Exclude<R, Scope>>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => Effect<S, E2, R2>): Effect<S, E | E2, Exclude<R, Scope> | Exclude<R2, Scope>>; }",
      description: "Executes an effectful fold over the stream of values. Stops the fold early\nwhen the condition is not fulfilled.",
      documentation: "Executes an effectful fold over the stream of values. Stops the fold early\nwhen the condition is not fulfilled.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7138,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7138"
    },
    {
      id: "Stream.runFoldWhileScoped",
      name: "runFoldWhileScoped",
      module: "Stream",
      package: "effect",
      signature: "{ <S, A>(s: S, cont: Predicate<S>, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect<S, E, Scope | R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => S): Effect<S, E, Scope | R>; }",
      description: "Executes a pure fold over the stream of values. Returns a scoped value that\nrepresents the scope of the stream. Stops the fold early when the condition\nis not fulfilled.",
      documentation: "Executes a pure fold over the stream of values. Returns a scoped value that\nrepresents the scope of the stream. Stops the fold early when the condition\nis not fulfilled.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7164,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7164"
    },
    {
      id: "Stream.runFoldWhileScopedEffect",
      name: "runFoldWhileScopedEffect",
      module: "Stream",
      package: "effect",
      signature: "{ <S, A, E2, R2>(s: S, cont: Predicate<S>, f: (s: S, a: A) => Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect<S, E2 | E, Scope | R2 | R>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => Effect<S, E2, R2>): Effect<S, E | E2, Scope | R | R2>; }",
      description: "Executes an effectful fold over the stream of values. Returns a scoped\nvalue that represents the scope of the stream. Stops the fold early when\nthe condition is not fulfilled.",
      documentation: "Executes an effectful fold over the stream of values. Returns a scoped\nvalue that represents the scope of the stream. Stops the fold early when\nthe condition is not fulfilled.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7192,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7192"
    },
    {
      id: "Stream.runForEach",
      name: "runForEach",
      module: "Stream",
      package: "effect",
      signature: "{ <A, X, E2, R2>(f: (a: A) => Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect<void, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect<X, E2, R2>): Effect<void, E | E2, R | R2>; }",
      description: "Consumes all elements of the stream, passing them to the specified\ncallback.",
      documentation: "Consumes all elements of the stream, passing them to the specified\ncallback.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7219,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7219"
    },
    {
      id: "Stream.runForEachChunk",
      name: "runForEachChunk",
      module: "Stream",
      package: "effect",
      signature: "{ <A, X, E2, R2>(f: (a: Chunk<A>) => Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect<void, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: Chunk<A>) => Effect<X, E2, R2>): Effect<void, E | E2, R | R2>; }",
      description: "Consumes all elements of the stream, passing them to the specified\ncallback.",
      documentation: "Consumes all elements of the stream, passing them to the specified\ncallback.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7244,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7244"
    },
    {
      id: "Stream.runForEachChunkScoped",
      name: "runForEachChunkScoped",
      module: "Stream",
      package: "effect",
      signature: "{ <A, X, E2, R2>(f: (a: Chunk<A>) => Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect<void, E2 | E, Scope | R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: Chunk<A>) => Effect<X, E2, R2>): Effect<void, E | E2, Scope | R | R2>; }",
      description: "Like `Stream.runForEachChunk`, but returns a scoped effect so the\nfinalization order can be controlled.",
      documentation: "Like `Stream.runForEachChunk`, but returns a scoped effect so the\nfinalization order can be controlled.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7269,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7269"
    },
    {
      id: "Stream.runForEachScoped",
      name: "runForEachScoped",
      module: "Stream",
      package: "effect",
      signature: "{ <A, X, E2, R2>(f: (a: A) => Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect<void, E2 | E, Scope | R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect<X, E2, R2>): Effect<void, E | E2, Scope | R | R2>; }",
      description: "Like `Stream.forEach`, but returns a scoped effect so the finalization\norder can be controlled.",
      documentation: "Like `Stream.forEach`, but returns a scoped effect so the finalization\norder can be controlled.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7294,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7294"
    },
    {
      id: "Stream.runForEachWhile",
      name: "runForEachWhile",
      module: "Stream",
      package: "effect",
      signature: "{ <A, E2, R2>(f: (a: A) => Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect<void, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect<boolean, E2, R2>): Effect<void, E | E2, R | R2>; }",
      description: "Consumes elements of the stream, passing them to the specified callback,\nand terminating consumption when the callback returns `false`.",
      documentation: "Consumes elements of the stream, passing them to the specified callback,\nand terminating consumption when the callback returns `false`.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7319,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7319"
    },
    {
      id: "Stream.runForEachWhileScoped",
      name: "runForEachWhileScoped",
      module: "Stream",
      package: "effect",
      signature: "{ <A, E2, R2>(f: (a: A) => Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect<void, E2 | E, Scope | R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect<boolean, E2, R2>): Effect<void, E | E2, Scope | R | R2>; }",
      description: "Like `Stream.runForEachWhile`, but returns a scoped effect so the\nfinalization order can be controlled.",
      documentation: "Like `Stream.runForEachWhile`, but returns a scoped effect so the\nfinalization order can be controlled.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7344,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7344"
    },
    {
      id: "Stream.runHead",
      name: "runHead",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(self: Stream<A, E, R>) => Effect<Option<A>, E, R>",
      description: "Runs the stream to completion and yields the first value emitted by it,\ndiscarding the rest of the elements.",
      documentation: "Runs the stream to completion and yields the first value emitted by it,\ndiscarding the rest of the elements.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7369,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7369"
    },
    {
      id: "Stream.runIntoPubSub",
      name: "runIntoPubSub",
      module: "Stream",
      package: "effect",
      signature: "{ <A, E>(pubsub: PubSub<Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect<void, never, R>; <A, E, R>(self: Stream<A, E, R>, pubsub: PubSub<Take<A, E>>): Effect<void, never, R>; }",
      description: "Publishes elements of this stream to a `PubSub`. Stream failure and ending will\nalso be signalled.",
      documentation: "Publishes elements of this stream to a `PubSub`. Stream failure and ending will\nalso be signalled.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7377,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7377"
    },
    {
      id: "Stream.runIntoPubSubScoped",
      name: "runIntoPubSubScoped",
      module: "Stream",
      package: "effect",
      signature: "{ <A, E>(pubsub: PubSub<Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect<void, never, Scope | R>; <A, E, R>(self: Stream<A, E, R>, pubsub: PubSub<Take<A, E>>): Effect<void, never, Scope | R>; }",
      description: "Like `Stream.runIntoPubSub`, but provides the result as a scoped effect to\nallow for scope composition.",
      documentation: "Like `Stream.runIntoPubSub`, but provides the result as a scoped effect to\nallow for scope composition.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7402,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7402"
    },
    {
      id: "Stream.runIntoQueue",
      name: "runIntoQueue",
      module: "Stream",
      package: "effect",
      signature: "{ <A, E>(queue: Enqueue<Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect<void, never, R>; <A, E, R>(self: Stream<A, E, R>, queue: Enqueue<Take<A, E>>): Effect<void, never, R>; }",
      description: "Enqueues elements of this stream into a queue. Stream failure and ending\nwill also be signalled.",
      documentation: "Enqueues elements of this stream into a queue. Stream failure and ending\nwill also be signalled.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7427,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7427"
    },
    {
      id: "Stream.runIntoQueueElementsScoped",
      name: "runIntoQueueElementsScoped",
      module: "Stream",
      package: "effect",
      signature: "{ <A, E>(queue: Enqueue<Exit<A, Option<E>>>): <R>(self: Stream<A, E, R>) => Effect<void, never, Scope | R>; <A, E, R>(self: Stream<A, E, R>, queue: Enqueue<Exit<A, Option<E>>>): Effect<void, never, Scope | R>; }",
      description: "Like `Stream.runIntoQueue`, but provides the result as a scoped [[ZIO]]\nto allow for scope composition.",
      documentation: "Like `Stream.runIntoQueue`, but provides the result as a scoped [[ZIO]]\nto allow for scope composition.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7452,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7452"
    },
    {
      id: "Stream.runIntoQueueScoped",
      name: "runIntoQueueScoped",
      module: "Stream",
      package: "effect",
      signature: "{ <A, E>(queue: Enqueue<Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect<void, never, Scope | R>; <A, E, R>(self: Stream<A, E, R>, queue: Enqueue<Take<A, E>>): Effect<void, never, Scope | R>; }",
      description: "Like `Stream.runIntoQueue`, but provides the result as a scoped effect\nto allow for scope composition.",
      documentation: "Like `Stream.runIntoQueue`, but provides the result as a scoped effect\nto allow for scope composition.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7477,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7477"
    },
    {
      id: "Stream.runLast",
      name: "runLast",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(self: Stream<A, E, R>) => Effect<Option<A>, E, R>",
      description: "Runs the stream to completion and yields the last value emitted by it,\ndiscarding the rest of the elements.",
      documentation: "Runs the stream to completion and yields the last value emitted by it,\ndiscarding the rest of the elements.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7502,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7502"
    },
    {
      id: "Stream.runScoped",
      name: "runScoped",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, A, E2, R2>(sink: Sink<A2, A, unknown, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect<A2, E2 | E, Scope | R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink<A2, A, unknown, E2, R2>): Effect<A2, E | E2, Scope | R | R2>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7507,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7507"
    },
    {
      id: "Stream.runSum",
      name: "runSum",
      module: "Stream",
      package: "effect",
      signature: "<E, R>(self: Stream<number, E, R>) => Effect<number, E, R>",
      description: "Runs the stream to a sink which sums elements, provided they are Numeric.",
      documentation: "Runs the stream to a sink which sums elements, provided they are Numeric.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7525,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7525"
    },
    {
      id: "Stream.scan",
      name: "scan",
      module: "Stream",
      package: "effect",
      signature: "{ <S, A>(s: S, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Stream<S, E, R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => S): Stream<S, E, R>; }",
      description: "Statefully maps over the elements of this stream to produce all\nintermediate results of type `S` given an initial S.",
      documentation: "Statefully maps over the elements of this stream to produce all\nintermediate results of type `S` given an initial S.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

const stream = Stream.range(1, 6).pipe(Stream.scan(0, (a, b) => a + b))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 0,  1,  3, 6, 10, 15, 21 ] }`
        }
      ],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7543,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7543"
    },
    {
      id: "Stream.scanEffect",
      name: "scanEffect",
      module: "Stream",
      package: "effect",
      signature: "{ <S, A, E2, R2>(s: S, f: (s: S, a: A) => Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<S, E2 | E, R2 | R>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => Effect<S, E2, R2>): Stream<S, E | E2, R | R2>; }",
      description: "Statefully and effectfully maps over the elements of this stream to produce\nall intermediate results of type `S` given an initial S.",
      documentation: "Statefully and effectfully maps over the elements of this stream to produce\nall intermediate results of type `S` given an initial S.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7588,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7588"
    },
    {
      id: "Stream.scanReduce",
      name: "scanReduce",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, A>(f: (a2: A2 | A, a: A) => A2): <E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, f: (a2: A | A2, a: A) => A2): Stream<A | A2, E, R>; }",
      description: "Statefully maps over the elements of this stream to produce all\nintermediate results. See also `Stream.scan`.",
      documentation: "Statefully maps over the elements of this stream to produce all\nintermediate results.\n\nSee also `Stream.scan`.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7615,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7615"
    },
    {
      id: "Stream.scanReduceEffect",
      name: "scanReduceEffect",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, A, E2, R2>(f: (a2: A2 | A, a: A) => Effect<A2 | A, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a2: A | A2, a: A) => Effect<A | A2, E2, R2>): Stream<A | A2, E | E2, R | R2>; }",
      description: "Statefully and effectfully maps over the elements of this stream to produce\nall intermediate results. See also `Stream.scanEffect`.",
      documentation: "Statefully and effectfully maps over the elements of this stream to produce\nall intermediate results.\n\nSee also `Stream.scanEffect`.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7646,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7646"
    },
    {
      id: "Stream.schedule",
      name: "schedule",
      module: "Stream",
      package: "effect",
      signature: "{ <X, A0 extends A, R2, A>(schedule: Schedule<X, A0, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, A0 extends A, R2>(self: Stream<A, E, R>, schedule: Schedule<X, A0, R2>): Stream<A, E, R | R2>; }",
      description: "Schedules the output of the stream using the provided `schedule`.",
      documentation: "Schedules the output of the stream using the provided `schedule`.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7674,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7674"
    },
    {
      id: "Stream.scheduleWith",
      name: "scheduleWith",
      module: "Stream",
      package: "effect",
      signature: "{ <B, A0 extends A, R2, A, C>(schedule: Schedule<B, A0, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): <E, R>(self: Stream<A, E, R>) => Stream<C, E, R2 | R>; <A, E, R, B, A0 extends A, R2, C>(self: Stream<A, E, R>, schedule: Schedule<B, A0, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): Stream<C, E, R | R2>; }",
      description: "Schedules the output of the stream using the provided `schedule` and emits\nits output at the end (if `schedule` is finite). Uses the provided function\nto align the stream and schedule outputs on the same type.",
      documentation: "Schedules the output of the stream using the provided `schedule` and emits\nits output at the end (if `schedule` is finite). Uses the provided function\nto align the stream and schedule outputs on the same type.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7698,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7698"
    },
    {
      id: "Stream.scoped",
      name: "scoped",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(effect: Effect<A, E, R>) => Stream<A, E, Exclude<R, Scope>>",
      description: "Creates a single-valued stream from a scoped resource.",
      documentation: "Creates a single-valued stream from a scoped resource.",
      examples: [
        {
          code: `import { Console, Effect, Stream } from "effect"

// Creating a single-valued stream from a scoped resource
const stream = Stream.scoped(
 Effect.acquireRelease(
   Console.log("acquire"),
   () => Console.log("release")
 )
).pipe(
 Stream.flatMap(() => Console.log("use"))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// acquire
// use
// release
// { _id: 'Chunk', values: [ undefined ] }`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7751,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7751"
    },
    {
      id: "Stream.scopedWith",
      name: "scopedWith",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(f: (scope: Scope) => Effect<A, E, R>) => Stream<A, E, R>",
      description: "Use a function that receives a scope and returns an effect to emit an output\nelement. The output element will be the result of the returned effect, if\nsuccessful.",
      documentation: "Use a function that receives a scope and returns an effect to emit an output\nelement. The output element will be the result of the returned effect, if\nsuccessful.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "3.11.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7760,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7760"
    },
    {
      id: "Stream.sliding",
      name: "sliding",
      module: "Stream",
      package: "effect",
      signature: "{ (chunkSize: number): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, chunkSize: number): Stream<Chunk<A>, E, R>; }",
      description: "Emits a sliding window of `n` elements.",
      documentation: 'Emits a sliding window of `n` elements.\n\n```ts\nimport { pipe, Stream } from "effect"\n\npipe(\n  Stream.make(1, 2, 3, 4),\n  Stream.sliding(2),\n  Stream.runCollect\n)\n// => Chunk(Chunk(1, 2), Chunk(2, 3), Chunk(3, 4))\n```',
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7778,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7778"
    },
    {
      id: "Stream.slidingSize",
      name: "slidingSize",
      module: "Stream",
      package: "effect",
      signature: "{ (chunkSize: number, stepSize: number): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, chunkSize: number, stepSize: number): Stream<Chunk<A>, E, R>; }",
      description: "Like `sliding`, but with a configurable `stepSize` parameter.",
      documentation: "Like `sliding`, but with a configurable `stepSize` parameter.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7822,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7822"
    },
    {
      id: "Stream.some",
      name: "some",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(self: Stream<Option<A>, E, R>) => Stream<A, Option<E>, R>",
      description: "Converts an option on values into an option on errors.",
      documentation: "Converts an option on values into an option on errors.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7844,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7844"
    },
    {
      id: "Stream.someOrElse",
      name: "someOrElse",
      module: "Stream",
      package: "effect",
      signature: "{ <A2>(fallback: LazyArg<A2>): <A, E, R>(self: Stream<Option<A>, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<Option<A>, E, R>, fallback: LazyArg<A2>): Stream<A | A2, E, R>; }",
      description: "Extracts the optional value, or returns the given 'default'.",
      documentation: "Extracts the optional value, or returns the given 'default'.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7851,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7851"
    },
    {
      id: "Stream.someOrFail",
      name: "someOrFail",
      module: "Stream",
      package: "effect",
      signature: "{ <E2>(error: LazyArg<E2>): <A, E, R>(self: Stream<Option<A>, E, R>) => Stream<A, E2 | E, R>; <A, E, R, E2>(self: Stream<Option<A>, E, R>, error: LazyArg<E2>): Stream<A, E | E2, R>; }",
      description: "Extracts the optional value, or fails with the given error 'e'.",
      documentation: "Extracts the optional value, or fails with the given error 'e'.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7873,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7873"
    },
    {
      id: "Stream.split",
      name: "split",
      module: "Stream",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<Chunk<Exclude<A, B>>, E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<Chunk<A>, E, R>; <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<Chunk<Exclude<A, B>>, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<Chunk<A>, E, R>; }",
      description: "Splits elements based on a predicate or refinement.",
      documentation: 'Splits elements based on a predicate or refinement.\n\n```ts\nimport { pipe, Stream } from "effect"\n\npipe(\n  Stream.range(1, 10),\n  Stream.split((n) => n % 4 === 0),\n  Stream.runCollect\n)\n// => Chunk(Chunk(1, 2, 3), Chunk(5, 6, 7), Chunk(9))\n```',
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7906,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7906"
    },
    {
      id: "Stream.splitOnChunk",
      name: "splitOnChunk",
      module: "Stream",
      package: "effect",
      signature: "{ <A>(delimiter: Chunk<A>): <E, R>(self: Stream<A, E, R>) => Stream<Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, delimiter: Chunk<A>): Stream<Chunk<A>, E, R>; }",
      description: "Splits elements on a delimiter and transforms the splits into desired output.",
      documentation: "Splits elements on a delimiter and transforms the splits into desired output.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 7986,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L7986"
    },
    {
      id: "Stream.splitLines",
      name: "splitLines",
      module: "Stream",
      package: "effect",
      signature: "<E, R>(self: Stream<string, E, R>) => Stream<string, E, R>",
      description: "Splits strings on newlines. Handles both Windows newlines (`\\r\\n`) and UNIX\nnewlines (`\\n`).",
      documentation: "Splits strings on newlines. Handles both Windows newlines (`\\r\\n`) and UNIX\nnewlines (`\\n`).",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 8009,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8009"
    },
    {
      id: "Stream.succeed",
      name: "succeed",
      module: "Stream",
      package: "effect",
      signature: "<A>(value: A) => Stream<A, never, never>",
      description: "Creates a single-valued pure stream.",
      documentation: "Creates a single-valued pure stream.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

// A Stream with a single number
const stream = Stream.succeed(3)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 3 ] }`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 8027,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8027"
    },
    {
      id: "Stream.sync",
      name: "sync",
      module: "Stream",
      package: "effect",
      signature: "<A>(evaluate: LazyArg<A>) => Stream<A, never, never>",
      description: "Creates a single-valued pure stream.",
      documentation: "Creates a single-valued pure stream.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 8034,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8034"
    },
    {
      id: "Stream.suspend",
      name: "suspend",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(stream: LazyArg<Stream<A, E, R>>) => Stream<A, E, R>",
      description: "Returns a lazily constructed stream.",
      documentation: "Returns a lazily constructed stream.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 8041,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8041"
    },
    {
      id: "Stream.take",
      name: "take",
      module: "Stream",
      package: "effect",
      signature: "{ (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }",
      description: "Takes the specified number of elements from this stream.",
      documentation: "Takes the specified number of elements from this stream.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

const stream = Stream.take(Stream.iterate(0, (n) => n + 1), 5)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }`
        }
      ],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 8058,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8058"
    },
    {
      id: "Stream.takeRight",
      name: "takeRight",
      module: "Stream",
      package: "effect",
      signature: "{ (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }",
      description: "Takes the last specified number of elements from this stream.",
      documentation: "Takes the last specified number of elements from this stream.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

const stream = Stream.takeRight(Stream.make(1, 2, 3, 4, 5, 6), 3)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 4, 5, 6 ] }`
        }
      ],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 8110,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8110"
    },
    {
      id: "Stream.takeUntil",
      name: "takeUntil",
      module: "Stream",
      package: "effect",
      signature: "{ <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }",
      description: "Takes all elements of the stream until the specified predicate evaluates to\n`true`.",
      documentation: "Takes all elements of the stream until the specified predicate evaluates to\n`true`.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

const stream = Stream.takeUntil(Stream.iterate(0, (n) => n + 1), (n) => n === 4)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }`
        }
      ],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 8163,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8163"
    },
    {
      id: "Stream.takeUntilEffect",
      name: "takeUntilEffect",
      module: "Stream",
      package: "effect",
      signature: "{ <A, E2, R2>(predicate: (a: NoInfer<A>) => Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, predicate: (a: A) => Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }",
      description: "Takes all elements of the stream until the specified effectual predicate\nevaluates to `true`.",
      documentation: "Takes all elements of the stream until the specified effectual predicate\nevaluates to `true`.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 8208,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8208"
    },
    {
      id: "Stream.takeWhile",
      name: "takeWhile",
      module: "Stream",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<B, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }",
      description: "Takes all elements of the stream for as long as the specified predicate\nevaluates to `true`.",
      documentation: "Takes all elements of the stream for as long as the specified predicate\nevaluates to `true`.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

const stream = Stream.takeWhile(Stream.iterate(0, (n) => n + 1), (n) => n < 5)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }`
        }
      ],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 8243,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8243"
    },
    {
      id: "Stream.tap",
      name: "tap",
      module: "Stream",
      package: "effect",
      signature: "{ <A, X, E2, R2>(f: (a: NoInfer<A>) => Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: NoInfer<A>) => Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }",
      description: "Adds an effect to consumption of every element of the stream.",
      documentation: "Adds an effect to consumption of every element of the stream.",
      examples: [
        {
          code: "import { Console, Effect, Stream } from \"effect\"\n\nconst stream = Stream.make(1, 2, 3).pipe(\n  Stream.tap((n) => Console.log(`before mapping: ${n}`)),\n  Stream.map((n) => n * 2),\n  Stream.tap((n) => Console.log(`after mapping: ${n}`))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// before mapping: 1\n// after mapping: 2\n// before mapping: 2\n// after mapping: 4\n// before mapping: 3\n// after mapping: 6\n// { _id: 'Chunk', values: [ 2, 4, 6 ] }"
        }
      ],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 8343,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8343"
    },
    {
      id: "Stream.tapBoth",
      name: "tapBoth",
      module: "Stream",
      package: "effect",
      signature: "{ <E, X1, E2, R2, A, X2, E3, R3>(options: { readonly onFailure: (e: NoInfer<E>) => Effect<X1, E2, R2>; readonly onSuccess: (a: NoInfer<A>) => Effect<X2, E3, R3>; }): <R>(self: Stream<A, E, R>) => Stream<A, E | E2 | E3, R2 | R3 | R>; <A, E, R, X1, E2, R2, X2, E3, R3>(self: Stream<A, E, R>, options: { readonly onFailure: (e: NoInfer<E>) => Effect<X1, E2, R2>; readonly onSuccess: (a: NoInfer<A>) => Effect<X2, E3, R3>; }): Stream<A, E | E2 | E3, R | R2 | R3>; }",
      description: 'Returns a stream that effectfully "peeks" at the failure or success of\nthe stream.',
      documentation: 'Returns a stream that effectfully "peeks" at the failure or success of\nthe stream.',
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 8406,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8406"
    },
    {
      id: "Stream.tapError",
      name: "tapError",
      module: "Stream",
      package: "effect",
      signature: "{ <E, X, E2, R2>(f: (error: NoInfer<E>) => Effect<X, E2, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (error: E) => Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }",
      description: 'Returns a stream that effectfully "peeks" at the failure of the stream.',
      documentation: 'Returns a stream that effectfully "peeks" at the failure of the stream.',
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 8436,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8436"
    },
    {
      id: "Stream.tapErrorCause",
      name: "tapErrorCause",
      module: "Stream",
      package: "effect",
      signature: "{ <E, X, E2, R2>(f: (cause: Cause<NoInfer<E>>) => Effect<X, E2, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (cause: Cause<E>) => Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }",
      description: 'Returns a stream that effectfully "peeks" at the cause of failure of the\nstream.',
      documentation: 'Returns a stream that effectfully "peeks" at the cause of failure of the\nstream.',
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 8459,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8459"
    },
    {
      id: "Stream.tapSink",
      name: "tapSink",
      module: "Stream",
      package: "effect",
      signature: "{ <A, E2, R2>(sink: Sink<unknown, A, unknown, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, sink: Sink<unknown, A, unknown, E2, R2>): Stream<A, E | E2, R | R2>; }",
      description: "Sends all elements emitted by this stream to the specified sink in addition\nto emitting them.",
      documentation: "Sends all elements emitted by this stream to the specified sink in addition\nto emitting them.",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 8484,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8484"
    },
    {
      id: "Stream.throttle",
      name: "throttle",
      module: "Stream",
      package: "effect",
      signature: '{ <A>(options: { readonly cost: (chunk: Chunk<A>) => number; readonly units: number; readonly duration: DurationInput; readonly burst?: number; readonly strategy?: "enforce" | "shape"; }): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, options: { readonly cost: (chunk: Chunk<A>) => number; readonly units: number; readonly duration: DurationInput; readonly burst?: number; readonly strategy?: "enforce" | "shape"; }): Stream<A, E, R>; }',
      description: 'Delays the chunks of this stream according to the given bandwidth\nparameters using the token bucket algorithm. Allows for burst in the\nprocessing of elements by allowing the token bucket to accumulate tokens up\nto a `units + burst` threshold. The weight of each chunk is determined by\nthe `cost` function. If using the "enforce" strategy, chunks that do not meet the bandwidth\nconstraints are dropped. If using the "shape" strategy, chunks are delayed\nuntil they can be emitted without exceeding the bandwidth constraints. Defaults to the "shape" strategy.',
      documentation: 'Delays the chunks of this stream according to the given bandwidth\nparameters using the token bucket algorithm. Allows for burst in the\nprocessing of elements by allowing the token bucket to accumulate tokens up\nto a `units + burst` threshold. The weight of each chunk is determined by\nthe `cost` function.\n\nIf using the "enforce" strategy, chunks that do not meet the bandwidth\nconstraints are dropped. If using the "shape" strategy, chunks are delayed\nuntil they can be emitted without exceeding the bandwidth constraints.\n\nDefaults to the "shape" strategy.',
      examples: [
        {
          code: 'import { Chunk, Effect, Schedule, Stream } from "effect"\n\nlet last = Date.now()\nconst log = (message: string) =>\n  Effect.sync(() => {\n    const end = Date.now()\n    console.log(`${message} after ${end - last}ms`)\n    last = end\n  })\n\nconst stream = Stream.fromSchedule(Schedule.spaced("50 millis")).pipe(\n  Stream.take(6),\n  Stream.tap((n) => log(`Received ${n}`)),\n  Stream.throttle({\n    cost: Chunk.size,\n    duration: "100 millis",\n    units: 1\n  }),\n  Stream.tap((n) => log(`> Emitted ${n}`))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// Received 0 after 56ms\n// > Emitted 0 after 0ms\n// Received 1 after 52ms\n// > Emitted 1 after 48ms\n// Received 2 after 52ms\n// > Emitted 2 after 49ms\n// Received 3 after 52ms\n// > Emitted 3 after 48ms\n// Received 4 after 52ms\n// > Emitted 4 after 47ms\n// Received 5 after 52ms\n// > Emitted 5 after 49ms\n// { _id: \'Chunk\', values: [ 0, 1, 2, 3, 4, 5 ] }'
        }
      ],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 8557,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8557"
    },
    {
      id: "Stream.throttleEffect",
      name: "throttleEffect",
      module: "Stream",
      package: "effect",
      signature: '{ <A, E2, R2>(options: { readonly cost: (chunk: Chunk<A>) => Effect<number, E2, R2>; readonly units: number; readonly duration: DurationInput; readonly burst?: number; readonly strategy?: "enforce" | "shape"; }): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, options: { readonly cost: (chunk: Chunk<A>) => Effect<number, E2, R2>; readonly units: number; readonly duration: DurationInput; readonly burst?: number; readonly strategy?: "enforce" | "shape"; }): Stream<A, E | E2, R | R2>; }',
      description: 'Delays the chunks of this stream according to the given bandwidth\nparameters using the token bucket algorithm. Allows for burst in the\nprocessing of elements by allowing the token bucket to accumulate tokens up\nto a `units + burst` threshold. The weight of each chunk is determined by\nthe effectful `costFn` function. If using the "enforce" strategy, chunks that do not meet the bandwidth\nconstraints are dropped. If using the "shape" strategy, chunks are delayed\nuntil they can be emitted without exceeding the bandwidth constraints. Defaults to the "shape" strategy.',
      documentation: 'Delays the chunks of this stream according to the given bandwidth\nparameters using the token bucket algorithm. Allows for burst in the\nprocessing of elements by allowing the token bucket to accumulate tokens up\nto a `units + burst` threshold. The weight of each chunk is determined by\nthe effectful `costFn` function.\n\nIf using the "enforce" strategy, chunks that do not meet the bandwidth\nconstraints are dropped. If using the "shape" strategy, chunks are delayed\nuntil they can be emitted without exceeding the bandwidth constraints.\n\nDefaults to the "shape" strategy.',
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 8699,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8699"
    },
    {
      id: "Stream.tick",
      name: "tick",
      module: "Stream",
      package: "effect",
      signature: "(interval: DurationInput) => Stream<void, never, never>",
      description: "A stream that emits void values spaced by the specified duration.",
      documentation: "A stream that emits void values spaced by the specified duration.",
      examples: [
        {
          code: 'import { Effect, Stream } from "effect"\n\nlet last = Date.now()\nconst log = (message: string) =>\n  Effect.sync(() => {\n    const end = Date.now()\n    console.log(`${message} after ${end - last}ms`)\n    last = end\n  })\n\nconst stream = Stream.tick("1 seconds").pipe(Stream.tap(() => log("tick")))\n\nEffect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)\n// tick after 4ms\n// tick after 1003ms\n// tick after 1001ms\n// tick after 1002ms\n// tick after 1002ms\n// { _id: \'Chunk\', values: [ undefined, undefined, undefined, undefined, undefined ] }'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 8776,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8776"
    },
    {
      id: "Stream.timeout",
      name: "timeout",
      module: "Stream",
      package: "effect",
      signature: "{ (duration: DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, duration: DurationInput): Stream<A, E, R>; }",
      description: "Ends the stream if it does not produce a value after the specified duration.",
      documentation: "Ends the stream if it does not produce a value after the specified duration.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 8783,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8783"
    },
    {
      id: "Stream.timeoutFail",
      name: "timeoutFail",
      module: "Stream",
      package: "effect",
      signature: "{ <E2>(error: LazyArg<E2>, duration: DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>; <A, E, R, E2>(self: Stream<A, E, R>, error: LazyArg<E2>, duration: DurationInput): Stream<A, E | E2, R>; }",
      description: "Fails the stream with given error if it does not produce a value after d\nduration.",
      documentation: "Fails the stream with given error if it does not produce a value after d\nduration.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 8806,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8806"
    },
    {
      id: "Stream.timeoutFailCause",
      name: "timeoutFailCause",
      module: "Stream",
      package: "effect",
      signature: "{ <E2>(cause: LazyArg<Cause<E2>>, duration: DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>; <A, E, R, E2>(self: Stream<A, E, R>, cause: LazyArg<Cause<E2>>, duration: DurationInput): Stream<A, E | E2, R>; }",
      description: "Fails the stream with given cause if it does not produce a value after d\nduration.",
      documentation: "Fails the stream with given cause if it does not produce a value after d\nduration.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 8831,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8831"
    },
    {
      id: "Stream.timeoutTo",
      name: "timeoutTo",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, E2, R2>(duration: DurationInput, that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, duration: DurationInput, that: Stream<A2, E2, R2>): Stream<A | A2, E | E2, R | R2>; }",
      description: "Switches the stream if it does not produce a value after the specified\nduration.",
      documentation: "Switches the stream if it does not produce a value after the specified\nduration.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 8856,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8856"
    },
    {
      id: "Stream.toPubSub",
      name: "toPubSub",
      module: "Stream",
      package: "effect",
      signature: '{ (capacity: number | { readonly capacity: "unbounded"; readonly replay?: number; } | { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend"; readonly replay?: number; }): <A, E, R>(self: Stream<A, E, R>) => Effect<PubSub<Take<A, E>>, never, Scope | R>; <A, E, R>(self: Stream<A, E, R>, capacity: number | { readonly capacity: "unbounded"; readonly replay?: number; } | { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend"; readonly replay?: number; }): Effect<PubSub<Take<A, E>>, never, Scope | R>; }',
      description: "Converts the stream to a scoped `PubSub` of chunks. After the scope is closed,\nthe `PubSub` will never again produce values and should be discarded.",
      documentation: "Converts the stream to a scoped `PubSub` of chunks. After the scope is closed,\nthe `PubSub` will never again produce values and should be discarded.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 8881,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8881"
    },
    {
      id: "Stream.toPull",
      name: "toPull",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(self: Stream<A, E, R>) => Effect<Effect<Chunk<A>, Option<E>, R>, never, Scope | R>",
      description: "Returns in a scope a ZIO effect that can be used to repeatedly pull chunks\nfrom the stream. The pull effect fails with None when the stream is\nfinished, or with Some error if it fails, otherwise it returns a chunk of\nthe stream's output.",
      documentation: "Returns in a scope a ZIO effect that can be used to repeatedly pull chunks\nfrom the stream. The pull effect fails with None when the stream is\nfinished, or with Some error if it fails, otherwise it returns a chunk of\nthe stream's output.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

// Simulate a chunked stream
const stream = Stream.fromIterable([1, 2, 3, 4, 5]).pipe(Stream.rechunk(2))

const program = Effect.gen(function*() {
  // Create an effect to get data chunks from the stream
  const getChunk = yield* Stream.toPull(stream)

  // Continuously fetch and process chunks
  while (true) {
    const chunk = yield* getChunk
    console.log(chunk)
  }
})

Effect.runPromise(Effect.scoped(program)).then(console.log, console.error)
// { _id: 'Chunk', values: [ 1, 2 ] }
// { _id: 'Chunk', values: [ 3, 4 ] }
// { _id: 'Chunk', values: [ 5 ] }
// (FiberFailure) Error: {
//   "_id": "Option",
//   "_tag": "None"
// }`
        }
      ],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 8950,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8950"
    },
    {
      id: "Stream.toQueue",
      name: "toQueue",
      module: "Stream",
      package: "effect",
      signature: '{ (options?: { readonly strategy?: "dropping" | "sliding" | "suspend"; readonly capacity?: number; } | { readonly strategy: "unbounded"; }): <A, E, R>(self: Stream<A, E, R>) => Effect<Dequeue<Take<A, E>>, never, Scope | R>; <A, E, R>(self: Stream<A, E, R>, options?: { readonly strategy?: "dropping" | "sliding" | "suspend"; readonly capacity?: number; } | { readonly strategy: "unbounded"; }): Effect<Dequeue<Take<A, E>>, never, Scope | R>; }',
      description: 'Converts the stream to a scoped queue of chunks. After the scope is closed,\nthe queue will never again produce values and should be discarded. Defaults to the "suspend" back pressure strategy with a capacity of 2.',
      documentation: 'Converts the stream to a scoped queue of chunks. After the scope is closed,\nthe queue will never again produce values and should be discarded.\n\nDefaults to the "suspend" back pressure strategy with a capacity of 2.',
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 8960,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8960"
    },
    {
      id: "Stream.toQueueOfElements",
      name: "toQueueOfElements",
      module: "Stream",
      package: "effect",
      signature: "{ (options?: { readonly capacity?: number; }): <A, E, R>(self: Stream<A, E, R>) => Effect<Dequeue<Exit<A, Option<E>>>, never, Scope | R>; <A, E, R>(self: Stream<A, E, R>, options?: { readonly capacity?: number; }): Effect<Dequeue<Exit<A, Option<E>>>, never, Scope | R>; }",
      description: "Converts the stream to a scoped queue of elements. After the scope is\nclosed, the queue will never again produce values and should be discarded. Defaults to a capacity of 2.",
      documentation: "Converts the stream to a scoped queue of elements. After the scope is\nclosed, the queue will never again produce values and should be discarded.\n\nDefaults to a capacity of 2.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9001,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9001"
    },
    {
      id: "Stream.toReadableStream",
      name: "toReadableStream",
      module: "Stream",
      package: "effect",
      signature: "{ <A>(options?: { readonly strategy?: QueuingStrategy<A>; }): <E>(self: Stream<A, E, never>) => ReadableStream<A>; <A, E>(self: Stream<A, E, never>, options?: { readonly strategy?: QueuingStrategy<A>; }): ReadableStream<A>; }",
      description: "Converts the stream to a `ReadableStream`. See https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.",
      documentation: "Converts the stream to a `ReadableStream`.\n\nSee https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9035,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9035"
    },
    {
      id: "Stream.toReadableStreamEffect",
      name: "toReadableStreamEffect",
      module: "Stream",
      package: "effect",
      signature: "{ <A>(options?: { readonly strategy?: QueuingStrategy<A>; }): <E, R>(self: Stream<A, E, R>) => Effect<ReadableStream<A>, never, R>; <A, E, R>(self: Stream<A, E, R>, options?: { readonly strategy?: QueuingStrategy<A>; }): Effect<ReadableStream<A>, never, R>; }",
      description: "Converts the stream to a `Effect<ReadableStream>`. See https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.",
      documentation: "Converts the stream to a `Effect<ReadableStream>`.\n\nSee https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9067,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9067"
    },
    {
      id: "Stream.toReadableStreamRuntime",
      name: "toReadableStreamRuntime",
      module: "Stream",
      package: "effect",
      signature: "{ <A, XR>(runtime: Runtime<XR>, options?: { readonly strategy?: QueuingStrategy<A>; }): <E, R extends XR>(self: Stream<A, E, R>) => ReadableStream<A>; <A, E, XR, R extends XR>(self: Stream<A, E, R>, runtime: Runtime<XR>, options?: { readonly strategy?: QueuingStrategy<A>; }): ReadableStream<A>; }",
      description: "Converts the stream to a `ReadableStream` using the provided runtime. See https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.",
      documentation: "Converts the stream to a `ReadableStream` using the provided runtime.\n\nSee https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9099,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9099"
    },
    {
      id: "Stream.toAsyncIterableRuntime",
      name: "toAsyncIterableRuntime",
      module: "Stream",
      package: "effect",
      signature: "{ <A, XR>(runtime: Runtime<XR>): <E, R extends XR>(self: Stream<A, E, R>) => AsyncIterable<A>; <A, E, XR, R extends XR>(self: Stream<A, E, R>, runtime: Runtime<XR>): AsyncIterable<A>; }",
      description: "Converts the stream to a `AsyncIterable` using the provided runtime.",
      documentation: "Converts the stream to a `AsyncIterable` using the provided runtime.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "3.15.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9129,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9129"
    },
    {
      id: "Stream.toAsyncIterableEffect",
      name: "toAsyncIterableEffect",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(self: Stream<A, E, R>) => Effect<AsyncIterable<A>, never, R>",
      description: "Converts the stream to a `AsyncIterable` capturing the required dependencies.",
      documentation: "Converts the stream to a `AsyncIterable` capturing the required dependencies.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "3.15.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9151,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9151"
    },
    {
      id: "Stream.toAsyncIterable",
      name: "toAsyncIterable",
      module: "Stream",
      package: "effect",
      signature: "<A, E>(self: Stream<A, E, never>) => AsyncIterable<A>",
      description: "Converts the stream to a `AsyncIterable`.",
      documentation: "Converts the stream to a `AsyncIterable`.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "3.15.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9158,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9158"
    },
    {
      id: "Stream.transduce",
      name: "transduce",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, A, E2, R2>(sink: Sink<A2, A, A, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink<A2, A, A, E2, R2>): Stream<A2, E | E2, R | R2>; }",
      description: "Applies the transducer to the stream and emits its outputs.",
      documentation: "Applies the transducer to the stream and emits its outputs.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9165,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9165"
    },
    {
      id: "Stream.unfold",
      name: "unfold",
      module: "Stream",
      package: "effect",
      signature: "<S, A>(s: S, f: (s: S) => Option<readonly [A, S]>) => Stream<A, never, never>",
      description: 'Creates a stream by peeling off the "layers" of a value of type `S`.',
      documentation: 'Creates a stream by peeling off the "layers" of a value of type `S`.',
      examples: [
        {
          code: `import { Effect, Option, Stream } from "effect"

const stream = Stream.unfold(1, (n) => Option.some([n, n + 1]))

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5 ] }`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9197,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9197"
    },
    {
      id: "Stream.unfoldChunk",
      name: "unfoldChunk",
      module: "Stream",
      package: "effect",
      signature: "<S, A>(s: S, f: (s: S) => Option<readonly [Chunk<A>, S]>) => Stream<A, never, never>",
      description: 'Creates a stream by peeling off the "layers" of a value of type `S`.',
      documentation: 'Creates a stream by peeling off the "layers" of a value of type `S`.',
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9204,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9204"
    },
    {
      id: "Stream.unfoldChunkEffect",
      name: "unfoldChunkEffect",
      module: "Stream",
      package: "effect",
      signature: "<S, A, E, R>(s: S, f: (s: S) => Effect<Option<readonly [Chunk<A>, S]>, E, R>) => Stream<A, E, R>",
      description: 'Creates a stream by effectfully peeling off the "layers" of a value of type\n`S`.',
      documentation: 'Creates a stream by effectfully peeling off the "layers" of a value of type\n`S`.',
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9212,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9212"
    },
    {
      id: "Stream.unfoldEffect",
      name: "unfoldEffect",
      module: "Stream",
      package: "effect",
      signature: "<S, A, E, R>(s: S, f: (s: S) => Effect<Option<readonly [A, S]>, E, R>) => Stream<A, E, R>",
      description: 'Creates a stream by effectfully peeling off the "layers" of a value of type\n`S`.',
      documentation: 'Creates a stream by effectfully peeling off the "layers" of a value of type\n`S`.',
      examples: [
        {
          code: `import { Effect, Option, Random, Stream } from "effect"

const stream = Stream.unfoldEffect(1, (n) =>
  Random.nextBoolean.pipe(
    Effect.map((b) => (b ? Option.some([n, -n]) : Option.some([n, n])))
  ))

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)
// { _id: 'Chunk', values: [ 1, -1, -1, -1, -1 ] }`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9233,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9233"
    },
    {
      id: "Stream.unwrap",
      name: "unwrap",
      module: "Stream",
      package: "effect",
      signature: "<A, E2, R2, E, R>(effect: Effect<Stream<A, E2, R2>, E, R>) => Stream<A, E2 | E, R2 | R>",
      description: "Creates a stream produced from an `Effect`.",
      documentation: "Creates a stream produced from an `Effect`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9259,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9259"
    },
    {
      id: "Stream.unwrapScoped",
      name: "unwrapScoped",
      module: "Stream",
      package: "effect",
      signature: "<A, E2, R2, E, R>(effect: Effect<Stream<A, E2, R2>, E, R>) => Stream<A, E2 | E, R2 | Exclude<R, Scope>>",
      description: "Creates a stream produced from a scoped `Effect`.",
      documentation: "Creates a stream produced from a scoped `Effect`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9266,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9266"
    },
    {
      id: "Stream.unwrapScopedWith",
      name: "unwrapScopedWith",
      module: "Stream",
      package: "effect",
      signature: "<A, E2, R2, E, R>(f: (scope: Scope) => Effect<Stream<A, E2, R2>, E, R>) => Stream<A, E2 | E, R2 | R>",
      description: "Creates a stream produced from a function which receives a `Scope` and\nreturns an `Effect`. The resulting stream will emit a single element, which\nwill be the result of the returned effect, if successful.",
      documentation: "Creates a stream produced from a function which receives a `Scope` and\nreturns an `Effect`. The resulting stream will emit a single element, which\nwill be the result of the returned effect, if successful.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "3.11.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9275,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9275"
    },
    {
      id: "Stream.updateService",
      name: "updateService",
      module: "Stream",
      package: "effect",
      signature: "{ <I, S>(tag: Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, I | R>; <A, E, R, I, S>(self: Stream<A, E, R>, tag: Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): Stream<A, E, R | I>; }",
      description: "Updates the specified service within the context of the `Stream`.",
      documentation: "Updates the specified service within the context of the `Stream`.",
      examples: [],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9282,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9282"
    },
    {
      id: "Stream.when",
      name: "when",
      module: "Stream",
      package: "effect",
      signature: "{ (test: LazyArg<boolean>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, test: LazyArg<boolean>): Stream<A, E, R>; }",
      description: "Returns the specified stream if the given condition is satisfied, otherwise\nreturns an empty stream.",
      documentation: "Returns the specified stream if the given condition is satisfied, otherwise\nreturns an empty stream.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9305,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9305"
    },
    {
      id: "Stream.whenCase",
      name: "whenCase",
      module: "Stream",
      package: "effect",
      signature: "<A, A2, E, R>(evaluate: LazyArg<A>, pf: (a: A) => Option<Stream<A2, E, R>>) => Stream<A2, E, R>",
      description: "Returns the resulting stream when the given `PartialFunction` is defined\nfor the given value, otherwise returns an empty stream.",
      documentation: "Returns the resulting stream when the given `PartialFunction` is defined\nfor the given value, otherwise returns an empty stream.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9330,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9330"
    },
    {
      id: "Stream.whenCaseEffect",
      name: "whenCaseEffect",
      module: "Stream",
      package: "effect",
      signature: "{ <A, A2, E2, R2>(pf: (a: A) => Option<Stream<A2, E2, R2>>): <E, R>(self: Effect<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, pf: (a: A) => Option<Stream<A2, E2, R2>>): Stream<A2, E | E2, R | R2>; }",
      description: "Returns the stream when the given partial function is defined for the given\neffectful value, otherwise returns an empty stream.",
      documentation: "Returns the stream when the given partial function is defined for the given\neffectful value, otherwise returns an empty stream.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9338,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9338"
    },
    {
      id: "Stream.whenEffect",
      name: "whenEffect",
      module: "Stream",
      package: "effect",
      signature: "{ <E2, R2>(effect: Effect<boolean, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, effect: Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }",
      description: "Returns the stream if the given effectful condition is satisfied, otherwise\nreturns an empty stream.",
      documentation: "Returns the stream if the given effectful condition is satisfied, otherwise\nreturns an empty stream.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9363,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9363"
    },
    {
      id: "Stream.withSpan",
      name: "withSpan",
      module: "Stream",
      package: "effect",
      signature: "{ (name: string, options?: SpanOptions): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, Exclude<R, ParentSpan>>; <A, E, R>(self: Stream<A, E, R>, name: string, options?: SpanOptions): Stream<A, E, Exclude<R, ParentSpan>>; }",
      description: "Wraps the stream with a new span for tracing.",
      documentation: "Wraps the stream with a new span for tracing.",
      examples: [],
      tags: [
        "tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9387,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9387"
    },
    {
      id: "Stream.zip",
      name: "zip",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<[A, A2], E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<[A, A2], E | E2, R | R2>; }",
      description: "Zips this stream with another point-wise and emits tuples of elements from\nboth streams. The new stream will end when one of the sides ends.",
      documentation: "Zips this stream with another point-wise and emits tuples of elements from\nboth streams.\n\nThe new stream will end when one of the sides ends.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

// We create two streams and zip them together.
const stream = Stream.zip(
  Stream.make(1, 2, 3, 4, 5, 6),
  Stream.make("a", "b", "c")
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ [ 1, 'a' ], [ 2, 'b' ], [ 3, 'c' ] ] }`
        }
      ],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9426,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9426"
    },
    {
      id: "Stream.zipFlatten",
      name: "zipFlatten",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, E2, R2>(that: Stream<A2, E2, R2>): <A extends ReadonlyArray<any>, E, R>(self: Stream<A, E, R>) => Stream<[...A, A2], E2 | E, R2 | R>; <A extends ReadonlyArray<any>, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<[...A, A2], E | E2, R | R2>; }",
      description: "Zips this stream with another point-wise and emits tuples of elements from\nboth streams. The new stream will end when one of the sides ends.",
      documentation: "Zips this stream with another point-wise and emits tuples of elements from\nboth streams.\n\nThe new stream will end when one of the sides ends.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9485,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9485"
    },
    {
      id: "Stream.zipAll",
      name: "zipAll",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, E2, R2, A>(options: { readonly other: Stream<A2, E2, R2>; readonly defaultSelf: A; readonly defaultOther: A2; }): <E, R>(self: Stream<A, E, R>) => Stream<[A, A2], E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, options: { readonly other: Stream<A2, E2, R2>; readonly defaultSelf: A; readonly defaultOther: A2; }): Stream<[A, A2], E | E2, R | R2>; }",
      description: "Zips this stream with another point-wise, creating a new stream of pairs of\nelements from both sides. The defaults `defaultLeft` and `defaultRight` will be used if the streams\nhave different lengths and one of the streams has ended before the other.",
      documentation: "Zips this stream with another point-wise, creating a new stream of pairs of\nelements from both sides.\n\nThe defaults `defaultLeft` and `defaultRight` will be used if the streams\nhave different lengths and one of the streams has ended before the other.",
      examples: [
        {
          code: 'import { Effect, Stream } from "effect"\n\nconst stream = Stream.zipAll(Stream.make(1, 2, 3, 4, 5, 6), {\n  other: Stream.make("a", "b", "c"),\n  defaultSelf: 0,\n  defaultOther: "x"\n})\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: "Chunk", values: [ [ 1, "a" ], [ 2, "b" ], [ 3, "c" ], [ 4, "x" ], [ 5, "x" ], [ 6, "x" ] ] }'
        }
      ],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9531,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9531"
    },
    {
      id: "Stream.zipAllLeft",
      name: "zipAllLeft",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, E2, R2, A>(that: Stream<A2, E2, R2>, defaultLeft: A): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, defaultLeft: A): Stream<A, E | E2, R | R2>; }",
      description: "Zips this stream with another point-wise, and keeps only elements from this\nstream. The provided default value will be used if the other stream ends before\nthis one.",
      documentation: "Zips this stream with another point-wise, and keeps only elements from this\nstream.\n\nThe provided default value will be used if the other stream ends before\nthis one.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9601,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9601"
    },
    {
      id: "Stream.zipAllRight",
      name: "zipAllRight",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, E2, R2>(that: Stream<A2, E2, R2>, defaultRight: A2): <A, E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, defaultRight: A2): Stream<A2, E | E2, R | R2>; }",
      description: "Zips this stream with another point-wise, and keeps only elements from the\nother stream. The provided default value will be used if this stream ends before the\nother one.",
      documentation: "Zips this stream with another point-wise, and keeps only elements from the\nother stream.\n\nThe provided default value will be used if this stream ends before the\nother one.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9635,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9635"
    },
    {
      id: "Stream.zipAllSortedByKey",
      name: "zipAllSortedByKey",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, E2, R2, A, K>(options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultSelf: A; readonly defaultOther: A2; readonly order: Order<K>; }): <E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, [A, A2]], E2 | E, R2 | R>; <K, A, E, R, A2, E2, R2>(self: Stream<readonly [K, A], E, R>, options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultSelf: A; readonly defaultOther: A2; readonly order: Order<K>; }): Stream<[K, [A, A2]], E | E2, R | R2>; }",
      description: "Zips this stream that is sorted by distinct keys and the specified stream\nthat is sorted by distinct keys to produce a new stream that is sorted by\ndistinct keys. Combines values associated with each key into a tuple,\nusing the specified values `defaultLeft` and `defaultRight` to fill in\nmissing values. This allows zipping potentially unbounded streams of data by key in\nconstant space but the caller is responsible for ensuring that the\nstreams are sorted by distinct keys.",
      documentation: "Zips this stream that is sorted by distinct keys and the specified stream\nthat is sorted by distinct keys to produce a new stream that is sorted by\ndistinct keys. Combines values associated with each key into a tuple,\nusing the specified values `defaultLeft` and `defaultRight` to fill in\nmissing values.\n\nThis allows zipping potentially unbounded streams of data by key in\nconstant space but the caller is responsible for ensuring that the\nstreams are sorted by distinct keys.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9673,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9673"
    },
    {
      id: "Stream.zipAllSortedByKeyLeft",
      name: "zipAllSortedByKeyLeft",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, E2, R2, A, K>(options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultSelf: A; readonly order: Order<K>; }): <E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, A], E2 | E, R2 | R>; <K, A, E, R, A2, E2, R2>(self: Stream<readonly [K, A], E, R>, options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultSelf: A; readonly order: Order<K>; }): Stream<[K, A], E | E2, R | R2>; }",
      description: "Zips this stream that is sorted by distinct keys and the specified stream\nthat is sorted by distinct keys to produce a new stream that is sorted by\ndistinct keys. Keeps only values from this stream, using the specified\nvalue `default` to fill in missing values. This allows zipping potentially unbounded streams of data by key in\nconstant space but the caller is responsible for ensuring that the\nstreams are sorted by distinct keys.",
      documentation: "Zips this stream that is sorted by distinct keys and the specified stream\nthat is sorted by distinct keys to produce a new stream that is sorted by\ndistinct keys. Keeps only values from this stream, using the specified\nvalue `default` to fill in missing values.\n\nThis allows zipping potentially unbounded streams of data by key in\nconstant space but the caller is responsible for ensuring that the\nstreams are sorted by distinct keys.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9728,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9728"
    },
    {
      id: "Stream.zipAllSortedByKeyRight",
      name: "zipAllSortedByKeyRight",
      module: "Stream",
      package: "effect",
      signature: "{ <K, A2, E2, R2>(options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultOther: A2; readonly order: Order<K>; }): <A, E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, A2], E2 | E, R2 | R>; <A, E, R, K, A2, E2, R2>(self: Stream<readonly [K, A], E, R>, options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultOther: A2; readonly order: Order<K>; }): Stream<[K, A2], E | E2, R | R2>; }",
      description: "Zips this stream that is sorted by distinct keys and the specified stream\nthat is sorted by distinct keys to produce a new stream that is sorted by\ndistinct keys. Keeps only values from that stream, using the specified\nvalue `default` to fill in missing values. This allows zipping potentially unbounded streams of data by key in\nconstant space but the caller is responsible for ensuring that the\nstreams are sorted by distinct keys.",
      documentation: "Zips this stream that is sorted by distinct keys and the specified stream\nthat is sorted by distinct keys to produce a new stream that is sorted by\ndistinct keys. Keeps only values from that stream, using the specified\nvalue `default` to fill in missing values.\n\nThis allows zipping potentially unbounded streams of data by key in\nconstant space but the caller is responsible for ensuring that the\nstreams are sorted by distinct keys.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9779,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9779"
    },
    {
      id: "Stream.zipAllSortedByKeyWith",
      name: "zipAllSortedByKeyWith",
      module: "Stream",
      package: "effect",
      signature: "{ <K, A2, E2, R2, A, A3>(options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A3; readonly onBoth: (a: A, a2: A2) => A3; readonly order: Order<K>; }): <E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, A3], E2 | E, R2 | R>; <K, A, E, R, A2, E2, R2, A3>(self: Stream<readonly [K, A], E, R>, options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A3; readonly onBoth: (a: A, a2: A2) => A3; readonly order: Order<K>; }): Stream<[K, A3], E | E2, R | R2>; }",
      description: "Zips this stream that is sorted by distinct keys and the specified stream\nthat is sorted by distinct keys to produce a new stream that is sorted by\ndistinct keys. Uses the functions `left`, `right`, and `both` to handle\nthe cases where a key and value exist in this stream, that stream, or\nboth streams. This allows zipping potentially unbounded streams of data by key in\nconstant space but the caller is responsible for ensuring that the\nstreams are sorted by distinct keys.",
      documentation: "Zips this stream that is sorted by distinct keys and the specified stream\nthat is sorted by distinct keys to produce a new stream that is sorted by\ndistinct keys. Uses the functions `left`, `right`, and `both` to handle\nthe cases where a key and value exist in this stream, that stream, or\nboth streams.\n\nThis allows zipping potentially unbounded streams of data by key in\nconstant space but the caller is responsible for ensuring that the\nstreams are sorted by distinct keys.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9831,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9831"
    },
    {
      id: "Stream.zipAllWith",
      name: "zipAllWith",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, E2, R2, A, A3>(options: { readonly other: Stream<A2, E2, R2>; readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A3; readonly onBoth: (a: A, a2: A2) => A3; }): <E, R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, A3>(self: Stream<A, E, R>, options: { readonly other: Stream<A2, E2, R2>; readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A3; readonly onBoth: (a: A, a2: A2) => A3; }): Stream<A3, E | E2, R | R2>; }",
      description: "Zips this stream with another point-wise. The provided functions will be\nused to create elements for the composed stream. The functions `left` and `right` will be used if the streams have different\nlengths and one of the streams has ended before the other.",
      documentation: "Zips this stream with another point-wise. The provided functions will be\nused to create elements for the composed stream.\n\nThe functions `left` and `right` will be used if the streams have different\nlengths and one of the streams has ended before the other.",
      examples: [
        {
          code: 'import { Effect, Stream } from "effect"\n\nconst stream = Stream.zipAllWith(Stream.make(1, 2, 3, 4, 5, 6), {\n  other: Stream.make("a", "b", "c"),\n  onSelf: (n) => [n, "x"],\n  onOther: (s) => [0, s],\n  onBoth: (n, s) => [n - s.length, s]\n})\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: "Chunk", values: [ [ 0, "a" ], [ 1, "b" ], [ 2, "c" ], [ 4, "x" ], [ 5, "x" ], [ 6, "x" ] ] }'
        }
      ],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9900,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9900"
    },
    {
      id: "Stream.zipLatest",
      name: "zipLatest",
      module: "Stream",
      package: "effect",
      signature: "{ <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<[AL, AR], ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<[AL, AR], EL | ER, RL | RR>; }",
      description: "Zips the two streams so that when a value is emitted by either of the two\nstreams, it is combined with the latest value from the other stream to\nproduce a result. Note: tracking the latest value is done on a per-chunk basis. That means\nthat emitted elements that are not the last value in chunks will never be\nused for zipping.",
      documentation: "Zips the two streams so that when a value is emitted by either of the two\nstreams, it is combined with the latest value from the other stream to\nproduce a result.\n\nNote: tracking the latest value is done on a per-chunk basis. That means\nthat emitted elements that are not the last value in chunks will never be\nused for zipping.",
      examples: [
        {
          code: 'import { Effect, Schedule, Stream } from "effect"\n\nconst s1 = Stream.make(1, 2, 3).pipe(\n  Stream.schedule(Schedule.spaced("1 second"))\n)\n\nconst s2 = Stream.make("a", "b", "c", "d").pipe(\n  Stream.schedule(Schedule.spaced("500 millis"))\n)\n\nconst stream = Stream.zipLatest(s1, s2)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// { _id: "Chunk", values: [ [ 1, "a" ], [ 1, "b" ], [ 2, "b" ], [ 2, "c" ], [ 2, "d" ], [ 3, "d" ] ] }'
        }
      ],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 9994,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L9994"
    },
    {
      id: "Stream.zipLatestAll",
      name: "zipLatestAll",
      module: "Stream",
      package: "effect",
      signature: "<T extends ReadonlyArray<Stream<any, any, any>>>(...streams: T) => Stream<[T[number]] extends [never] ? never : { [K in keyof T]: T[K] extends Stream<infer A, infer _E, infer _R> ? A : never; }, [T[number]] extends [never] ? never : T[number] extends Stream<infer _A, infer _E, infer _R> ? _E : never, [T[number]] extends [never] ? never : T[number] extends Stream<infer _A, infer _E, infer _R> ? _R : never>",
      description: "Zips multiple streams so that when a value is emitted by any of the streams,\nit is combined with the latest values from the other streams to produce a result. Note: tracking the latest value is done on a per-chunk basis. That means\nthat emitted elements that are not the last value in chunks will never be\nused for zipping.",
      documentation: "Zips multiple streams so that when a value is emitted by any of the streams,\nit is combined with the latest values from the other streams to produce a result.\n\nNote: tracking the latest value is done on a per-chunk basis. That means\nthat emitted elements that are not the last value in chunks will never be\nused for zipping.",
      examples: [
        {
          code: `import { Stream, Schedule, Console, Effect } from "effect"

const stream = Stream.zipLatestAll(
    Stream.fromSchedule(Schedule.spaced('1 millis')),
    Stream.fromSchedule(Schedule.spaced('2 millis')),
    Stream.fromSchedule(Schedule.spaced('4 millis')),
).pipe(Stream.take(6), Stream.tap(Console.log))

Effect.runPromise(Stream.runDrain(stream))
// Output:
// [ 0, 0, 0 ]
// [ 1, 0, 0 ]
// [ 1, 1, 0 ]
// [ 2, 1, 0 ]
// [ 3, 1, 0 ]
// [ 3, 1, 1 ]
// .....`
        }
      ],
      tags: [
        "zipping"
      ],
      since: "3.3.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 10090,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L10090"
    },
    {
      id: "Stream.zipLatestWith",
      name: "zipLatestWith",
      module: "Stream",
      package: "effect",
      signature: "{ <AR, ER, RR, AL, A>(right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): <EL, RL>(left: Stream<AL, EL, RL>) => Stream<A, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR, A>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): Stream<A, EL | ER, RL | RR>; }",
      description: "Zips the two streams so that when a value is emitted by either of the two\nstreams, it is combined with the latest value from the other stream to\nproduce a result. Note: tracking the latest value is done on a per-chunk basis. That means\nthat emitted elements that are not the last value in chunks will never be\nused for zipping.",
      documentation: "Zips the two streams so that when a value is emitted by either of the two\nstreams, it is combined with the latest value from the other stream to\nproduce a result.\n\nNote: tracking the latest value is done on a per-chunk basis. That means\nthat emitted elements that are not the last value in chunks will never be\nused for zipping.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 10111,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L10111"
    },
    {
      id: "Stream.zipLeft",
      name: "zipLeft",
      module: "Stream",
      package: "effect",
      signature: "{ <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL, EL | ER, RL | RR>; }",
      description: "Zips this stream with another point-wise, but keeps only the outputs of\n`left` stream. The new stream will end when one of the sides ends.",
      documentation: "Zips this stream with another point-wise, but keeps only the outputs of\n`left` stream.\n\nThe new stream will end when one of the sides ends.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 10148,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L10148"
    },
    {
      id: "Stream.zipRight",
      name: "zipRight",
      module: "Stream",
      package: "effect",
      signature: "{ <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AR, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AR, EL | ER, RL | RR>; }",
      description: "Zips this stream with another point-wise, but keeps only the outputs of the\n`right` stream. The new stream will end when one of the sides ends.",
      documentation: "Zips this stream with another point-wise, but keeps only the outputs of the\n`right` stream.\n\nThe new stream will end when one of the sides ends.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 10179,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L10179"
    },
    {
      id: "Stream.zipWith",
      name: "zipWith",
      module: "Stream",
      package: "effect",
      signature: "{ <AR, ER, RR, AL, A>(right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): <EL, RL>(left: Stream<AL, EL, RL>) => Stream<A, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR, A>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): Stream<A, EL | ER, RL | RR>; }",
      description: "Zips this stream with another point-wise and applies the function to the\npaired elements. The new stream will end when one of the sides ends.",
      documentation: "Zips this stream with another point-wise and applies the function to the\npaired elements.\n\nThe new stream will end when one of the sides ends.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

// We create two streams and zip them with custom logic.
const stream = Stream.zipWith(
  Stream.make(1, 2, 3, 4, 5, 6),
  Stream.make("a", "b", "c"),
  (n, s) => [n - s.length, s]
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ [ 0, 'a' ], [ 1, 'b' ], [ 2, 'c' ] ] }`
        }
      ],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 10225,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L10225"
    },
    {
      id: "Stream.zipWithChunks",
      name: "zipWithChunks",
      module: "Stream",
      package: "effect",
      signature: "{ <A2, E2, R2, A, A3>(that: Stream<A2, E2, R2>, f: (left: Chunk<A>, right: Chunk<A2>) => readonly [Chunk<A3>, Either<Chunk<A2>, Chunk<A>>]): <E, R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, A3>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, f: (left: Chunk<A>, right: Chunk<A2>) => readonly [Chunk<A3>, Either<Chunk<A2>, Chunk<A>>]): Stream<A3, E | E2, R | R2>; }",
      description: "Zips this stream with another point-wise and applies the function to the\npaired elements. The new stream will end when one of the sides ends.",
      documentation: "Zips this stream with another point-wise and applies the function to the\npaired elements.\n\nThe new stream will end when one of the sides ends.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 10286,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L10286"
    },
    {
      id: "Stream.zipWithNext",
      name: "zipWithNext",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(self: Stream<A, E, R>) => Stream<[A, Option<A>], E, R>",
      description: "Zips each element with the next element if present.",
      documentation: "Zips each element with the next element if present.",
      examples: [
        {
          code: `import { Chunk, Effect, Stream } from "effect"

const stream = Stream.zipWithNext(Stream.make(1, 2, 3, 4))

Effect.runPromise(Stream.runCollect(stream)).then((chunk) => console.log(Chunk.toArray(chunk)))
// [
//   [ 1, { _id: 'Option', _tag: 'Some', value: 2 } ],
//   [ 2, { _id: 'Option', _tag: 'Some', value: 3 } ],
//   [ 3, { _id: 'Option', _tag: 'Some', value: 4 } ],
//   [ 4, { _id: 'Option', _tag: 'None' } ]
// ]`
        }
      ],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 10329,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L10329"
    },
    {
      id: "Stream.zipWithPrevious",
      name: "zipWithPrevious",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(self: Stream<A, E, R>) => Stream<[Option<A>, A], E, R>",
      description: "Zips each element with the previous element. Initially accompanied by\n`None`.",
      documentation: "Zips each element with the previous element. Initially accompanied by\n`None`.",
      examples: [
        {
          code: `import { Chunk, Effect, Stream } from "effect"

const stream = Stream.zipWithPrevious(Stream.make(1, 2, 3, 4))

Effect.runPromise(Stream.runCollect(stream)).then((chunk) => console.log(Chunk.toArray(chunk)))
// [
//   [ { _id: 'Option', _tag: 'None' }, 1 ],
//   [ { _id: 'Option', _tag: 'Some', value: 1 }, 2 ],
//   [ { _id: 'Option', _tag: 'Some', value: 2 }, 3 ],
//   [ { _id: 'Option', _tag: 'Some', value: 3 }, 4 ]
// ]`
        }
      ],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 10352,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L10352"
    },
    {
      id: "Stream.zipWithPreviousAndNext",
      name: "zipWithPreviousAndNext",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(self: Stream<A, E, R>) => Stream<[Option<A>, A, Option<A>], E, R>",
      description: "Zips each element with both the previous and next element.",
      documentation: "Zips each element with both the previous and next element.",
      examples: [
        {
          code: `import { Chunk, Effect, Stream } from "effect"

const stream = Stream.zipWithPreviousAndNext(Stream.make(1, 2, 3, 4))

Effect.runPromise(Stream.runCollect(stream)).then((chunk) => console.log(Chunk.toArray(chunk)))
// [
//   [
//     { _id: 'Option', _tag: 'None' },
//     1,
//     { _id: 'Option', _tag: 'Some', value: 2 }
//   ],
//   [
//     { _id: 'Option', _tag: 'Some', value: 1 },
//     2,
//     { _id: 'Option', _tag: 'Some', value: 3 }
//   ],
//   [
//     { _id: 'Option', _tag: 'Some', value: 2 },
//     3,
//     { _id: 'Option', _tag: 'Some', value: 4 }
//   ],
//   [
//     { _id: 'Option', _tag: 'Some', value: 3 },
//     4,
//     { _id: 'Option', _tag: 'None' }
//   ]
// ]`
        }
      ],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 10390,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L10390"
    },
    {
      id: "Stream.zipWithIndex",
      name: "zipWithIndex",
      module: "Stream",
      package: "effect",
      signature: "<A, E, R>(self: Stream<A, E, R>) => Stream<[A, number], E, R>",
      description: "Zips this stream together with the index of elements.",
      documentation: "Zips this stream together with the index of elements.",
      examples: [
        {
          code: `import { Effect, Stream } from "effect"

const stream = Stream.make("Mary", "James", "Robert", "Patricia")

const indexedStream = Stream.zipWithIndex(stream)

Effect.runPromise(Stream.runCollect(indexedStream)).then(console.log)
// {
//   _id: 'Chunk',
//   values: [ [ 'Mary', 0 ], [ 'James', 1 ], [ 'Robert', 2 ], [ 'Patricia', 3 ] ]
// }`
        }
      ],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 10412,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L10412"
    },
    {
      id: "Stream.Do",
      name: "Do",
      module: "Stream",
      package: "effect",
      signature: "Stream<{}, never, never>",
      description: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`. Here\'s how the do simulation works: 1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Stream` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values',
      documentation: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere\'s how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Stream` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values',
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Chunk, Effect, pipe, Stream } from "effect"\n\nconst result = pipe(\n  Stream.Do,\n  Stream.bind("x", () => Stream.succeed(2)),\n  Stream.bind("y", () => Stream.succeed(3)),\n  Stream.let("sum", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(Stream.runCollect(result)), Chunk.of({ x: 2, y: 3, sum: 5 }))'
        }
      ],
      tags: [
        "do notation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 10445,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L10445"
    },
    {
      id: "Stream.bind",
      name: "bind",
      module: "Stream",
      package: "effect",
      signature: '{ <N extends string, A, B, E2, R2>(tag: Exclude<N, keyof A>, f: (_: NoInfer<A>) => Stream<B, E2, R2>, options?: { readonly concurrency?: number | "unbounded"; readonly bufferSize?: number; }): <E, R>(self: Stream<A, E, R>) => Stream<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E2 | E, R2 | R>; <A, E, R, N extends string, B, E2, R2>(self: Stream<A, E, R>, tag: Exclude<N, keyof A>, f: (_: NoInfer<A>) => Stream<B, E2, R2>, options?: { readonly concurrency?: number | "unbounded"; readonly bufferSize?: number; }): Stream<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E | E2, R | R2>; }',
      description: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`. Here\'s how the do simulation works: 1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Stream` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values',
      documentation: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere\'s how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Stream` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values',
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Chunk, Effect, pipe, Stream } from "effect"\n\nconst result = pipe(\n  Stream.Do,\n  Stream.bind("x", () => Stream.succeed(2)),\n  Stream.bind("y", () => Stream.succeed(3)),\n  Stream.let("sum", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(Stream.runCollect(result)), Chunk.of({ x: 2, y: 3, sum: 5 }))'
        }
      ],
      tags: [
        "do notation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 10478,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L10478"
    },
    {
      id: "Stream.bindEffect",
      name: "bindEffect",
      module: "Stream",
      package: "effect",
      signature: '{ <N extends string, A, B, E2, R2>(tag: Exclude<N, keyof A>, f: (_: NoInfer<A>) => Effect<B, E2, R2>, options?: { readonly concurrency?: number | "unbounded"; readonly bufferSize?: number; }): <E, R>(self: Stream<A, E, R>) => Stream<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E2 | E, R2 | R>; <A, E, R, N extends string, B, E2, R2>(self: Stream<A, E, R>, tag: Exclude<N, keyof A>, f: (_: NoInfer<A>) => Effect<B, E2, R2>, options?: { readonly concurrency?: number | "unbounded"; readonly unordered?: boolean; }): Stream<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E | E2, R | R2>; }',
      description: "Binds an effectful value in a `do` scope",
      documentation: "Binds an effectful value in a `do` scope",
      examples: [],
      tags: [
        "do notation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 10567,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L10567"
    },
    {
      id: "Stream.bindTo",
      name: "bindTo",
      module: "Stream",
      package: "effect",
      signature: "{ <N extends string>(name: N): <A, E, R>(self: Stream<A, E, R>) => Stream<{ [K in N]: A; }, E, R>; <A, E, R, N extends string>(self: Stream<A, E, R>, name: N): Stream<{ [K in N]: A; }, E, R>; }",
      description: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`. Here\'s how the do simulation works: 1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Stream` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values',
      documentation: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere\'s how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Stream` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values',
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Chunk, Effect, pipe, Stream } from "effect"\n\nconst result = pipe(\n  Stream.Do,\n  Stream.bind("x", () => Stream.succeed(2)),\n  Stream.bind("y", () => Stream.succeed(3)),\n  Stream.let("sum", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(Effect.runSync(Stream.runCollect(result)), Chunk.of({ x: 2, y: 3, sum: 5 }))'
        }
      ],
      tags: [
        "do notation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 10635,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L10635"
    },
    {
      id: "Stream.decodeText",
      name: "decodeText",
      module: "Stream",
      package: "effect",
      signature: "{ (encoding?: string): <E, R>(self: Stream<Uint8Array, E, R>) => Stream<string, E, R>; <E, R>(self: Stream<Uint8Array, E, R>, encoding?: string): Stream<string, E, R>; }",
      description: "Decode Uint8Array chunks into a stream of strings using the specified encoding.",
      documentation: "Decode Uint8Array chunks into a stream of strings using the specified encoding.",
      examples: [],
      tags: [
        "encoding"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 10755,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L10755"
    },
    {
      id: "Stream.encodeText",
      name: "encodeText",
      module: "Stream",
      package: "effect",
      signature: "<E, R>(self: Stream<string, E, R>) => Stream<Uint8Array, E, R>",
      description: "Encode a stream of strings into a stream of Uint8Array chunks using the specified encoding.",
      documentation: "Encode a stream of strings into a stream of Uint8Array chunks using the specified encoding.",
      examples: [],
      tags: [
        "encoding"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 10777,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L10777"
    },
    {
      id: "Stream.fromEventListener",
      name: "fromEventListener",
      module: "Stream",
      package: "effect",
      signature: '<A = unknown>(target: EventListener<A>, type: string, options?: boolean | { readonly capture?: boolean; readonly passive?: boolean; readonly once?: boolean; readonly bufferSize?: number | "unbounded"; }) => Stream<A, never, never>',
      description: "Creates a `Stream` using addEventListener.",
      documentation: "Creates a `Stream` using addEventListener.",
      examples: [],
      tags: [],
      since: "3.1.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
      sourceLine: 10797,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L10797"
    },
    {
      id: "Option.TypeId",
      name: "TypeId",
      module: "Option",
      package: "effect",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 38,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L38"
    },
    {
      id: "Option.none",
      name: "none",
      module: "Option",
      package: "effect",
      signature: "<A = never>() => Option<A>",
      description: "Represents the absence of a value by creating an empty `Option`. `Option.none` returns an `Option<never>`, which is a subtype of `Option<A>`.\nThis means you can use it in place of any `Option<A>` regardless of the type\n`A`.",
      documentation: "Represents the absence of a value by creating an empty `Option`.\n\n`Option.none` returns an `Option<never>`, which is a subtype of `Option<A>`.\nThis means you can use it in place of any `Option<A>` regardless of the type\n`A`.\n\n**Example** (Creating an Option with No Value)\n\n```ts\nimport { Option } from \"effect\"\n\n// An Option holding no value\n//\n//      \u250C\u2500\u2500\u2500 Option<never>\n//      \u25BC\nconst noValue = Option.none()\n\nconsole.log(noValue)\n// Output: { _id: 'Option', _tag: 'None' }\n```",
      examples: [
        {
          title: "Creating an Option with No Value",
          code: `import { Option } from "effect"

// An Option holding no value
//
//      \u250C\u2500\u2500\u2500 Option<never>
//      \u25BC
const noValue = Option.none()

console.log(noValue)
// Output: { _id: 'Option', _tag: 'None' }`
        }
      ],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 149,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L149"
    },
    {
      id: "Option.some",
      name: "some",
      module: "Option",
      package: "effect",
      signature: "<A>(value: A) => Option<A>",
      description: "Wraps the given value into an `Option` to represent its presence.",
      documentation: "Wraps the given value into an `Option` to represent its presence.\n\n**Example** (Creating an Option with a Value)\n\n```ts\nimport { Option } from \"effect\"\n\n// An Option holding the number 1\n//\n//      \u250C\u2500\u2500\u2500 Option<number>\n//      \u25BC\nconst value = Option.some(1)\n\nconsole.log(value)\n// Output: { _id: 'Option', _tag: 'Some', value: 1 }\n```",
      examples: [
        {
          title: "Creating an Option with a Value",
          code: `import { Option } from "effect"

// An Option holding the number 1
//
//      \u250C\u2500\u2500\u2500 Option<number>
//      \u25BC
const value = Option.some(1)

console.log(value)
// Output: { _id: 'Option', _tag: 'Some', value: 1 }`
        }
      ],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 173,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L173"
    },
    {
      id: "Option.isOption",
      name: "isOption",
      module: "Option",
      package: "effect",
      signature: "(input: unknown) => input is Option<unknown>",
      description: "Determines whether the given value is an `Option`.",
      documentation: "Determines whether the given value is an `Option`.\n\n**Details**\n\nThis function checks if a value is an instance of `Option`. It returns `true`\nif the value is either `Option.some` or `Option.none`, and `false` otherwise.\nThis is particularly useful when working with unknown values or when you need\nto ensure type safety in your code.",
      examples: [
        {
          code: 'import { Option } from "effect"\n\nconsole.log(Option.isOption(Option.some(1)))\n// Output: true\n\nconsole.log(Option.isOption(Option.none()))\n// Output: true\n\nconsole.log(Option.isOption({}))\n// Output: false'
        }
      ],
      tags: [
        "Guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 201,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L201"
    },
    {
      id: "Option.isNone",
      name: "isNone",
      module: "Option",
      package: "effect",
      signature: "<A>(self: Option<A>) => self is None<A>",
      description: "Checks whether an `Option` represents the absence of a value (`None`).",
      documentation: "Checks whether an `Option` represents the absence of a value (`None`).",
      examples: [
        {
          code: 'import { Option } from "effect"\n\nconsole.log(Option.isNone(Option.some(1)))\n// Output: false\n\nconsole.log(Option.isNone(Option.none()))\n// Output: true'
        }
      ],
      tags: [
        "Guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 221,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L221"
    },
    {
      id: "Option.isSome",
      name: "isSome",
      module: "Option",
      package: "effect",
      signature: "<A>(self: Option<A>) => self is Some<A>",
      description: "Checks whether an `Option` contains a value (`Some`).",
      documentation: "Checks whether an `Option` contains a value (`Some`).",
      examples: [
        {
          code: 'import { Option } from "effect"\n\nconsole.log(Option.isSome(Option.some(1)))\n// Output: true\n\nconsole.log(Option.isSome(Option.none()))\n// Output: false'
        }
      ],
      tags: [
        "Guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 241,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L241"
    },
    {
      id: "Option.match",
      name: "match",
      module: "Option",
      package: "effect",
      signature: "{ <B, A, C = B>(options: { readonly onNone: LazyArg<B>; readonly onSome: (a: A) => C; }): (self: Option<A>) => B | C; <A, B, C = B>(self: Option<A>, options: { readonly onNone: LazyArg<B>; readonly onSome: (a: A) => C; }): B | C; }",
      description: "Performs pattern matching on an `Option` to handle both `Some` and `None`\ncases.",
      documentation: 'Performs pattern matching on an `Option` to handle both `Some` and `None`\ncases.\n\n**Details**\n\nThis function allows you to match against an `Option` and handle both\nscenarios: when the `Option` is `None` (i.e., contains no value), and when\nthe `Option` is `Some` (i.e., contains a value). It executes one of the\nprovided functions based on the case:\n\n- If the `Option` is `None`, the `onNone` function is executed and its result\n  is returned.\n- If the `Option` is `Some`, the `onSome` function is executed with the\n  contained value, and its result is returned.\n\nThis function provides a concise and functional way to handle optional values\nwithout resorting to `if` or manual checks, making your code more declarative\nand readable.\n\n**Example** (Pattern Matching with Option)\n\n```ts\nimport { Option } from "effect"\n\nconst foo = Option.some(1)\n\nconst message = Option.match(foo, {\n  onNone: () => "Option is empty",\n  onSome: (value) => `Option has a value: ${value}`\n})\n\nconsole.log(message)\n// Output: "Option has a value: 1"\n```',
      examples: [
        {
          title: "Pattern Matching with Option",
          code: 'import { Option } from "effect"\n\nconst foo = Option.some(1)\n\nconst message = Option.match(foo, {\n  onNone: () => "Option is empty",\n  onSome: (value) => `Option has a value: ${value}`\n})\n\nconsole.log(message)\n// Output: "Option has a value: 1"'
        }
      ],
      tags: [
        "Pattern matching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 281,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L281"
    },
    {
      id: "Option.toRefinement",
      name: "toRefinement",
      module: "Option",
      package: "effect",
      signature: "<A, B extends A>(f: (a: A) => Option<B>) => (a: A) => a is B",
      description: "Converts an `Option`-returning function into a type guard.",
      documentation: "Converts an `Option`-returning function into a type guard.\n\n**Details**\n\nThis function transforms a function that returns an `Option` into a type\nguard, ensuring type safety when validating or narrowing types. The returned\ntype guard function checks whether the input satisfies the condition defined\nin the original `Option`-returning function.\n\nIf the original function returns `Option.some`, the type guard evaluates to\n`true`, confirming the input is of the desired type. If the function returns\n`Option.none`, the type guard evaluates to `false`.\n\nThis utility is especially useful for validating types in union types,\nfiltering arrays, or ensuring safe handling of specific subtypes.",
      examples: [
        {
          code: 'import { Option } from "effect"\n\ntype MyData = string | number\n\nconst parseString = (data: MyData): Option.Option<string> =>\n  typeof data === "string" ? Option.some(data) : Option.none()\n\n//      \u250C\u2500\u2500\u2500 (a: MyData) => a is string\n//      \u25BC\nconst isString = Option.toRefinement(parseString)\n\nconsole.log(isString("a"))\n// Output: true\n\nconsole.log(isString(1))\n// Output: false'
        }
      ],
      tags: [
        "Conversions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 409,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L409"
    },
    {
      id: "Option.fromIterable",
      name: "fromIterable",
      module: "Option",
      package: "effect",
      signature: "<A>(collection: Iterable<A>) => Option<A>",
      description: "Converts an `Iterable` into an `Option`, wrapping the first element if it\nexists.",
      documentation: "Converts an `Iterable` into an `Option`, wrapping the first element if it\nexists.\n\n**Details**\n\nThis function takes an `Iterable` (e.g., an array, a generator, or any object\nimplementing the `Iterable` interface) and returns an `Option` based on its\ncontent:\n\n- If the `Iterable` contains at least one element, the first element is\n  wrapped in a `Some` and returned.\n- If the `Iterable` is empty, `None` is returned, representing the absence of\n  a value.\n\nThis utility is useful for safely handling collections that might be empty,\nensuring you explicitly handle both cases where a value exists or doesn't.",
      examples: [
        {
          code: `import { Option } from "effect"

console.log(Option.fromIterable([1, 2, 3]))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(Option.fromIterable([]))
// Output: { _id: 'Option', _tag: 'None' }`
        }
      ],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 442,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L442"
    },
    {
      id: "Option.getRight",
      name: "getRight",
      module: "Option",
      package: "effect",
      signature: "<R, L>(self: Either<R, L>) => Option<R>",
      description: "Converts an `Either` into an `Option` by discarding the error and extracting\nthe right value.",
      documentation: "Converts an `Either` into an `Option` by discarding the error and extracting\nthe right value.\n\n**Details**\n\nThis function takes an `Either` and returns an `Option` based on its value:\n\n- If the `Either` is a `Right`, its value is wrapped in a `Some` and\n  returned.\n- If the `Either` is a `Left`, the error is discarded, and `None` is\n  returned.\n\nThis is particularly useful when you only care about the success case\n(`Right`) of an `Either` and want to handle the result using `Option`. By\nusing this function, you can convert `Either` into a simpler structure for\ncases where error handling is not required.",
      examples: [
        {
          code: `import { Either, Option } from "effect"

console.log(Option.getRight(Either.right("ok")))
// Output: { _id: 'Option', _tag: 'Some', value: 'ok' }

console.log(Option.getRight(Either.left("err")))
// Output: { _id: 'Option', _tag: 'None' }`
        }
      ],
      tags: [
        "Conversions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 477,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L477"
    },
    {
      id: "Option.getLeft",
      name: "getLeft",
      module: "Option",
      package: "effect",
      signature: "<R, L>(self: Either<R, L>) => Option<L>",
      description: "Converts an `Either` into an `Option` by discarding the right value and\nextracting the left value.",
      documentation: "Converts an `Either` into an `Option` by discarding the right value and\nextracting the left value.\n\n**Details**\n\nThis function transforms an `Either` into an `Option` as follows:\n\n- If the `Either` is a `Left`, its value is wrapped in a `Some` and returned.\n- If the `Either` is a `Right`, the value is discarded, and `None` is\n  returned.\n\nThis utility is useful when you only care about the error case (`Left`) of an\n`Either` and want to handle it as an `Option`. By discarding the right value,\nit simplifies error-focused workflows.",
      examples: [
        {
          code: `import { Either, Option } from "effect"

console.log(Option.getLeft(Either.right("ok")))
// Output: { _id: 'Option', _tag: 'None' }

console.log(Option.getLeft(Either.left("err")))
// Output: { _id: 'Option', _tag: 'Some', value: 'err' }`
        }
      ],
      tags: [
        "Conversions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 510,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L510"
    },
    {
      id: "Option.getOrElse",
      name: "getOrElse",
      module: "Option",
      package: "effect",
      signature: "{ <B>(onNone: LazyArg<B>): <A>(self: Option<A>) => B | A; <A, B>(self: Option<A>, onNone: LazyArg<B>): A | B; }",
      description: "Returns the value contained in the `Option` if it is `Some`, otherwise\nevaluates and returns the result of `onNone`.",
      documentation: "Returns the value contained in the `Option` if it is `Some`, otherwise\nevaluates and returns the result of `onNone`.\n\n**Details**\n\nThis function allows you to provide a fallback value or computation for when\nan `Option` is `None`. If the `Option` contains a value (`Some`), that value\nis returned. If it is empty (`None`), the `onNone` function is executed, and\nits result is returned instead.\n\nThis utility is helpful for safely handling `Option` values by ensuring you\nalways receive a meaningful result, whether or not the `Option` contains a\nvalue. It is particularly useful for providing default values or alternative\nlogic when working with optional values.",
      examples: [
        {
          code: 'import { Option } from "effect"\n\nconsole.log(Option.some(1).pipe(Option.getOrElse(() => 0)))\n// Output: 1\n\nconsole.log(Option.none().pipe(Option.getOrElse(() => 0)))\n// Output: 0'
        }
      ],
      tags: [
        "Getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 544,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L544"
    },
    {
      id: "Option.orElse",
      name: "orElse",
      module: "Option",
      package: "effect",
      signature: "{ <B>(that: LazyArg<Option<B>>): <A>(self: Option<A>) => Option<B | A>; <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<A | B>; }",
      description: "Returns the provided `Option` `that` if the current `Option` (`self`) is\n`None`; otherwise, it returns `self`.",
      documentation: "Returns the provided `Option` `that` if the current `Option` (`self`) is\n`None`; otherwise, it returns `self`.\n\n**Details**\n\nThis function provides a fallback mechanism for `Option` values. If the\ncurrent `Option` is `None` (i.e., it contains no value), the `that` function\nis evaluated, and its resulting `Option` is returned. If the current `Option`\nis `Some` (i.e., it contains a value), the original `Option` is returned\nunchanged.\n\nThis is particularly useful for chaining fallback values or computations,\nallowing you to provide alternative `Option` values when the first one is\nempty.",
      examples: [
        {
          code: `import { Option } from "effect"

console.log(Option.none().pipe(Option.orElse(() => Option.none())))
// Output: { _id: 'Option', _tag: 'None' }

console.log(Option.some("a").pipe(Option.orElse(() => Option.none())))
// Output: { _id: 'Option', _tag: 'Some', value: 'a' }

console.log(Option.none().pipe(Option.orElse(() => Option.some("b"))))
// Output: { _id: 'Option', _tag: 'Some', value: 'b' }

console.log(Option.some("a").pipe(Option.orElse(() => Option.some("b"))))
// Output: { _id: 'Option', _tag: 'Some', value: 'a' }`
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 650,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L650"
    },
    {
      id: "Option.orElseSome",
      name: "orElseSome",
      module: "Option",
      package: "effect",
      signature: "{ <B>(onNone: LazyArg<B>): <A>(self: Option<A>) => Option<B | A>; <A, B>(self: Option<A>, onNone: LazyArg<B>): Option<A | B>; }",
      description: "Returns the provided default value wrapped in `Some` if the current `Option`\n(`self`) is `None`; otherwise, returns `self`.",
      documentation: "Returns the provided default value wrapped in `Some` if the current `Option`\n(`self`) is `None`; otherwise, returns `self`.\n\n**Details**\n\nThis function provides a way to supply a default value for cases where an\n`Option` is `None`. If the current `Option` is empty (`None`), the `onNone`\nfunction is executed to compute the default value, which is then wrapped in a\n`Some`. If the current `Option` contains a value (`Some`), it is returned as\nis.\n\nThis is particularly useful for handling optional values where a fallback\ndefault needs to be provided explicitly in case of absence.",
      examples: [
        {
          code: `import { Option } from "effect"

console.log(Option.none().pipe(Option.orElseSome(() => "b")))
// Output: { _id: 'Option', _tag: 'Some', value: 'b' }

console.log(Option.some("a").pipe(Option.orElseSome(() => "b")))
// Output: { _id: 'Option', _tag: 'Some', value: 'a' }`
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 755,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L755"
    },
    {
      id: "Option.orElseEither",
      name: "orElseEither",
      module: "Option",
      package: "effect",
      signature: "{ <B>(that: LazyArg<Option<B>>): <A>(self: Option<A>) => Option<Either<B, A>>; <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<Either<B, A>>; }",
      description: "/\n * Similar to {@link orElse}, but returns an `Either` wrapped in an `Option` to\n * indicate the source of the value.\n *\n *",
      documentation: "/**\n * Similar to {@link orElse}, but returns an `Either` wrapped in an `Option` to\n * indicate the source of the value.\n *\n * **Details**\n *\n * This function allows you to provide a fallback `Option` in case the current\n * `Option` (`self`) is `None`. However, unlike `orElse`, it returns the value\n * wrapped in an `Either` object, providing additional information about where\n * the value came from:\n *\n * - If the value is from the fallback `Option` (`that`), it is wrapped in an\n *   `Either.right`.\n * - If the value is from the original `Option` (`self`), it is wrapped in an\n *   `Either.left`.\n *\n * This is especially useful when you need to differentiate between values\n * originating from the primary `Option` and those coming from the fallback,\n * while still maintaining the `Option`-style handling.\n *\n *",
      examples: [],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 840,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L840"
    },
    {
      id: "Option.firstSomeOf",
      name: "firstSomeOf",
      module: "Option",
      package: "effect",
      signature: "<T, C extends Iterable<Option<T>> = Iterable<Option<T>>>(collection: C) => [C] extends [Iterable<Option<infer A>>] ? Option<A> : never",
      description: "Returns the first `Some` value found in an `Iterable` collection of\n`Option`s, or `None` if no `Some` is found.",
      documentation: "Returns the first `Some` value found in an `Iterable` collection of\n`Option`s, or `None` if no `Some` is found.\n\n**Details**\n\nThis function iterates over a collection of `Option` values and returns the\nfirst `Some` it encounters. If the collection contains only `None` values,\nthe result will also be `None`. This utility is useful for efficiently\nfinding the first valid value in a sequence of potentially empty or invalid\noptions.\n\nThe iteration stops as soon as a `Some` is found, making this function\nefficient for large collections.",
      examples: [
        {
          code: `import { Option } from "effect"

console.log(Option.firstSomeOf([
  Option.none(),
  Option.some(1),
  Option.some(2)
]))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }`
        }
      ],
      tags: [
        "Error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 920,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L920"
    },
    {
      id: "Option.fromNullable",
      name: "fromNullable",
      module: "Option",
      package: "effect",
      signature: "<A>(nullableValue: A) => Option<NonNullable<A>>",
      description: "Converts a nullable value into an `Option`. Returns `None` if the value is\n`null` or `undefined`, otherwise wraps the value in a `Some`.",
      documentation: "Converts a nullable value into an `Option`. Returns `None` if the value is\n`null` or `undefined`, otherwise wraps the value in a `Some`.",
      examples: [
        {
          code: `import { Option } from "effect"

console.log(Option.fromNullable(undefined))
// Output: { _id: 'Option', _tag: 'None' }

console.log(Option.fromNullable(null))
// Output: { _id: 'Option', _tag: 'None' }

console.log(Option.fromNullable(1))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }`
        }
      ],
      tags: [
        "Conversions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 942,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L942"
    },
    {
      id: "Option.liftNullable",
      name: "liftNullable",
      module: "Option",
      package: "effect",
      signature: "<A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B) => (...a: A) => Option<NonNullable<B>>",
      description: "Lifts a function that returns `null` or `undefined` into the `Option`\ncontext.",
      documentation: "Lifts a function that returns `null` or `undefined` into the `Option`\ncontext.\n\n**Details**\n\nThis function takes a function `f` that might return `null` or `undefined`\nand transforms it into a function that returns an `Option`. The resulting\nfunction will return:\n- `Some` if the original function produces a non-null, non-undefined value.\n- `None` if the original function produces `null` or `undefined`.",
      examples: [
        {
          code: `import { Option } from "effect"

const parse = (s: string): number | undefined => {
  const n = parseFloat(s)
  return isNaN(n) ? undefined : n
}

const parseOption = Option.liftNullable(parse)

console.log(parseOption("1"))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(parseOption("not a number"))
// Output: { _id: 'Option', _tag: 'None' }`
        }
      ],
      tags: [
        "Conversions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 976,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L976"
    },
    {
      id: "Option.getOrNull",
      name: "getOrNull",
      module: "Option",
      package: "effect",
      signature: "<A>(self: Option<A>) => A",
      description: "Returns the value contained in the `Option` if it is `Some`; otherwise,\nreturns `null`.",
      documentation: "Returns the value contained in the `Option` if it is `Some`; otherwise,\nreturns `null`.\n\n**Details**\n\nThis function provides a way to extract the value of an `Option` while\nfalling back to `null` if the `Option` is `None`.\n\nIt is particularly useful in scenarios where `null` is an acceptable\nplaceholder for the absence of a value, such as when interacting with APIs or\nsystems that use `null` as a default for missing values.",
      examples: [
        {
          code: 'import { Option } from "effect"\n\nconsole.log(Option.getOrNull(Option.some(1)))\n// Output: 1\n\nconsole.log(Option.getOrNull(Option.none()))\n// Output: null'
        }
      ],
      tags: [
        "Getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 1004,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L1004"
    },
    {
      id: "Option.getOrUndefined",
      name: "getOrUndefined",
      module: "Option",
      package: "effect",
      signature: "<A>(self: Option<A>) => A",
      description: "Returns the value contained in the `Option` if it is `Some`; otherwise,\nreturns `undefined`.",
      documentation: "Returns the value contained in the `Option` if it is `Some`; otherwise,\nreturns `undefined`.\n\n**Details**\n\nThis function provides a way to extract the value of an `Option` while\nfalling back to `undefined` if the `Option` is `None`.\n\nIt is particularly useful in scenarios where `undefined` is an acceptable\nplaceholder for the absence of a value, such as when interacting with APIs or\nsystems that use `undefined` as a default for missing values.",
      examples: [
        {
          code: 'import { Option } from "effect"\n\nconsole.log(Option.getOrUndefined(Option.some(1)))\n// Output: 1\n\nconsole.log(Option.getOrUndefined(Option.none()))\n// Output: undefined'
        }
      ],
      tags: [
        "Getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 1032,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L1032"
    },
    {
      id: "Option.liftThrowable",
      name: "liftThrowable",
      module: "Option",
      package: "effect",
      signature: "<A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B) => (...a: A) => Option<B>",
      description: "Lifts a function that throws exceptions into a function that returns an\n`Option`.",
      documentation: "Lifts a function that throws exceptions into a function that returns an\n`Option`.\n\n**Details**\n\nThis utility function takes a function `f` that might throw an exception and\ntransforms it into a safer function that returns an `Option`. If the original\nfunction executes successfully, the result is wrapped in a `Some`. If an\nexception is thrown, the result is `None`, allowing the developer to handle\nerrors in a functional, type-safe way.",
      examples: [
        {
          code: `import { Option } from "effect"

const parse = Option.liftThrowable(JSON.parse)

console.log(parse("1"))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(parse(""))
// Output: { _id: 'Option', _tag: 'None' }`
        }
      ],
      tags: [
        "Conversions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 1061,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L1061"
    },
    {
      id: "Option.getOrThrowWith",
      name: "getOrThrowWith",
      module: "Option",
      package: "effect",
      signature: "{ (onNone: () => unknown): <A>(self: Option<A>) => A; <A>(self: Option<A>, onNone: () => unknown): A; }",
      description: "Extracts the value of an `Option` or throws an error if the `Option` is\n`None`, using a custom error factory.",
      documentation: "Extracts the value of an `Option` or throws an error if the `Option` is\n`None`, using a custom error factory.\n\n**Details**\n\nThis function allows you to extract the value of an `Option` when it is\n`Some`. If the `Option` is `None`, it throws an error generated by the\nprovided `onNone` function. This utility is particularly useful when you need\na fail-fast behavior for empty `Option` values and want to provide a custom\nerror message or object.",
      examples: [
        {
          code: `import * as assert from "node:assert"
import { Option } from "effect"

assert.deepStrictEqual(
  Option.getOrThrowWith(Option.some(1), () => new Error('Unexpected None')),
  1
)
assert.throws(() => Option.getOrThrowWith(Option.none(), () => new Error('Unexpected None')))`
        }
      ],
      tags: [
        "Conversions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 1091,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L1091"
    },
    {
      id: "Option.getOrThrow",
      name: "getOrThrow",
      module: "Option",
      package: "effect",
      signature: "<A>(self: Option<A>) => A",
      description: "Extracts the value of an `Option` or throws a default error if the `Option`\nis `None`.",
      documentation: "Extracts the value of an `Option` or throws a default error if the `Option`\nis `None`.\n\n**Details**\n\nThis function extracts the value from an `Option` if it is `Some`. If the\n`Option` is `None`, it throws a default error. It is useful for fail-fast\nscenarios where the absence of a value is treated as an exceptional case and\na default error is sufficient.",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Option } from "effect"\n\nassert.deepStrictEqual(Option.getOrThrow(Option.some(1)), 1)\nassert.throws(() => Option.getOrThrow(Option.none()))'
        }
      ],
      tags: [
        "Conversions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 1178,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L1178"
    },
    {
      id: "Option.map",
      name: "map",
      module: "Option",
      package: "effect",
      signature: "{ <A, B>(f: (a: A) => B): (self: Option<A>) => Option<B>; <A, B>(self: Option<A>, f: (a: A) => B): Option<B>; }",
      description: "Transforms the value inside a `Some` to a new value using the provided\nfunction, while leaving `None` unchanged.",
      documentation: "Transforms the value inside a `Some` to a new value using the provided\nfunction, while leaving `None` unchanged.\n\n**Details**\n\nThis function applies a mapping function `f` to the value inside an `Option`\nif it is a `Some`. If the `Option` is `None`, it remains unchanged. The\nresult is a new `Option` with the transformed value (if it was a `Some`) or\nstill `None`.\n\nThis utility is particularly useful for chaining transformations in a\nfunctional way without needing to manually handle `None` cases.",
      examples: [
        {
          code: "import { Option } from \"effect\"\n\n// Mapping over a `Some`\nconst someValue = Option.some(2)\n\nconsole.log(Option.map(someValue, (n) => n * 2))\n// Output: { _id: 'Option', _tag: 'Some', value: 4 }\n\n// Mapping over a `None`\nconst noneValue = Option.none<number>()\n\nconsole.log(Option.map(noneValue, (n) => n * 2))\n// Output: { _id: 'Option', _tag: 'None' }"
        }
      ],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 1213,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L1213"
    },
    {
      id: "Option.as",
      name: "as",
      module: "Option",
      package: "effect",
      signature: "{ <B>(b: B): <X>(self: Option<X>) => Option<B>; <X, B>(self: Option<X>, b: B): Option<B>; }",
      description: "Replaces the value inside a `Some` with the specified constant value, leaving\n`None` unchanged.",
      documentation: "Replaces the value inside a `Some` with the specified constant value, leaving\n`None` unchanged.\n\n**Details**\n\nThis function transforms an `Option` by replacing the value inside a `Some`\nwith the given constant value `b`. If the `Option` is `None`, it remains\nunchanged.\n\nThis is useful when you want to preserve the presence of a value (`Some`) but\nreplace its content with a fixed value.",
      examples: [
        {
          code: `import { Option } from "effect"

// Replacing the value of a \`Some\`
const someValue = Option.some(42)

console.log(Option.as(someValue, "new value"))
// Output: { _id: 'Option', _tag: 'Some', value: 'new value' }

// Replacing a \`None\` (no effect)
const noneValue = Option.none<number>()

console.log(Option.as(noneValue, "new value"))
// Output: { _id: 'Option', _tag: 'None' }`
        }
      ],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 1318,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L1318"
    },
    {
      id: "Option.asVoid",
      name: "asVoid",
      module: "Option",
      package: "effect",
      signature: "<_>(self: Option<_>) => Option<void>",
      description: "Replaces the value inside a `Some` with the constant value `void`, leaving\n`None` unchanged.",
      documentation: "Replaces the value inside a `Some` with the constant value `void`, leaving\n`None` unchanged.\n\n**Details**\n\nThis function transforms an `Option` by replacing the value inside a `Some`\nwith `void`. If the `Option` is `None`, it remains unchanged.\n\nThis is particularly useful in scenarios where the presence or absence of a\nvalue is significant, but the actual content of the value is irrelevant.",
      examples: [],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 1403,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L1403"
    },
    {
      id: "Option.flatMap",
      name: "flatMap",
      module: "Option",
      package: "effect",
      signature: "{ <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>; <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>; }",
      description: "Applies a function to the value of a `Some` and flattens the resulting\n`Option`. If the input is `None`, it remains `None`.",
      documentation: "Applies a function to the value of a `Some` and flattens the resulting\n`Option`. If the input is `None`, it remains `None`.\n\n**Details**\n\nThis function allows you to chain computations that return `Option` values.\nIf the input `Option` is `Some`, the provided function `f` is applied to the\ncontained value, and the resulting `Option` is returned. If the input is\n`None`, the function is not applied, and the result remains `None`.\n\nThis utility is particularly useful for sequencing operations that may fail\nor produce optional results, enabling clean and concise workflows for\nhandling such cases.",
      examples: [
        {
          code: `import { Option } from "effect"

interface Address {
  readonly city: string
  readonly street: Option.Option<string>
}

interface User {
  readonly id: number
  readonly username: string
  readonly email: Option.Option<string>
  readonly address: Option.Option<Address>
}

const user: User = {
  id: 1,
  username: "john_doe",
  email: Option.some("john.doe@example.com"),
  address: Option.some({
    city: "New York",
    street: Option.some("123 Main St")
  })
}

// Use flatMap to extract the street value
const street = user.address.pipe(
  Option.flatMap((address) => address.street)
)

console.log(street)
// Output: { _id: 'Option', _tag: 'Some', value: '123 Main St' }`
        }
      ],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 1463,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L1463"
    },
    {
      id: "Option.andThen",
      name: "andThen",
      module: "Option",
      package: "effect",
      signature: "{ <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>; <B>(f: Option<B>): <A>(self: Option<A>) => Option<B>; <A, B>(f: (a: A) => B): (self: Option<A>) => Option<B>; <B>(f: NotFunction<B>): <A>(self: Option<A>) => Option<B>; <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>; <A, B>(self: Option<A>, f: Option<B>): Option<B>; <A, B>(self: Option<A>, f: (a: A) => B): Option<B>; <A, B>(self: Option<A>, f: NotFunction<B>): Option<B>; }",
      description: "Chains two `Option`s together. The second `Option` can either be a static\nvalue or depend on the result of the first `Option`.",
      documentation: "Chains two `Option`s together. The second `Option` can either be a static\nvalue or depend on the result of the first `Option`.\n\n**Details**\n\nThis function enables sequencing of two `Option` computations. If the first\n`Option` is `Some`, the second `Option` is evaluated. The second `Option` can\neither:\n\n- Be a static `Option` value.\n- Be a function that produces an `Option`, optionally based on the value of\n  the first `Option`.\n\nIf the first `Option` is `None`, the function skips the evaluation of the\nsecond `Option` and directly returns `None`.",
      examples: [],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 1593,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L1593"
    },
    {
      id: "Option.flatMapNullable",
      name: "flatMapNullable",
      module: "Option",
      package: "effect",
      signature: "{ <A, B>(f: (a: A) => B): (self: Option<A>) => Option<NonNullable<B>>; <A, B>(self: Option<A>, f: (a: A) => B): Option<NonNullable<B>>; }",
      description: "Combines `flatMap` and `fromNullable`, transforming the value inside a `Some`\nusing a function that may return `null` or `undefined`.",
      documentation: "Combines `flatMap` and `fromNullable`, transforming the value inside a `Some`\nusing a function that may return `null` or `undefined`.\n\n**Details**\n\nThis function applies a transformation function `f` to the value inside a\n`Some`. The function `f` may return a value, `null`, or `undefined`. If `f`\nreturns a value, it is wrapped in a `Some`. If `f` returns `null` or\n`undefined`, the result is `None`. If the input `Option` is `None`, the\nfunction is not applied, and `None` is returned.\n\nThis utility is particularly useful when working with deeply nested optional\nvalues or chaining computations that may result in `null` or `undefined` at\nsome point.",
      examples: [
        {
          code: `import { Option } from "effect"

interface Employee {
  company?: {
    address?: {
      street?: {
        name?: string
      }
    }
  }
}

const employee1: Employee = { company: { address: { street: { name: "high street" } } } }

// Extracting a deeply nested property
console.log(
  Option.some(employee1)
    .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))
)
// Output: { _id: 'Option', _tag: 'Some', value: 'high street' }

const employee2: Employee = { company: { address: { street: {} } } }

// Property does not exist
console.log(
  Option.some(employee2)
    .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))
)
// Output: { _id: 'Option', _tag: 'None' }`
        }
      ],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 1815,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L1815"
    },
    {
      id: "Option.flatten",
      name: "flatten",
      module: "Option",
      package: "effect",
      signature: "<A>(self: Option<Option<A>>) => Option<A>",
      description: "Flattens an `Option` of `Option` into a single `Option`.",
      documentation: "Flattens an `Option` of `Option` into a single `Option`.\n\n**Details**\n\nThis function takes an `Option` that wraps another `Option` and flattens it\ninto a single `Option`. If the outer `Option` is `Some`, the function\nextracts the inner `Option`. If the outer `Option` is `None`, the result\nremains `None`.\n\nThis is useful for simplifying nested `Option` structures that may arise\nduring functional operations.",
      examples: [],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 1939,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L1939"
    },
    {
      id: "Option.zipRight",
      name: "zipRight",
      module: "Option",
      package: "effect",
      signature: "{ <B>(that: Option<B>): <_>(self: Option<_>) => Option<B>; <X, B>(self: Option<X>, that: Option<B>): Option<B>; }",
      description: "Combines two `Option`s, keeping the value from the second `Option` if both\nare `Some`.",
      documentation: 'Combines two `Option`s, keeping the value from the second `Option` if both\nare `Some`.\n\n**Details**\n\nThis function takes two `Option`s and returns the second one if the first is\n`Some`. If the first `Option` is `None`, the result will also be `None`,\nregardless of the second `Option`. It effectively "zips" the two `Option`s\nwhile discarding the value from the first `Option`.\n\nThis is particularly useful when sequencing computations where the result of\nthe first computation is not needed, and you only care about the result of\nthe second computation.',
      examples: [],
      tags: [
        "Zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 1958,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L1958"
    },
    {
      id: "Option.zipLeft",
      name: "zipLeft",
      module: "Option",
      package: "effect",
      signature: "{ <_>(that: Option<_>): <A>(self: Option<A>) => Option<A>; <A, X>(self: Option<A>, that: Option<X>): Option<A>; }",
      description: "Combines two `Option`s, keeping the value from the first `Option` if both are\n`Some`.",
      documentation: 'Combines two `Option`s, keeping the value from the first `Option` if both are\n`Some`.\n\n**Details**\n\nThis function takes two `Option`s and returns the first one if it is `Some`.\nIf either the first `Option` or the second `Option` is `None`, the result\nwill be `None`. This operation "zips" the two `Option`s while discarding the\nvalue from the second `Option`.\n\nThis is useful when sequencing computations where the second `Option`\nrepresents a dependency or condition that must hold, but its value is\nirrelevant.',
      examples: [],
      tags: [
        "Zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 2016,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L2016"
    },
    {
      id: "Option.composeK",
      name: "composeK",
      module: "Option",
      package: "effect",
      signature: "{ <B, C>(bfc: (b: B) => Option<C>): <A>(afb: (a: A) => Option<B>) => (a: A) => Option<C>; <A, B, C>(afb: (a: A) => Option<B>, bfc: (b: B) => Option<C>): (a: A) => Option<C>; }",
      description: "Composes two functions that return `Option` values, creating a new function\nthat chains them together.",
      documentation: "Composes two functions that return `Option` values, creating a new function\nthat chains them together.\n\n**Details**\n\nThis function allows you to compose two computations, each represented by a\nfunction that returns an `Option`. The result of the first function is passed\nto the second function if it is `Some`. If the first function returns `None`,\nthe composed function short-circuits and returns `None` without invoking the\nsecond function.",
      examples: [
        {
          code: `import { Option } from "effect"

const parse = (s: string): Option.Option<number> => isNaN(Number(s)) ? Option.none() : Option.some(Number(s))

const double = (n: number): Option.Option<number> => n > 0 ? Option.some(n * 2) : Option.none()

const parseAndDouble = Option.composeK(parse, double)

console.log(parseAndDouble("42"))
// Output: { _id: 'Option', _tag: 'Some', value: 84 }

console.log(parseAndDouble("not a number"))
// Output: { _id: 'Option', _tag: 'None' }`
        }
      ],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 2088,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L2088"
    },
    {
      id: "Option.tap",
      name: "tap",
      module: "Option",
      package: "effect",
      signature: "{ <A, X>(f: (a: A) => Option<X>): (self: Option<A>) => Option<A>; <A, X>(self: Option<A>, f: (a: A) => Option<X>): Option<A>; }",
      description: "Applies the provided function `f` to the value of the `Option` if it is\n`Some` and returns the original `Option`, unless `f` returns `None`, in which\ncase it returns `None`.",
      documentation: "Applies the provided function `f` to the value of the `Option` if it is\n`Some` and returns the original `Option`, unless `f` returns `None`, in which\ncase it returns `None`.\n\n**Details**\n\nThis function allows you to perform additional computations on the value of\nan `Option` without modifying its original value. If the `Option` is `Some`,\nthe provided function `f` is executed with the value, and its result\ndetermines whether the original `Option` is returned (`Some`) or the result\nis `None` if `f` returns `None`. If the input `Option` is `None`, the\nfunction is not executed, and `None` is returned.\n\nThis is particularly useful for applying side conditions or performing\nvalidation checks while retaining the original `Option`'s value.",
      examples: [
        {
          code: `import { Option } from "effect"

const getInteger = (n: number) => Number.isInteger(n) ? Option.some(n) : Option.none()

console.log(Option.tap(Option.none(), getInteger))
// Output: { _id: 'Option', _tag: 'None' }

console.log(Option.tap(Option.some(1), getInteger))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(Option.tap(Option.some(1.14), getInteger))
// Output: { _id: 'Option', _tag: 'None' }`
        }
      ],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 2192,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L2192"
    },
    {
      id: "Option.product",
      name: "product",
      module: "Option",
      package: "effect",
      signature: "<A, B>(self: Option<A>, that: Option<B>) => Option<[A, B]>",
      description: "Combines two `Option` values into a single `Option` containing a tuple of\ntheir values if both are `Some`.",
      documentation: "Combines two `Option` values into a single `Option` containing a tuple of\ntheir values if both are `Some`.\n\n**Details**\n\nThis function takes two `Option`s and combines their values into a tuple `[A,\nB]` if both are `Some`. If either of the `Option`s is `None`, the result is\n`None`. This is particularly useful for combining multiple `Option` values\ninto a single one, ensuring both contain valid values.",
      examples: [],
      tags: [
        "Combining"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 2282,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L2282"
    },
    {
      id: "Option.productMany",
      name: "productMany",
      module: "Option",
      package: "effect",
      signature: "<A>(self: Option<A>, collection: Iterable<Option<A>>) => Option<[A, ...A[]]>",
      description: "Combines an `Option` with a collection of `Option`s into a single `Option`\ncontaining a tuple of their values if all are `Some`.",
      documentation: "Combines an `Option` with a collection of `Option`s into a single `Option`\ncontaining a tuple of their values if all are `Some`.\n\n**Details**\n\nThis function takes a primary `Option` and a collection of `Option`s and\ncombines their values into a tuple `[A, ...Array<A>]` if all are `Some`. If\nthe primary `Option` or any `Option` in the collection is `None`, the result\nis `None`.",
      examples: [],
      tags: [
        "Combining"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 2297,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L2297"
    },
    {
      id: "Option.all",
      name: "all",
      module: "Option",
      package: "effect",
      signature: "<const I extends Iterable<Option<any>> | Record<string, Option<any>>>(input: I) => [I] extends [readonly Option<any>[]] ? Option<{ -readonly [K in keyof I]: [I[K]] extends [Option<infer A>] ? A : never; }> : [I] extends [Iterable<Option<infer A>>] ? Option<A[]> : Option<{ -readonly [K in keyof I]: [I[K]] extends [Option<infer A>] ? A : never; }>",
      description: "Combines a structure of `Option`s into a single `Option` containing the\nvalues with the same structure.",
      documentation: "Combines a structure of `Option`s into a single `Option` containing the\nvalues with the same structure.\n\n**Details**\n\nThis function takes a structure of `Option`s (a tuple, struct, or iterable)\nand produces a single `Option` that contains the values from the input\nstructure if all `Option`s are `Some`. If any `Option` in the input is\n`None`, the result is `None`. The structure of the input is preserved in the\noutput.\n\n- If the input is a tuple (e.g., an array), the result will be an `Option`\n  containing a tuple with the same length.\n- If the input is a struct (e.g., an object), the result will be an `Option`\n  containing a struct with the same keys.\n- If the input is an iterable, the result will be an `Option` containing an\n  array.",
      examples: [
        {
          code: `import { Option } from "effect"

const maybeName: Option.Option<string> = Option.some("John")
const maybeAge: Option.Option<number> = Option.some(25)

//      \u250C\u2500\u2500\u2500 Option<[string, number]>
//      \u25BC
const tuple = Option.all([maybeName, maybeAge])
console.log(tuple)
// Output:
// { _id: 'Option', _tag: 'Some', value: [ 'John', 25 ] }

//      \u250C\u2500\u2500\u2500 Option<{ name: string; age: number; }>
//      \u25BC
const struct = Option.all({ name: maybeName, age: maybeAge })
console.log(struct)
// Output:
// { _id: 'Option', _tag: 'Some', value: { name: 'John', age: 25 } }`
        }
      ],
      tags: [
        "Combining"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 2342,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L2342"
    },
    {
      id: "Option.zipWith",
      name: "zipWith",
      module: "Option",
      package: "effect",
      signature: "{ <B, A, C>(that: Option<B>, f: (a: A, b: B) => C): (self: Option<A>) => Option<C>; <A, B, C>(self: Option<A>, that: Option<B>, f: (a: A, b: B) => C): Option<C>; }",
      description: "Combines two `Option` values into a new `Option` by applying a provided\nfunction to their values.",
      documentation: "Combines two `Option` values into a new `Option` by applying a provided\nfunction to their values.\n\n**Details**\n\nThis function takes two `Option` values (`self` and `that`) and a combining\nfunction `f`. If both `Option` values are `Some`, the function `f` is applied\nto their values, and the result is wrapped in a new `Some`. If either\n`Option` is `None`, the result is `None`.\n\nThis utility is useful for combining two optional computations into a single\nresult while maintaining type safety and avoiding explicit checks for `None`.",
      examples: [
        {
          code: `import { Option } from "effect"

const maybeName: Option.Option<string> = Option.some("John")
const maybeAge: Option.Option<number> = Option.some(25)

// Combine the name and age into a person object
const person = Option.zipWith(maybeName, maybeAge, (name, age) => ({
  name: name.toUpperCase(),
  age
}))

console.log(person)
// Output:
// { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }`
        }
      ],
      tags: [
        "Zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 2382,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L2382"
    },
    {
      id: "Option.ap",
      name: "ap",
      module: "Option",
      package: "effect",
      signature: "{ <A>(that: Option<A>): <B>(self: Option<(a: A) => B>) => Option<B>; <A, B>(self: Option<(a: A) => B>, that: Option<A>): Option<B>; }",
      description: "Applies a function inside a `Some` to a value inside another `Some`,\ncombining them into a new `Option`.",
      documentation: "Applies a function inside a `Some` to a value inside another `Some`,\ncombining them into a new `Option`.\n\n**Details**\n\nThis function allows you to apply a function wrapped in an `Option` (`self`)\nto a value wrapped in another `Option` (`that`). If both `Option`s are\n`Some`, the function is applied to the value, and the result is wrapped in a\nnew `Some`. If either `Option` is `None`, the result is `None`.",
      examples: [],
      tags: [
        "Combining"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 2470,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L2470"
    },
    {
      id: "Option.reduceCompact",
      name: "reduceCompact",
      module: "Option",
      package: "effect",
      signature: "{ <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<Option<A>>) => B; <A, B>(self: Iterable<Option<A>>, b: B, f: (b: B, a: A) => B): B; }",
      description: "Reduces an `Iterable` of `Option<A>` to a single value of type `B`, ignoring\nelements that are `None`.",
      documentation: "Reduces an `Iterable` of `Option<A>` to a single value of type `B`, ignoring\nelements that are `None`.\n\n**Details**\n\nThis function takes an initial value of type `B` and a reducing function `f`\nthat combines the accumulator with values of type `A`. It processes an\niterable of `Option<A>`, applying `f` only to the `Some` values while\nignoring the `None` values. The result is a single value of type `B`.\n\nThis utility is particularly useful for aggregating values from an iterable\nof `Option`s while skipping the absent (`None`) values.",
      examples: [
        {
          code: 'import { Option, pipe } from "effect"\n\nconst iterable = [Option.some(1), Option.none(), Option.some(2), Option.none()]\n\nconsole.log(pipe(iterable, Option.reduceCompact(0, (b, a) => b + a)))\n// Output: 3'
        }
      ],
      tags: [
        "Reducing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 2529,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L2529"
    },
    {
      id: "Option.toArray",
      name: "toArray",
      module: "Option",
      package: "effect",
      signature: "<A>(self: Option<A>) => A[]",
      description: "Converts an `Option` into an `Array`.\nIf the input is `None`, an empty array is returned.\nIf the input is `Some`, its value is wrapped in a single-element array.",
      documentation: "Converts an `Option` into an `Array`.\nIf the input is `None`, an empty array is returned.\nIf the input is `Some`, its value is wrapped in a single-element array.",
      examples: [
        {
          code: 'import { Option } from "effect"\n\nconsole.log(Option.toArray(Option.some(1)))\n// Output: [1]\n\nconsole.log(Option.toArray(Option.none()))\n// Output: []'
        }
      ],
      tags: [
        "Conversions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 2606,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L2606"
    },
    {
      id: "Option.partitionMap",
      name: "partitionMap",
      module: "Option",
      package: "effect",
      signature: "{ <A, B, C>(f: (a: A) => Either<C, B>): (self: Option<A>) => [left: Option<B>, right: Option<C>]; <A, B, C>(self: Option<A>, f: (a: A) => Either<C, B>): [left: Option<B>, right: Option<C>]; }",
      description: "Splits an `Option` into two `Option`s based on the result of a mapping\nfunction that produces an `Either`.",
      documentation: "Splits an `Option` into two `Option`s based on the result of a mapping\nfunction that produces an `Either`.\n\n**Details**\n\nThis function takes an `Option` and a mapping function `f` that converts its\nvalue into an `Either`. It returns a tuple of two `Option`s:\n\n- The first `Option` (`left`) contains the value from the `Left` side of the\n  `Either` if it exists, otherwise `None`.\n- The second `Option` (`right`) contains the value from the `Right` side of\n  the `Either` if it exists, otherwise `None`.\n\nIf the input `Option` is `None`, both returned `Option`s are `None`.\n\nThis utility is useful for filtering and categorizing the contents of an\n`Option` based on a bifurcating computation.",
      examples: [],
      tags: [
        "Filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 2629,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L2629"
    },
    {
      id: "Option.filterMap",
      name: "filterMap",
      module: "Option",
      package: "effect",
      signature: "{ <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>; <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>; }",
      description: "/\n * Alias of {@link flatMap}.\n *\n *",
      documentation: "/**\n * Alias of {@link flatMap}.\n *\n *",
      examples: [
        {
          code: "import { Option } from \"effect\"\n\n// Transform and filter numbers\nconst transformEven = (n: Option.Option<number>): Option.Option<string> =>\n  Option.filterMap(n, (n) => (n % 2 === 0 ? Option.some(`Even: ${n}`) : Option.none()))\n\nconsole.log(transformEven(Option.none()))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(transformEven(Option.some(1)))\n// Output: { _id: 'Option', _tag: 'None' }\n\nconsole.log(transformEven(Option.some(2)))\n// Output: { _id: 'Option', _tag: 'Some', value: 'Even: 2' }"
        }
      ],
      tags: [
        "Filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 2701,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L2701"
    },
    {
      id: "Option.filter",
      name: "filter",
      module: "Option",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Option<A>) => Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Option<A>) => Option<A>; <A, B extends A>(self: Option<A>, refinement: Refinement<A, B>): Option<B>; <A>(self: Option<A>, predicate: Predicate<A>): Option<A>; }",
      description: "Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`. If you need to change the type of the `Option` in addition to filtering, see `filterMap`.",
      documentation: "Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.\n\nIf you need to change the type of the `Option` in addition to filtering, see `filterMap`.",
      examples: [
        {
          code: `import { Option } from "effect"

const removeEmptyString = (input: Option.Option<string>) =>
  Option.filter(input, (value) => value !== "")

console.log(removeEmptyString(Option.none()))
// Output: { _id: 'Option', _tag: 'None' }

console.log(removeEmptyString(Option.some("")))
// Output: { _id: 'Option', _tag: 'None' }

console.log(removeEmptyString(Option.some("a")))
// Output: { _id: 'Option', _tag: 'Some', value: 'a' }`
        }
      ],
      tags: [
        "Filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 2778,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L2778"
    },
    {
      id: "Option.getEquivalence",
      name: "getEquivalence",
      module: "Option",
      package: "effect",
      signature: "<A>(isEquivalent: Equivalence<A>) => Equivalence<Option<A>>",
      description: "Creates an `Equivalence` instance for comparing `Option` values, using a\nprovided `Equivalence` for the inner type.",
      documentation: 'Creates an `Equivalence` instance for comparing `Option` values, using a\nprovided `Equivalence` for the inner type.\n\n**Details**\n\nThis function takes an `Equivalence` instance for a specific type `A` and\nproduces an `Equivalence` instance for `Option<A>`. The resulting\n`Equivalence` determines whether two `Option` values are equivalent:\n\n- Two `None`s are considered equivalent.\n- A `Some` and a `None` are not equivalent.\n- Two `Some` values are equivalent if their inner values are equivalent\n  according to the provided `Equivalence`.\n\n**Example** (Comparing Optional Numbers for Equivalence)\n\n```ts\nimport { Number, Option } from "effect"\n\nconst isEquivalent = Option.getEquivalence(Number.Equivalence)\n\nconsole.log(isEquivalent(Option.none(), Option.none()))\n// Output: true\n\nconsole.log(isEquivalent(Option.none(), Option.some(1)))\n// Output: false\n\nconsole.log(isEquivalent(Option.some(1), Option.none()))\n// Output: false\n\nconsole.log(isEquivalent(Option.some(1), Option.some(2)))\n// Output: false\n\nconsole.log(isEquivalent(Option.some(1), Option.some(1)))\n// Output: true\n```',
      examples: [
        {
          title: "Comparing Optional Numbers for Equivalence",
          code: 'import { Number, Option } from "effect"\n\nconst isEquivalent = Option.getEquivalence(Number.Equivalence)\n\nconsole.log(isEquivalent(Option.none(), Option.none()))\n// Output: true\n\nconsole.log(isEquivalent(Option.none(), Option.some(1)))\n// Output: false\n\nconsole.log(isEquivalent(Option.some(1), Option.none()))\n// Output: false\n\nconsole.log(isEquivalent(Option.some(1), Option.some(2)))\n// Output: false\n\nconsole.log(isEquivalent(Option.some(1), Option.some(1)))\n// Output: true'
        }
      ],
      tags: [
        "Equivalence"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 2925,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L2925"
    },
    {
      id: "Option.getOrder",
      name: "getOrder",
      module: "Option",
      package: "effect",
      signature: "<A>(O: Order<A>) => Order<Option<A>>",
      description: "Creates an `Order` instance for comparing `Option` values, using a provided\n`Order` for the inner type.",
      documentation: "Creates an `Order` instance for comparing `Option` values, using a provided\n`Order` for the inner type.\n\n**Details**\n\nThis function produces an `Order` instance for `Option<A>`, allowing `Option`\nvalues to be compared:\n\n- `None` is always considered less than any `Some` value.\n- If both are `Some`, their inner values are compared using the provided\n  `Order` instance.",
      examples: [
        {
          code: 'import { Number, Option } from "effect"\n\nconst order = Option.getOrder(Number.Order)\n\nconsole.log(order(Option.none(), Option.none()))\n// Output: 0\n\nconsole.log(order(Option.none(), Option.some(1)))\n// Output: -1\n\nconsole.log(order(Option.some(1), Option.none()))\n// Output: 1\n\nconsole.log(order(Option.some(1), Option.some(2)))\n// Output: -1\n\nconsole.log(order(Option.some(1), Option.some(1)))\n// Output: 0'
        }
      ],
      tags: [
        "Sorting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 2964,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L2964"
    },
    {
      id: "Option.lift2",
      name: "lift2",
      module: "Option",
      package: "effect",
      signature: "<A, B, C>(f: (a: A, b: B) => C) => { (that: Option<B>): (self: Option<A>) => Option<C>; (self: Option<A>, that: Option<B>): Option<C>; }",
      description: "Lifts a binary function to work with `Option` values, allowing the function\nto operate on two `Option`s.",
      documentation: "Lifts a binary function to work with `Option` values, allowing the function\nto operate on two `Option`s.\n\n**Details**\n\nThis function takes a binary function `f` and returns a new function that\napplies `f` to the values of two `Option`s (`self` and `that`). If both\n`Option`s are `Some`, the binary function `f` is applied to their values, and\nthe result is wrapped in a new `Some`. If either `Option` is `None`, the\nresult is `None`.",
      examples: [
        {
          code: "import { Option } from \"effect\"\n\n// A binary function to add two numbers\nconst add = (a: number, b: number): number => a + b\n\n// Lift the `add` function to work with `Option` values\nconst addOptions = Option.lift2(add)\n\n// Both `Option`s are `Some`\nconsole.log(addOptions(Option.some(2), Option.some(3)))\n// Output: { _id: 'Option', _tag: 'Some', value: 5 }\n\n// One `Option` is `None`\nconsole.log(addOptions(Option.some(2), Option.none()))\n// Output: { _id: 'Option', _tag: 'None' }"
        }
      ],
      tags: [
        "Lifting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 2999,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L2999"
    },
    {
      id: "Option.liftPredicate",
      name: "liftPredicate",
      module: "Option",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<A, B>): (a: A) => Option<B>; <B extends A, A = B>(predicate: Predicate<A>): (b: B) => Option<B>; <A, B extends A>(self: A, refinement: Refinement<A, B>): Option<B>; <B extends A, A = B>(self: B, predicate: Predicate<A>): Option<B>; }",
      description: "Lifts a `Predicate` or `Refinement` into the `Option` context, returning a\n`Some` of the input value if the predicate is satisfied, or `None` otherwise.",
      documentation: "Lifts a `Predicate` or `Refinement` into the `Option` context, returning a\n`Some` of the input value if the predicate is satisfied, or `None` otherwise.\n\n**Details**\n\nThis function transforms a `Predicate` (or a more specific `Refinement`) into\na function that produces an `Option`. If the predicate evaluates to `true`,\nthe input value is wrapped in a `Some`. If the predicate evaluates to\n`false`, the result is `None`.",
      examples: [
        {
          code: `import { Option } from "effect"

// Check if a number is positive
const isPositive = (n: number) => n > 0

//      \u250C\u2500\u2500\u2500 (b: number) => Option<number>
//      \u25BC
const parsePositive = Option.liftPredicate(isPositive)

console.log(parsePositive(1))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(parsePositive(-1))
// OUtput: { _id: 'Option', _tag: 'None' }`
        }
      ],
      tags: [
        "Lifting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 3035,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L3035"
    },
    {
      id: "Option.containsWith",
      name: "containsWith",
      module: "Option",
      package: "effect",
      signature: "<A>(isEquivalent: (self: A, that: A) => boolean) => { (a: A): (self: Option<A>) => boolean; (self: Option<A>, a: A): boolean; }",
      description: "Returns a function that checks if an `Option` contains a specified value,\nusing a provided equivalence function.",
      documentation: "Returns a function that checks if an `Option` contains a specified value,\nusing a provided equivalence function.\n\n**Details**\n\nThis function allows you to check whether an `Option` contains a specific\nvalue. It uses an equivalence function `isEquivalent` to compare the value\ninside the `Option` to the provided value. If the `Option` is `Some` and the\nequivalence function returns `true`, the result is `true`. If the `Option` is\n`None` or the values are not equivalent, the result is `false`.",
      examples: [
        {
          code: 'import { Number, Option } from "effect"\n\nconst contains = Option.containsWith(Number.Equivalence)\n\nconsole.log(Option.some(2).pipe(contains(2)))\n// Output: true\n\nconsole.log(Option.some(1).pipe(contains(2)))\n// Output: false\n\nconsole.log(Option.none().pipe(contains(2)))\n// Output: false'
        }
      ],
      tags: [
        "Elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 3170,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L3170"
    },
    {
      id: "Option.contains",
      name: "contains",
      module: "Option",
      package: "effect",
      signature: "{ <A>(a: A): (self: Option<A>) => boolean; <A>(self: Option<A>, a: A): boolean; }",
      description: "Returns a function that checks if an `Option` contains a specified value\nusing the default `Equivalence`.",
      documentation: "Returns a function that checks if an `Option` contains a specified value\nusing the default `Equivalence`.\n\n**Details**\n\nThis function allows you to check whether an `Option` contains a specific\nvalue. It uses the default `Equivalence` for equality comparison. If the\n`Option` is `Some` and its value is equivalent to the provided value, the\nresult is `true`. If the `Option` is `None` or the values are not equivalent,\nthe result is `false`.",
      examples: [
        {
          code: 'import { Option } from "effect"\n\nconsole.log(Option.some(2).pipe(Option.contains(2)))\n// Output: true\n\nconsole.log(Option.some(1).pipe(Option.contains(2)))\n// Output: false\n\nconsole.log(Option.none().pipe(Option.contains(2)))\n// Output: false'
        }
      ],
      tags: [
        "Elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 3205,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L3205"
    },
    {
      id: "Option.exists",
      name: "exists",
      module: "Option",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Option<A>) => self is Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Option<A>) => boolean; <A, B extends A>(self: Option<A>, refinement: Refinement<A, B>): self is Option<B>; <A>(self: Option<A>, predicate: Predicate<A>): boolean; }",
      description: "Checks if a value in an `Option` satisfies a given predicate or refinement.",
      documentation: "Checks if a value in an `Option` satisfies a given predicate or refinement.\n\n**Details**\n\nThis function allows you to check if a value inside a `Some` meets a\nspecified condition. If the `Option` is `None`, the result is `false`. If the\n`Option` is `Some`, the provided predicate or refinement is applied to the\nvalue:\n\n- If the condition is met, the result is `true`.\n- If the condition is not met, the result is `false`.",
      examples: [
        {
          code: 'import { Option } from "effect"\n\nconst isEven = (n: number) => n % 2 === 0\n\nconsole.log(Option.some(2).pipe(Option.exists(isEven)))\n// Output: true\n\nconsole.log(Option.some(1).pipe(Option.exists(isEven)))\n// Output: false\n\nconsole.log(Option.none().pipe(Option.exists(isEven)))\n// Output: false'
        }
      ],
      tags: [
        "Elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 3303,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L3303"
    },
    {
      id: "Option.bindTo",
      name: "bindTo",
      module: "Option",
      package: "effect",
      signature: "{ <N extends string>(name: N): <A>(self: Option<A>) => Option<{ [K in N]: A; }>; <A, N extends string>(self: Option<A>, name: N): Option<{ [K in N]: A; }>; }",
      description: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`. Here\'s how the do simulation works: 1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope',
      documentation: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere\'s how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope',
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Option, pipe } from "effect"\n\nconst result = pipe(\n  Option.Do,\n  Option.bind("x", () => Option.some(2)),\n  Option.bind("y", () => Option.some(3)),\n  Option.let("sum", ({ x, y }) => x + y),\n  Option.filter(({ x, y }) => x * y > 5)\n)\nassert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))'
        }
      ],
      tags: [
        "Do notation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 3470,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L3470"
    },
    {
      id: "Option.bind",
      name: "bind",
      module: "Option",
      package: "effect",
      signature: "{ <N extends string, A extends object, B>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Option<B>): (self: Option<A>) => Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; <A extends object, N extends string, B>(self: Option<A>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Option<B>): Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; }",
      description: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`. Here\'s how the do simulation works: 1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope',
      documentation: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere\'s how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope',
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Option, pipe } from "effect"\n\nconst result = pipe(\n  Option.Do,\n  Option.bind("x", () => Option.some(2)),\n  Option.bind("y", () => Option.some(3)),\n  Option.let("sum", ({ x, y }) => x + y),\n  Option.filter(({ x, y }) => x * y > 5)\n)\nassert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))'
        }
      ],
      tags: [
        "Do notation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 3620,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L3620"
    },
    {
      id: "Option.Do",
      name: "Do",
      module: "Option",
      package: "effect",
      signature: "Option<{}>",
      description: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`. Here\'s how the do simulation works: 1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope',
      documentation: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere\'s how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Option` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Option` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope',
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Option, pipe } from "effect"\n\nconst result = pipe(\n  Option.Do,\n  Option.bind("x", () => Option.some(2)),\n  Option.bind("y", () => Option.some(3)),\n  Option.let("sum", ({ x, y }) => x + y),\n  Option.filter(({ x, y }) => x * y > 5)\n)\nassert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))'
        }
      ],
      tags: [
        "Do notation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 3727,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L3727"
    },
    {
      id: "Option.gen",
      name: "gen",
      module: "Option",
      package: "effect",
      signature: "Gen<OptionTypeLambda, Adapter<OptionTypeLambda>>",
      description: "Similar to `Effect.gen`, `Option.gen` provides a more readable,\ngenerator-based syntax for working with `Option` values, making code that\ninvolves `Option` easier to write and understand. This approach is similar to\nusing `async/await` but tailored for `Option`.",
      documentation: "Similar to `Effect.gen`, `Option.gen` provides a more readable,\ngenerator-based syntax for working with `Option` values, making code that\ninvolves `Option` easier to write and understand. This approach is similar to\nusing `async/await` but tailored for `Option`.\n\n**Example** (Using `Option.gen` to Create a Combined Value)\n\n```ts\nimport { Option } from \"effect\"\n\nconst maybeName: Option.Option<string> = Option.some(\"John\")\nconst maybeAge: Option.Option<number> = Option.some(25)\n\nconst person = Option.gen(function* () {\n  const name = (yield* maybeName).toUpperCase()\n  const age = yield* maybeAge\n  return { name, age }\n})\n\nconsole.log(person)\n// Output:\n// { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }\n```",
      examples: [
        {
          title: "Using `Option.gen` to Create a Combined Value",
          code: `import { Option } from "effect"

const maybeName: Option.Option<string> = Option.some("John")
const maybeAge: Option.Option<number> = Option.some(25)

const person = Option.gen(function* () {
  const name = (yield* maybeName).toUpperCase()
  const age = yield* maybeAge
  return { name, age }
})

console.log(person)
// Output:
// { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }`
        }
      ],
      tags: [
        "Generators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Option.d.ts",
      sourceLine: 3756,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Option.ts#L3756"
    },
    {
      id: "Either.TypeId",
      name: "TypeId",
      module: "Either",
      package: "effect",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 23,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L23"
    },
    {
      id: "Either.right",
      name: "right",
      module: "Either",
      package: "effect",
      signature: "<A>(a: A) => Either<A, never>",
      description: "Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\nof this structure.",
      documentation: "Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\nof this structure.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 105,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L105"
    },
    {
      id: "Either.left",
      name: "left",
      module: "Either",
      package: "effect",
      signature: "<E>(e: E) => Either<never, E>",
      description: "Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\nstructure.",
      documentation: "Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\nstructure.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 120,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L120"
    },
    {
      id: "Either.fromNullable",
      name: "fromNullable",
      module: "Either",
      package: "effect",
      signature: "{ <A, E>(onNullable: (right: A) => E): (self: A) => Either<NonNullable<A>, E>; <A, E>(self: A, onNullable: (right: A) => E): Either<NonNullable<A>, E>; }",
      description: "Takes a lazy default and a nullable value, if the value is not nully (`null` or `undefined`), turn it into a `Right`, if the value is nully use\nthe provided default as a `Left`.",
      documentation: "Takes a lazy default and a nullable value, if the value is not nully (`null` or `undefined`), turn it into a `Right`, if the value is nully use\nthe provided default as a `Left`.",
      examples: [
        {
          code: `import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(Either.fromNullable(1, () => 'fallback'), Either.right(1))
assert.deepStrictEqual(Either.fromNullable(null, () => 'fallback'), Either.left('fallback'))`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 137,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L137"
    },
    {
      id: "Either.fromOption",
      name: "fromOption",
      module: "Either",
      package: "effect",
      signature: "{ <E>(onNone: () => E): <A>(self: Option<A>) => Either<A, E>; <A, E>(self: Option<A>, onNone: () => E): Either<A, E>; }",
      description: "",
      documentation: "",
      examples: [
        {
          code: `import * as assert from "node:assert"
import { Either, Option } from "effect"

assert.deepStrictEqual(Either.fromOption(Option.some(1), () => 'error'), Either.right(1))
assert.deepStrictEqual(Either.fromOption(Option.none(), () => 'error'), Either.left('error'))`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 186,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L186"
    },
    {
      id: "Either.isEither",
      name: "isEither",
      module: "Either",
      package: "effect",
      signature: "(input: unknown) => input is Either<unknown, unknown>",
      description: "Tests if a value is a `Either`.",
      documentation: "Tests if a value is a `Either`.",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Either } from "effect"\n\nassert.deepStrictEqual(Either.isEither(Either.right(1)), true)\nassert.deepStrictEqual(Either.isEither(Either.left("a")), true)\nassert.deepStrictEqual(Either.isEither({ right: 1 }), false)'
        }
      ],
      tags: [
        "guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 248,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L248"
    },
    {
      id: "Either.isLeft",
      name: "isLeft",
      module: "Either",
      package: "effect",
      signature: "<A, E>(self: Either<A, E>) => self is Left<E, A>",
      description: "Determine if a `Either` is a `Left`.",
      documentation: "Determine if a `Either` is a `Left`.",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Either } from "effect"\n\nassert.deepStrictEqual(Either.isLeft(Either.right(1)), false)\nassert.deepStrictEqual(Either.isLeft(Either.left("a")), true)'
        }
      ],
      tags: [
        "guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 264,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L264"
    },
    {
      id: "Either.isRight",
      name: "isRight",
      module: "Either",
      package: "effect",
      signature: "<A, E>(self: Either<A, E>) => self is Right<E, A>",
      description: "Determine if a `Either` is a `Right`.",
      documentation: "Determine if a `Either` is a `Right`.",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Either } from "effect"\n\nassert.deepStrictEqual(Either.isRight(Either.right(1)), true)\nassert.deepStrictEqual(Either.isRight(Either.left("a")), false)'
        }
      ],
      tags: [
        "guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 280,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L280"
    },
    {
      id: "Either.getRight",
      name: "getRight",
      module: "Either",
      package: "effect",
      signature: "<A, E>(self: Either<A, E>) => Option<A>",
      description: "Converts a `Either` to an `Option` discarding the `Left`.",
      documentation: "Converts a `Either` to an `Option` discarding the `Left`.",
      examples: [
        {
          code: `import * as assert from "node:assert"
import { Either, Option } from "effect"

assert.deepStrictEqual(Either.getRight(Either.right('ok')), Option.some('ok'))
assert.deepStrictEqual(Either.getRight(Either.left('err')), Option.none())`
        }
      ],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 296,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L296"
    },
    {
      id: "Either.getLeft",
      name: "getLeft",
      module: "Either",
      package: "effect",
      signature: "<A, E>(self: Either<A, E>) => Option<E>",
      description: "Converts a `Either` to an `Option` discarding the value.",
      documentation: "Converts a `Either` to an `Option` discarding the value.",
      examples: [
        {
          code: `import * as assert from "node:assert"
import { Either, Option } from "effect"

assert.deepStrictEqual(Either.getLeft(Either.right('ok')), Option.none())
assert.deepStrictEqual(Either.getLeft(Either.left('err')), Option.some('err'))`
        }
      ],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 312,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L312"
    },
    {
      id: "Either.getEquivalence",
      name: "getEquivalence",
      module: "Either",
      package: "effect",
      signature: "<A, E>({ left, right }: { right: Equivalence<A>; left: Equivalence<E>; }) => Equivalence<Either<A, E>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "equivalence"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 317,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L317"
    },
    {
      id: "Either.mapBoth",
      name: "mapBoth",
      module: "Either",
      package: "effect",
      signature: "{ <E, E2, A, A2>(options: { readonly onLeft: (left: E) => E2; readonly onRight: (right: A) => A2; }): (self: Either<A, E>) => Either<A2, E2>; <A, E, E2, A2>(self: Either<A, E>, options: { readonly onLeft: (left: E) => E2; readonly onRight: (right: A) => A2; }): Either<A2, E2>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 325,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L325"
    },
    {
      id: "Either.mapLeft",
      name: "mapLeft",
      module: "Either",
      package: "effect",
      signature: "{ <E, E2>(f: (left: E) => E2): <A>(self: Either<A, E>) => Either<A, E2>; <A, E, E2>(self: Either<A, E>, f: (left: E) => E2): Either<A, E2>; }",
      description: "Maps the `Left` side of an `Either` value to a new `Either` value.",
      documentation: "Maps the `Left` side of an `Either` value to a new `Either` value.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 349,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L349"
    },
    {
      id: "Either.map",
      name: "map",
      module: "Either",
      package: "effect",
      signature: "{ <A, A2>(f: (right: A) => A2): <E>(self: Either<A, E>) => Either<A2, E>; <A, E, A2>(self: Either<A, E>, f: (right: A) => A2): Either<A2, E>; }",
      description: "Maps the `Right` side of an `Either` value to a new `Either` value.",
      documentation: "Maps the `Right` side of an `Either` value to a new `Either` value.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 371,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L371"
    },
    {
      id: "Either.match",
      name: "match",
      module: "Either",
      package: "effect",
      signature: "{ <E, B, A, C = B>(options: { readonly onLeft: (left: E) => B; readonly onRight: (right: A) => C; }): (self: Either<A, E>) => B | C; <A, E, B, C = B>(self: Either<A, E>, options: { readonly onLeft: (left: E) => B; readonly onRight: (right: A) => C; }): B | C; }",
      description: "Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the `onLeft function,\nif the value is a `Right` the inner value is applied to the `onRight` function.",
      documentation: "Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the `onLeft function,\nif the value is a `Right` the inner value is applied to the `onRight` function.",
      examples: [
        {
          code: "import * as assert from \"node:assert\"\nimport { pipe, Either } from \"effect\"\n\nconst onLeft  = (strings: ReadonlyArray<string>): string => `strings: ${strings.join(', ')}`\n\nconst onRight = (value: number): string => `Ok: ${value}`\n\nassert.deepStrictEqual(pipe(Either.right(1), Either.match({ onLeft, onRight })), 'Ok: 1')\nassert.deepStrictEqual(\n  pipe(Either.left(['string 1', 'string 2']), Either.match({ onLeft, onRight })),\n  'strings: string 1, string 2'\n)"
        }
      ],
      tags: [
        "pattern matching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 410,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L410"
    },
    {
      id: "Either.liftPredicate",
      name: "liftPredicate",
      module: "Either",
      package: "effect",
      signature: "{ <A, B extends A, E>(refinement: Refinement<A, B>, orLeftWith: (a: A) => E): (a: A) => Either<B, E>; <B extends A, E, A = B>(predicate: Predicate<A>, orLeftWith: (a: A) => E): (a: B) => Either<B, E>; <A, E, B extends A>(self: A, refinement: Refinement<A, B>, orLeftWith: (a: A) => E): Either<B, E>; <B extends A, E, A = B>(self: B, predicate: Predicate<A>, orLeftWith: (a: A) => E): Either<B, E>; }",
      description: "Transforms a `Predicate` function into a `Right` of the input value if the predicate returns `true`\nor `Left` of the result of the provided function if the predicate returns false",
      documentation: "Transforms a `Predicate` function into a `Right` of the input value if the predicate returns `true`\nor `Left` of the result of the provided function if the predicate returns false",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { pipe, Either } from "effect"\n\nconst isPositive = (n: number): boolean => n > 0\nconst isPositiveEither = Either.liftPredicate(isPositive, n => `${n} is not positive`)\n\nassert.deepStrictEqual(\n  isPositiveEither(1),\n  Either.right(1)\n)\nassert.deepStrictEqual(\n  isPositiveEither(0),\n  Either.left("0 is not positive")\n)'
        }
      ],
      tags: [
        "lifting"
      ],
      since: "3.4.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 491,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L491"
    },
    {
      id: "Either.filterOrLeft",
      name: "filterOrLeft",
      module: "Either",
      package: "effect",
      signature: "{ <A, B extends A, E2>(refinement: Refinement<NoInfer<A>, B>, orLeftWith: (right: NoInfer<A>) => E2): <E>(self: Either<A, E>) => Either<B, E2 | E>; <A, E2>(predicate: Predicate<NoInfer<A>>, orLeftWith: (right: NoInfer<A>) => E2): <E>(self: Either<A, E>) => Either<A, E2 | E>; <A, E, B extends A, E2>(self: Either<A, E>, refinement: Refinement<A, B>, orLeftWith: (right: A) => E2): Either<B, E | E2>; <A, E, E2>(self: Either<A, E>, predicate: Predicate<A>, orLeftWith: (right: A) => E2): Either<A, E | E2>; }",
      description: "Filter the right value with the provided function.\nIf the predicate fails, set the left value with the result of the provided function.",
      documentation: "Filter the right value with the provided function.\nIf the predicate fails, set the left value with the result of the provided function.",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { pipe, Either } from "effect"\n\nconst isPositive = (n: number): boolean => n > 0\n\nassert.deepStrictEqual(\n  pipe(\n    Either.right(1),\n    Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n  ),\n  Either.right(1)\n)\nassert.deepStrictEqual(\n  pipe(\n    Either.right(0),\n    Either.filterOrLeft(isPositive, n => `${n} is not positive`)\n  ),\n  Either.left("0 is not positive")\n)'
        }
      ],
      tags: [
        "filtering & conditionals"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 627,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L627"
    },
    {
      id: "Either.merge",
      name: "merge",
      module: "Either",
      package: "effect",
      signature: "<A, E>(self: Either<A, E>) => A | E",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 757,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L757"
    },
    {
      id: "Either.getOrElse",
      name: "getOrElse",
      module: "Either",
      package: "effect",
      signature: "{ <E, A2>(onLeft: (left: E) => A2): <A>(self: Either<A, E>) => A2 | A; <A, E, A2>(self: Either<A, E>, onLeft: (left: E) => A2): A | A2; }",
      description: "Returns the wrapped value if it's a `Right` or a default value if is a `Left`.",
      documentation: "Returns the wrapped value if it's a `Right` or a default value if is a `Left`.",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Either } from "effect"\n\nassert.deepStrictEqual(Either.getOrElse(Either.right(1), (error) => error + "!"), 1)\nassert.deepStrictEqual(Either.getOrElse(Either.left("not a number"), (error) => error + "!"), "not a number!")'
        }
      ],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 773,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L773"
    },
    {
      id: "Either.getOrNull",
      name: "getOrNull",
      module: "Either",
      package: "effect",
      signature: "<A, E>(self: Either<A, E>) => A",
      description: "",
      documentation: "",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Either } from "effect"\n\nassert.deepStrictEqual(Either.getOrNull(Either.right(1)), 1)\nassert.deepStrictEqual(Either.getOrNull(Either.left("a")), null)'
        }
      ],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 820,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L820"
    },
    {
      id: "Either.getOrUndefined",
      name: "getOrUndefined",
      module: "Either",
      package: "effect",
      signature: "<A, E>(self: Either<A, E>) => A",
      description: "",
      documentation: "",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Either } from "effect"\n\nassert.deepStrictEqual(Either.getOrUndefined(Either.right(1)), 1)\nassert.deepStrictEqual(Either.getOrUndefined(Either.left("a")), undefined)'
        }
      ],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 834,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L834"
    },
    {
      id: "Either.getOrThrowWith",
      name: "getOrThrowWith",
      module: "Either",
      package: "effect",
      signature: "{ <E>(onLeft: (left: E) => unknown): <A>(self: Either<A, E>) => A; <A, E>(self: Either<A, E>, onLeft: (left: E) => unknown): A; }",
      description: "/\n * Extracts the value of an `Either` or throws if the `Either` is `Left`.\n *\n * If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.\n *\n *",
      documentation: "/**\n * Extracts the value of an `Either` or throws if the `Either` is `Left`.\n *\n * If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.\n *\n *",
      examples: [
        {
          code: `import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(
  Either.getOrThrowWith(Either.right(1), () => new Error('Unexpected Left')),
  1
)
assert.throws(() => Either.getOrThrowWith(Either.left("error"), () => new Error('Unexpected Left')))`
        }
      ],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 855,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L855"
    },
    {
      id: "Either.getOrThrow",
      name: "getOrThrow",
      module: "Either",
      package: "effect",
      signature: "<A, E>(self: Either<A, E>) => A",
      description: "/\n * Extracts the value of an `Either` or throws if the `Either` is `Left`.\n *\n * The thrown error is a default error. To configure the error thrown, see  {@link getOrThrowWith}.\n *\n *",
      documentation: "/**\n * Extracts the value of an `Either` or throws if the `Either` is `Left`.\n *\n * The thrown error is a default error. To configure the error thrown, see  {@link getOrThrowWith}.\n *\n *",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Either } from "effect"\n\nassert.deepStrictEqual(Either.getOrThrow(Either.right(1)), 1)\nassert.throws(() => Either.getOrThrow(Either.left("error")))'
        }
      ],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 918,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L918"
    },
    {
      id: "Either.orElse",
      name: "orElse",
      module: "Either",
      package: "effect",
      signature: "{ <E, A2, E2>(that: (left: E) => Either<A2, E2>): <A>(self: Either<A, E>) => Either<A2 | A, E2>; <A, E, A2, E2>(self: Either<A, E>, that: (left: E) => Either<A2, E2>): Either<A | A2, E2>; }",
      description: "Returns `self` if it is a `Right` or `that` otherwise.",
      documentation: "Returns `self` if it is a `Right` or `that` otherwise.",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 925,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L925"
    },
    {
      id: "Either.flatMap",
      name: "flatMap",
      module: "Either",
      package: "effect",
      signature: "{ <A, A2, E2>(f: (right: A) => Either<A2, E2>): <E>(self: Either<A, E>) => Either<A2, E2 | E>; <A, E, A2, E2>(self: Either<A, E>, f: (right: A) => Either<A2, E2>): Either<A2, E | E2>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 945,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L945"
    },
    {
      id: "Either.andThen",
      name: "andThen",
      module: "Either",
      package: "effect",
      signature: "{ <A, A2, E2>(f: (right: A) => Either<A2, E2>): <E>(self: Either<A, E>) => Either<A2, E2 | E>; <A2, E2>(f: Either<A2, E2>): <E, A>(self: Either<A, E>) => Either<A2, E2 | E>; <A, A2>(f: (right: A) => A2): <E>(self: Either<A, E>) => Either<A2, E>; <A2>(right: NotFunction<A2>): <A, E>(self: Either<A, E>) => Either<A2, E>; <A, E, A2, E2>(self: Either<A, E>, f: (right: A) => Either<A2, E2>): Either<A2, E | E2>; <A, E, A2, E2>(self: Either<A, E>, f: Either<A2, E2>): Either<A2, E | E2>; <A, E, A2>(self: Either<A, E>, f: (right: A) => A2): Either<A2, E>; <A, E, A2>(self: Either<A, E>, f: NotFunction<A2>): Either<A2, E>; }",
      description: "Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.",
      documentation: "Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 963,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L963"
    },
    {
      id: "Either.zipWith",
      name: "zipWith",
      module: "Either",
      package: "effect",
      signature: "{ <A2, E2, A, B>(that: Either<A2, E2>, f: (right: A, right2: A2) => B): <E>(self: Either<A, E>) => Either<B, E2 | E>; <A, E, A2, E2, B>(self: Either<A, E>, that: Either<A2, E2>, f: (right: A, right2: A2) => B): Either<B, E | E2>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 1025,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L1025"
    },
    {
      id: "Either.ap",
      name: "ap",
      module: "Either",
      package: "effect",
      signature: "{ <A, E2>(that: Either<A, E2>): <A2, E>(self: Either<(right: A) => A2, E>) => Either<A2, E2 | E>; <A, A2, E, E2>(self: Either<(right: A) => A2, E>, that: Either<A, E2>): Either<A2, E | E2>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combining"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 1041,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L1041"
    },
    {
      id: "Either.all",
      name: "all",
      module: "Either",
      package: "effect",
      signature: "<const I extends Iterable<Either<any, any>> | Record<string, Either<any, any>>>(input: I) => [I] extends [readonly Either<any, any>[]] ? Either<{ -readonly [K in keyof I]: [I[K]] extends [Either<infer A, any>] ? A : never; }, I[number] extends never ? never : [I[number]] extends [Either<any, infer E>] ? E : never> : [I] extends [Iterable<Either<infer A, infer E>>] ? Either<A[], E> : Either<{ -readonly [K in keyof I]: [I[K]] extends [Either<infer A, any>] ? A : never; }, I[keyof I] extends never ? never : [I[keyof I]] extends [Either<any, infer E>] ? E : never>",
      description: "Takes a structure of `Either`s and returns an `Either` of values with the same structure. - If a tuple is supplied, then the returned `Either` will contain a tuple with the same length.\n- If a struct is supplied, then the returned `Either` will contain a struct with the same keys.\n- If an iterable is supplied, then the returned `Either` will contain an array.",
      documentation: "Takes a structure of `Either`s and returns an `Either` of values with the same structure.\n\n- If a tuple is supplied, then the returned `Either` will contain a tuple with the same length.\n- If a struct is supplied, then the returned `Either` will contain a struct with the same keys.\n- If an iterable is supplied, then the returned `Either` will contain an array.",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Either } from "effect"\n\nassert.deepStrictEqual(Either.all([Either.right(1), Either.right(2)]), Either.right([1, 2]))\nassert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.right("hello") }), Either.right({ right: 1, b: "hello" }))\nassert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.left("error") }), Either.left("error"))'
        }
      ],
      tags: [
        "combining"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 1073,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L1073"
    },
    {
      id: "Either.flip",
      name: "flip",
      module: "Either",
      package: "effect",
      signature: "<A, E>(self: Either<A, E>) => Either<E, A>",
      description: "Returns an `Either` that swaps the error/success cases. This allows you to\nuse all methods on the error channel, possibly before flipping back.",
      documentation: "Returns an `Either` that swaps the error/success cases. This allows you to\nuse all methods on the error channel, possibly before flipping back.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 1085,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L1085"
    },
    {
      id: "Either.gen",
      name: "gen",
      module: "Either",
      package: "effect",
      signature: "Gen<EitherTypeLambda, Adapter<EitherTypeLambda>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "generators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 1090,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L1090"
    },
    {
      id: "Either.Do",
      name: "Do",
      module: "Either",
      package: "effect",
      signature: "Either<{}, never>",
      description: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`. Here\'s how the do simulation works: 1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values',
      documentation: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere\'s how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values',
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Either, pipe } from "effect"\n\nconst result = pipe(\n  Either.Do,\n  Either.bind("x", () => Either.right(2)),\n  Either.bind("y", () => Either.right(3)),\n  Either.let("sum", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))'
        }
      ],
      tags: [
        "do notation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 1122,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L1122"
    },
    {
      id: "Either.bind",
      name: "bind",
      module: "Either",
      package: "effect",
      signature: "{ <N extends string, A extends object, B, E2>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Either<B, E2>): <E>(self: Either<A, E>) => Either<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E2 | E>; <A extends object, E, N extends string, B, E2>(self: Either<A, E>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Either<B, E2>): Either<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E | E2>; }",
      description: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`. Here\'s how the do simulation works: 1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values',
      documentation: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere\'s how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values',
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Either, pipe } from "effect"\n\nconst result = pipe(\n  Either.Do,\n  Either.bind("x", () => Either.right(2)),\n  Either.bind("y", () => Either.right(3)),\n  Either.let("sum", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))'
        }
      ],
      tags: [
        "do notation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 1154,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L1154"
    },
    {
      id: "Either.bindTo",
      name: "bindTo",
      module: "Either",
      package: "effect",
      signature: "{ <N extends string>(name: N): <A, E>(self: Either<A, E>) => Either<{ [K in N]: A; }, E>; <A, E, N extends string>(self: Either<A, E>, name: N): Either<{ [K in N]: A; }, E>; }",
      description: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`. Here\'s how the do simulation works: 1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values',
      documentation: 'The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.\n\nHere\'s how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Either` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values',
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Either, pipe } from "effect"\n\nconst result = pipe(\n  Either.Do,\n  Either.bind("x", () => Either.right(2)),\n  Either.bind("y", () => Either.right(3)),\n  Either.let("sum", ({ x, y }) => x + y)\n)\nassert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))'
        }
      ],
      tags: [
        "do notation"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 1255,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L1255"
    },
    {
      id: "Either.transposeOption",
      name: "transposeOption",
      module: "Either",
      package: "effect",
      signature: "<A = never, E = never>(self: Option<Either<A, E>>) => Either<Option<A>, E>",
      description: "Converts an `Option` of an `Either` into an `Either` of an `Option`.",
      documentation: "Converts an `Option` of an `Either` into an `Either` of an `Option`.\n\n**Details**\n\nThis function transforms an `Option<Either<A, E>>` into an\n`Either<Option<A>, E>`. If the `Option` is `None`, the resulting `Either`\nwill be a `Right` with a `None` value. If the `Option` is `Some`, the\ninner `Either` will be executed, and its result wrapped in a `Some`.",
      examples: [
        {
          code: `import { Effect, Either, Option } from "effect"

//      \u250C\u2500\u2500\u2500 Option<Either<number, never>>
//      \u25BC
const maybe = Option.some(Either.right(42))

//      \u250C\u2500\u2500\u2500 Either<Option<number>, never, never>
//      \u25BC
const result = Either.transposeOption(maybe)

console.log(Effect.runSync(result))
// Output: { _id: 'Option', _tag: 'Some', value: 42 }`
        }
      ],
      tags: [
        "Optional Wrapping & Unwrapping"
      ],
      since: "3.14.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 1395,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L1395"
    },
    {
      id: "Either.transposeMapOption",
      name: "transposeMapOption",
      module: "Either",
      package: "effect",
      signature: "(<A, B, E = never>(f: (self: A) => Either<B, E>) => (self: Option<A>) => Either<Option<B>, E>) & (<A, B, E = never>(self: Option<A>, f: (self: A) => Either<B, E>) => Either<Option<B>, E>)",
      description: "Applies an `Either` on an `Option` and transposes the result.",
      documentation: "Applies an `Either` on an `Option` and transposes the result.\n\n**Details**\n\nIf the `Option` is `None`, the resulting `Either` will immediately succeed with a `Right` value of `None`.\nIf the `Option` is `Some`, the transformation function will be applied to the inner value, and its result wrapped in a `Some`.",
      examples: [
        {
          code: `import { Either, Option, pipe } from "effect"

//          \u250C\u2500\u2500\u2500 Either<Option<number>, never>>
//          \u25BC
const noneResult = pipe(
  Option.none(),
  Either.transposeMapOption(() => Either.right(42)) // will not be executed
)
console.log(noneResult)
// Output: { _id: 'Either', _tag: 'Right', right: { _id: 'Option', _tag: 'None' } }

//          \u250C\u2500\u2500\u2500 Either<Option<number>, never>>
//          \u25BC
const someRightResult = pipe(
  Option.some(42),
  Either.transposeMapOption((value) => Either.right(value * 2))
)
console.log(someRightResult)
// Output: { _id: 'Either', _tag: 'Right', right: { _id: 'Option', _tag: 'Some', value: 84 } }`
        }
      ],
      tags: [
        "Optional Wrapping & Unwrapping"
      ],
      since: "3.15.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Either.d.ts",
      sourceLine: 1430,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Either.ts#L1430"
    },
    {
      id: "Array.make",
      name: "make",
      module: "Array",
      package: "effect",
      signature: "<Elements extends NonEmptyArray<any>>(...elements: Elements) => [Elements[number], ...Elements[number][]]",
      description: "Builds a `NonEmptyArray` from an non-empty collection of elements.",
      documentation: 'Builds a `NonEmptyArray` from an non-empty collection of elements.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.make(1, 2, 3)\nconsole.log(result) // [1, 2, 3]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.make(1, 2, 3)\nconsole.log(result) // [1, 2, 3]'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 47,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L47"
    },
    {
      id: "Array.allocate",
      name: "allocate",
      module: "Array",
      package: "effect",
      signature: "<A = never>(n: number) => A[]",
      description: "Creates a new `Array` of the specified length.",
      documentation: 'Creates a new `Array` of the specified length.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.allocate<number>(3)\nconsole.log(result) // [ <3 empty items> ]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.allocate<number>(3)\nconsole.log(result) // [ <3 empty items> ]'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 63,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L63"
    },
    {
      id: "Array.makeBy",
      name: "makeBy",
      module: "Array",
      package: "effect",
      signature: "{ <A>(f: (i: number) => A): (n: number) => [A, ...A[]]; <A>(n: number, f: (i: number) => A): [A, ...A[]]; }",
      description: "Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`. Note. `n` is normalized to an integer >= 1.",
      documentation: 'Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n\n**Note**. `n` is normalized to an integer >= 1.\n\n**Example**\n\n```ts\nimport { makeBy } from "effect/Array"\n\nconst result = makeBy(5, n => n * 2)\nconsole.log(result) // [0, 2, 4, 6, 8]\n```',
      examples: [
        {
          code: 'import { makeBy } from "effect/Array"\n\nconst result = makeBy(5, n => n * 2)\nconsole.log(result) // [0, 2, 4, 6, 8]'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 81,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L81"
    },
    {
      id: "Array.range",
      name: "range",
      module: "Array",
      package: "effect",
      signature: "(start: number, end: number) => [number, ...number[]]",
      description: "Return a `NonEmptyArray` containing a range of integers, including both endpoints.",
      documentation: 'Return a `NonEmptyArray` containing a range of integers, including both endpoints.\n\n**Example**\n\n```ts\nimport { range } from "effect/Array"\n\nconst result = range(1, 3)\nconsole.log(result) // [1, 2, 3]\n```',
      examples: [
        {
          code: 'import { range } from "effect/Array"\n\nconst result = range(1, 3)\nconsole.log(result) // [1, 2, 3]'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 134,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L134"
    },
    {
      id: "Array.replicate",
      name: "replicate",
      module: "Array",
      package: "effect",
      signature: "{ (n: number): <A>(a: A) => [A, ...A[]]; <A>(a: A, n: number): [A, ...A[]]; }",
      description: "Return a `NonEmptyArray` containing a value repeated the specified number of times. Note. `n` is normalized to an integer >= 1.",
      documentation: 'Return a `NonEmptyArray` containing a value repeated the specified number of times.\n\n**Note**. `n` is normalized to an integer >= 1.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.replicate("a", 3)\nconsole.log(result) // ["a", "a", "a"]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.replicate("a", 3)\nconsole.log(result) // ["a", "a", "a"]'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 152,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L152"
    },
    {
      id: "Array.fromIterable",
      name: "fromIterable",
      module: "Array",
      package: "effect",
      signature: "<A>(collection: Iterable<A>) => A[]",
      description: "Creates a new `Array` from an iterable collection of values.\nIf the input is already an array, it returns the input as-is.\nOtherwise, it converts the iterable collection to an array.",
      documentation: 'Creates a new `Array` from an iterable collection of values.\nIf the input is already an array, it returns the input as-is.\nOtherwise, it converts the iterable collection to an array.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.fromIterable(new Set([1, 2, 3]))\nconsole.log(result) // [1, 2, 3]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.fromIterable(new Set([1, 2, 3]))\nconsole.log(result) // [1, 2, 3]'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 207,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L207"
    },
    {
      id: "Array.ensure",
      name: "ensure",
      module: "Array",
      package: "effect",
      signature: "<A>(self: A | readonly A[]) => A[]",
      description: "Creates a new `Array` from a value that might not be an iterable.",
      documentation: 'Creates a new `Array` from a value that might not be an iterable.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconsole.log(Array.ensure("a")) // ["a"]\nconsole.log(Array.ensure(["a"])) // ["a"]\nconsole.log(Array.ensure(["a", "b", "c"])) // ["a", "b", "c"]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconsole.log(Array.ensure("a")) // ["a"]\nconsole.log(Array.ensure(["a"])) // ["a"]\nconsole.log(Array.ensure(["a", "b", "c"])) // ["a", "b", "c"]'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "3.3.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 224,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L224"
    },
    {
      id: "Array.fromRecord",
      name: "fromRecord",
      module: "Array",
      package: "effect",
      signature: "<K extends string, A>(self: Readonly<Record<K, A>>) => [K, A][]",
      description: "Takes a record and returns an array of tuples containing its keys and values.",
      documentation: 'Takes a record and returns an array of tuples containing its keys and values.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.fromRecord({ a: 1, b: 2, c: 3 })\nconsole.log(result) // [["a", 1], ["b", 2], ["c", 3]]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.fromRecord({ a: 1, b: 2, c: 3 })\nconsole.log(result) // [["a", 1], ["b", 2], ["c", 3]]'
        }
      ],
      tags: [
        "conversions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 240,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L240"
    },
    {
      id: "Array.fromOption",
      name: "fromOption",
      module: "Array",
      package: "effect",
      signature: "<A>(self: Option<A>) => A[]",
      description: "Converts an `Option` to an array.",
      documentation: 'Converts an `Option` to an array.\n\n**Example**\n\n```ts\nimport { Array, Option } from "effect"\n\nconsole.log(Array.fromOption(Option.some(1))) // [1]\nconsole.log(Array.fromOption(Option.none())) // []\n```',
      examples: [
        {
          code: 'import { Array, Option } from "effect"\n\nconsole.log(Array.fromOption(Option.some(1))) // [1]\nconsole.log(Array.fromOption(Option.none())) // []'
        }
      ],
      tags: [
        "conversions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 256,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L256"
    },
    {
      id: "Array.match",
      name: "match",
      module: "Array",
      package: "effect",
      signature: "{ <B, A, C = B>(options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (self: readonly [A, ...A[]]) => C; }): (self: readonly A[]) => B | C; <A, B, C = B>(self: readonly A[], options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (self: readonly [A, ...A[]]) => C; }): B | C; }",
      description: "Matches the elements of an array, applying functions to cases of empty and non-empty arrays.",
      documentation: 'Matches the elements of an array, applying functions to cases of empty and non-empty arrays.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst match = Array.match({\n  onEmpty: () => "empty",\n  onNonEmpty: ([head, ...tail]) => `head: ${head}, tail: ${tail.length}`\n})\nconsole.log(match([])) // "empty"\nconsole.log(match([1, 2, 3])) // "head: 1, tail: 2"\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst match = Array.match({\n  onEmpty: () => "empty",\n  onNonEmpty: ([head, ...tail]) => `head: ${head}, tail: ${tail.length}`\n})\nconsole.log(match([])) // "empty"\nconsole.log(match([1, 2, 3])) // "head: 1, tail: 2"'
        }
      ],
      tags: [
        "pattern matching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 276,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L276"
    },
    {
      id: "Array.matchLeft",
      name: "matchLeft",
      module: "Array",
      package: "effect",
      signature: "{ <B, A, C = B>(options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (head: A, tail: A[]) => C; }): (self: readonly A[]) => B | C; <A, B, C = B>(self: readonly A[], options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (head: A, tail: A[]) => C; }): B | C; }",
      description: "Matches the elements of an array from the left, applying functions to cases of empty and non-empty arrays.",
      documentation: 'Matches the elements of an array from the left, applying functions to cases of empty and non-empty arrays.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst matchLeft = Array.matchLeft({\n  onEmpty: () => "empty",\n  onNonEmpty: (head, tail) => `head: ${head}, tail: ${tail.length}`\n})\nconsole.log(matchLeft([])) // "empty"\nconsole.log(matchLeft([1, 2, 3])) // "head: 1, tail: 2"\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst matchLeft = Array.matchLeft({\n  onEmpty: () => "empty",\n  onNonEmpty: (head, tail) => `head: ${head}, tail: ${tail.length}`\n})\nconsole.log(matchLeft([])) // "empty"\nconsole.log(matchLeft([1, 2, 3])) // "head: 1, tail: 2"'
        }
      ],
      tags: [
        "pattern matching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 343,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L343"
    },
    {
      id: "Array.matchRight",
      name: "matchRight",
      module: "Array",
      package: "effect",
      signature: "{ <B, A, C = B>(options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (init: A[], last: A) => C; }): (self: readonly A[]) => B | C; <A, B, C = B>(self: readonly A[], options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (init: A[], last: A) => C; }): B | C; }",
      description: "Matches the elements of an array from the right, applying functions to cases of empty and non-empty arrays.",
      documentation: 'Matches the elements of an array from the right, applying functions to cases of empty and non-empty arrays.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst matchRight = Array.matchRight({\n  onEmpty: () => "empty",\n  onNonEmpty: (init, last) => `init: ${init.length}, last: ${last}`\n})\nconsole.log(matchRight([])) // "empty"\nconsole.log(matchRight([1, 2, 3])) // "init: 2, last: 3"\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst matchRight = Array.matchRight({\n  onEmpty: () => "empty",\n  onNonEmpty: (init, last) => `init: ${init.length}, last: ${last}`\n})\nconsole.log(matchRight([])) // "empty"\nconsole.log(matchRight([1, 2, 3])) // "init: 2, last: 3"'
        }
      ],
      tags: [
        "pattern matching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 410,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L410"
    },
    {
      id: "Array.prepend",
      name: "prepend",
      module: "Array",
      package: "effect",
      signature: "{ <B>(head: B): <A>(self: Iterable<A>) => [B | A, ...(B | A)[]]; <A, B>(self: Iterable<A>, head: B): [A | B, ...(A | B)[]]; }",
      description: "Prepend an element to the front of an `Iterable`, creating a new `NonEmptyArray`.",
      documentation: 'Prepend an element to the front of an `Iterable`, creating a new `NonEmptyArray`.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.prepend([2, 3, 4], 1)\nconsole.log(result) // [1, 2, 3, 4]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.prepend([2, 3, 4], 1)\nconsole.log(result) // [1, 2, 3, 4]'
        }
      ],
      tags: [
        "concatenating"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 473,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L473"
    },
    {
      id: "Array.prependAll",
      name: "prependAll",
      module: "Array",
      package: "effect",
      signature: "{ <S extends Iterable<any>, T extends Iterable<any>>(that: T): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>; <A, B>(self: Iterable<A>, that: readonly [B, ...B[]]): [A | B, ...(A | B)[]]; <A, B>(self: readonly [A, ...A[]], that: Iterable<B>): [A | B, ...(A | B)[]]; <A, B>(self: Iterable<A>, that: Iterable<B>): (A | B)[]; }",
      description: "Prepends the specified prefix array (or iterable) to the beginning of the specified array (or iterable).\nIf either array is non-empty, the result is also a non-empty array.",
      documentation: 'Prepends the specified prefix array (or iterable) to the beginning of the specified array (or iterable).\nIf either array is non-empty, the result is also a non-empty array.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.prependAll([2, 3], [0, 1])\nconsole.log(result) // [0, 1, 2, 3]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.prependAll([2, 3], [0, 1])\nconsole.log(result) // [0, 1, 2, 3]'
        }
      ],
      tags: [
        "concatenating"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 523,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L523"
    },
    {
      id: "Array.append",
      name: "append",
      module: "Array",
      package: "effect",
      signature: "{ <B>(last: B): <A>(self: Iterable<A>) => [B | A, ...(B | A)[]]; <A, B>(self: Iterable<A>, last: B): [A | B, ...(A | B)[]]; }",
      description: "Append an element to the end of an `Iterable`, creating a new `NonEmptyArray`.",
      documentation: 'Append an element to the end of an `Iterable`, creating a new `NonEmptyArray`.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.append([1, 2, 3], 4);\nconsole.log(result) // [1, 2, 3, 4]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.append([1, 2, 3], 4);\nconsole.log(result) // [1, 2, 3, 4]'
        }
      ],
      tags: [
        "concatenating"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 608,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L608"
    },
    {
      id: "Array.appendAll",
      name: "appendAll",
      module: "Array",
      package: "effect",
      signature: "{ <S extends Iterable<any>, T extends Iterable<any>>(that: T): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>; <A, B>(self: Iterable<A>, that: readonly [B, ...B[]]): [A | B, ...(A | B)[]]; <A, B>(self: readonly [A, ...A[]], that: Iterable<B>): [A | B, ...(A | B)[]]; <A, B>(self: Iterable<A>, that: Iterable<B>): (A | B)[]; }",
      description: "Concatenates two arrays (or iterables), combining their elements.\nIf either array is non-empty, the result is also a non-empty array.",
      documentation: "Concatenates two arrays (or iterables), combining their elements.\nIf either array is non-empty, the result is also a non-empty array.",
      examples: [],
      tags: [
        "concatenating"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 649,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L649"
    },
    {
      id: "Array.scan",
      name: "scan",
      module: "Array",
      package: "effect",
      signature: "{ <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => [B, ...B[]]; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): [B, ...B[]]; }",
      description: "Accumulates values from an `Iterable` starting from the left, storing\neach intermediate result in an array. Useful for tracking the progression of\na value through a series of transformations.",
      documentation: 'Accumulates values from an `Iterable` starting from the left, storing\neach intermediate result in an array. Useful for tracking the progression of\na value through a series of transformations.\n\n**Example**\n\n```ts\nimport { Array } from "effect";\n\nconst result = Array.scan([1, 2, 3, 4], 0, (acc, value) => acc + value)\nconsole.log(result) // [0, 1, 3, 6, 10]\n\n// Explanation:\n// This function starts with the initial value (0 in this case)\n// and adds each element of the array to this accumulator one by one,\n// keeping track of the cumulative sum after each addition.\n// Each of these sums is captured in the resulting array.\n```',
      examples: [
        {
          code: 'import { Array } from "effect";\n\nconst result = Array.scan([1, 2, 3, 4], 0, (acc, value) => acc + value)\nconsole.log(result) // [0, 1, 3, 6, 10]\n\n// Explanation:\n// This function starts with the initial value (0 in this case)\n// and adds each element of the array to this accumulator one by one,\n// keeping track of the cumulative sum after each addition.\n// Each of these sums is captured in the resulting array.'
        }
      ],
      tags: [
        "folding"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 706,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L706"
    },
    {
      id: "Array.scanRight",
      name: "scanRight",
      module: "Array",
      package: "effect",
      signature: "{ <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => [B, ...B[]]; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): [B, ...B[]]; }",
      description: "Accumulates values from an `Iterable` starting from the right, storing\neach intermediate result in an array. Useful for tracking the progression of\na value through a series of transformations.",
      documentation: 'Accumulates values from an `Iterable` starting from the right, storing\neach intermediate result in an array. Useful for tracking the progression of\na value through a series of transformations.\n\n**Example**\n\n```ts\nimport { Array } from "effect";\n\nconst result = Array.scanRight([1, 2, 3, 4], 0, (acc, value) => acc + value)\nconsole.log(result) // [10, 9, 7, 4, 0]\n```',
      examples: [
        {
          code: 'import { Array } from "effect";\n\nconst result = Array.scanRight([1, 2, 3, 4], 0, (acc, value) => acc + value)\nconsole.log(result) // [10, 9, 7, 4, 0]'
        }
      ],
      tags: [
        "folding"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 773,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L773"
    },
    {
      id: "Array.isArray",
      name: "isArray",
      module: "Array",
      package: "effect",
      signature: "{ (self: unknown): self is unknown[]; <T>(self: T): self is Extract<T, readonly any[]>; }",
      description: "Determine if `unknown` is an Array.",
      documentation: 'Determine if `unknown` is an Array.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconsole.log(Array.isArray(null)) // false\nconsole.log(Array.isArray([1, 2, 3])) // true\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconsole.log(Array.isArray(null)) // false\nconsole.log(Array.isArray([1, 2, 3])) // true'
        }
      ],
      tags: [
        "guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 826,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L826"
    },
    {
      id: "Array.isEmptyArray",
      name: "isEmptyArray",
      module: "Array",
      package: "effect",
      signature: "<A>(self: A[]) => self is []",
      description: "Determine if an `Array` is empty narrowing down the type to `[]`.",
      documentation: 'Determine if an `Array` is empty narrowing down the type to `[]`.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconsole.log(Array.isEmptyArray([])) // true\nconsole.log(Array.isEmptyArray([1, 2, 3])) // false\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconsole.log(Array.isEmptyArray([])) // true\nconsole.log(Array.isEmptyArray([1, 2, 3])) // false'
        }
      ],
      tags: [
        "guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 875,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L875"
    },
    {
      id: "Array.isEmptyReadonlyArray",
      name: "isEmptyReadonlyArray",
      module: "Array",
      package: "effect",
      signature: "<A>(self: readonly A[]) => self is readonly []",
      description: "Determine if a `ReadonlyArray` is empty narrowing down the type to `readonly []`.",
      documentation: 'Determine if a `ReadonlyArray` is empty narrowing down the type to `readonly []`.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconsole.log(Array.isEmptyReadonlyArray([])) // true\nconsole.log(Array.isEmptyReadonlyArray([1, 2, 3])) // false\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconsole.log(Array.isEmptyReadonlyArray([])) // true\nconsole.log(Array.isEmptyReadonlyArray([1, 2, 3])) // false'
        }
      ],
      tags: [
        "guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 891,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L891"
    },
    {
      id: "Array.isNonEmptyArray",
      name: "isNonEmptyArray",
      module: "Array",
      package: "effect",
      signature: "<A>(self: A[]) => self is [A, ...A[]]",
      description: "Determine if an `Array` is non empty narrowing down the type to `NonEmptyArray`. An `Array` is considered to be a `NonEmptyArray` if it contains at least one element.",
      documentation: 'Determine if an `Array` is non empty narrowing down the type to `NonEmptyArray`.\n\nAn `Array` is considered to be a `NonEmptyArray` if it contains at least one element.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconsole.log(Array.isNonEmptyArray([])) // false\nconsole.log(Array.isNonEmptyArray([1, 2, 3])) // true\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconsole.log(Array.isNonEmptyArray([])) // false\nconsole.log(Array.isNonEmptyArray([1, 2, 3])) // true'
        }
      ],
      tags: [
        "guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 909,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L909"
    },
    {
      id: "Array.isNonEmptyReadonlyArray",
      name: "isNonEmptyReadonlyArray",
      module: "Array",
      package: "effect",
      signature: "<A>(self: readonly A[]) => self is readonly [A, ...A[]]",
      description: "Determine if a `ReadonlyArray` is non empty narrowing down the type to `NonEmptyReadonlyArray`. A `ReadonlyArray` is considered to be a `NonEmptyReadonlyArray` if it contains at least one element.",
      documentation: 'Determine if a `ReadonlyArray` is non empty narrowing down the type to `NonEmptyReadonlyArray`.\n\nA `ReadonlyArray` is considered to be a `NonEmptyReadonlyArray` if it contains at least one element.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconsole.log(Array.isNonEmptyReadonlyArray([])) // false\nconsole.log(Array.isNonEmptyReadonlyArray([1, 2, 3])) // true\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconsole.log(Array.isNonEmptyReadonlyArray([])) // false\nconsole.log(Array.isNonEmptyReadonlyArray([1, 2, 3])) // true'
        }
      ],
      tags: [
        "guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 927,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L927"
    },
    {
      id: "Array.length",
      name: "length",
      module: "Array",
      package: "effect",
      signature: "<A>(self: readonly A[]) => number",
      description: "Return the number of elements in a `ReadonlyArray`.",
      documentation: "Return the number of elements in a `ReadonlyArray`.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 934,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L934"
    },
    {
      id: "Array.get",
      name: "get",
      module: "Array",
      package: "effect",
      signature: "{ (index: number): <A>(self: readonly A[]) => Option<A>; <A>(self: readonly A[], index: number): Option<A>; }",
      description: "This function provides a safe way to read a value at a particular index from a `ReadonlyArray`.",
      documentation: "This function provides a safe way to read a value at a particular index from a `ReadonlyArray`.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 941,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L941"
    },
    {
      id: "Array.unsafeGet",
      name: "unsafeGet",
      module: "Array",
      package: "effect",
      signature: "{ (index: number): <A>(self: readonly A[]) => A; <A>(self: readonly A[], index: number): A; }",
      description: "Gets an element unsafely, will throw on out of bounds.",
      documentation: "Gets an element unsafely, will throw on out of bounds.",
      examples: [],
      tags: [
        "unsafe"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 963,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L963"
    },
    {
      id: "Array.unprepend",
      name: "unprepend",
      module: "Array",
      package: "effect",
      signature: "<A>(self: readonly [A, ...A[]]) => [firstElement: A, remainingElements: A[]]",
      description: "Return a tuple containing the first element, and a new `Array` of the remaining elements, if any.",
      documentation: 'Return a tuple containing the first element, and a new `Array` of the remaining elements, if any.\n\n**Example**\n\n```ts\nimport { Array } from "effect";\n\nconst result = Array.unprepend([1, 2, 3, 4])\nconsole.log(result) // [1, [2, 3, 4]]\n```',
      examples: [
        {
          code: 'import { Array } from "effect";\n\nconst result = Array.unprepend([1, 2, 3, 4])\nconsole.log(result) // [1, [2, 3, 4]]'
        }
      ],
      tags: [
        "splitting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 994,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L994"
    },
    {
      id: "Array.unappend",
      name: "unappend",
      module: "Array",
      package: "effect",
      signature: "<A>(self: readonly [A, ...A[]]) => [arrayWithoutLastElement: A[], lastElement: A]",
      description: "Return a tuple containing a copy of the `NonEmptyReadonlyArray` without its last element, and that last element.",
      documentation: 'Return a tuple containing a copy of the `NonEmptyReadonlyArray` without its last element, and that last element.\n\n**Example**\n\n```ts\nimport { Array } from "effect";\n\nconst result = Array.unappend([1, 2, 3, 4])\nconsole.log(result) // [[1, 2, 3], 4]\n```',
      examples: [
        {
          code: 'import { Array } from "effect";\n\nconst result = Array.unappend([1, 2, 3, 4])\nconsole.log(result) // [[1, 2, 3], 4]'
        }
      ],
      tags: [
        "splitting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 1010,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L1010"
    },
    {
      id: "Array.head",
      name: "head",
      module: "Array",
      package: "effect",
      signature: "<A>(self: readonly A[]) => Option<A>",
      description: "Get the first element of a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.",
      documentation: "Get the first element of a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 1017,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L1017"
    },
    {
      id: "Array.headNonEmpty",
      name: "headNonEmpty",
      module: "Array",
      package: "effect",
      signature: "<A>(self: readonly [A, ...A[]]) => A",
      description: "Get the first element of a non empty array.",
      documentation: 'Get the first element of a non empty array.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.headNonEmpty([1, 2, 3, 4])\nconsole.log(result) // 1\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.headNonEmpty([1, 2, 3, 4])\nconsole.log(result) // 1'
        }
      ],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 1033,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L1033"
    },
    {
      id: "Array.last",
      name: "last",
      module: "Array",
      package: "effect",
      signature: "<A>(self: readonly A[]) => Option<A>",
      description: "Get the last element in a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.",
      documentation: "Get the last element in a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 1040,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L1040"
    },
    {
      id: "Array.lastNonEmpty",
      name: "lastNonEmpty",
      module: "Array",
      package: "effect",
      signature: "<A>(self: readonly [A, ...A[]]) => A",
      description: "Get the last element of a non empty array.",
      documentation: 'Get the last element of a non empty array.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.lastNonEmpty([1, 2, 3, 4])\nconsole.log(result) // 4\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.lastNonEmpty([1, 2, 3, 4])\nconsole.log(result) // 4'
        }
      ],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 1056,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L1056"
    },
    {
      id: "Array.tail",
      name: "tail",
      module: "Array",
      package: "effect",
      signature: "<A>(self: Iterable<A>) => Option<A[]>",
      description: "Get all but the first element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.",
      documentation: "Get all but the first element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 1063,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L1063"
    },
    {
      id: "Array.tailNonEmpty",
      name: "tailNonEmpty",
      module: "Array",
      package: "effect",
      signature: "<A>(self: readonly [A, ...A[]]) => A[]",
      description: "Get all but the first element of a `NonEmptyReadonlyArray`.",
      documentation: 'Get all but the first element of a `NonEmptyReadonlyArray`.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.tailNonEmpty([1, 2, 3, 4])\nconsole.log(result) // [2, 3, 4]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.tailNonEmpty([1, 2, 3, 4])\nconsole.log(result) // [2, 3, 4]'
        }
      ],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 1079,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L1079"
    },
    {
      id: "Array.init",
      name: "init",
      module: "Array",
      package: "effect",
      signature: "<A>(self: Iterable<A>) => Option<A[]>",
      description: "Get all but the last element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.",
      documentation: "Get all but the last element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 1086,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L1086"
    },
    {
      id: "Array.initNonEmpty",
      name: "initNonEmpty",
      module: "Array",
      package: "effect",
      signature: "<A>(self: readonly [A, ...A[]]) => A[]",
      description: "Get all but the last element of a non empty array, creating a new array.",
      documentation: 'Get all but the last element of a non empty array, creating a new array.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.initNonEmpty([1, 2, 3, 4])\nconsole.log(result) // [1, 2, 3]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.initNonEmpty([1, 2, 3, 4])\nconsole.log(result) // [1, 2, 3]'
        }
      ],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 1102,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L1102"
    },
    {
      id: "Array.take",
      name: "take",
      module: "Array",
      package: "effect",
      signature: "{ (n: number): <A>(self: Iterable<A>) => A[]; <A>(self: Iterable<A>, n: number): A[]; }",
      description: "Keep only a max number of elements from the start of an `Iterable`, creating a new `Array`. Note. `n` is normalized to a non negative integer.",
      documentation: 'Keep only a max number of elements from the start of an `Iterable`, creating a new `Array`.\n\n**Note**. `n` is normalized to a non negative integer.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.take([1, 2, 3, 4, 5], 3)\nconsole.log(result) // [1, 2, 3]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.take([1, 2, 3, 4, 5], 3)\nconsole.log(result) // [1, 2, 3]'
        }
      ],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 1120,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L1120"
    },
    {
      id: "Array.takeRight",
      name: "takeRight",
      module: "Array",
      package: "effect",
      signature: "{ (n: number): <A>(self: Iterable<A>) => A[]; <A>(self: Iterable<A>, n: number): A[]; }",
      description: "Keep only a max number of elements from the end of an `Iterable`, creating a new `Array`. Note. `n` is normalized to a non negative integer.",
      documentation: 'Keep only a max number of elements from the end of an `Iterable`, creating a new `Array`.\n\n**Note**. `n` is normalized to a non negative integer.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.takeRight([1, 2, 3, 4, 5], 3)\nconsole.log(result) // [3, 4, 5]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.takeRight([1, 2, 3, 4, 5], 3)\nconsole.log(result) // [3, 4, 5]'
        }
      ],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 1175,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L1175"
    },
    {
      id: "Array.takeWhile",
      name: "takeWhile",
      module: "Array",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => B[]; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => A[]; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): B[]; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): A[]; }",
      description: "Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.",
      documentation: 'Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.takeWhile([1, 3, 2, 4, 1, 2], x => x < 4)\nconsole.log(result) // [1, 3, 2]\n\n// Explanation:\n// - The function starts with the first element (`1`), which is less than `4`, so it adds `1` to the result.\n// - The next element (`3`) is also less than `4`, so it adds `3`.\n// - The next element (`2`) is again less than `4`, so it adds `2`.\n// - The function then encounters `4`, which is not less than `4`. At this point, it stops checking further elements and finalizes the result.\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.takeWhile([1, 3, 2, 4, 1, 2], x => x < 4)\nconsole.log(result) // [1, 3, 2]\n\n// Explanation:\n// - The function starts with the first element (`1`), which is less than `4`, so it adds `1` to the result.\n// - The next element (`3`) is also less than `4`, so it adds `3`.\n// - The next element (`2`) is again less than `4`, so it adds `2`.\n// - The function then encounters `4`, which is not less than `4`. At this point, it stops checking further elements and finalizes the result.'
        }
      ],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 1234,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L1234"
    },
    {
      id: "Array.span",
      name: "span",
      module: "Array",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => [init: B[], rest: Exclude<A, B>[]]; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [init: A[], rest: A[]]; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): [init: B[], rest: Exclude<A, B>[]]; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [init: A[], rest: A[]]; }",
      description: "Split an `Iterable` into two parts: 1. the longest initial subarray for which all elements satisfy the specified predicate\n2. the remaining elements",
      documentation: "Split an `Iterable` into two parts:\n\n1. the longest initial subarray for which all elements satisfy the specified predicate\n2. the remaining elements",
      examples: [],
      tags: [
        "splitting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 1333,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L1333"
    },
    {
      id: "Array.drop",
      name: "drop",
      module: "Array",
      package: "effect",
      signature: "{ (n: number): <A>(self: Iterable<A>) => A[]; <A>(self: Iterable<A>, n: number): A[]; }",
      description: "Drop a max number of elements from the start of an `Iterable`, creating a new `Array`. Note. `n` is normalized to a non negative integer.",
      documentation: 'Drop a max number of elements from the start of an `Iterable`, creating a new `Array`.\n\n**Note**. `n` is normalized to a non negative integer.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.drop([1, 2, 3, 4, 5], 2)\nconsole.log(result) // [3, 4, 5]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.drop([1, 2, 3, 4, 5], 2)\nconsole.log(result) // [3, 4, 5]'
        }
      ],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 1392,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L1392"
    },
    {
      id: "Array.dropRight",
      name: "dropRight",
      module: "Array",
      package: "effect",
      signature: "{ (n: number): <A>(self: Iterable<A>) => A[]; <A>(self: Iterable<A>, n: number): A[]; }",
      description: "Drop a max number of elements from the end of an `Iterable`, creating a new `Array`. Note. `n` is normalized to a non negative integer.",
      documentation: 'Drop a max number of elements from the end of an `Iterable`, creating a new `Array`.\n\n**Note**. `n` is normalized to a non negative integer.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.dropRight([1, 2, 3, 4, 5], 2)\nconsole.log(result) // [1, 2, 3]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.dropRight([1, 2, 3, 4, 5], 2)\nconsole.log(result) // [1, 2, 3]'
        }
      ],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 1447,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L1447"
    },
    {
      id: "Array.dropWhile",
      name: "dropWhile",
      module: "Array",
      package: "effect",
      signature: "{ <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => A[]; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): A[]; }",
      description: "Remove the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.",
      documentation: 'Remove the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.dropWhile([1, 2, 3, 4, 5], x => x < 4)\nconsole.log(result) // [4, 5]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.dropWhile([1, 2, 3, 4, 5], x => x < 4)\nconsole.log(result) // [4, 5]'
        }
      ],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 1500,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L1500"
    },
    {
      id: "Array.findFirstIndex",
      name: "findFirstIndex",
      module: "Array",
      package: "effect",
      signature: "{ <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<number>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<number>; }",
      description: "Return the first index for which a predicate holds.",
      documentation: 'Return the first index for which a predicate holds.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.findFirstIndex([5, 3, 8, 9], x => x > 5)\nconsole.log(result) // Option.some(2)\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.findFirstIndex([5, 3, 8, 9], x => x > 5)\nconsole.log(result) // Option.some(2)'
        }
      ],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 1549,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L1549"
    },
    {
      id: "Array.findLastIndex",
      name: "findLastIndex",
      module: "Array",
      package: "effect",
      signature: "{ <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<number>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<number>; }",
      description: "Return the last index for which a predicate holds.",
      documentation: 'Return the last index for which a predicate holds.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.findLastIndex([1, 3, 8, 9], x => x < 5)\nconsole.log(result) // Option.some(1)\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.findLastIndex([1, 3, 8, 9], x => x < 5)\nconsole.log(result) // Option.some(1)'
        }
      ],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 1598,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L1598"
    },
    {
      id: "Array.findFirst",
      name: "findFirst",
      module: "Array",
      package: "effect",
      signature: "{ <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<B>; <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<A>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<B>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<A>; }",
      description: "Returns the first element that satisfies the specified\npredicate, or `None` if no such element exists.",
      documentation: 'Returns the first element that satisfies the specified\npredicate, or `None` if no such element exists.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.findFirst([1, 2, 3, 4, 5], x => x > 3)\nconsole.log(result) // Option.some(4)\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.findFirst([1, 2, 3, 4, 5], x => x > 3)\nconsole.log(result) // Option.some(4)'
        }
      ],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 1648,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L1648"
    },
    {
      id: "Array.findLast",
      name: "findLast",
      module: "Array",
      package: "effect",
      signature: "{ <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<B>; <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<A>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<B>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<A>; }",
      description: "Finds the last element in an iterable collection that satisfies the given predicate or refinement.\nReturns an `Option` containing the found element, or `Option.none` if no element matches.",
      documentation: 'Finds the last element in an iterable collection that satisfies the given predicate or refinement.\nReturns an `Option` containing the found element, or `Option.none` if no element matches.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.findLast([1, 2, 3, 4, 5], n => n % 2 === 0)\nconsole.log(result) // Option.some(4)\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.findLast([1, 2, 3, 4, 5], n => n % 2 === 0)\nconsole.log(result) // Option.some(4)'
        }
      ],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 1768,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L1768"
    },
    {
      id: "Array.findFirstWithIndex",
      name: "findFirstWithIndex",
      module: "Array",
      package: "effect",
      signature: "{ <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<[B, number]>; <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<[B, number]>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<[A, number]>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<[B, number]>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<[B, number]>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<[A, number]>; }",
      description: "Returns a tuple of the first element that satisfies the specified\npredicate and its index, or `None` if no such element exists.",
      documentation: 'Returns a tuple of the first element that satisfies the specified\npredicate and its index, or `None` if no such element exists.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.findFirstWithIndex([1, 2, 3, 4, 5], x => x > 3)\nconsole.log(result) // Option.some([4, 3])\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.findFirstWithIndex([1, 2, 3, 4, 5], x => x > 3)\nconsole.log(result) // Option.some([4, 3])'
        }
      ],
      tags: [
        "elements"
      ],
      since: "3.17.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 1888,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L1888"
    },
    {
      id: "Array.countBy",
      name: "countBy",
      module: "Array",
      package: "effect",
      signature: "{ <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => number; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): number; }",
      description: "Counts all the element of the given array that pass the given predicate",
      documentation: 'Counts all the element of the given array that pass the given predicate\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.countBy([1, 2, 3, 4, 5], n => n % 2 === 0)\nconsole.log(result) // 2\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.countBy([1, 2, 3, 4, 5], n => n % 2 === 0)\nconsole.log(result) // 2'
        }
      ],
      tags: [
        "folding"
      ],
      since: "3.16.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 2007,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L2007"
    },
    {
      id: "Array.insertAt",
      name: "insertAt",
      module: "Array",
      package: "effect",
      signature: "{ <B>(i: number, b: B): <A>(self: Iterable<A>) => Option<[B | A, ...(B | A)[]]>; <A, B>(self: Iterable<A>, i: number, b: B): Option<[A | B, ...(A | B)[]]>; }",
      description: "Insert an element at the specified index, creating a new `NonEmptyArray`,\nor return `None` if the index is out of bounds.",
      documentation: "Insert an element at the specified index, creating a new `NonEmptyArray`,\nor return `None` if the index is out of bounds.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.insertAt(['a', 'b', 'c', 'e'], 3, 'd')\nconsole.log(result) // Option.some(['a', 'b', 'c', 'd', 'e'])\n```",
      examples: [
        {
          code: `import { Array } from "effect"

const result = Array.insertAt(['a', 'b', 'c', 'e'], 3, 'd')
console.log(result) // Option.some(['a', 'b', 'c', 'd', 'e'])`
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 2056,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L2056"
    },
    {
      id: "Array.replace",
      name: "replace",
      module: "Array",
      package: "effect",
      signature: "{ <B>(i: number, b: B): <A, S extends Iterable<A> = Iterable<A>>(self: S) => ReadonlyArray.With<S, B | ReadonlyArray.Infer<S>>; <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, b: B): ReadonlyArray.With<S, B | ReadonlyArray.Infer<S>>; }",
      description: "Change the element at the specified index, creating a new `Array`,\nor return a copy of the input if the index is out of bounds.",
      documentation: "Change the element at the specified index, creating a new `Array`,\nor return a copy of the input if the index is out of bounds.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.replace(['a', 'b', 'c', 'd'], 1, 'z')\nconsole.log(result) // ['a', 'z', 'c', 'd']\n```",
      examples: [
        {
          code: `import { Array } from "effect"

const result = Array.replace(['a', 'b', 'c', 'd'], 1, 'z')
console.log(result) // ['a', 'z', 'c', 'd']`
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 2105,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L2105"
    },
    {
      id: "Array.replaceOption",
      name: "replaceOption",
      module: "Array",
      package: "effect",
      signature: "{ <B>(i: number, b: B): <A, S extends Iterable<A> = Iterable<A>>(self: S) => Option<ReadonlyArray.With<S, B | ReadonlyArray.Infer<S>>>; <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, b: B): Option<ReadonlyArray.With<S, B | ReadonlyArray.Infer<S>>>; }",
      description: "Replaces an element in an array with the given value, returning an option of the updated array.",
      documentation: 'Replaces an element in an array with the given value, returning an option of the updated array.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.replaceOption([1, 2, 3], 1, 4)\nconsole.log(result) // Option.some([1, 4, 3])\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.replaceOption([1, 2, 3], 1, 4)\nconsole.log(result) // Option.some([1, 4, 3])'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 2153,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L2153"
    },
    {
      id: "Array.modify",
      name: "modify",
      module: "Array",
      package: "effect",
      signature: "{ <A, B, S extends Iterable<A> = Iterable<A>>(i: number, f: (a: ReadonlyArray.Infer<S>) => B): (self: S) => ReadonlyArray.With<S, B | ReadonlyArray.Infer<S>>; <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, f: (a: ReadonlyArray.Infer<S>) => B): ReadonlyArray.With<S, B | ReadonlyArray.Infer<S>>; }",
      description: "Apply a function to the element at the specified index, creating a new `Array`,\nor return a copy of the input if the index is out of bounds.",
      documentation: 'Apply a function to the element at the specified index, creating a new `Array`,\nor return a copy of the input if the index is out of bounds.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.modify([1, 2, 3, 4], 2, (n) => n * 2)\nconsole.log(result) // [1, 2, 6, 4]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.modify([1, 2, 3, 4], 2, (n) => n * 2)\nconsole.log(result) // [1, 2, 6, 4]'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 2200,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L2200"
    },
    {
      id: "Array.modifyOption",
      name: "modifyOption",
      module: "Array",
      package: "effect",
      signature: "{ <A, B, S extends Iterable<A> = Iterable<A>>(i: number, f: (a: ReadonlyArray.Infer<S>) => B): (self: S) => Option<ReadonlyArray.With<S, B | ReadonlyArray.Infer<S>>>; <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, f: (a: ReadonlyArray.Infer<S>) => B): Option<ReadonlyArray.With<S, B | ReadonlyArray.Infer<S>>>; }",
      description: "Apply a function to the element at the specified index, creating a new `Array`,\nor return `None` if the index is out of bounds.",
      documentation: 'Apply a function to the element at the specified index, creating a new `Array`,\nor return `None` if the index is out of bounds.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst input = [1, 2, 3, 4]\nconst result = Array.modifyOption(input, 2, (n) => n * 2)\nconsole.log(result) // Option.some([1, 2, 6, 4])\n\nconst outOfBoundsResult = Array.modifyOption(input, 5, (n) => n * 2)\nconsole.log(outOfBoundsResult) // Option.none()\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst input = [1, 2, 3, 4]\nconst result = Array.modifyOption(input, 2, (n) => n * 2)\nconsole.log(result) // Option.some([1, 2, 6, 4])\n\nconst outOfBoundsResult = Array.modifyOption(input, 5, (n) => n * 2)\nconsole.log(outOfBoundsResult) // Option.none()'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 2253,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L2253"
    },
    {
      id: "Array.remove",
      name: "remove",
      module: "Array",
      package: "effect",
      signature: "{ (i: number): <A>(self: Iterable<A>) => A[]; <A>(self: Iterable<A>, i: number): A[]; }",
      description: "Delete the element at the specified index, creating a new `Array`,\nor return a copy of the input if the index is out of bounds.",
      documentation: 'Delete the element at the specified index, creating a new `Array`,\nor return a copy of the input if the index is out of bounds.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst input = [1, 2, 3, 4]\nconst result = Array.remove(input, 2)\nconsole.log(result) // [1, 2, 4]\n\nconst outOfBoundsResult = Array.remove(input, 5)\nconsole.log(outOfBoundsResult) // [1, 2, 3, 4]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst input = [1, 2, 3, 4]\nconst result = Array.remove(input, 2)\nconsole.log(result) // [1, 2, 4]\n\nconst outOfBoundsResult = Array.remove(input, 5)\nconsole.log(outOfBoundsResult) // [1, 2, 3, 4]'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 2314,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L2314"
    },
    {
      id: "Array.removeOption",
      name: "removeOption",
      module: "Array",
      package: "effect",
      signature: "{ (i: number): <A>(self: Iterable<A>) => Option<A[]>; <A>(self: Iterable<A>, i: number): Option<A[]>; }",
      description: "Delete the element at the specified index, creating a new `Array`,\nor return `None` if the index is out of bounds.",
      documentation: "Delete the element at the specified index, creating a new `Array`,\nor return `None` if the index is out of bounds.",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Array, Option } from "effect"\n\nconst numbers = [1, 2, 3, 4]\nconst result = Array.removeOption(numbers, 2)\nassert.deepStrictEqual(result, Option.some([1, 2, 4]))\n\nconst outOfBoundsResult = Array.removeOption(numbers, 5)\nassert.deepStrictEqual(outOfBoundsResult, Option.none())'
        }
      ],
      tags: [],
      since: "3.16.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 2375,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L2375"
    },
    {
      id: "Array.reverse",
      name: "reverse",
      module: "Array",
      package: "effect",
      signature: "<S extends Iterable<any>>(self: S) => S extends readonly [infer A, ...(infer A)[]] ? [A, ...A[]] : S extends Iterable<infer A> ? A[] : never",
      description: "Reverse an `Iterable`, creating a new `Array`.",
      documentation: 'Reverse an `Iterable`, creating a new `Array`.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.reverse([1, 2, 3, 4])\nconsole.log(result) // [4, 3, 2, 1]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.reverse([1, 2, 3, 4])\nconsole.log(result) // [4, 3, 2, 1]'
        }
      ],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 2432,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L2432"
    },
    {
      id: "Array.sort",
      name: "sort",
      module: "Array",
      package: "effect",
      signature: "{ <B>(O: Order<B>): <A extends B, S extends Iterable<A>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A extends B, B>(self: readonly [A, ...A[]], O: Order<B>): [A, ...A[]]; <A extends B, B>(self: Iterable<A>, O: Order<B>): A[]; }",
      description: "Create a new array with elements sorted in increasing order based on the specified comparator.\nIf the input is a `NonEmptyReadonlyArray`, the output will also be a `NonEmptyReadonlyArray`.",
      documentation: "Create a new array with elements sorted in increasing order based on the specified comparator.\nIf the input is a `NonEmptyReadonlyArray`, the output will also be a `NonEmptyReadonlyArray`.",
      examples: [],
      tags: [
        "sorting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 2440,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L2440"
    },
    {
      id: "Array.sortWith",
      name: "sortWith",
      module: "Array",
      package: "effect",
      signature: "{ <S extends Iterable<any>, B>(f: (a: ReadonlyArray.Infer<S>) => B, order: Order<B>): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A, B>(self: readonly [A, ...A[]], f: (a: A) => B, O: Order<B>): [A, ...A[]]; <A, B>(self: Iterable<A>, f: (a: A) => B, order: Order<B>): A[]; }",
      description: "Sorts an array based on a provided mapping function and order. The mapping\nfunction transforms the elements into a value that can be compared, and the\norder defines how those values should be sorted.",
      documentation: 'Sorts an array based on a provided mapping function and order. The mapping\nfunction transforms the elements into a value that can be compared, and the\norder defines how those values should be sorted.\n\n**Example**\n\n```ts\nimport { Array, Order } from "effect"\n\nconst result = Array.sortWith(["aaa", "b", "cc"], (s) => s.length, Order.number)\nconsole.log(result) // ["b", "cc", "aaa"]\n\n// Explanation:\n// The array of strings is sorted based on their lengths. The mapping function `(s) => s.length`\n// converts each string into its length, and the `Order.number` specifies that the lengths should\n// be sorted in ascending order.\n```',
      examples: [
        {
          code: 'import { Array, Order } from "effect"\n\nconst result = Array.sortWith(["aaa", "b", "cc"], (s) => s.length, Order.number)\nconsole.log(result) // ["b", "cc", "aaa"]\n\n// Explanation:\n// The array of strings is sorted based on their lengths. The mapping function `(s) => s.length`\n// converts each string into its length, and the `Order.number` specifies that the lengths should\n// be sorted in ascending order.'
        }
      ],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 2488,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L2488"
    },
    {
      id: "Array.sortBy",
      name: "sortBy",
      module: "Array",
      package: "effect",
      signature: "<S extends Iterable<any>>(...orders: readonly Order<ReadonlyArray.Infer<S>>[]) => (self: S) => S extends readonly [infer A, ...(infer A)[]] ? [A, ...A[]] : S extends Iterable<infer A> ? A[] : never",
      description: "Sorts the elements of an `Iterable` in increasing order based on the provided\norders. The elements are compared using the first order in `orders`, then the\nsecond order if the first comparison is equal, and so on.",
      documentation: 'Sorts the elements of an `Iterable` in increasing order based on the provided\norders. The elements are compared using the first order in `orders`, then the\nsecond order if the first comparison is equal, and so on.\n\n**Example**\n\n```ts\nimport { Array, Order, pipe } from "effect"\n\nconst users = [\n  { name: "Alice", age: 30 },\n  { name: "Bob", age: 25 },\n  { name: "Charlie", age: 30 }\n]\n\nconst result = pipe(\n  users,\n  Array.sortBy(\n    Order.mapInput(Order.number, (user: (typeof users)[number]) => user.age),\n    Order.mapInput(Order.string, (user: (typeof users)[number]) => user.name)\n  )\n)\n\nconsole.log(result)\n// [\n//   { name: "Bob", age: 25 },\n//   { name: "Alice", age: 30 },\n//   { name: "Charlie", age: 30 }\n// ]\n\n// Explanation:\n// The array of users is sorted first by age in ascending order. When ages are equal,\n// the users are further sorted by name in ascending order.\n```',
      examples: [
        {
          code: 'import { Array, Order, pipe } from "effect"\n\nconst users = [\n  { name: "Alice", age: 30 },\n  { name: "Bob", age: 25 },\n  { name: "Charlie", age: 30 }\n]\n\nconst result = pipe(\n  users,\n  Array.sortBy(\n    Order.mapInput(Order.number, (user: (typeof users)[number]) => user.age),\n    Order.mapInput(Order.string, (user: (typeof users)[number]) => user.name)\n  )\n)\n\nconsole.log(result)\n// [\n//   { name: "Bob", age: 25 },\n//   { name: "Alice", age: 30 },\n//   { name: "Charlie", age: 30 }\n// ]\n\n// Explanation:\n// The array of users is sorted first by age in ascending order. When ages are equal,\n// the users are further sorted by name in ascending order.'
        }
      ],
      tags: [
        "sorting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 2598,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L2598"
    },
    {
      id: "Array.zip",
      name: "zip",
      module: "Array",
      package: "effect",
      signature: "{ <B>(that: readonly [B, ...B[]]): <A>(self: readonly [A, ...A[]]) => [[A, B], ...[A, B][]]; <B>(that: Iterable<B>): <A>(self: Iterable<A>) => [A, B][]; <A, B>(self: readonly [A, ...A[]], that: readonly [B, ...B[]]): [[A, B], ...[A, B][]]; <A, B>(self: Iterable<A>, that: Iterable<B>): [A, B][]; }",
      description: "Takes two `Iterable`s and returns an `Array` of corresponding pairs.\nIf one input `Iterable` is short, excess elements of the\nlonger `Iterable` are discarded.",
      documentation: "Takes two `Iterable`s and returns an `Array` of corresponding pairs.\nIf one input `Iterable` is short, excess elements of the\nlonger `Iterable` are discarded.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.zip([1, 2, 3], ['a', 'b'])\nconsole.log(result) // [[1, 'a'], [2, 'b']]\n```",
      examples: [
        {
          code: `import { Array } from "effect"

const result = Array.zip([1, 2, 3], ['a', 'b'])
console.log(result) // [[1, 'a'], [2, 'b']]`
        }
      ],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 2616,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L2616"
    },
    {
      id: "Array.zipWith",
      name: "zipWith",
      module: "Array",
      package: "effect",
      signature: "{ <B, A, C>(that: readonly [B, ...B[]], f: (a: A, b: B) => C): (self: readonly [A, ...A[]]) => [C, ...C[]]; <B, A, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => C[]; <A, B, C>(self: readonly [A, ...A[]], that: readonly [B, ...B[]], f: (a: A, b: B) => C): [C, ...C[]]; <B, A, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): C[]; }",
      description: "Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one\ninput `Iterable` is short, excess elements of the longer `Iterable` are discarded.",
      documentation: 'Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one\ninput `Iterable` is short, excess elements of the longer `Iterable` are discarded.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.zipWith([1, 2, 3], [4, 5, 6], (a, b) => a + b)\nconsole.log(result) // [5, 7, 9]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.zipWith([1, 2, 3], [4, 5, 6], (a, b) => a + b)\nconsole.log(result) // [5, 7, 9]'
        }
      ],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 2706,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L2706"
    },
    {
      id: "Array.unzip",
      name: "unzip",
      module: "Array",
      package: "effect",
      signature: "<S extends Iterable<readonly [any, any]>>(self: S) => S extends readonly [readonly [infer A, infer B], ...(readonly [infer A, infer B])[]] ? [[A, ...A[]], [B, ...B[]]] : S extends Iterable<readonly [infer A, infer B]> ? [A[], B[]] : never",
      description: "This function is the inverse of `zip`. Takes an `Iterable` of pairs and return two corresponding `Array`s.",
      documentation: 'This function is the inverse of `zip`. Takes an `Iterable` of pairs and return two corresponding `Array`s.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.unzip([[1, "a"], [2, "b"], [3, "c"]])\nconsole.log(result) // [[1, 2, 3], [\'a\', \'b\', \'c\']]\n```',
      examples: [
        {
          code: `import { Array } from "effect"

const result = Array.unzip([[1, "a"], [2, "b"], [3, "c"]])
console.log(result) // [[1, 2, 3], ['a', 'b', 'c']]`
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 2790,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L2790"
    },
    {
      id: "Array.intersperse",
      name: "intersperse",
      module: "Array",
      package: "effect",
      signature: "{ <B>(middle: B): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, B | ReadonlyArray.Infer<S>>; <A, B>(self: readonly [A, ...A[]], middle: B): [A | B, ...(A | B)[]]; <A, B>(self: Iterable<A>, middle: B): (A | B)[]; }",
      description: "Places an element in between members of an `Iterable`.\nIf the input is a non-empty array, the result is also a non-empty array.",
      documentation: 'Places an element in between members of an `Iterable`.\nIf the input is a non-empty array, the result is also a non-empty array.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.intersperse([1, 2, 3], 0)\nconsole.log(result) // [1, 0, 2, 0, 3]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.intersperse([1, 2, 3], 0)\nconsole.log(result) // [1, 0, 2, 0, 3]'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 2806,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L2806"
    },
    {
      id: "Array.modifyNonEmptyHead",
      name: "modifyNonEmptyHead",
      module: "Array",
      package: "effect",
      signature: "{ <A, B>(f: (a: A) => B): (self: readonly [A, ...A[]]) => [A | B, ...(A | B)[]]; <A, B>(self: readonly [A, ...A[]], f: (a: A) => B): [A | B, ...(A | B)[]]; }",
      description: "Apply a function to the head, creating a new `NonEmptyReadonlyArray`.",
      documentation: 'Apply a function to the head, creating a new `NonEmptyReadonlyArray`.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.modifyNonEmptyHead([1, 2, 3], n => n * 10)\nconsole.log(result) // [10, 2, 3]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.modifyNonEmptyHead([1, 2, 3], n => n * 10)\nconsole.log(result) // [10, 2, 3]'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 2870,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L2870"
    },
    {
      id: "Array.setNonEmptyHead",
      name: "setNonEmptyHead",
      module: "Array",
      package: "effect",
      signature: "{ <B>(b: B): <A>(self: readonly [A, ...A[]]) => [B | A, ...(B | A)[]]; <A, B>(self: readonly [A, ...A[]], b: B): [A | B, ...(A | B)[]]; }",
      description: "Change the head, creating a new `NonEmptyReadonlyArray`.",
      documentation: 'Change the head, creating a new `NonEmptyReadonlyArray`.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.setNonEmptyHead([1, 2, 3], 10)\nconsole.log(result) // [10, 2, 3]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.setNonEmptyHead([1, 2, 3], 10)\nconsole.log(result) // [10, 2, 3]'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 2916,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L2916"
    },
    {
      id: "Array.modifyNonEmptyLast",
      name: "modifyNonEmptyLast",
      module: "Array",
      package: "effect",
      signature: "{ <A, B>(f: (a: A) => B): (self: readonly [A, ...A[]]) => [A | B, ...(A | B)[]]; <A, B>(self: readonly [A, ...A[]], f: (a: A) => B): [A | B, ...(A | B)[]]; }",
      description: "Apply a function to the last element, creating a new `NonEmptyReadonlyArray`.",
      documentation: 'Apply a function to the last element, creating a new `NonEmptyReadonlyArray`.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.modifyNonEmptyLast([1, 2, 3], n => n * 2)\nconsole.log(result) // [1, 2, 6]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.modifyNonEmptyLast([1, 2, 3], n => n * 2)\nconsole.log(result) // [1, 2, 6]'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 2962,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L2962"
    },
    {
      id: "Array.setNonEmptyLast",
      name: "setNonEmptyLast",
      module: "Array",
      package: "effect",
      signature: "{ <B>(b: B): <A>(self: readonly [A, ...A[]]) => [B | A, ...(B | A)[]]; <A, B>(self: readonly [A, ...A[]], b: B): [A | B, ...(A | B)[]]; }",
      description: "Change the last element, creating a new `NonEmptyReadonlyArray`.",
      documentation: 'Change the last element, creating a new `NonEmptyReadonlyArray`.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.setNonEmptyLast([1, 2, 3], 4)\nconsole.log(result) // [1, 2, 4]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.setNonEmptyLast([1, 2, 3], 4)\nconsole.log(result) // [1, 2, 4]'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 3008,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L3008"
    },
    {
      id: "Array.rotate",
      name: "rotate",
      module: "Array",
      package: "effect",
      signature: "{ (n: number): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A>(self: readonly [A, ...A[]], n: number): [A, ...A[]]; <A>(self: Iterable<A>, n: number): A[]; }",
      description: "Rotate an `Iterable` by `n` steps.\nIf the input is a non-empty array, the result is also a non-empty array.",
      documentation: "Rotate an `Iterable` by `n` steps.\nIf the input is a non-empty array, the result is also a non-empty array.\n\n**Example**\n\n```ts\nimport { Array } from \"effect\"\n\nconst result = Array.rotate(['a', 'b', 'c', 'd', 'e'], 2)\nconsole.log(result) // [ 'd', 'e', 'a', 'b', 'c' ]\n```",
      examples: [
        {
          code: `import { Array } from "effect"

const result = Array.rotate(['a', 'b', 'c', 'd', 'e'], 2)
console.log(result) // [ 'd', 'e', 'a', 'b', 'c' ]`
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 3055,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L3055"
    },
    {
      id: "Array.containsWith",
      name: "containsWith",
      module: "Array",
      package: "effect",
      signature: "<A>(isEquivalent: (self: A, that: A) => boolean) => { (a: A): (self: Iterable<A>) => boolean; (self: Iterable<A>, a: A): boolean; }",
      description: "Returns a function that checks if a `ReadonlyArray` contains a given value using a provided `isEquivalent` function.",
      documentation: 'Returns a function that checks if a `ReadonlyArray` contains a given value using a provided `isEquivalent` function.\n\n**Example**\n\n```ts\nimport { Array, pipe } from "effect"\n\nconst isEquivalent = (a: number, b: number) => a === b\nconst containsNumber = Array.containsWith(isEquivalent)\nconst result = pipe([1, 2, 3, 4], containsNumber(3))\nconsole.log(result) // true\n```',
      examples: [
        {
          code: 'import { Array, pipe } from "effect"\n\nconst isEquivalent = (a: number, b: number) => a === b\nconst containsNumber = Array.containsWith(isEquivalent)\nconst result = pipe([1, 2, 3, 4], containsNumber(3))\nconsole.log(result) // true'
        }
      ],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 3122,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L3122"
    },
    {
      id: "Array.contains",
      name: "contains",
      module: "Array",
      package: "effect",
      signature: "{ <A>(a: A): (self: Iterable<A>) => boolean; <A>(self: Iterable<A>, a: A): boolean; }",
      description: "Returns a function that checks if a `ReadonlyArray` contains a given value using the default `Equivalence`.",
      documentation: "Returns a function that checks if a `ReadonlyArray` contains a given value using the default `Equivalence`.\n\n**Example**\n\n```ts\nimport { Array, pipe } from \"effect\"\n\nconst result = pipe(['a', 'b', 'c', 'd'], Array.contains('c'))\nconsole.log(result) // true\n```",
      examples: [
        {
          code: `import { Array, pipe } from "effect"

const result = pipe(['a', 'b', 'c', 'd'], Array.contains('c'))
console.log(result) // true`
        }
      ],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 3141,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L3141"
    },
    {
      id: "Array.chop",
      name: "chop",
      module: "Array",
      package: "effect",
      signature: "{ <S extends Iterable<any>, B>(f: (as: readonly [ReadonlyArray.Infer<S>, ...ReadonlyArray.Infer<S>[]]) => readonly [B, readonly ReadonlyArray.Infer<S>[]]): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A, B>(self: readonly [A, ...A[]], f: (as: readonly [A, ...A[]]) => readonly [B, readonly A[]]): [B, ...B[]]; <A, B>(self: Iterable<A>, f: (as: readonly [A, ...A[]]) => readonly [B, readonly A[]]): B[]; }",
      description: 'A useful recursion pattern for processing an `Iterable` to produce a new `Array`, often used for "chopping" up the input\n`Iterable`. Typically chop is called with some function that will consume an initial prefix of the `Iterable` and produce a\nvalue and the rest of the `Array`.',
      documentation: 'A useful recursion pattern for processing an `Iterable` to produce a new `Array`, often used for "chopping" up the input\n`Iterable`. Typically chop is called with some function that will consume an initial prefix of the `Iterable` and produce a\nvalue and the rest of the `Array`.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.chop([1, 2, 3, 4, 5], (as): [number, Array<number>] => [as[0] * 2, as.slice(1)])\nconsole.log(result) // [2, 4, 6, 8, 10]\n\n// Explanation:\n// The `chopFunction` takes the first element of the array, doubles it, and then returns it along with the rest of the array.\n// The `chop` function applies this `chopFunction` recursively to the input array `[1, 2, 3, 4, 5]`,\n// resulting in a new array `[2, 4, 6, 8, 10]`.\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.chop([1, 2, 3, 4, 5], (as): [number, Array<number>] => [as[0] * 2, as.slice(1)])\nconsole.log(result) // [2, 4, 6, 8, 10]\n\n// Explanation:\n// The `chopFunction` takes the first element of the array, doubles it, and then returns it along with the rest of the array.\n// The `chop` function applies this `chopFunction` recursively to the input array `[1, 2, 3, 4, 5]`,\n// resulting in a new array `[2, 4, 6, 8, 10]`.'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 3196,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L3196"
    },
    {
      id: "Array.splitAt",
      name: "splitAt",
      module: "Array",
      package: "effect",
      signature: "{ (n: number): <A>(self: Iterable<A>) => [beforeIndex: A[], fromIndex: A[]]; <A>(self: Iterable<A>, n: number): [beforeIndex: A[], fromIndex: A[]]; }",
      description: "Splits an `Iterable` into two segments, with the first segment containing a maximum of `n` elements.\nThe value of `n` can be `0`.",
      documentation: 'Splits an `Iterable` into two segments, with the first segment containing a maximum of `n` elements.\nThe value of `n` can be `0`.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.splitAt([1, 2, 3, 4, 5], 3)\nconsole.log(result) // [[1, 2, 3], [4, 5]]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.splitAt([1, 2, 3, 4, 5], 3)\nconsole.log(result) // [[1, 2, 3], [4, 5]]'
        }
      ],
      tags: [
        "splitting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 3280,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L3280"
    },
    {
      id: "Array.splitNonEmptyAt",
      name: "splitNonEmptyAt",
      module: "Array",
      package: "effect",
      signature: "{ (n: number): <A>(self: readonly [A, ...A[]]) => [beforeIndex: [A, ...A[]], fromIndex: A[]]; <A>(self: readonly [A, ...A[]], n: number): [beforeIndex: [A, ...A[]], fromIndex: A[]]; }",
      description: "Splits a `NonEmptyReadonlyArray` into two segments, with the first segment containing a maximum of `n` elements.\nThe value of `n` must be `>= 1`.",
      documentation: 'Splits a `NonEmptyReadonlyArray` into two segments, with the first segment containing a maximum of `n` elements.\nThe value of `n` must be `>= 1`.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.splitNonEmptyAt(["a", "b", "c", "d", "e"], 3)\nconsole.log(result) // [["a", "b", "c"], ["d", "e"]]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.splitNonEmptyAt(["a", "b", "c", "d", "e"], 3)\nconsole.log(result) // [["a", "b", "c"], ["d", "e"]]'
        }
      ],
      tags: [
        "splitting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 3332,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L3332"
    },
    {
      id: "Array.split",
      name: "split",
      module: "Array",
      package: "effect",
      signature: "{ (n: number): <A>(self: Iterable<A>) => A[][]; <A>(self: Iterable<A>, n: number): A[][]; }",
      description: "Splits this iterable into `n` equally sized arrays.",
      documentation: 'Splits this iterable into `n` equally sized arrays.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.split([1, 2, 3, 4, 5, 6, 7, 8], 3)\nconsole.log(result) // [[1, 2, 3], [4, 5, 6], [7, 8]]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.split([1, 2, 3, 4, 5, 6, 7, 8], 3)\nconsole.log(result) // [[1, 2, 3], [4, 5, 6], [7, 8]]'
        }
      ],
      tags: [
        "splitting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 3383,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L3383"
    },
    {
      id: "Array.splitWhere",
      name: "splitWhere",
      module: "Array",
      package: "effect",
      signature: "{ <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [beforeMatch: A[], fromMatch: A[]]; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [beforeMatch: A[], fromMatch: A[]]; }",
      description: "Splits this iterable on the first element that matches this predicate.\nReturns a tuple containing two arrays: the first one is before the match, and the second one is from the match onward.",
      documentation: 'Splits this iterable on the first element that matches this predicate.\nReturns a tuple containing two arrays: the first one is before the match, and the second one is from the match onward.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.splitWhere([1, 2, 3, 4, 5], n => n > 3)\nconsole.log(result) // [[1, 2, 3], [4, 5]]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.splitWhere([1, 2, 3, 4, 5], n => n > 3)\nconsole.log(result) // [[1, 2, 3], [4, 5]]'
        }
      ],
      tags: [
        "splitting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 3433,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L3433"
    },
    {
      id: "Array.copy",
      name: "copy",
      module: "Array",
      package: "effect",
      signature: "{ <A>(self: readonly [A, ...A[]]): [A, ...A[]]; <A>(self: readonly A[]): A[]; }",
      description: "Copies an array.",
      documentation: 'Copies an array.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.copy([1, 2, 3])\nconsole.log(result) // [1, 2, 3]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.copy([1, 2, 3])\nconsole.log(result) // [1, 2, 3]'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 3483,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L3483"
    },
    {
      id: "Array.pad",
      name: "pad",
      module: "Array",
      package: "effect",
      signature: "{ <A, T>(n: number, fill: T): (self: A[]) => (A | T)[]; <A, T>(self: A[], n: number, fill: T): (A | T)[]; }",
      description: "Pads an array.\nReturns a new array of length `n` with the elements of `array` followed by `fill` elements if `array` is shorter than `n`.\nIf `array` is longer than `n`, the returned array will be a slice of `array` containing the `n` first elements of `array`.\nIf `n` is less than or equal to 0, the returned array will be an empty array.",
      documentation: 'Pads an array.\nReturns a new array of length `n` with the elements of `array` followed by `fill` elements if `array` is shorter than `n`.\nIf `array` is longer than `n`, the returned array will be a slice of `array` containing the `n` first elements of `array`.\nIf `n` is less than or equal to 0, the returned array will be an empty array.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.pad([1, 2, 3], 6, 0)\nconsole.log(result) // [1, 2, 3, 0, 0, 0]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.pad([1, 2, 3], 6, 0)\nconsole.log(result) // [1, 2, 3, 0, 0, 0]'
        }
      ],
      tags: [],
      since: "3.8.4",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 3532,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L3532"
    },
    {
      id: "Array.chunksOf",
      name: "chunksOf",
      module: "Array",
      package: "effect",
      signature: "{ (n: number): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, [ReadonlyArray.Infer<S>, ...ReadonlyArray.Infer<S>[]]>; <A>(self: readonly [A, ...A[]], n: number): [[A, ...A[]], ...[A, ...A[]][]]; <A>(self: Iterable<A>, n: number): [A, ...A[]][]; }",
      description: "Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\nthe `Iterable`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\ndefinition of `chunksOf`; it satisfies the property that whenever `n` evenly divides the length of `self`.",
      documentation: 'Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\nthe `Iterable`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\ndefinition of `chunksOf`; it satisfies the property that\n\n```ts skip-type-checking\nchunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n```\n\nwhenever `n` evenly divides the length of `self`.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.chunksOf([1, 2, 3, 4, 5], 2)\nconsole.log(result) // [[1, 2], [3, 4], [5]]\n\n// Explanation:\n// The `chunksOf` function takes an array of numbers `[1, 2, 3, 4, 5]` and a number `2`.\n// It splits the array into chunks of length 2. Since the array length is not evenly divisible by 2,\n// the last chunk contains the remaining elements.\n// The result is `[[1, 2], [3, 4], [5]]`.\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.chunksOf([1, 2, 3, 4, 5], 2)\nconsole.log(result) // [[1, 2], [3, 4], [5]]\n\n// Explanation:\n// The `chunksOf` function takes an array of numbers `[1, 2, 3, 4, 5]` and a number `2`.\n// It splits the array into chunks of length 2. Since the array length is not evenly divisible by 2,\n// the last chunk contains the remaining elements.\n// The result is `[[1, 2], [3, 4], [5]]`.'
        }
      ],
      tags: [
        "splitting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 3599,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L3599"
    },
    {
      id: "Array.window",
      name: "window",
      module: "Array",
      package: "effect",
      signature: "{ <N extends number = number>(n: N): <A>(self: Iterable<A>) => TupleOf<N, A>[]; <A, N extends number = number>(self: Iterable<A>, n: N): TupleOf<N, A>[]; }",
      description: "Creates sliding windows of size `n` from an `Iterable`.\nIf the number of elements is less than `n` or if `n` is not greater than zero,\nan empty array is returned.",
      documentation: "Creates sliding windows of size `n` from an `Iterable`.\nIf the number of elements is less than `n` or if `n` is not greater than zero,\nan empty array is returned.",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Array } from "effect"\n\nconst numbers = [1, 2, 3, 4, 5]\nassert.deepStrictEqual(Array.window(numbers, 3), [[1, 2, 3], [2, 3, 4], [3, 4, 5]])\nassert.deepStrictEqual(Array.window(numbers, 6), [])'
        }
      ],
      tags: [
        "splitting"
      ],
      since: "3.13.2",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 3709,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L3709"
    },
    {
      id: "Array.groupWith",
      name: "groupWith",
      module: "Array",
      package: "effect",
      signature: "{ <A>(isEquivalent: (self: A, that: A) => boolean): (self: readonly [A, ...A[]]) => [[A, ...A[]], ...[A, ...A[]][]]; <A>(self: readonly [A, ...A[]], isEquivalent: (self: A, that: A) => boolean): [[A, ...A[]], ...[A, ...A[]][]]; }",
      description: "Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s using the provided `isEquivalent` function.",
      documentation: 'Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s using the provided `isEquivalent` function.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.groupWith(["a", "a", "b", "b", "b", "c", "a"], (x, y) => x === y)\nconsole.log(result) // [["a", "a"], ["b", "b", "b"], ["c"], ["a"]]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.groupWith(["a", "a", "b", "b", "b", "c", "a"], (x, y) => x === y)\nconsole.log(result) // [["a", "a"], ["b", "b", "b"], ["c"], ["a"]]'
        }
      ],
      tags: [
        "grouping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 3764,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L3764"
    },
    {
      id: "Array.group",
      name: "group",
      module: "Array",
      package: "effect",
      signature: "<A>(self: readonly [A, ...A[]]) => [[A, ...A[]], ...[A, ...A[]][]]",
      description: "Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s.",
      documentation: 'Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.group([1, 1, 2, 2, 2, 3, 1])\nconsole.log(result) // [[1, 1], [2, 2, 2], [3], [1]]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.group([1, 1, 2, 2, 2, 3, 1])\nconsole.log(result) // [[1, 1], [2, 2, 2], [3], [1]]'
        }
      ],
      tags: [
        "grouping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 3813,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L3813"
    },
    {
      id: "Array.groupBy",
      name: "groupBy",
      module: "Array",
      package: "effect",
      signature: "{ <A, K extends string | symbol>(f: (a: A) => K): (self: Iterable<A>) => Record<ReadonlyRecord.NonLiteralKey<K>, [A, ...A[]]>; <A, K extends string | symbol>(self: Iterable<A>, f: (a: A) => K): Record<ReadonlyRecord.NonLiteralKey<K>, [A, ...A[]]>; }",
      description: "Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\nfunction on each element, and grouping the results according to values returned",
      documentation: 'Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\nfunction on each element, and grouping the results according to values returned\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst people = [\n  { name: "Alice", group: "A" },\n  { name: "Bob", group: "B" },\n  { name: "Charlie", group: "A" }\n]\n\nconst result = Array.groupBy(people, person => person.group)\nconsole.log(result)\n// {\n//  A: [{ name: "Alice", group: "A" }, { name: "Charlie", group: "A" }],\n//  B: [{ name: "Bob", group: "B" }]\n// }\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst people = [\n  { name: "Alice", group: "A" },\n  { name: "Bob", group: "B" },\n  { name: "Charlie", group: "A" }\n]\n\nconst result = Array.groupBy(people, person => person.group)\nconsole.log(result)\n// {\n//  A: [{ name: "Alice", group: "A" }, { name: "Charlie", group: "A" }],\n//  B: [{ name: "Bob", group: "B" }]\n// }'
        }
      ],
      tags: [
        "grouping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 3840,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L3840"
    },
    {
      id: "Array.unionWith",
      name: "unionWith",
      module: "Array",
      package: "effect",
      signature: "{ <S extends Iterable<any>, T extends Iterable<any>>(that: T, isEquivalent: (self: ReadonlyArray.Infer<S>, that: ReadonlyArray.Infer<T>) => boolean): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>; <A, B>(self: readonly [A, ...A[]], that: Iterable<B>, isEquivalent: (self: A, that: B) => boolean): [A | B, ...(A | B)[]]; <A, B>(self: Iterable<A>, that: readonly [B, ...B[]], isEquivalent: (self: A, that: B) => boolean): [A | B, ...(A | B)[]]; <A, B>(self: Iterable<A>, that: Iterable<B>, isEquivalent: (self: A, that: B) => boolean): (A | B)[]; }",
      description: "Calculates the union of two arrays using the provided equivalence relation.",
      documentation: 'Calculates the union of two arrays using the provided equivalence relation.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst union = Array.unionWith([1, 2], [2, 3], (a, b) => a === b)\nconsole.log(union) // [1, 2, 3]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst union = Array.unionWith([1, 2], [2, 3], (a, b) => a === b)\nconsole.log(union) // [1, 2, 3]'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 3910,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L3910"
    },
    {
      id: "Array.union",
      name: "union",
      module: "Array",
      package: "effect",
      signature: "{ <T extends Iterable<any>>(that: T): <S extends Iterable<any>>(self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>; <A, B>(self: readonly [A, ...A[]], that: readonly B[]): [A | B, ...(A | B)[]]; <A, B>(self: readonly A[], that: readonly [B, ...B[]]): [A | B, ...(A | B)[]]; <A, B>(self: Iterable<A>, that: Iterable<B>): (A | B)[]; }",
      description: "Creates a union of two arrays, removing duplicates.",
      documentation: 'Creates a union of two arrays, removing duplicates.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.union([1, 2], [2, 3])\nconsole.log(result) // [1, 2, 3]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.union([1, 2], [2, 3])\nconsole.log(result) // [1, 2, 3]'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 3986,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L3986"
    },
    {
      id: "Array.intersectionWith",
      name: "intersectionWith",
      module: "Array",
      package: "effect",
      signature: "<A>(isEquivalent: (self: A, that: A) => boolean) => { (that: Iterable<A>): (self: Iterable<A>) => A[]; (self: Iterable<A>, that: Iterable<A>): A[]; }",
      description: "Creates an `Array` of unique values that are included in all given `Iterable`s using the provided `isEquivalent` function.\nThe order and references of result values are determined by the first `Iterable`.",
      documentation: 'Creates an `Array` of unique values that are included in all given `Iterable`s using the provided `isEquivalent` function.\nThe order and references of result values are determined by the first `Iterable`.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst array1 = [{ id: 1 }, { id: 2 }, { id: 3 }]\nconst array2 = [{ id: 3 }, { id: 4 }, { id: 1 }]\nconst isEquivalent = (a: { id: number }, b: { id: number }) => a.id === b.id\nconst result = Array.intersectionWith(isEquivalent)(array2)(array1)\nconsole.log(result) // [{ id: 1 }, { id: 3 }]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst array1 = [{ id: 1 }, { id: 2 }, { id: 3 }]\nconst array2 = [{ id: 3 }, { id: 4 }, { id: 1 }]\nconst isEquivalent = (a: { id: number }, b: { id: number }) => a.id === b.id\nconst result = Array.intersectionWith(isEquivalent)(array2)(array1)\nconsole.log(result) // [{ id: 1 }, { id: 3 }]'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4066,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4066"
    },
    {
      id: "Array.intersection",
      name: "intersection",
      module: "Array",
      package: "effect",
      signature: "{ <B>(that: Iterable<B>): <A>(self: Iterable<A>) => (A & B)[]; <A, B>(self: Iterable<A>, that: Iterable<B>): (A & B)[]; }",
      description: "Creates an `Array` of unique values that are included in all given `Iterable`s.\nThe order and references of result values are determined by the first `Iterable`.",
      documentation: 'Creates an `Array` of unique values that are included in all given `Iterable`s.\nThe order and references of result values are determined by the first `Iterable`.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.intersection([1, 2, 3], [3, 4, 1])\nconsole.log(result) // [1, 3]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.intersection([1, 2, 3], [3, 4, 1])\nconsole.log(result) // [1, 3]'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4085,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4085"
    },
    {
      id: "Array.differenceWith",
      name: "differenceWith",
      module: "Array",
      package: "effect",
      signature: "<A>(isEquivalent: (self: A, that: A) => boolean) => { (that: Iterable<A>): (self: Iterable<A>) => A[]; (self: Iterable<A>, that: Iterable<A>): A[]; }",
      description: "Creates a `Array` of values not included in the other given `Iterable` using the provided `isEquivalent` function.\nThe order and references of result values are determined by the first `Iterable`.",
      documentation: 'Creates a `Array` of values not included in the other given `Iterable` using the provided `isEquivalent` function.\nThe order and references of result values are determined by the first `Iterable`.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst array1 = [1, 2, 3]\nconst array2 = [2, 3, 4]\nconst difference = Array.differenceWith<number>((a, b) => a === b)(array1, array2)\nconsole.log(difference) // [1]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst array1 = [1, 2, 3]\nconst array2 = [2, 3, 4]\nconst difference = Array.differenceWith<number>((a, b) => a === b)(array1, array2)\nconsole.log(difference) // [1]'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4136,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4136"
    },
    {
      id: "Array.difference",
      name: "difference",
      module: "Array",
      package: "effect",
      signature: "{ <A>(that: Iterable<A>): (self: Iterable<A>) => A[]; <A>(self: Iterable<A>, that: Iterable<A>): A[]; }",
      description: "Creates a `Array` of values not included in the other given `Iterable`.\nThe order and references of result values are determined by the first `Iterable`.",
      documentation: 'Creates a `Array` of values not included in the other given `Iterable`.\nThe order and references of result values are determined by the first `Iterable`.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst difference = Array.difference([1, 2, 3], [2, 3, 4])\nconsole.log(difference) // [1]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst difference = Array.difference([1, 2, 3], [2, 3, 4])\nconsole.log(difference) // [1]'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4155,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4155"
    },
    {
      id: "Array.empty",
      name: "empty",
      module: "Array",
      package: "effect",
      signature: "<A = never>() => A[]",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4193,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4193"
    },
    {
      id: "Array.of",
      name: "of",
      module: "Array",
      package: "effect",
      signature: "<A>(a: A) => [A, ...A[]]",
      description: "Constructs a new `NonEmptyArray<A>` from the specified value.",
      documentation: "Constructs a new `NonEmptyArray<A>` from the specified value.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4200,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4200"
    },
    {
      id: "Array.map",
      name: "map",
      module: "Array",
      package: "effect",
      signature: "{ <S extends ReadonlyArray<any>, B>(f: (a: ReadonlyArray.Infer<S>, i: number) => B): (self: S) => ReadonlyArray.With<S, B>; <S extends ReadonlyArray<any>, B>(self: S, f: (a: ReadonlyArray.Infer<S>, i: number) => B): ReadonlyArray.With<S, B>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4230,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4230"
    },
    {
      id: "Array.flatMap",
      name: "flatMap",
      module: "Array",
      package: "effect",
      signature: "{ <S extends ReadonlyArray<any>, T extends ReadonlyArray<any>>(f: (a: ReadonlyArray.Infer<S>, i: number) => T): (self: S) => ReadonlyArray.AndNonEmpty<S, T, ReadonlyArray.Infer<T>>; <A, B>(self: readonly [A, ...A[]], f: (a: A, i: number) => readonly [B, ...B[]]): [B, ...B[]]; <A, B>(self: readonly A[], f: (a: A, i: number) => readonly B[]): B[]; }",
      description: "Applies a function to each element in an array and returns a new array containing the concatenated mapped elements.",
      documentation: "Applies a function to each element in an array and returns a new array containing the concatenated mapped elements.",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4248,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4248"
    },
    {
      id: "Array.flatten",
      name: "flatten",
      module: "Array",
      package: "effect",
      signature: "<S extends ReadonlyArray<ReadonlyArray<any>>>(self: S) => ReadonlyArray.Flatten<S>",
      description: "Combines multiple arrays into a single array by concatenating all elements\nfrom each nested array. This function ensures that the structure of nested\narrays is collapsed into a single, flat array.",
      documentation: 'Combines multiple arrays into a single array by concatenating all elements\nfrom each nested array. This function ensures that the structure of nested\narrays is collapsed into a single, flat array.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.flatten([[1, 2], [], [3, 4], [], [5, 6]])\nconsole.log(result) // [1, 2, 3, 4, 5, 6]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.flatten([[1, 2], [], [3, 4], [], [5, 6]])\nconsole.log(result) // [1, 2, 3, 4, 5, 6]'
        }
      ],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4288,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4288"
    },
    {
      id: "Array.filterMap",
      name: "filterMap",
      module: "Array",
      package: "effect",
      signature: "{ <A, B>(f: (a: A, i: number) => Option<B>): (self: Iterable<A>) => B[]; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): B[]; }",
      description: "Applies a function to each element of the `Iterable` and filters based on the result, keeping the transformed values where the function returns `Some`.\nThis method combines filtering and mapping functionalities, allowing transformations and filtering of elements based on a single function pass.",
      documentation: 'Applies a function to each element of the `Iterable` and filters based on the result, keeping the transformed values where the function returns `Some`.\nThis method combines filtering and mapping functionalities, allowing transformations and filtering of elements based on a single function pass.\n\n**Example**\n\n```ts\nimport { Array, Option } from "effect"\n\nconst evenSquares = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()\n\nconst result = Array.filterMap([1, 2, 3, 4, 5], evenSquares);\nconsole.log(result) // [4, 16]\n```',
      examples: [
        {
          code: 'import { Array, Option } from "effect"\n\nconst evenSquares = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()\n\nconst result = Array.filterMap([1, 2, 3, 4, 5], evenSquares);\nconsole.log(result) // [4, 16]'
        }
      ],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4307,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4307"
    },
    {
      id: "Array.filterMapWhile",
      name: "filterMapWhile",
      module: "Array",
      package: "effect",
      signature: "{ <A, B>(f: (a: A, i: number) => Option<B>): (self: Iterable<A>) => B[]; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): B[]; }",
      description: "Applies a function to each element of the array and filters based on the result, stopping when a condition is not met.\nThis method combines filtering and mapping in a single pass, and short-circuits, i.e., stops processing, as soon as the function returns `None`.\nThis is useful when you need to transform an array but only up to the point where a certain condition holds true.",
      documentation: 'Applies a function to each element of the array and filters based on the result, stopping when a condition is not met.\nThis method combines filtering and mapping in a single pass, and short-circuits, i.e., stops processing, as soon as the function returns `None`.\nThis is useful when you need to transform an array but only up to the point where a certain condition holds true.\n\n**Example**\n\n```ts\nimport { Array, Option } from "effect"\n\nconst toSquareTillOdd = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()\n\nconst result = Array.filterMapWhile([2, 4, 5], toSquareTillOdd)\nconsole.log(result) // [4, 16]\n```',
      examples: [
        {
          code: 'import { Array, Option } from "effect"\n\nconst toSquareTillOdd = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()\n\nconst result = Array.filterMapWhile([2, 4, 5], toSquareTillOdd)\nconsole.log(result) // [4, 16]'
        }
      ],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4366,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4366"
    },
    {
      id: "Array.partitionMap",
      name: "partitionMap",
      module: "Array",
      package: "effect",
      signature: "{ <A, B, C>(f: (a: A, i: number) => Either<C, B>): (self: Iterable<A>) => [left: B[], right: C[]]; <A, B, C>(self: Iterable<A>, f: (a: A, i: number) => Either<C, B>): [left: B[], right: C[]]; }",
      description: "Applies a function to each element of the `Iterable`, categorizing the results into two separate arrays.\nThis function is particularly useful for operations where each element can result in two possible types,\nand you want to separate these types into different collections. For instance, separating validation results\ninto successes and failures.",
      documentation: 'Applies a function to each element of the `Iterable`, categorizing the results into two separate arrays.\nThis function is particularly useful for operations where each element can result in two possible types,\nand you want to separate these types into different collections. For instance, separating validation results\ninto successes and failures.\n\n**Example**\n\n```ts\nimport { Array, Either } from "effect";\n\nconst isEven = (x: number) => x % 2 === 0\n\nconst result = Array.partitionMap([1, 2, 3, 4, 5], x =>\n  isEven(x) ? Either.right(x) : Either.left(x)\n)\nconsole.log(result)\n// [\n//   [1, 3, 5],\n//   [2, 4]\n// ]\n```',
      examples: [
        {
          code: 'import { Array, Either } from "effect";\n\nconst isEven = (x: number) => x % 2 === 0\n\nconst result = Array.partitionMap([1, 2, 3, 4, 5], x =>\n  isEven(x) ? Either.right(x) : Either.left(x)\n)\nconsole.log(result)\n// [\n//   [1, 3, 5],\n//   [2, 4]\n// ]'
        }
      ],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4434,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4434"
    },
    {
      id: "Array.getSomes",
      name: "getSomes",
      module: "Array",
      package: "effect",
      signature: "<T extends Iterable<Option.Option<X>>, X = any>(self: T) => Option.Value<ReadonlyArray.Infer<T>>[]",
      description: "Retrieves the `Some` values from an `Iterable` of `Option`s, collecting them into an array.",
      documentation: 'Retrieves the `Some` values from an `Iterable` of `Option`s, collecting them into an array.\n\n**Example**\n\n```ts\nimport { Array, Option } from "effect"\n\nconst result = Array.getSomes([Option.some(1), Option.none(), Option.some(2)])\nconsole.log(result) // [1, 2]\n```',
      examples: [
        {
          code: 'import { Array, Option } from "effect"\n\nconst result = Array.getSomes([Option.some(1), Option.none(), Option.some(2)])\nconsole.log(result) // [1, 2]'
        }
      ],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4505,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4505"
    },
    {
      id: "Array.getLefts",
      name: "getLefts",
      module: "Array",
      package: "effect",
      signature: "<T extends Iterable<Either.Either<any, any>>>(self: T) => Either.Left<ReadonlyArray.Infer<T>>[]",
      description: "Retrieves the `Left` values from an `Iterable` of `Either`s, collecting them into an array.",
      documentation: 'Retrieves the `Left` values from an `Iterable` of `Either`s, collecting them into an array.\n\n**Example**\n\n```ts\nimport { Array, Either } from "effect"\n\nconst result = Array.getLefts([Either.right(1), Either.left("err"), Either.right(2)])\nconsole.log(result) // ["err"]\n```',
      examples: [
        {
          code: 'import { Array, Either } from "effect"\n\nconst result = Array.getLefts([Either.right(1), Either.left("err"), Either.right(2)])\nconsole.log(result) // ["err"]'
        }
      ],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4521,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4521"
    },
    {
      id: "Array.getRights",
      name: "getRights",
      module: "Array",
      package: "effect",
      signature: "<T extends Iterable<Either.Either<any, any>>>(self: T) => Either.Right<ReadonlyArray.Infer<T>>[]",
      description: "Retrieves the `Right` values from an `Iterable` of `Either`s, collecting them into an array.",
      documentation: 'Retrieves the `Right` values from an `Iterable` of `Either`s, collecting them into an array.\n\n**Example**\n\n```ts\nimport { Array, Either } from "effect"\n\nconst result = Array.getRights([Either.right(1), Either.left("err"), Either.right(2)])\nconsole.log(result) // [1, 2]\n```',
      examples: [
        {
          code: 'import { Array, Either } from "effect"\n\nconst result = Array.getRights([Either.right(1), Either.left("err"), Either.right(2)])\nconsole.log(result) // [1, 2]'
        }
      ],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4537,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4537"
    },
    {
      id: "Array.filter",
      name: "filter",
      module: "Array",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => B[]; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => A[]; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): B[]; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): A[]; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4542,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4542"
    },
    {
      id: "Array.partition",
      name: "partition",
      module: "Array",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => [excluded: Exclude<A, B>[], satisfying: B[]]; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [excluded: A[], satisfying: A[]]; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): [excluded: Exclude<A, B>[], satisfying: B[]]; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [excluded: A[], satisfying: A[]]; }",
      description: "Separate elements based on a predicate that also exposes the index of the element.",
      documentation: 'Separate elements based on a predicate that also exposes the index of the element.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.partition([1, 2, 3, 4], n => n % 2 === 0)\nconsole.log(result) // [[1, 3], [2, 4]]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.partition([1, 2, 3, 4], n => n % 2 === 0)\nconsole.log(result) // [[1, 3], [2, 4]]'
        }
      ],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4579,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4579"
    },
    {
      id: "Array.separate",
      name: "separate",
      module: "Array",
      package: "effect",
      signature: "<T extends Iterable<Either.Either<any, any>>>(self: T) => [Either.Left<ReadonlyArray.Infer<T>>[], Either.Right<ReadonlyArray.Infer<T>>[]]",
      description: "Separates an `Iterable` into two arrays based on a predicate.",
      documentation: "Separates an `Iterable` into two arrays based on a predicate.",
      examples: [],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4651,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4651"
    },
    {
      id: "Array.reduce",
      name: "reduce",
      module: "Array",
      package: "effect",
      signature: "{ <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Iterable<A>) => B; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B; }",
      description: "Reduces an array from the left.",
      documentation: 'Reduces an array from the left.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.reduce([1, 2, 3], 0, (acc, n) => acc + n)\nconsole.log(result) // 6\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.reduce([1, 2, 3], 0, (acc, n) => acc + n)\nconsole.log(result) // 6'
        }
      ],
      tags: [
        "folding"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4667,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4667"
    },
    {
      id: "Array.reduceRight",
      name: "reduceRight",
      module: "Array",
      package: "effect",
      signature: "{ <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Iterable<A>) => B; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B; }",
      description: "Reduces an array from the right.",
      documentation: 'Reduces an array from the right.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.reduceRight([1, 2, 3], 0, (acc, n) => acc + n)\nconsole.log(result) // 6\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.reduceRight([1, 2, 3], 0, (acc, n) => acc + n)\nconsole.log(result) // 6'
        }
      ],
      tags: [
        "folding"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4716,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4716"
    },
    {
      id: "Array.liftPredicate",
      name: "liftPredicate",
      module: "Array",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<A, B>): (a: A) => B[]; <A>(predicate: Predicate<A>): <B extends A>(b: B) => B[]; }",
      description: "Lifts a predicate into an array.",
      documentation: 'Lifts a predicate into an array.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst isEven = (n: number) => n % 2 === 0\nconst to = Array.liftPredicate(isEven)\nconsole.log(to(1)) // []\nconsole.log(to(2)) // [2]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst isEven = (n: number) => n % 2 === 0\nconst to = Array.liftPredicate(isEven)\nconsole.log(to(1)) // []\nconsole.log(to(2)) // [2]'
        }
      ],
      tags: [
        "lifting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4767,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4767"
    },
    {
      id: "Array.liftOption",
      name: "liftOption",
      module: "Array",
      package: "effect",
      signature: "<A extends Array<unknown>, B>(f: (...a: A) => Option<B>) => (...a: A) => B[]",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "lifting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4792,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4792"
    },
    {
      id: "Array.fromNullable",
      name: "fromNullable",
      module: "Array",
      package: "effect",
      signature: "<A>(a: A) => NonNullable<A>[]",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4797,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4797"
    },
    {
      id: "Array.liftNullable",
      name: "liftNullable",
      module: "Array",
      package: "effect",
      signature: "<A extends Array<unknown>, B>(f: (...a: A) => B) => (...a: A) => NonNullable<B>[]",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "lifting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4802,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4802"
    },
    {
      id: "Array.flatMapNullable",
      name: "flatMapNullable",
      module: "Array",
      package: "effect",
      signature: "{ <A, B>(f: (a: A) => B): (self: readonly A[]) => NonNullable<B>[]; <A, B>(self: readonly A[], f: (a: A) => B): NonNullable<B>[]; }",
      description: "Maps over an array and flattens the result, removing null and undefined values.",
      documentation: 'Maps over an array and flattens the result, removing null and undefined values.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.flatMapNullable([1, 2, 3], n => (n % 2 === 0 ? null : n))\nconsole.log(result) // [1, 3]\n\n// Explanation:\n// The array of numbers [1, 2, 3] is mapped with a function that returns null for even numbers\n// and the number itself for odd numbers. The resulting array [1, null, 3] is then flattened\n// to remove null values, resulting in [1, 3].\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.flatMapNullable([1, 2, 3], n => (n % 2 === 0 ? null : n))\nconsole.log(result) // [1, 3]\n\n// Explanation:\n// The array of numbers [1, 2, 3] is mapped with a function that returns null for even numbers\n// and the number itself for odd numbers. The resulting array [1, null, 3] is then flattened\n// to remove null values, resulting in [1, 3].'
        }
      ],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4823,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4823"
    },
    {
      id: "Array.liftEither",
      name: "liftEither",
      module: "Array",
      package: "effect",
      signature: "<A extends Array<unknown>, E, B>(f: (...a: A) => Either<B, E>) => (...a: A) => B[]",
      description: "Lifts a function that returns an `Either` into a function that returns an array.\nIf the `Either` is a left, it returns an empty array.\nIf the `Either` is a right, it returns an array with the right value.",
      documentation: 'Lifts a function that returns an `Either` into a function that returns an array.\nIf the `Either` is a left, it returns an empty array.\nIf the `Either` is a right, it returns an array with the right value.\n\n**Example**\n\n```ts\nimport { Array, Either } from "effect"\n\nconst parseNumber = (s: string): Either.Either<number, Error> =>\n  isNaN(Number(s)) ? Either.left(new Error("Not a number")) : Either.right(Number(s))\n\nconst liftedParseNumber = Array.liftEither(parseNumber)\n\nconst result1 = liftedParseNumber("42")\nconsole.log(result1) // [42]\n\nconst result2 = liftedParseNumber("not a number")\nconsole.log(result2) // []\n\n// Explanation:\n// The function parseNumber is lifted to return an array.\n// When parsing "42", it returns an Either.left with the number 42, resulting in [42].\n// When parsing "not a number", it returns an Either.right with an error, resulting in an empty array [].\n```',
      examples: [
        {
          code: 'import { Array, Either } from "effect"\n\nconst parseNumber = (s: string): Either.Either<number, Error> =>\n  isNaN(Number(s)) ? Either.left(new Error("Not a number")) : Either.right(Number(s))\n\nconst liftedParseNumber = Array.liftEither(parseNumber)\n\nconst result1 = liftedParseNumber("42")\nconsole.log(result1) // [42]\n\nconst result2 = liftedParseNumber("not a number")\nconsole.log(result2) // []\n\n// Explanation:\n// The function parseNumber is lifted to return an array.\n// When parsing "42", it returns an Either.left with the number 42, resulting in [42].\n// When parsing "not a number", it returns an Either.right with an error, resulting in an empty array [].'
        }
      ],
      tags: [
        "lifting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4897,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4897"
    },
    {
      id: "Array.every",
      name: "every",
      module: "Array",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: readonly A[]) => self is readonly B[]; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: readonly A[]) => boolean; <A, B extends A>(self: readonly A[], refinement: (a: A, i: number) => a is B): self is readonly B[]; <A>(self: readonly A[], predicate: (a: A, i: number) => boolean): boolean; }",
      description: "Check if a predicate holds true for every `ReadonlyArray` element.",
      documentation: "Check if a predicate holds true for every `ReadonlyArray` element.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4904,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4904"
    },
    {
      id: "Array.some",
      name: "some",
      module: "Array",
      package: "effect",
      signature: "{ <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: readonly A[]) => self is readonly [A, ...A[]]; <A>(self: readonly A[], predicate: (a: A, i: number) => boolean): self is readonly [A, ...A[]]; }",
      description: "Check if a predicate holds true for some `ReadonlyArray` element.",
      documentation: "Check if a predicate holds true for some `ReadonlyArray` element.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4940,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4940"
    },
    {
      id: "Array.extend",
      name: "extend",
      module: "Array",
      package: "effect",
      signature: "{ <A, B>(f: (as: readonly A[]) => B): (self: readonly A[]) => B[]; <A, B>(self: readonly A[], f: (as: readonly A[]) => B): B[]; }",
      description: "Extends an array with a function that maps each subarray to a value.",
      documentation: 'Extends an array with a function that maps each subarray to a value.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.extend([1, 2, 3], as => as.length)\nconsole.log(result) // [3, 2, 1]\n\n// Explanation:\n// The function maps each subarray starting from each element to its length.\n// The subarrays are: [1, 2, 3], [2, 3], [3].\n// The lengths are: 3, 2, 1.\n// Therefore, the result is [3, 2, 1].\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.extend([1, 2, 3], as => as.length)\nconsole.log(result) // [3, 2, 1]\n\n// Explanation:\n// The function maps each subarray starting from each element to its length.\n// The subarrays are: [1, 2, 3], [2, 3], [3].\n// The lengths are: 3, 2, 1.\n// Therefore, the result is [3, 2, 1].'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 4976,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L4976"
    },
    {
      id: "Array.min",
      name: "min",
      module: "Array",
      package: "effect",
      signature: "{ <A>(O: Order<A>): (self: readonly [A, ...A[]]) => A; <A>(self: readonly [A, ...A[]], O: Order<A>): A; }",
      description: "Finds the minimum element in an array based on a comparator.",
      documentation: 'Finds the minimum element in an array based on a comparator.\n\n**Example**\n\n```ts\nimport { Array, Order } from "effect"\n\nconst result = Array.min([3, 1, 2], Order.number)\nconsole.log(result) // 1\n```',
      examples: [
        {
          code: 'import { Array, Order } from "effect"\n\nconst result = Array.min([3, 1, 2], Order.number)\nconsole.log(result) // 1'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 5034,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L5034"
    },
    {
      id: "Array.max",
      name: "max",
      module: "Array",
      package: "effect",
      signature: "{ <A>(O: Order<A>): (self: readonly [A, ...A[]]) => A; <A>(self: readonly [A, ...A[]], O: Order<A>): A; }",
      description: "Finds the maximum element in an array based on a comparator.",
      documentation: 'Finds the maximum element in an array based on a comparator.\n\n**Example**\n\n```ts\nimport { Array, Order } from "effect"\n\nconst result = Array.max([3, 1, 2], Order.number)\nconsole.log(result) // 3\n```',
      examples: [
        {
          code: 'import { Array, Order } from "effect"\n\nconst result = Array.max([3, 1, 2], Order.number)\nconsole.log(result) // 3'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 5080,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L5080"
    },
    {
      id: "Array.unfold",
      name: "unfold",
      module: "Array",
      package: "effect",
      signature: "<B, A>(b: B, f: (b: B) => Option<readonly [A, B]>) => A[]",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 5116,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L5116"
    },
    {
      id: "Array.getOrder",
      name: "getOrder",
      module: "Array",
      package: "effect",
      signature: "<A>(O: Order<A>) => Order<readonly A[]>",
      description: "This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.\nThe returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.\nIf all elements are equal, the arrays are then compared based on their length.\nIt is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.",
      documentation: "This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.\nThe returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.\nIf all elements are equal, the arrays are then compared based on their length.\nIt is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.",
      examples: [],
      tags: [
        "instances"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 5126,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L5126"
    },
    {
      id: "Array.getEquivalence",
      name: "getEquivalence",
      module: "Array",
      package: "effect",
      signature: "<A>(isEquivalent: Equivalence<A>) => Equivalence<readonly A[]>",
      description: "Creates an equivalence relation for arrays.",
      documentation: 'Creates an equivalence relation for arrays.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst eq = Array.getEquivalence<number>((a, b) => a === b)\nconsole.log(eq([1, 2, 3], [1, 2, 3])) // true\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst eq = Array.getEquivalence<number>((a, b) => a === b)\nconsole.log(eq([1, 2, 3], [1, 2, 3])) // true'
        }
      ],
      tags: [
        "instances"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 5142,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L5142"
    },
    {
      id: "Array.forEach",
      name: "forEach",
      module: "Array",
      package: "effect",
      signature: "{ <A>(f: (a: A, i: number) => void): (self: Iterable<A>) => void; <A>(self: Iterable<A>, f: (a: A, i: number) => void): void; }",
      description: "Performs a side-effect for each element of the `Iterable`.",
      documentation: 'Performs a side-effect for each element of the `Iterable`.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nArray.forEach([1, 2, 3], n => console.log(n)) // 1, 2, 3\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nArray.forEach([1, 2, 3], n => console.log(n)) // 1, 2, 3'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 5156,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L5156"
    },
    {
      id: "Array.dedupeWith",
      name: "dedupeWith",
      module: "Array",
      package: "effect",
      signature: "{ <S extends Iterable<any>>(isEquivalent: (self: ReadonlyArray.Infer<S>, that: ReadonlyArray.Infer<S>) => boolean): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A>(self: readonly [A, ...A[]], isEquivalent: (self: A, that: A) => boolean): [A, ...A[]]; <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): A[]; }",
      description: "Remove duplicates from an `Iterable` using the provided `isEquivalent` function,\npreserving the order of the first occurrence of each element.",
      documentation: 'Remove duplicates from an `Iterable` using the provided `isEquivalent` function,\npreserving the order of the first occurrence of each element.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.dedupeWith([1, 2, 2, 3, 3, 3], (a, b) => a === b)\nconsole.log(result) // [1, 2, 3]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.dedupeWith([1, 2, 2, 3, 3, 3], (a, b) => a === b)\nconsole.log(result) // [1, 2, 3]'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 5201,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L5201"
    },
    {
      id: "Array.dedupe",
      name: "dedupe",
      module: "Array",
      package: "effect",
      signature: "<S extends Iterable<any>>(self: S) => S extends readonly [infer A, ...(infer A)[]] ? [A, ...A[]] : S extends Iterable<infer A> ? A[] : never",
      description: "Remove duplicates from an `Iterable`, preserving the order of the first occurrence of each element.\nThe equivalence used to compare elements is provided by `Equal.equivalence()` from the `Equal` module.",
      documentation: "Remove duplicates from an `Iterable`, preserving the order of the first occurrence of each element.\nThe equivalence used to compare elements is provided by `Equal.equivalence()` from the `Equal` module.",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 5257,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L5257"
    },
    {
      id: "Array.dedupeAdjacentWith",
      name: "dedupeAdjacentWith",
      module: "Array",
      package: "effect",
      signature: "{ <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => A[]; <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): A[]; }",
      description: "Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.",
      documentation: 'Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.dedupeAdjacentWith([1, 1, 2, 2, 3, 3], (a, b) => a === b)\nconsole.log(result) // [1, 2, 3]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.dedupeAdjacentWith([1, 1, 2, 2, 3, 3], (a, b) => a === b)\nconsole.log(result) // [1, 2, 3]'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 5272,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L5272"
    },
    {
      id: "Array.dedupeAdjacent",
      name: "dedupeAdjacent",
      module: "Array",
      package: "effect",
      signature: "<A>(self: Iterable<A>) => A[]",
      description: "Deduplicates adjacent elements that are identical.",
      documentation: 'Deduplicates adjacent elements that are identical.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.dedupeAdjacent([1, 1, 2, 2, 3, 3])\nconsole.log(result) // [1, 2, 3]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.dedupeAdjacent([1, 1, 2, 2, 3, 3])\nconsole.log(result) // [1, 2, 3]'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 5318,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L5318"
    },
    {
      id: "Array.join",
      name: "join",
      module: "Array",
      package: "effect",
      signature: "{ (sep: string): (self: Iterable<string>) => string; (self: Iterable<string>, sep: string): string; }",
      description: 'Joins the elements together with "sep" in the middle.',
      documentation: 'Joins the elements together with "sep" in the middle.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst strings = ["a", "b", "c"]\nconst joined = Array.join(strings, "-")\nconsole.log(joined) // "a-b-c"\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst strings = ["a", "b", "c"]\nconst joined = Array.join(strings, "-")\nconsole.log(joined) // "a-b-c"'
        }
      ],
      tags: [
        "folding"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 5335,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L5335"
    },
    {
      id: "Array.mapAccum",
      name: "mapAccum",
      module: "Array",
      package: "effect",
      signature: "{ <S, A, B, I extends Iterable<A> = Iterable<A>>(s: S, f: (s: S, a: ReadonlyArray.Infer<I>, i: number) => readonly [S, B]): (self: I) => [state: S, mappedArray: ReadonlyArray.With<I, B>]; <S, A, B, I extends Iterable<A> = Iterable<A>>(self: I, s: S, f: (s: S, a: ReadonlyArray.Infer<I>, i: number) => readonly [S, B]): [state: S, mappedArray: ReadonlyArray.With<I, B>]; }",
      description: "Statefully maps over the chunk, producing new elements of type `B`.",
      documentation: 'Statefully maps over the chunk, producing new elements of type `B`.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.mapAccum([1, 2, 3], 0, (acc, n) => [acc + n, acc + n])\nconsole.log(result) // [6, [1, 3, 6]]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.mapAccum([1, 2, 3], 0, (acc, n) => [acc + n, acc + n])\nconsole.log(result) // [6, [1, 3, 6]]'
        }
      ],
      tags: [
        "folding"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 5386,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L5386"
    },
    {
      id: "Array.cartesianWith",
      name: "cartesianWith",
      module: "Array",
      package: "effect",
      signature: "{ <A, B, C>(that: readonly B[], f: (a: A, b: B) => C): (self: readonly A[]) => C[]; <A, B, C>(self: readonly A[], that: readonly B[], f: (a: A, b: B) => C): C[]; }",
      description: "Zips this chunk crosswise with the specified chunk using the specified combiner.",
      documentation: 'Zips this chunk crosswise with the specified chunk using the specified combiner.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.cartesianWith([1, 2], ["a", "b"], (a, b) => `${a}-${b}`)\nconsole.log(result) // ["1-a", "1-b", "2-a", "2-b"]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.cartesianWith([1, 2], ["a", "b"], (a, b) => `${a}-${b}`)\nconsole.log(result) // ["1-a", "1-b", "2-a", "2-b"]'
        }
      ],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 5435,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L5435"
    },
    {
      id: "Array.cartesian",
      name: "cartesian",
      module: "Array",
      package: "effect",
      signature: "{ <B>(that: readonly B[]): <A>(self: readonly A[]) => [A, B][]; <A, B>(self: readonly A[], that: readonly B[]): [A, B][]; }",
      description: "Zips this chunk crosswise with the specified chunk.",
      documentation: 'Zips this chunk crosswise with the specified chunk.\n\n**Example**\n\n```ts\nimport { Array } from "effect"\n\nconst result = Array.cartesian([1, 2], ["a", "b"])\nconsole.log(result) // [[1, "a"], [1, "b"], [2, "a"], [2, "b"]]\n```',
      examples: [
        {
          code: 'import { Array } from "effect"\n\nconst result = Array.cartesian([1, 2], ["a", "b"])\nconsole.log(result) // [[1, "a"], [1, "b"], [2, "a"], [2, "b"]]'
        }
      ],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 5484,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L5484"
    },
    {
      id: "Array.Do",
      name: "Do",
      module: "Array",
      package: "effect",
      signature: "readonly {}[]",
      description: 'The "do simulation" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays. It can be used to simulate "array comprehension".\nIt\'s a technique that allows you to create new arrays by iterating over existing ones and applying specific conditions or transformations to the elements. It\'s like assembling a new collection from pieces of other collections based on certain rules. Here\'s how the do simulation works: 1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Array` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope',
      documentation: 'The "do simulation" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n\nIt can be used to simulate "array comprehension".\nIt\'s a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It\'s like assembling a new collection from pieces of other collections based on certain rules.\n\nHere\'s how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Array` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n\n**Example**\n\n```ts\nimport { Array, pipe } from "effect"\n\nconst doResult = pipe(\n  Array.Do,\n  Array.bind("x", () => [1, 3, 5]),\n  Array.bind("y", () => [2, 4, 6]),\n  Array.filter(({ x, y }) => x < y), // condition\n  Array.map(({ x, y }) => [x, y] as const) // transformation\n)\nconsole.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n\n// equivalent\nconst x = [1, 3, 5],\n      y = [2, 4, 6],\n      result = [];\nfor(let i = 0; i < x.length; i++) {\n  for(let j = 0; j < y.length; j++) {\n    const _x = x[i], _y = y[j];\n    if(_x < _y) result.push([_x, _y] as const)\n  }\n}\n```',
      examples: [
        {
          code: 'import { Array, pipe } from "effect"\n\nconst doResult = pipe(\n  Array.Do,\n  Array.bind("x", () => [1, 3, 5]),\n  Array.bind("y", () => [2, 4, 6]),\n  Array.filter(({ x, y }) => x < y), // condition\n  Array.map(({ x, y }) => [x, y] as const) // transformation\n)\nconsole.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n\n// equivalent\nconst x = [1, 3, 5],\n      y = [2, 4, 6],\n      result = [];\nfor(let i = 0; i < x.length; i++) {\n  for(let j = 0; j < y.length; j++) {\n    const _x = x[i], _y = y[j];\n    if(_x < _y) result.push([_x, _y] as const)\n  }\n}'
        }
      ],
      tags: [
        "do notation"
      ],
      since: "3.2.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 5565,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L5565"
    },
    {
      id: "Array.bind",
      name: "bind",
      module: "Array",
      package: "effect",
      signature: "{ <A extends object, N extends string, B>(tag: Exclude<N, keyof A>, f: (a: NoInfer<A>) => readonly B[]): (self: readonly A[]) => { [K in N | keyof A]: K extends keyof A ? A[K] : B; }[]; <A extends object, N extends string, B>(self: readonly A[], tag: Exclude<N, keyof A>, f: (a: NoInfer<A>) => readonly B[]): { [K in N | keyof A]: K extends keyof A ? A[K] : B; }[]; }",
      description: 'The "do simulation" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays. It can be used to simulate "array comprehension".\nIt\'s a technique that allows you to create new arrays by iterating over existing ones and applying specific conditions or transformations to the elements. It\'s like assembling a new collection from pieces of other collections based on certain rules. Here\'s how the do simulation works: 1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Array` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope',
      documentation: 'The "do simulation" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n\nIt can be used to simulate "array comprehension".\nIt\'s a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It\'s like assembling a new collection from pieces of other collections based on certain rules.\n\nHere\'s how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Array` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n\n**Example**\n\n```ts\nimport { Array, pipe } from "effect"\n\nconst doResult = pipe(\n  Array.Do,\n  Array.bind("x", () => [1, 3, 5]),\n  Array.bind("y", () => [2, 4, 6]),\n  Array.filter(({ x, y }) => x < y), // condition\n  Array.map(({ x, y }) => [x, y] as const) // transformation\n)\nconsole.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n\n// equivalent\nconst x = [1, 3, 5],\n      y = [2, 4, 6],\n      result = [];\nfor(let i = 0; i < x.length; i++) {\n  for(let j = 0; j < y.length; j++) {\n    const _x = x[i], _y = y[j];\n    if(_x < _y) result.push([_x, _y] as const)\n  }\n}\n```',
      examples: [
        {
          code: 'import { Array, pipe } from "effect"\n\nconst doResult = pipe(\n  Array.Do,\n  Array.bind("x", () => [1, 3, 5]),\n  Array.bind("y", () => [2, 4, 6]),\n  Array.filter(({ x, y }) => x < y), // condition\n  Array.map(({ x, y }) => [x, y] as const) // transformation\n)\nconsole.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n\n// equivalent\nconst x = [1, 3, 5],\n      y = [2, 4, 6],\n      result = [];\nfor(let i = 0; i < x.length; i++) {\n  for(let j = 0; j < y.length; j++) {\n    const _x = x[i], _y = y[j];\n    if(_x < _y) result.push([_x, _y] as const)\n  }\n}'
        }
      ],
      tags: [
        "do notation"
      ],
      since: "3.2.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 5613,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L5613"
    },
    {
      id: "Array.bindTo",
      name: "bindTo",
      module: "Array",
      package: "effect",
      signature: "{ <N extends string>(tag: N): <A>(self: readonly A[]) => { [K in N]: A; }[]; <A, N extends string>(self: readonly A[], tag: N): { [K in N]: A; }[]; }",
      description: 'The "do simulation" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays. It can be used to simulate "array comprehension".\nIt\'s a technique that allows you to create new arrays by iterating over existing ones and applying specific conditions or transformations to the elements. It\'s like assembling a new collection from pieces of other collections based on certain rules. Here\'s how the do simulation works: 1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Array` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope',
      documentation: 'The "do simulation" for array allows you to sequentially apply operations to the elements of arrays, just as nested loops allow you to go through all combinations of elements in an arrays.\n\nIt can be used to simulate "array comprehension".\nIt\'s a technique that allows you to create new arrays by iterating over existing ones and applying specific **conditions** or **transformations** to the elements. It\'s like assembling a new collection from pieces of other collections based on certain rules.\n\nHere\'s how the do simulation works:\n\n1. Start the do simulation using the `Do` value\n2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Array` values\n3. You can accumulate multiple `bind` statements to define multiple variables within the scope\n4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values\n5. Regular `Array` functions like `map` and `filter` can still be used within the do simulation. These functions will receive the accumulated variables as arguments within the scope\n\n**Example**\n\n```ts\nimport { Array, pipe } from "effect"\n\nconst doResult = pipe(\n  Array.Do,\n  Array.bind("x", () => [1, 3, 5]),\n  Array.bind("y", () => [2, 4, 6]),\n  Array.filter(({ x, y }) => x < y), // condition\n  Array.map(({ x, y }) => [x, y] as const) // transformation\n)\nconsole.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n\n// equivalent\nconst x = [1, 3, 5],\n      y = [2, 4, 6],\n      result = [];\nfor(let i = 0; i < x.length; i++) {\n  for(let j = 0; j < y.length; j++) {\n    const _x = x[i], _y = y[j];\n    if(_x < _y) result.push([_x, _y] as const)\n  }\n}\n```',
      examples: [
        {
          code: 'import { Array, pipe } from "effect"\n\nconst doResult = pipe(\n  Array.Do,\n  Array.bind("x", () => [1, 3, 5]),\n  Array.bind("y", () => [2, 4, 6]),\n  Array.filter(({ x, y }) => x < y), // condition\n  Array.map(({ x, y }) => [x, y] as const) // transformation\n)\nconsole.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]\n\n// equivalent\nconst x = [1, 3, 5],\n      y = [2, 4, 6],\n      result = [];\nfor(let i = 0; i < x.length; i++) {\n  for(let j = 0; j < y.length; j++) {\n    const _x = x[i], _y = y[j];\n    if(_x < _y) result.push([_x, _y] as const)\n  }\n}'
        }
      ],
      tags: [
        "do notation"
      ],
      since: "3.2.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Array.d.ts",
      sourceLine: 5762,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Array.ts#L5762"
    },
    {
      id: "Ref.RefTypeId",
      name: "RefTypeId",
      module: "Ref",
      package: "effect",
      signature: "typeof RefTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Ref.d.ts",
      sourceLine: 13,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ref.ts#L13"
    },
    {
      id: "Ref.make",
      name: "make",
      module: "Ref",
      package: "effect",
      signature: "<A>(value: A) => Effect<Ref<A>, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Ref.d.ts",
      sourceLine: 63,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ref.ts#L63"
    },
    {
      id: "Ref.get",
      name: "get",
      module: "Ref",
      package: "effect",
      signature: "<A>(self: Ref<A>) => Effect<A, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Ref.d.ts",
      sourceLine: 68,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ref.ts#L68"
    },
    {
      id: "Ref.getAndSet",
      name: "getAndSet",
      module: "Ref",
      package: "effect",
      signature: "{ <A>(value: A): (self: Ref<A>) => Effect<A, never, never>; <A>(self: Ref<A>, value: A): Effect<A, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Ref.d.ts",
      sourceLine: 73,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ref.ts#L73"
    },
    {
      id: "Ref.getAndUpdate",
      name: "getAndUpdate",
      module: "Ref",
      package: "effect",
      signature: "{ <A>(f: (a: A) => A): (self: Ref<A>) => Effect<A, never, never>; <A>(self: Ref<A>, f: (a: A) => A): Effect<A, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Ref.d.ts",
      sourceLine: 89,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ref.ts#L89"
    },
    {
      id: "Ref.getAndUpdateSome",
      name: "getAndUpdateSome",
      module: "Ref",
      package: "effect",
      signature: "{ <A>(pf: (a: A) => Option<A>): (self: Ref<A>) => Effect<A, never, never>; <A>(self: Ref<A>, pf: (a: A) => Option<A>): Effect<A, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Ref.d.ts",
      sourceLine: 105,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ref.ts#L105"
    },
    {
      id: "Ref.modify",
      name: "modify",
      module: "Ref",
      package: "effect",
      signature: "{ <A, B>(f: (a: A) => readonly [B, A]): (self: Ref<A>) => Effect<B, never, never>; <A, B>(self: Ref<A>, f: (a: A) => readonly [B, A]): Effect<B, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Ref.d.ts",
      sourceLine: 121,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ref.ts#L121"
    },
    {
      id: "Ref.modifySome",
      name: "modifySome",
      module: "Ref",
      package: "effect",
      signature: "{ <B, A>(fallback: B, pf: (a: A) => Option<readonly [B, A]>): (self: Ref<A>) => Effect<B, never, never>; <A, B>(self: Ref<A>, fallback: B, pf: (a: A) => Option<readonly [B, A]>): Effect<B, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Ref.d.ts",
      sourceLine: 137,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ref.ts#L137"
    },
    {
      id: "Ref.set",
      name: "set",
      module: "Ref",
      package: "effect",
      signature: "{ <A>(value: A): (self: Ref<A>) => Effect<void, never, never>; <A>(self: Ref<A>, value: A): Effect<void, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Ref.d.ts",
      sourceLine: 153,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ref.ts#L153"
    },
    {
      id: "Ref.setAndGet",
      name: "setAndGet",
      module: "Ref",
      package: "effect",
      signature: "{ <A>(value: A): (self: Ref<A>) => Effect<A, never, never>; <A>(self: Ref<A>, value: A): Effect<A, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Ref.d.ts",
      sourceLine: 169,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ref.ts#L169"
    },
    {
      id: "Ref.update",
      name: "update",
      module: "Ref",
      package: "effect",
      signature: "{ <A>(f: (a: A) => A): (self: Ref<A>) => Effect<void, never, never>; <A>(self: Ref<A>, f: (a: A) => A): Effect<void, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Ref.d.ts",
      sourceLine: 185,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ref.ts#L185"
    },
    {
      id: "Ref.updateAndGet",
      name: "updateAndGet",
      module: "Ref",
      package: "effect",
      signature: "{ <A>(f: (a: A) => A): (self: Ref<A>) => Effect<A, never, never>; <A>(self: Ref<A>, f: (a: A) => A): Effect<A, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Ref.d.ts",
      sourceLine: 201,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ref.ts#L201"
    },
    {
      id: "Ref.updateSome",
      name: "updateSome",
      module: "Ref",
      package: "effect",
      signature: "{ <A>(f: (a: A) => Option<A>): (self: Ref<A>) => Effect<void, never, never>; <A>(self: Ref<A>, f: (a: A) => Option<A>): Effect<void, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Ref.d.ts",
      sourceLine: 217,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ref.ts#L217"
    },
    {
      id: "Ref.updateSomeAndGet",
      name: "updateSomeAndGet",
      module: "Ref",
      package: "effect",
      signature: "{ <A>(pf: (a: A) => Option<A>): (self: Ref<A>) => Effect<A, never, never>; <A>(self: Ref<A>, pf: (a: A) => Option<A>): Effect<A, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Ref.d.ts",
      sourceLine: 233,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ref.ts#L233"
    },
    {
      id: "Ref.unsafeMake",
      name: "unsafeMake",
      module: "Ref",
      package: "effect",
      signature: "<A>(value: A) => Ref<A>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "unsafe"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Ref.d.ts",
      sourceLine: 249,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ref.ts#L249"
    },
    {
      id: "Queue.EnqueueTypeId",
      name: "EnqueueTypeId",
      module: "Queue",
      package: "effect",
      signature: "typeof EnqueueTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 17,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L17"
    },
    {
      id: "Queue.DequeueTypeId",
      name: "DequeueTypeId",
      module: "Queue",
      package: "effect",
      signature: "typeof DequeueTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 27,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L27"
    },
    {
      id: "Queue.QueueStrategyTypeId",
      name: "QueueStrategyTypeId",
      module: "Queue",
      package: "effect",
      signature: "typeof QueueStrategyTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 37,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L37"
    },
    {
      id: "Queue.BackingQueueTypeId",
      name: "BackingQueueTypeId",
      module: "Queue",
      package: "effect",
      signature: "typeof BackingQueueTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 47,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L47"
    },
    {
      id: "Queue.isQueue",
      name: "isQueue",
      module: "Queue",
      package: "effect",
      signature: "(u: unknown) => u is Queue<unknown>",
      description: "Returns `true` if the specified value is a `Queue`, `false` otherwise.",
      documentation: "Returns `true` if the specified value is a `Queue`, `false` otherwise.",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 322,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L322"
    },
    {
      id: "Queue.isDequeue",
      name: "isDequeue",
      module: "Queue",
      package: "effect",
      signature: "(u: unknown) => u is Dequeue<unknown>",
      description: "Returns `true` if the specified value is a `Dequeue`, `false` otherwise.",
      documentation: "Returns `true` if the specified value is a `Dequeue`, `false` otherwise.",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 329,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L329"
    },
    {
      id: "Queue.isEnqueue",
      name: "isEnqueue",
      module: "Queue",
      package: "effect",
      signature: "(u: unknown) => u is Enqueue<unknown>",
      description: "Returns `true` if the specified value is a `Enqueue`, `false` otherwise.",
      documentation: "Returns `true` if the specified value is a `Enqueue`, `false` otherwise.",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 336,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L336"
    },
    {
      id: "Queue.backPressureStrategy",
      name: "backPressureStrategy",
      module: "Queue",
      package: "effect",
      signature: "<A>() => Strategy<A>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "strategies"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 341,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L341"
    },
    {
      id: "Queue.droppingStrategy",
      name: "droppingStrategy",
      module: "Queue",
      package: "effect",
      signature: "<A>() => Strategy<A>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "strategies"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 346,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L346"
    },
    {
      id: "Queue.slidingStrategy",
      name: "slidingStrategy",
      module: "Queue",
      package: "effect",
      signature: "<A>() => Strategy<A>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "strategies"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 351,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L351"
    },
    {
      id: "Queue.make",
      name: "make",
      module: "Queue",
      package: "effect",
      signature: "<A>(queue: BackingQueue<A>, strategy: Strategy<A>) => Effect<Queue<A>, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 356,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L356"
    },
    {
      id: "Queue.bounded",
      name: "bounded",
      module: "Queue",
      package: "effect",
      signature: "<A>(requestedCapacity: number) => Effect<Queue<A>, never, never>",
      description: "Makes a new bounded `Queue`. When the capacity of the queue is reached, any\nadditional calls to `offer` will be suspended until there is more room in\nthe queue. Note: When possible use only power of 2 capacities; this will provide\nbetter performance by utilising an optimised version of the underlying\n`RingBuffer`.",
      documentation: "Makes a new bounded `Queue`. When the capacity of the queue is reached, any\nadditional calls to `offer` will be suspended until there is more room in\nthe queue.\n\n**Note**: When possible use only power of 2 capacities; this will provide\nbetter performance by utilising an optimised version of the underlying\n`RingBuffer`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 369,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L369"
    },
    {
      id: "Queue.dropping",
      name: "dropping",
      module: "Queue",
      package: "effect",
      signature: "<A>(requestedCapacity: number) => Effect<Queue<A>, never, never>",
      description: "Makes a new bounded `Queue` with the dropping strategy. When the capacity of the queue is reached, new elements will be dropped and the\nold elements will remain. Note: When possible use only power of 2 capacities; this will provide\nbetter performance by utilising an optimised version of the underlying\n`RingBuffer`.",
      documentation: "Makes a new bounded `Queue` with the dropping strategy.\n\nWhen the capacity of the queue is reached, new elements will be dropped and the\nold elements will remain.\n\n**Note**: When possible use only power of 2 capacities; this will provide\nbetter performance by utilising an optimised version of the underlying\n`RingBuffer`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 383,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L383"
    },
    {
      id: "Queue.sliding",
      name: "sliding",
      module: "Queue",
      package: "effect",
      signature: "<A>(requestedCapacity: number) => Effect<Queue<A>, never, never>",
      description: "Makes a new bounded `Queue` with the sliding strategy. When the capacity of the queue is reached, new elements will be added and the\nold elements will be dropped. Note: When possible use only power of 2 capacities; this will provide\nbetter performance by utilising an optimised version of the underlying\n`RingBuffer`.",
      documentation: "Makes a new bounded `Queue` with the sliding strategy.\n\nWhen the capacity of the queue is reached, new elements will be added and the\nold elements will be dropped.\n\n**Note**: When possible use only power of 2 capacities; this will provide\nbetter performance by utilising an optimised version of the underlying\n`RingBuffer`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 397,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L397"
    },
    {
      id: "Queue.unbounded",
      name: "unbounded",
      module: "Queue",
      package: "effect",
      signature: "<A>() => Effect<Queue<A>, never, never>",
      description: "Creates a new unbounded `Queue`.",
      documentation: "Creates a new unbounded `Queue`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 404,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L404"
    },
    {
      id: "Queue.capacity",
      name: "capacity",
      module: "Queue",
      package: "effect",
      signature: "<A>(self: Dequeue<A> | Enqueue<A>) => number",
      description: "Returns the number of elements the queue can hold.",
      documentation: "Returns the number of elements the queue can hold.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 411,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L411"
    },
    {
      id: "Queue.size",
      name: "size",
      module: "Queue",
      package: "effect",
      signature: "<A>(self: Dequeue<A> | Enqueue<A>) => Effect<number, never, never>",
      description: "Retrieves the size of the queue, which is equal to the number of elements\nin the queue. This may be negative if fibers are suspended waiting for\nelements to be added to the queue.",
      documentation: "Retrieves the size of the queue, which is equal to the number of elements\nin the queue. This may be negative if fibers are suspended waiting for\nelements to be added to the queue.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 420,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L420"
    },
    {
      id: "Queue.isEmpty",
      name: "isEmpty",
      module: "Queue",
      package: "effect",
      signature: "<A>(self: Dequeue<A> | Enqueue<A>) => Effect<boolean, never, never>",
      description: "Returns `true` if the `Queue` contains zero elements, `false` otherwise.",
      documentation: "Returns `true` if the `Queue` contains zero elements, `false` otherwise.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 427,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L427"
    },
    {
      id: "Queue.isFull",
      name: "isFull",
      module: "Queue",
      package: "effect",
      signature: "<A>(self: Dequeue<A> | Enqueue<A>) => Effect<boolean, never, never>",
      description: "Returns `true` if the `Queue` contains at least one element, `false`\notherwise.",
      documentation: "Returns `true` if the `Queue` contains at least one element, `false`\notherwise.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 435,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L435"
    },
    {
      id: "Queue.isShutdown",
      name: "isShutdown",
      module: "Queue",
      package: "effect",
      signature: "<A>(self: Dequeue<A> | Enqueue<A>) => Effect<boolean, never, never>",
      description: "Returns `true` if `shutdown` has been called, otherwise returns `false`.",
      documentation: "Returns `true` if `shutdown` has been called, otherwise returns `false`.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 442,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L442"
    },
    {
      id: "Queue.awaitShutdown",
      name: "awaitShutdown",
      module: "Queue",
      package: "effect",
      signature: "<A>(self: Dequeue<A> | Enqueue<A>) => Effect<void, never, never>",
      description: "Waits until the queue is shutdown. The `Effect` returned by this method will\nnot resume until the queue has been shutdown. If the queue is already\nshutdown, the `Effect` will resume right away.",
      documentation: "Waits until the queue is shutdown. The `Effect` returned by this method will\nnot resume until the queue has been shutdown. If the queue is already\nshutdown, the `Effect` will resume right away.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 451,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L451"
    },
    {
      id: "Queue.shutdown",
      name: "shutdown",
      module: "Queue",
      package: "effect",
      signature: "<A>(self: Dequeue<A> | Enqueue<A>) => Effect<void, never, never>",
      description: "Interrupts any fibers that are suspended on `offer` or `take`. Future calls\nto `offer*` and `take*` will be interrupted immediately.",
      documentation: "Interrupts any fibers that are suspended on `offer` or `take`. Future calls\nto `offer*` and `take*` will be interrupted immediately.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 459,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L459"
    },
    {
      id: "Queue.offer",
      name: "offer",
      module: "Queue",
      package: "effect",
      signature: "{ <A>(value: A): (self: Enqueue<A>) => Effect<boolean, never, never>; <A>(self: Enqueue<A>, value: A): Effect<boolean, never, never>; }",
      description: "Places one value in the queue.",
      documentation: "Places one value in the queue.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 466,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L466"
    },
    {
      id: "Queue.unsafeOffer",
      name: "unsafeOffer",
      module: "Queue",
      package: "effect",
      signature: "{ <A>(value: A): (self: Enqueue<A>) => boolean; <A>(self: Enqueue<A>, value: A): boolean; }",
      description: "Places one value in the queue.",
      documentation: "Places one value in the queue.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 488,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L488"
    },
    {
      id: "Queue.offerAll",
      name: "offerAll",
      module: "Queue",
      package: "effect",
      signature: "{ <A>(iterable: Iterable<A>): (self: Enqueue<A>) => Effect<boolean, never, never>; <A>(self: Enqueue<A>, iterable: Iterable<A>): Effect<boolean, never, never>; }",
      description: "For Bounded Queue: uses the `BackPressure` Strategy, places the values in\nthe queue and always returns true. If the queue has reached capacity, then\nthe fiber performing the `offerAll` will be suspended until there is room\nin the queue. For Unbounded Queue: Places all values in the queue and returns true. For Sliding Queue: uses `Sliding` Strategy If there is room in the queue,\nit places the values otherwise it removes the old elements and enqueues the\nnew ones. Always returns true. For Dropping Queue: uses `Dropping` Strategy, It places the values in the\nqueue but if there is no room it will not enqueue them and return false.",
      documentation: "For Bounded Queue: uses the `BackPressure` Strategy, places the values in\nthe queue and always returns true. If the queue has reached capacity, then\nthe fiber performing the `offerAll` will be suspended until there is room\nin the queue.\n\nFor Unbounded Queue: Places all values in the queue and returns true.\n\nFor Sliding Queue: uses `Sliding` Strategy If there is room in the queue,\nit places the values otherwise it removes the old elements and enqueues the\nnew ones. Always returns true.\n\nFor Dropping Queue: uses `Dropping` Strategy, It places the values in the\nqueue but if there is no room it will not enqueue them and return false.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 522,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L522"
    },
    {
      id: "Queue.poll",
      name: "poll",
      module: "Queue",
      package: "effect",
      signature: "<A>(self: Dequeue<A>) => Effect<Option<A>, never, never>",
      description: "Returns the first value in the `Queue` as a `Some<A>`, or `None` if the queue\nis empty.",
      documentation: "Returns the first value in the `Queue` as a `Some<A>`, or `None` if the queue\nis empty.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 569,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L569"
    },
    {
      id: "Queue.take",
      name: "take",
      module: "Queue",
      package: "effect",
      signature: "<A>(self: Dequeue<A>) => Effect<A, never, never>",
      description: "Takes the oldest value in the queue. If the queue is empty, this will return\na computation that resumes when an item has been added to the queue.",
      documentation: "Takes the oldest value in the queue. If the queue is empty, this will return\na computation that resumes when an item has been added to the queue.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 577,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L577"
    },
    {
      id: "Queue.takeAll",
      name: "takeAll",
      module: "Queue",
      package: "effect",
      signature: "<A>(self: Dequeue<A>) => Effect<Chunk<A>, never, never>",
      description: "Takes all the values in the queue and returns the values. If the queue is\nempty returns an empty collection.",
      documentation: "Takes all the values in the queue and returns the values. If the queue is\nempty returns an empty collection.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 585,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L585"
    },
    {
      id: "Queue.takeUpTo",
      name: "takeUpTo",
      module: "Queue",
      package: "effect",
      signature: "{ (max: number): <A>(self: Dequeue<A>) => Effect<Chunk<A>, never, never>; <A>(self: Dequeue<A>, max: number): Effect<Chunk<A>, never, never>; }",
      description: "Takes up to max number of values from the queue.",
      documentation: "Takes up to max number of values from the queue.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 592,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L592"
    },
    {
      id: "Queue.takeBetween",
      name: "takeBetween",
      module: "Queue",
      package: "effect",
      signature: "{ (min: number, max: number): <A>(self: Dequeue<A>) => Effect<Chunk<A>, never, never>; <A>(self: Dequeue<A>, min: number, max: number): Effect<Chunk<A>, never, never>; }",
      description: "Takes a number of elements from the queue between the specified minimum and\nmaximum. If there are fewer than the minimum number of elements available,\nsuspends until at least the minimum number of elements have been collected.",
      documentation: "Takes a number of elements from the queue between the specified minimum and\nmaximum. If there are fewer than the minimum number of elements available,\nsuspends until at least the minimum number of elements have been collected.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 616,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L616"
    },
    {
      id: "Queue.takeN",
      name: "takeN",
      module: "Queue",
      package: "effect",
      signature: "{ (n: number): <A>(self: Dequeue<A>) => Effect<Chunk<A>, never, never>; <A>(self: Dequeue<A>, n: number): Effect<Chunk<A>, never, never>; }",
      description: "Takes the specified number of elements from the queue. If there are fewer\nthan the specified number of elements available, it suspends until they\nbecome available.",
      documentation: "Takes the specified number of elements from the queue. If there are fewer\nthan the specified number of elements available, it suspends until they\nbecome available.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Queue.d.ts",
      sourceLine: 644,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Queue.ts#L644"
    },
    {
      id: "Schedule.ScheduleTypeId",
      name: "ScheduleTypeId",
      module: "Schedule",
      package: "effect",
      signature: "typeof ScheduleTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 24,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L24"
    },
    {
      id: "Schedule.ScheduleDriverTypeId",
      name: "ScheduleDriverTypeId",
      module: "Schedule",
      package: "effect",
      signature: "typeof ScheduleDriverTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 34,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L34"
    },
    {
      id: "Schedule.makeWithState",
      name: "makeWithState",
      module: "Schedule",
      package: "effect",
      signature: "<S, In, Out, R = never>(initial: S, step: (now: number, input: In, state: S) => Effect<readonly [S, Out, ScheduleDecision], never, R>) => Schedule<Out, In, R>",
      description: "Creates a new schedule with a custom state and step function.",
      documentation: "Creates a new schedule with a custom state and step function.\n\n**Details**\n\nThis function constructs a `Schedule` by defining its initial state and a\nstep function, which determines how the schedule progresses over time. The\nstep function is called on each iteration with the current time, an input\nvalue, and the schedule's current state. It returns the next state, an output\nvalue, and a decision on whether the schedule should continue or stop.\n\nThis function is useful for creating custom scheduling logic that goes beyond\npredefined schedules like fixed intervals or exponential backoff. It allows\nfull control over how the schedule behaves at each step.",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 154,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L154"
    },
    {
      id: "Schedule.isSchedule",
      name: "isSchedule",
      module: "Schedule",
      package: "effect",
      signature: "(u: unknown) => u is Schedule<unknown, never, unknown>",
      description: "Checks whether a given value is a `Schedule`.",
      documentation: "Checks whether a given value is a `Schedule`.",
      examples: [],
      tags: [
        "Guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 161,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L161"
    },
    {
      id: "Schedule.addDelay",
      name: "addDelay",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out>(f: (out: Out) => DurationInput): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: (out: Out) => DurationInput): Schedule<Out, In, R>; }",
      description: "Adds a delay to every interval in a schedule.",
      documentation: "Adds a delay to every interval in a schedule.\n\n**Details**\n\nThis function modifies a given schedule by applying an additional delay to\nevery interval it defines. The delay is determined by the provided function,\nwhich takes the schedule's output and returns a delay duration.",
      examples: [],
      tags: [
        "Timing & Delay"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 176,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L176"
    },
    {
      id: "Schedule.addDelayEffect",
      name: "addDelayEffect",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out, R2>(f: (out: Out) => Effect<DurationInput, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect<DurationInput, never, R2>): Schedule<Out, In, R | R2>; }",
      description: "Adds an effectfully computed delay to every interval in a schedule.",
      documentation: "Adds an effectfully computed delay to every interval in a schedule.\n\n**Details**\n\nThis function modifies a given schedule by applying an additional delay to\neach interval, where the delay is determined by an effectful function. The\nfunction takes the schedule\u2019s output and returns an effect that produces a\ndelay duration.",
      examples: [],
      tags: [
        "Timing & Delay"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 223,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L223"
    },
    {
      id: "Schedule.andThen",
      name: "andThen",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out2 | Out, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Out | Out2, In & In2, R | R2>; }",
      description: "/\n * Runs two schedules sequentially, merging their outputs.\n *\n *",
      documentation: "/**\n * Runs two schedules sequentially, merging their outputs.\n *\n * **Details**\n *\n * This function executes two schedules one after the other. The first schedule\n * runs to completion, and then the second schedule begins execution. Unlike\n * {@link andThenEither}, this function merges the outputs instead of wrapping\n * them in `Either`, allowing both schedules to contribute their results\n * directly.\n *\n * This is useful when a workflow consists of two phases where the second phase\n * should start only after the first one has fully completed.\n *\n *",
      examples: [],
      tags: [
        "Sequential Composition"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 277,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L277"
    },
    {
      id: "Schedule.andThenEither",
      name: "andThenEither",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Either<Out2, Out>, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Either<Out2, Out>, In & In2, R | R2>; }",
      description: "Runs two schedules sequentially, collecting results in an `Either`.",
      documentation: "Runs two schedules sequentially, collecting results in an `Either`.\n\n**Details**\n\nThis function combines two schedules in sequence. The first schedule runs to\ncompletion, and then the second schedule starts and runs to completion as\nwell. The outputs of both schedules are collected into an `Either` structure:\n- `Either.Left` contains the output of the second schedule.\n- `Either.Right` contains the output of the first schedule.\n\nThis is useful when you need to switch from one schedule to another after the\nfirst one finishes, while still keeping track of which schedule produced each\nresult.",
      examples: [],
      tags: [
        "Sequential Composition"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 341,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L341"
    },
    {
      id: "Schedule.as",
      name: "as",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out2>(out: Out2): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R>; <Out, In, R, Out2>(self: Schedule<Out, In, R>, out: Out2): Schedule<Out2, In, R>; }",
      description: "Transforms a schedule to always produce a constant output.",
      documentation: "Transforms a schedule to always produce a constant output.\n\n**Details**\n\nThis function modifies a given schedule so that instead of returning its\ncomputed outputs, it always returns a constant value.\n\nThis is useful when you need a schedule for timing but don\u2019t care about its\nactual output, or when you want to standardize results across different\nscheduling strategies.",
      examples: [],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 400,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L400"
    },
    {
      id: "Schedule.asVoid",
      name: "asVoid",
      module: "Schedule",
      package: "effect",
      signature: "<Out, In, R>(self: Schedule<Out, In, R>) => Schedule<void, In, R>",
      description: "Transforms a schedule to always return `void` instead of its output.",
      documentation: "Transforms a schedule to always return `void` instead of its output.\n\n**Details**\n\nThis function modifies a given schedule so that it no longer returns\nmeaningful output\u2014each execution produces `void`. This is useful when the\nschedule is used only for timing purposes and the actual output of the\nschedule is irrelevant.\n\nThe schedule still determines when executions should occur, but the results\nare discarded.",
      examples: [],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 450,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L450"
    },
    {
      id: "Schedule.bothInOut",
      name: "bothInOut",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], readonly [In, In2], R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], readonly [In, In2], R | R2>; }",
      description: "Combines two schedules, preserving both their inputs and outputs.",
      documentation: "Combines two schedules, preserving both their inputs and outputs.\n\n**Details**\n\nThis function merges two schedules so that both their input types and output\ntypes are retained. When executed, the resulting schedule will take inputs\nfrom both original schedules and produce a tuple containing both outputs.\n\nIt recurs if either schedule wants to continue, using the shorter delay.\n\nThis is useful when you want to track multiple schedules simultaneously,\nensuring that both receive the same inputs and produce combined results.",
      examples: [],
      tags: [
        "Zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 468,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L468"
    },
    {
      id: "Schedule.check",
      name: "check",
      module: "Schedule",
      package: "effect",
      signature: "{ <In, Out>(test: (input: In, output: Out) => boolean): <R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, test: (input: In, output: Out) => boolean): Schedule<Out, In, R>; }",
      description: "Filters schedule executions based on a custom condition.",
      documentation: "Filters schedule executions based on a custom condition.\n\n**Details**\n\nThis function modifies a schedule by applying a custom test function to each\ninput-output pair. The test function determines whether the schedule should\ncontinue or stop. If the function returns `true`, the schedule proceeds as\nusual; if it returns `false`, the schedule terminates.\n\nThis is useful for conditional retries, custom stop conditions, or\ndynamically controlling execution based on observed inputs and outputs.",
      examples: [],
      tags: [
        "Recurrence Conditions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 524,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L524"
    },
    {
      id: "Schedule.checkEffect",
      name: "checkEffect",
      module: "Schedule",
      package: "effect",
      signature: "{ <In, Out, R2>(test: (input: In, output: Out) => Effect<boolean, never, R2>): <R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, test: (input: In, output: Out) => Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }",
      description: "Conditionally filters schedule executions using an effectful function.",
      documentation: "Conditionally filters schedule executions using an effectful function.\n\n**Details**\n\nThis function modifies a schedule by applying a custom effectful test\nfunction to each input-output pair. The test function determines whether the\nschedule should continue (`true`) or stop (`false`).\n\nThis is useful when the decision to continue depends on external factors such\nas database lookups, API calls, or other asynchronous computations.",
      examples: [],
      tags: [
        "Recurrence Conditions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 581,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L581"
    },
    {
      id: "Schedule.collectAllInputs",
      name: "collectAllInputs",
      module: "Schedule",
      package: "effect",
      signature: "<A>() => Schedule<Chunk<A>, A, never>",
      description: "A schedule that collects all inputs into a `Chunk`.",
      documentation: "A schedule that collects all inputs into a `Chunk`.\n\n**Details**\n\nThis function creates a schedule that never terminates and continuously\ncollects every input it receives into a `Chunk`. Each time the schedule runs,\nit appends the new input to the collected list.\n\nThis is useful when you need to track all received inputs over time, such as\nlogging user actions, recording retry attempts, or accumulating data for\nlater processing.",
      examples: [],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 638,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L638"
    },
    {
      id: "Schedule.collectAllOutputs",
      name: "collectAllOutputs",
      module: "Schedule",
      package: "effect",
      signature: "<Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Chunk<Out>, In, R>",
      description: "Collects all outputs of a schedule into a `Chunk`.",
      documentation: "Collects all outputs of a schedule into a `Chunk`.\n\n**Details**\n\nThis function modifies a given schedule so that instead of returning\nindividual outputs, it accumulates them into a `Chunk`. The schedule\ncontinues to run, appending each output to the collected list.\n\nThis is useful when you need to track all results over time, such as logging\noutputs, aggregating data, or keeping a history of previous values.",
      examples: [],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 657,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L657"
    },
    {
      id: "Schedule.collectUntil",
      name: "collectUntil",
      module: "Schedule",
      package: "effect",
      signature: "<A>(f: Predicate<A>) => Schedule<Chunk<A>, A, never>",
      description: "Collects all inputs into a `Chunk` until a condition fails.",
      documentation: "Collects all inputs into a `Chunk` until a condition fails.\n\n**Details**\n\nThis function creates a schedule that continuously collects inputs into a\n`Chunk` until the given predicate function `f` evaluates to `false`. Once the\ncondition fails, the schedule stops.",
      examples: [],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 670,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L670"
    },
    {
      id: "Schedule.collectUntilEffect",
      name: "collectUntilEffect",
      module: "Schedule",
      package: "effect",
      signature: "<A, R>(f: (a: A) => Effect<boolean, never, R>) => Schedule<Chunk<A>, A, R>",
      description: "Collects all inputs into a `Chunk` until an effectful condition fails.",
      documentation: "Collects all inputs into a `Chunk` until an effectful condition fails.\n\n**Details**\n\nThis function creates a schedule that continuously collects inputs into a\n`Chunk` until the given effectful predicate `f` returns `false`. The\npredicate runs as an effect, meaning it can involve asynchronous computations\nlike API calls, database lookups, or randomness.",
      examples: [],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 684,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L684"
    },
    {
      id: "Schedule.collectWhile",
      name: "collectWhile",
      module: "Schedule",
      package: "effect",
      signature: "<A>(f: Predicate<A>) => Schedule<Chunk<A>, A, never>",
      description: "Collects all inputs into a `Chunk` while a condition holds.",
      documentation: "Collects all inputs into a `Chunk` while a condition holds.\n\n**Details**\n\nThis function creates a schedule that continuously collects inputs into a\n`Chunk` while the given predicate function `f` evaluates to `true`. As soon\nas the condition fails, the schedule stops.",
      examples: [],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 697,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L697"
    },
    {
      id: "Schedule.collectWhileEffect",
      name: "collectWhileEffect",
      module: "Schedule",
      package: "effect",
      signature: "<A, R>(f: (a: A) => Effect<boolean, never, R>) => Schedule<Chunk<A>, A, R>",
      description: "Collects all inputs into a `Chunk` while an effectful condition holds.",
      documentation: "Collects all inputs into a `Chunk` while an effectful condition holds.\n\n**Details**\n\nThis function creates a schedule that continuously collects inputs into a\n`Chunk` while the given effectful predicate `f` returns `true`. The predicate\nreturns an effect, meaning it can depend on external state, such as database\nqueries, API responses, or real-time user conditions.\n\nAs soon as the effectful condition returns `false`, the schedule stops. This\nis useful for dynamically controlled data collection, where stopping depends\non an external or asynchronous factor.",
      examples: [],
      tags: [
        "Collecting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 715,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L715"
    },
    {
      id: "Schedule.compose",
      name: "compose",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out2, Out, R2>(that: Schedule<Out2, Out, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R2 | R>; <Out, In, R, Out2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, Out, R2>): Schedule<Out2, In, R | R2>; }",
      description: "Chains two schedules, passing the output of the first as the input to the\nsecond, while selecting the shorter delay between them.",
      documentation: "Chains two schedules, passing the output of the first as the input to the\nsecond, while selecting the shorter delay between them.\n\n**Details**\n\nThis function composes two schedules so that the output of the first schedule\nbecomes the input of the second schedule. The first schedule executes first,\nand once it produces a result, the second schedule receives that result and\ncontinues execution based on it.\n\nThis is useful for building complex scheduling workflows where one schedule's\nbehavior determines how the next schedule behaves.",
      examples: [],
      tags: [
        "Composition"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 733,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L733"
    },
    {
      id: "Schedule.mapInput",
      name: "mapInput",
      module: "Schedule",
      package: "effect",
      signature: "{ <In, In2>(f: (in2: In2) => In): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In2, R>; <Out, In, R, In2>(self: Schedule<Out, In, R>, f: (in2: In2) => In): Schedule<Out, In2, R>; }",
      description: "Transforms the input type of a schedule.",
      documentation: "Transforms the input type of a schedule.\n\n**Details**\n\nThis function modifies a given schedule by applying a transformation function\nto its inputs. Instead of directly receiving values of type `In`, the\nschedule will now accept values of type `In2`, which are converted to `In`\nusing the provided mapping function `f`.\n\nThis is useful when you have a schedule that expects a specific input type\nbut you need to adapt it to work with a different type.",
      examples: [],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 789,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L789"
    },
    {
      id: "Schedule.mapInputEffect",
      name: "mapInputEffect",
      module: "Schedule",
      package: "effect",
      signature: "{ <In2, In, R2>(f: (in2: In2) => Effect<In, never, R2>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In2, R2 | R>; <Out, In, R, In2, R2>(self: Schedule<Out, In, R>, f: (in2: In2) => Effect<In, never, R2>): Schedule<Out, In2, R | R2>; }",
      description: "Transforms the input type of a schedule using an effectful function.",
      documentation: "Transforms the input type of a schedule using an effectful function.\n\n**Details**\n\nThis function modifies a schedule by applying an effectful transformation to\nits inputs. Instead of directly receiving values of type `In`, the schedule\nwill now accept values of type `In2`, which are converted to `In` via an\neffectful function `f`.\n\nThis is useful when the input transformation involves external dependencies,\nsuch as API calls, database lookups, or other asynchronous computations.",
      examples: [],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 847,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L847"
    },
    {
      id: "Schedule.mapInputContext",
      name: "mapInputContext",
      module: "Schedule",
      package: "effect",
      signature: "{ <R0, R>(f: (env0: Context<R0>) => Context<R>): <Out, In>(self: Schedule<Out, In, R>) => Schedule<Out, In, R0>; <Out, In, R, R0>(self: Schedule<Out, In, R>, f: (env0: Context<R0>) => Context<R>): Schedule<Out, In, R0>; }",
      description: "Transforms the required context of a schedule.",
      documentation: "Transforms the required context of a schedule.\n\n**Details**\n\nThis function modifies a schedule by mapping its required context (`R`) into\na new context (`R0`) using the provided function `f`.\n\nThis is useful when you need to adapt a schedule to work with a different\ndependency environment without changing its core logic.",
      examples: [],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 901,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L901"
    },
    {
      id: "Schedule.count",
      name: "count",
      module: "Schedule",
      package: "effect",
      signature: "Schedule<number, unknown, never>",
      description: "A schedule that recurs indefinitely, counting the number of recurrences.",
      documentation: "A schedule that recurs indefinitely, counting the number of recurrences.\n\n**Details**\n\nThis schedule never stops and simply counts how many times it has executed.\nEach recurrence increases the count, starting from `0`.\n\nThis is useful when tracking the number of attempts in retry policies,\nmeasuring execution loops, or implementing infinite polling scenarios.",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 947,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L947"
    },
    {
      id: "Schedule.cron",
      name: "cron",
      module: "Schedule",
      package: "effect",
      signature: "{ (cron: Cron): Schedule<[number, number], unknown, never>; (expression: string, tz?: string | TimeZone): Schedule<[number, number], unknown, never>; }",
      description: "Creates a schedule that recurs based on a cron expression.",
      documentation: "Creates a schedule that recurs based on a cron expression.\n\n**Details**\n\nThis schedule automatically executes at intervals defined by a cron\nexpression. It triggers at the beginning of each matched interval and\nproduces timestamps representing the start and end of the cron window.\n\nThe cron `expression` is validated lazily, meaning errors may only be\ndetected when the schedule is executed.",
      examples: [],
      tags: [
        "Cron"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 963,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L963"
    },
    {
      id: "Schedule.secondOfMinute",
      name: "secondOfMinute",
      module: "Schedule",
      package: "effect",
      signature: "(second: number) => Schedule<number, unknown, never>",
      description: "Cron-like schedule that recurs at a specific second of each minute.",
      documentation: "Cron-like schedule that recurs at a specific second of each minute.\n\n**Details**\n\nThis schedule triggers at the specified `second` of each minute,\nstarting at zero nanoseconds. It produces a count of executions\n(0, 1, 2, ...). The `second` parameter is validated lazily, meaning\ninvalid values will only be caught at runtime.",
      examples: [],
      tags: [
        "Cron"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1010,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1010"
    },
    {
      id: "Schedule.minuteOfHour",
      name: "minuteOfHour",
      module: "Schedule",
      package: "effect",
      signature: "(minute: number) => Schedule<number, unknown, never>",
      description: "Creates a schedule that recurs every specified minute of each hour.",
      documentation: "Creates a schedule that recurs every specified minute of each hour.\n\n**Details**\n\nThis schedule triggers once per hour at the specified `minute`, starting\nexactly at `minute:00` (zero seconds). The schedule produces a count of\nexecutions (`0, 1, 2, ...`), representing how many times it has run.\n\nThe `minute` parameter must be between `0` and `59`. It is validated lazily,\nmeaning an invalid value will cause errors only when the schedule is\nexecuted.",
      examples: [],
      tags: [
        "Cron"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1027,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1027"
    },
    {
      id: "Schedule.hourOfDay",
      name: "hourOfDay",
      module: "Schedule",
      package: "effect",
      signature: "(hour: number) => Schedule<number, unknown, never>",
      description: "Creates a schedule that recurs at a specific hour of each day.",
      documentation: "Creates a schedule that recurs at a specific hour of each day.\n\n**Details**\n\nThis schedule triggers once per day at the specified `hour`, starting at zero\nminutes of that hour. The schedule produces a count of executions (`0, 1, 2,\n...`), indicating how many times it has been triggered.\n\nThe `hour` parameter must be between `0` (midnight) and `23` (11 PM). It is\nvalidated lazily, meaning an invalid value will cause errors only when the\nschedule is executed.\n\nThis is useful for scheduling daily recurring tasks at a fixed time, such as\nrunning batch jobs or refreshing data.",
      examples: [],
      tags: [
        "Cron"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1047,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1047"
    },
    {
      id: "Schedule.dayOfMonth",
      name: "dayOfMonth",
      module: "Schedule",
      package: "effect",
      signature: "(day: number) => Schedule<number, unknown, never>",
      description: "Creates a schedule that recurs on a specific day of the month.",
      documentation: "Creates a schedule that recurs on a specific day of the month.\n\n**Details**\n\nThis schedule triggers at midnight on the specified day of each month. It\nwill not execute in months that have fewer days than the given day. For\nexample, if the schedule is set to run on the 31st, it will not execute in\nmonths with only 30 days.\n\nThe schedule produces a count of executions, starting at 0 and incrementing\nwith each recurrence.\n\nThe `day` parameter is validated lazily, meaning errors may only be detected\nwhen the schedule is executed.",
      examples: [],
      tags: [
        "Cron"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1067,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1067"
    },
    {
      id: "Schedule.dayOfWeek",
      name: "dayOfWeek",
      module: "Schedule",
      package: "effect",
      signature: "(day: number) => Schedule<number, unknown, never>",
      description: "Creates a schedule that recurs on a specific day of the week.",
      documentation: "Creates a schedule that recurs on a specific day of the week.\n\n**Details**\n\nThis schedule triggers at midnight on the specified day of the week. The\n`day` parameter follows the standard convention where `Monday = 1` and\n`Sunday = 7`. The schedule produces a count of executions, starting at 0 and\nincrementing with each recurrence.\n\nThe `day` parameter is validated lazily, meaning errors may only be detected\nwhen the schedule is executed.",
      examples: [],
      tags: [
        "Cron"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1084,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1084"
    },
    {
      id: "Schedule.delayed",
      name: "delayed",
      module: "Schedule",
      package: "effect",
      signature: "{ (f: (duration: Duration) => DurationInput): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: (duration: Duration) => DurationInput): Schedule<Out, In, R>; }",
      description: "Modifies a schedule by adding a computed delay before each execution.",
      documentation: "Modifies a schedule by adding a computed delay before each execution.\n\n**Details**\n\nThis function adjusts an existing schedule by applying a transformation to\nits delays. Instead of using the default interval, each delay is modified\nusing the provided function `f`, which takes the current delay and returns a\nnew delay.\n\nThis is useful for dynamically adjusting wait times between executions, such\nas introducing jitter, exponential backoff, or custom delay logic.",
      examples: [],
      tags: [
        "Timing & Delay"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1103,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1103"
    },
    {
      id: "Schedule.delayedEffect",
      name: "delayedEffect",
      module: "Schedule",
      package: "effect",
      signature: "{ <R2>(f: (duration: Duration) => Effect<DurationInput, never, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (duration: Duration) => Effect<DurationInput, never, R2>): Schedule<Out, In, R | R2>; }",
      description: "Modifies a schedule by adding an effectfully computed delay before each\nexecution.",
      documentation: "Modifies a schedule by adding an effectfully computed delay before each\nexecution.\n\n**Details**\n\nThis function adjusts an existing schedule by introducing a delay that is\ncomputed via an effect. Instead of using a fixed delay, each interval is\ndynamically adjusted based on an effectful function `f`, which takes the\ncurrent delay and returns a new delay wrapped in an `Effect`.\n\nThis is useful for adaptive scheduling where delays depend on external\nfactors, such as API calls, database queries, or dynamic system conditions.",
      examples: [],
      tags: [
        "Timing & Delay"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1162,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1162"
    },
    {
      id: "Schedule.delayedSchedule",
      name: "delayedSchedule",
      module: "Schedule",
      package: "effect",
      signature: "<In, R>(schedule: Schedule<Duration, In, R>) => Schedule<Duration, In, R>",
      description: "Uses the delays produced by a schedule to further delay its intervals.",
      documentation: "Uses the delays produced by a schedule to further delay its intervals.\n\n**Details**\n\nThis function modifies a schedule by using its own output delays to control\nits execution timing. Instead of executing immediately at each interval, the\nschedule will be delayed by the duration it produces.",
      examples: [],
      tags: [
        "Timing & Delay"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1216,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1216"
    },
    {
      id: "Schedule.delays",
      name: "delays",
      module: "Schedule",
      package: "effect",
      signature: "<Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Duration, In, R>",
      description: "Transforms a schedule to output the delay between each occurrence.",
      documentation: "Transforms a schedule to output the delay between each occurrence.\n\n**Details**\n\nThis function modifies an existing schedule so that instead of producing its\noriginal output, it now returns the delay between each scheduled execution.",
      examples: [],
      tags: [
        "Monitoring"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1228,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1228"
    },
    {
      id: "Schedule.mapBoth",
      name: "mapBoth",
      module: "Schedule",
      package: "effect",
      signature: "{ <In2, In, Out, Out2>(options: { readonly onInput: (in2: In2) => In; readonly onOutput: (out: Out) => Out2; }): <R>(self: Schedule<Out, In, R>) => Schedule<Out2, In2, R>; <Out, In, R, In2, Out2>(self: Schedule<Out, In, R>, options: { readonly onInput: (in2: In2) => In; readonly onOutput: (out: Out) => Out2; }): Schedule<Out2, In2, R>; }",
      description: "Transforms both the input and output of a schedule.",
      documentation: "Transforms both the input and output of a schedule.\n\n**Details**\n\nThis function modifies an existing schedule by applying a transformation to\nboth its input values and its output values. The provided transformation\nfunctions `onInput` and `onOutput` allow you to map the schedule to work with\na different input type while modifying its outputs as well.",
      examples: [],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1244,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1244"
    },
    {
      id: "Schedule.mapBothEffect",
      name: "mapBothEffect",
      module: "Schedule",
      package: "effect",
      signature: "{ <In2, In, R2, Out, R3, Out2>(options: { readonly onInput: (input: In2) => Effect<In, never, R2>; readonly onOutput: (out: Out) => Effect<Out2, never, R3>; }): <R>(self: Schedule<Out, In, R>) => Schedule<Out2, In2, R2 | R3 | R>; <Out, In, R, In2, R2, Out2, R3>(self: Schedule<Out, In, R>, options: { readonly onInput: (input: In2) => Effect<In, never, R2>; readonly onOutput: (out: Out) => Effect<Out2, never, R3>; }): Schedule<Out2, In2, R | R2 | R3>; }",
      description: "Transforms both the input and output of a schedule using effectful\ncomputations.",
      documentation: "Transforms both the input and output of a schedule using effectful\ncomputations.\n\n**Details**\n\nThis function modifies an existing schedule by applying effectful\ntransformations to both its input values and its output values. The provided\neffectful functions `onInput` and `onOutput` allow you to transform inputs\nand outputs using computations that may involve additional logic, resource\naccess, or side effects.",
      examples: [],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1301,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1301"
    },
    {
      id: "Schedule.driver",
      name: "driver",
      module: "Schedule",
      package: "effect",
      signature: "<Out, In, R>(self: Schedule<Out, In, R>) => Effect<ScheduleDriver<Out, In, R>, never, never>",
      description: "Creates a driver to manually control the execution of a schedule.",
      documentation: "Creates a driver to manually control the execution of a schedule.\n\n**Details**\n\nThis function returns a `ScheduleDriver`, which allows stepping through a\nschedule manually while handling delays and sleeping appropriately. A driver\nis useful when you need fine-grained control over how a schedule progresses,\nrather than relying on automatic execution.\n\nThe returned driver exposes methods for retrieving the current state,\nexecuting the next step, and resetting the schedule when needed.",
      examples: [],
      tags: [
        "getter"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1361,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1361"
    },
    {
      id: "Schedule.duration",
      name: "duration",
      module: "Schedule",
      package: "effect",
      signature: "(duration: DurationInput) => Schedule<Duration, unknown, never>",
      description: "/\n * Alias of {@link fromDelay}.\n *\n *",
      documentation: "/**\n * Alias of {@link fromDelay}.\n *\n *",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1368,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1368"
    },
    {
      id: "Schedule.either",
      name: "either",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], In & In2, R | R2>; }",
      description: "/\n * Alias of {@link union}.\n *\n *",
      documentation: "/**\n * Alias of {@link union}.\n *\n *",
      examples: [],
      tags: [
        "Alternatives"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1375,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1375"
    },
    {
      id: "Schedule.eitherWith",
      name: "eitherWith",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out2, In2, R2>(that: Schedule<Out2, In2, R2>, f: (x: Intervals, y: Intervals) => Intervals): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>, f: (x: Intervals, y: Intervals) => Intervals): Schedule<[Out, Out2], In & In2, R | R2>; }",
      description: "/\n * Alias of {@link unionWith}.\n *\n *",
      documentation: "/**\n * Alias of {@link unionWith}.\n *\n *",
      examples: [],
      tags: [
        "Alternatives"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1397,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1397"
    },
    {
      id: "Schedule.elapsed",
      name: "elapsed",
      module: "Schedule",
      package: "effect",
      signature: "Schedule<Duration, unknown, never>",
      description: "Creates a schedule that tracks the total elapsed duration since it started.",
      documentation: "Creates a schedule that tracks the total elapsed duration since it started.\n\n**Details**\n\nThis schedule executes continuously and returns the total time that has\npassed since the first execution. The duration keeps increasing with each\nstep, providing a way to measure elapsed time.\n\nThis is useful for tracking execution time, monitoring delays, or\nimplementing logic based on how long a process has been running.",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1428,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1428"
    },
    {
      id: "Schedule.ensuring",
      name: "ensuring",
      module: "Schedule",
      package: "effect",
      signature: "{ <X>(finalizer: Effect<X, never, never>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R, X>(self: Schedule<Out, In, R>, finalizer: Effect<X, never, never>): Schedule<Out, In, R>; }",
      description: "Attaches a finalizer to a schedule that runs when the schedule completes.",
      documentation: "Attaches a finalizer to a schedule that runs when the schedule completes.\n\n**Details**\n\nThis function returns a new schedule that executes a given finalizer when the\nschedule reaches completion. Unlike `Effect.ensuring`, this method does not\nguarantee the finalizer will run in all cases. If the schedule never\ninitializes or is not driven to completion, the finalizer may not execute.\nHowever, if the schedule decides not to continue, the finalizer will be\ninvoked.\n\nThis is useful for cleaning up resources, logging, or executing other side\neffects when a schedule completes.",
      examples: [],
      tags: [
        "Finalization"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1447,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1447"
    },
    {
      id: "Schedule.exponential",
      name: "exponential",
      module: "Schedule",
      package: "effect",
      signature: "(base: DurationInput, factor?: number) => Schedule<Duration, unknown, never>",
      description: "Creates a schedule that recurs indefinitely with exponentially increasing\ndelays.",
      documentation: "Creates a schedule that recurs indefinitely with exponentially increasing\ndelays.\n\n**Details**\n\nThis schedule starts with an initial delay of `base` and increases the delay\nexponentially on each repetition using the formula `base * factor^n`, where\n`n` is the number of times the schedule has executed so far. If no `factor`\nis provided, it defaults to `2`, causing the delay to double after each\nexecution.",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1502,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1502"
    },
    {
      id: "Schedule.fibonacci",
      name: "fibonacci",
      module: "Schedule",
      package: "effect",
      signature: "(one: DurationInput) => Schedule<Duration, unknown, never>",
      description: "Creates a schedule that recurs indefinitely with Fibonacci-based increasing\ndelays.",
      documentation: "Creates a schedule that recurs indefinitely with Fibonacci-based increasing\ndelays.\n\n**Details**\n\nThis schedule starts with an initial delay of `one` and increases subsequent\ndelays by summing the two previous delays, following the Fibonacci sequence.\nThe delay pattern follows: `one, one, one + one, (one + one) + one, ...`,\nresulting in `1s, 1s, 2s, 3s, 5s, 8s, 13s, ...` if `one = 1s`.\n\nThis is useful for progressive backoff strategies, where delays grow\nnaturally over time without increasing as aggressively as an exponential\nschedule.",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1521,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1521"
    },
    {
      id: "Schedule.fixed",
      name: "fixed",
      module: "Schedule",
      package: "effect",
      signature: "(interval: DurationInput) => Schedule<number, unknown, never>",
      description: "Creates a schedule that recurs at a fixed interval.",
      documentation: 'Creates a schedule that recurs at a fixed interval.\n\n**Details**\n\nThis schedule executes at regular, evenly spaced intervals, returning the\nnumber of times it has run so far. If the action being executed takes longer\nthan the interval, the next execution will happen immediately to prevent\n"pile-ups," ensuring that the schedule remains consistent without overlapping\nexecutions.\n\n```text\n|-----interval-----|-----interval-----|-----interval-----|\n|---------action--------||action|-----|action|-----------|\n```',
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1543,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1543"
    },
    {
      id: "Schedule.forever",
      name: "forever",
      module: "Schedule",
      package: "effect",
      signature: "Schedule<number, unknown, never>",
      description: "Creates a schedule that recurs indefinitely, producing a count of\nrepetitions.",
      documentation: "Creates a schedule that recurs indefinitely, producing a count of\nrepetitions.\n\n**Details**\n\nThis schedule runs indefinitely, returning an increasing count of executions\n(`0, 1, 2, 3, ...`). Each step increments the count by one, allowing tracking\nof how many times it has executed.",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1557,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1557"
    },
    {
      id: "Schedule.fromDelay",
      name: "fromDelay",
      module: "Schedule",
      package: "effect",
      signature: "(delay: DurationInput) => Schedule<Duration, unknown, never>",
      description: "Creates a schedule that recurs once after a specified duration.",
      documentation: "Creates a schedule that recurs once after a specified duration.\n\n**Details**\n\nThis schedule executes a single time after waiting for the given duration.\nOnce it has executed, it does not repeat.",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1571,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1571"
    },
    {
      id: "Schedule.fromDelays",
      name: "fromDelays",
      module: "Schedule",
      package: "effect",
      signature: "(delay: DurationInput, ...delays: DurationInput[]) => Schedule<Duration, unknown, never>",
      description: "Creates a schedule that recurs once for each specified duration, applying the\ngiven delays sequentially.",
      documentation: "Creates a schedule that recurs once for each specified duration, applying the\ngiven delays sequentially.\n\n**Details**\n\nThis schedule executes multiple times, each time waiting for the\ncorresponding duration from the provided list of delays. The first execution\nwaits for `delay`, the next for the second value in `delays`, and so on. Once\nall delays have been used, the schedule stops executing.\n\nThis is useful for defining a custom delay sequence that does not follow a\nfixed pattern like exponential or Fibonacci backoff.",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1589,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1589"
    },
    {
      id: "Schedule.fromFunction",
      name: "fromFunction",
      module: "Schedule",
      package: "effect",
      signature: "<A, B>(f: (a: A) => B) => Schedule<B, A, never>",
      description: "Creates a schedule that always recurs, transforming input values using the\nspecified function.",
      documentation: "Creates a schedule that always recurs, transforming input values using the\nspecified function.\n\n**Details**\n\nThis schedule continuously executes and applies the given function `f` to\neach input value, producing a transformed output. The schedule itself does\nnot control delays or stopping conditions; it simply transforms the input\nvalues as they are processed.\n\nThis is useful when defining schedules that map inputs to outputs, allowing\ndynamic transformations of incoming data.",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1607,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1607"
    },
    {
      id: "Schedule.identity",
      name: "identity",
      module: "Schedule",
      package: "effect",
      signature: "<A>() => Schedule<A, A, never>",
      description: "Creates a schedule that always recurs, passing inputs directly as outputs.",
      documentation: "Creates a schedule that always recurs, passing inputs directly as outputs.\n\n**Details**\n\nThis schedule runs indefinitely, returning each input value as its output\nwithout modification. It effectively acts as a pass-through that simply\nechoes its input values at each step.",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1620,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1620"
    },
    {
      id: "Schedule.passthrough",
      name: "passthrough",
      module: "Schedule",
      package: "effect",
      signature: "<Out, In, R>(self: Schedule<Out, In, R>) => Schedule<In, In, R>",
      description: "Transforms a schedule to pass through its inputs as outputs.",
      documentation: "Transforms a schedule to pass through its inputs as outputs.\n\n**Details**\n\nThis function modifies an existing schedule so that it returns its input\nvalues instead of its original output values. The schedule's timing remains\nunchanged, but its outputs are replaced with whatever inputs it receives.",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1632,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1632"
    },
    {
      id: "Schedule.intersect",
      name: "intersect",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], In & In2, R | R2>; }",
      description: "Combines two schedules, continuing only if both schedules want to continue,\nusing the longer delay.",
      documentation: "Combines two schedules, continuing only if both schedules want to continue,\nusing the longer delay.\n\n**Details**\n\nThis function takes two schedules and creates a new schedule that only\ncontinues execution if both schedules allow it. The interval between\nrecurrences is determined by the longer delay between the two schedules.\n\nThe output of the resulting schedule is a tuple containing the outputs of\nboth schedules. The input type is the intersection of both schedules' input\ntypes.\n\nThis is useful when coordinating multiple scheduling conditions where\nexecution should proceed only when both schedules permit it.",
      examples: [],
      tags: [
        "Composition"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1655,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1655"
    },
    {
      id: "Schedule.intersectWith",
      name: "intersectWith",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out2, In2, R2>(that: Schedule<Out2, In2, R2>, f: (x: Intervals, y: Intervals) => Intervals): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>, f: (x: Intervals, y: Intervals) => Intervals): Schedule<[Out, Out2], In & In2, R | R2>; }",
      description: "/\n * Combines two schedules, continuing only if both want to continue, merging\n * intervals using a custom function.\n *\n *",
      documentation: "/**\n * Combines two schedules, continuing only if both want to continue, merging\n * intervals using a custom function.\n *\n * **Details**\n *\n * This function takes two schedules and creates a new schedule that only\n * continues execution if both schedules allow it. Instead of automatically\n * using the longer delay (like {@link intersect}), this function applies a\n * user-provided merge function `f` to determine the next interval between\n * executions.\n *\n * The output of the resulting schedule is a tuple containing the outputs of\n * both schedules, and the input type is the intersection of both schedules'\n * input types.\n *\n *",
      examples: [],
      tags: [
        "Composition"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1722,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1722"
    },
    {
      id: "Schedule.jittered",
      name: "jittered",
      module: "Schedule",
      package: "effect",
      signature: "<Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>",
      description: "Returns a new schedule that randomly adjusts the interval size within a\nrange.",
      documentation: "Returns a new schedule that randomly adjusts the interval size within a\nrange.\n\n**Details**\n\nThis function modifies a schedule so that its delay between executions is\nrandomly varied within a range. By default, the delay is adjusted between\n`80%` (`0.8 * interval`) and `120%` (`1.2 * interval`) of the original\ninterval size.\n\nThis is useful for adding randomness to repeated executions, reducing\ncontention in distributed systems, and avoiding synchronized execution\npatterns that can cause bottlenecks.",
      examples: [],
      tags: [
        "Timing & Delay"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1784,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1784"
    },
    {
      id: "Schedule.jitteredWith",
      name: "jitteredWith",
      module: "Schedule",
      package: "effect",
      signature: "{ (options: { min?: number; max?: number; }): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, options: { min?: number; max?: number; }): Schedule<Out, In, R>; }",
      description: "/\n * Returns a new schedule that randomly adjusts the interval size within a\n * user-defined range.\n *\n *",
      documentation: "/**\n * Returns a new schedule that randomly adjusts the interval size within a\n * user-defined range.\n *\n * **Details**\n *\n * This function modifies a schedule so that its delay between executions is\n * randomly varied within a specified range. Instead of using the default `0.8 -\n * 1.2` range like {@link jittered}, this function allows customizing the `min`\n * and `max` multipliers.\n *\n * The delay for each step will be adjusted within `min * original_interval` and\n * `max * original_interval`. If `min` and `max` are not provided, the defaults\n * are `0.8` and `1.2`, respectively.\n *\n * This is useful for introducing randomness into scheduling behavior while\n * having precise control over the jitter range.\n *\n *",
      examples: [],
      tags: [
        "Timing & Delay"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1806,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1806"
    },
    {
      id: "Schedule.linear",
      name: "linear",
      module: "Schedule",
      package: "effect",
      signature: "(base: DurationInput) => Schedule<Duration, unknown, never>",
      description: "Creates a schedule that recurs indefinitely, increasing the delay linearly.",
      documentation: "Creates a schedule that recurs indefinitely, increasing the delay linearly.\n\n**Details**\n\nThis schedule starts with an initial delay of `base` and increases the delay\non each recurrence in a linear fashion, following the formula:\n\n`delay = base * n`\n\nwhere `n` is the number of times the schedule has executed so far. This\nresults in increasing intervals between executions.\n\nThis is useful for implementing linear backoff strategies where the wait time\nbetween retries increases at a steady rate.",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1877,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1877"
    },
    {
      id: "Schedule.map",
      name: "map",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out, Out2>(f: (out: Out) => Out2): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R>; <Out, In, R, Out2>(self: Schedule<Out, In, R>, f: (out: Out) => Out2): Schedule<Out2, In, R>; }",
      description: "Returns a new schedule that transforms its output using the specified\nfunction.",
      documentation: "Returns a new schedule that transforms its output using the specified\nfunction.\n\n**Details**\n\nThis function modifies an existing schedule so that its outputs are\ntransformed by the provided function `f`. The timing and recurrence behavior\nof the schedule remain unchanged, but the values it produces are mapped to\nnew values.\n\nThis is useful when composing schedules where you need to adjust the output\nformat or apply additional processing.",
      examples: [],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1898,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1898"
    },
    {
      id: "Schedule.mapEffect",
      name: "mapEffect",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out, Out2, R2>(f: (out: Out) => Effect<Out2, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R2 | R>; <Out, In, R, Out2, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect<Out2, never, R2>): Schedule<Out2, In, R | R2>; }",
      description: "Returns a new schedule that applies an effectful transformation to its\noutput.",
      documentation: "Returns a new schedule that applies an effectful transformation to its\noutput.\n\n**Details**\n\nThis function modifies an existing schedule by applying an effectful function\n`f` to its output values. The timing and recurrence behavior of the schedule\nremain unchanged, but each output is mapped to a new value within an\n`Effect`.\n\nThis is useful when you need to perform side effects or asynchronous\ntransformations before passing the output forward.",
      examples: [],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 1961,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L1961"
    },
    {
      id: "Schedule.modifyDelay",
      name: "modifyDelay",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out>(f: (out: Out, duration: Duration) => DurationInput): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: (out: Out, duration: Duration) => DurationInput): Schedule<Out, In, R>; }",
      description: "Returns a new schedule that modifies the delay between executions using a\ncustom function.",
      documentation: "Returns a new schedule that modifies the delay between executions using a\ncustom function.\n\n**Details**\n\nThis function transforms an existing schedule by applying `f` to modify the\ndelay before each execution. The function receives both the schedule's output\n(`out`) and the originally computed delay (`duration`), and returns a new\nadjusted delay.",
      examples: [],
      tags: [
        "Timing & Delay"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2019,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2019"
    },
    {
      id: "Schedule.modifyDelayEffect",
      name: "modifyDelayEffect",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out, R2>(f: (out: Out, duration: Duration) => Effect<DurationInput, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (out: Out, duration: Duration) => Effect<DurationInput, never, R2>): Schedule<Out, In, R | R2>; }",
      description: "Returns a new schedule that modifies the delay before execution using an\neffectful function.",
      documentation: "Returns a new schedule that modifies the delay before execution using an\neffectful function.\n\n**Details**\n\nThis function takes an existing schedule and applies an effectful function\n`f` to dynamically adjust the delay before each execution. The function\nreceives both the schedule's output (`out`) and the originally computed delay\n(`duration`), returning a new adjusted delay wrapped in an `Effect`.",
      examples: [],
      tags: [
        "Timing & Delay"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2071,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2071"
    },
    {
      id: "Schedule.onDecision",
      name: "onDecision",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out, X, R2>(f: (out: Out, decision: ScheduleDecision) => Effect<X, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, X, R2>(self: Schedule<Out, In, R>, f: (out: Out, decision: ScheduleDecision) => Effect<X, never, R2>): Schedule<Out, In, R | R2>; }",
      description: "Returns a new schedule that executes an effect every time the schedule makes\na decision.",
      documentation: "Returns a new schedule that executes an effect every time the schedule makes\na decision.\n\n**Details**\n\nThis function enhances an existing schedule by running an effectful function\n`f` whenever a scheduling decision is made. The function receives the current\nschedule output (`out`) and the decision (`ScheduleDecision`), allowing\nadditional logic to be executed, such as logging, monitoring, or side\neffects.",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2121,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2121"
    },
    {
      id: "Schedule.once",
      name: "once",
      module: "Schedule",
      package: "effect",
      signature: "Schedule<void, unknown, never>",
      description: "A schedule that executes only once and then stops.",
      documentation: "A schedule that executes only once and then stops.\n\n**Details**\n\nThis schedule triggers a single execution and then terminates. It does not\nrepeat or apply any additional logic.",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2164,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2164"
    },
    {
      id: "Schedule.provideContext",
      name: "provideContext",
      module: "Schedule",
      package: "effect",
      signature: "{ <R>(context: Context<R>): <Out, In>(self: Schedule<Out, In, R>) => Schedule<Out, In, never>; <Out, In, R>(self: Schedule<Out, In, R>, context: Context<R>): Schedule<Out, In, never>; }",
      description: "Returns a new schedule with a provided context, eliminating the need for\nexternal dependencies.",
      documentation: "Returns a new schedule with a provided context, eliminating the need for\nexternal dependencies.\n\n**Details**\n\nThis function supplies a required `context` to a schedule, allowing it to run\nwithout requiring external dependencies. After calling this function, the\nschedule can be used freely without needing to pass a context at execution\ntime.\n\nThis is useful when working with schedules that rely on contextual\ninformation, such as logging services, database connections, or configuration\nsettings.",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2183,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2183"
    },
    {
      id: "Schedule.provideService",
      name: "provideService",
      module: "Schedule",
      package: "effect",
      signature: "{ <I, S>(tag: Tag<I, S>, service: NoInfer<S>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, Exclude<R, I>>; <Out, In, R, I, S>(self: Schedule<Out, In, R>, tag: Tag<I, S>, service: NoInfer<S>): Schedule<Out, In, Exclude<R, I>>; }",
      description: "Returns a new schedule with a single required service provided, eliminating\nthe need for external dependencies.",
      documentation: "Returns a new schedule with a single required service provided, eliminating\nthe need for external dependencies.\n\n**Details**\n\nThis function supplies a single service dependency to a schedule, allowing it\nto run without requiring that service externally. If a schedule depends on\nmultiple services, consider using `provideContext` instead.\n\nThis is useful when working with schedules that require a specific service,\nsuch as logging, metrics, or configuration retrieval.",
      examples: [],
      tags: [
        "Context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2239,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2239"
    },
    {
      id: "Schedule.recurUntil",
      name: "recurUntil",
      module: "Schedule",
      package: "effect",
      signature: "<A>(f: Predicate<A>) => Schedule<A, A, never>",
      description: "A schedule that recurs until the given predicate evaluates to true.",
      documentation: "A schedule that recurs until the given predicate evaluates to true.\n\n**Details**\n\nThis schedule will continue executing as long as the provided predicate `f`\nreturns `false` for the input value. Once `f` evaluates to `true`, the\nschedule stops recurring.\n\nThis is useful for defining schedules that should stop when a certain\ncondition is met, such as detecting a success state, reaching a threshold, or\navoiding unnecessary retries.",
      examples: [],
      tags: [
        "Recurrence Conditions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2293,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2293"
    },
    {
      id: "Schedule.recurUntilEffect",
      name: "recurUntilEffect",
      module: "Schedule",
      package: "effect",
      signature: "<A, R>(f: (a: A) => Effect<boolean, never, R>) => Schedule<A, A, R>",
      description: "/\n * A schedule that recurs until the given effectful predicate evaluates to true.\n *\n *",
      documentation: "/**\n * A schedule that recurs until the given effectful predicate evaluates to true.\n *\n * **Details**\n *\n * This schedule continues executing as long as the provided effectful predicate\n * `f` returns `false`. Once `f` evaluates to `true`, the schedule stops\n * recurring. Unlike {@link recurUntil}, this function allows the stopping\n * condition to be computed asynchronously or based on external dependencies.\n *\n * This is useful when the stopping condition depends on an effectful\n * computation, such as checking a database, making an API call, or retrieving\n * system state dynamically.\n *\n *",
      examples: [],
      tags: [
        "Recurrence Conditions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2313,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2313"
    },
    {
      id: "Schedule.recurUntilOption",
      name: "recurUntilOption",
      module: "Schedule",
      package: "effect",
      signature: "<A, B>(pf: (a: A) => Option<B>) => Schedule<Option<B>, A, never>",
      description: "A schedule that recurs until the input value matches a partial function, then\nmaps the value.",
      documentation: "A schedule that recurs until the input value matches a partial function, then\nmaps the value.\n\n**Details**\n\nThis schedule continues executing until the provided partial function `pf`\nreturns `Some(value)`. At that point, it stops and maps the resulting value\nto an `Option<B>`. If `pf` returns `None`, the schedule continues.\n\nThis is useful when defining schedules that should stop once a certain\ncondition is met and transform the final value before completion.",
      examples: [],
      tags: [
        "Recurrence Conditions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2330,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2330"
    },
    {
      id: "Schedule.recurUpTo",
      name: "recurUpTo",
      module: "Schedule",
      package: "effect",
      signature: "(duration: DurationInput) => Schedule<Duration, unknown, never>",
      description: "A schedule that recurs until the specified duration has elapsed.",
      documentation: "A schedule that recurs until the specified duration has elapsed.\n\n**Details**\n\nThis schedule continues executing for the given `duration`, after which it\nstops. The schedule outputs the elapsed time on each recurrence.\n\nThis is useful for limiting the duration of retries, enforcing time-based\nconstraints, or ensuring that an operation does not run indefinitely.",
      examples: [],
      tags: [
        "Recurrence Conditions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2345,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2345"
    },
    {
      id: "Schedule.recurWhile",
      name: "recurWhile",
      module: "Schedule",
      package: "effect",
      signature: "<A>(f: Predicate<A>) => Schedule<A, A, never>",
      description: "A schedule that recurs as long as the given predicate evaluates to true. Details* This schedule continues executing as long as the provided predicate `f`\nreturns `true` for the input value. Once `f` evaluates to `false`, the\nschedule stops recurring.",
      documentation: "A schedule that recurs as long as the given predicate evaluates to true.\n\n**Details*\n\nThis schedule continues executing as long as the provided predicate `f`\nreturns `true` for the input value. Once `f` evaluates to `false`, the\nschedule stops recurring.",
      examples: [],
      tags: [
        "Recurrence Conditions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2360,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2360"
    },
    {
      id: "Schedule.recurWhileEffect",
      name: "recurWhileEffect",
      module: "Schedule",
      package: "effect",
      signature: "<A, R>(f: (a: A) => Effect<boolean, never, R>) => Schedule<A, A, R>",
      description: "/\n * A schedule that recurs as long as the given effectful predicate evaluates to\n * true.\n *\n *",
      documentation: "/**\n * A schedule that recurs as long as the given effectful predicate evaluates to\n * true.\n *\n * **Details**\n *\n * This schedule continues executing as long as the provided effectful predicate\n * `f` returns `true`. Once `f` evaluates to `false`, the schedule stops\n * recurring. Unlike {@link recurWhile}, this function allows the condition to\n * be computed dynamically using an effectful computation.\n *\n *",
      examples: [],
      tags: [
        "Recurrence Conditions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2377,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2377"
    },
    {
      id: "Schedule.recurs",
      name: "recurs",
      module: "Schedule",
      package: "effect",
      signature: "(n: number) => Schedule<number, unknown, never>",
      description: "A schedule that recurs a fixed number of times before terminating.",
      documentation: "A schedule that recurs a fixed number of times before terminating.\n\n**Details**\n\nThis schedule will continue executing until it has been stepped `n` times,\nafter which it will stop. The output of the schedule is the current count of\nrecurrences.",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2390,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2390"
    },
    {
      id: "Schedule.reduce",
      name: "reduce",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out, Z>(zero: Z, f: (z: Z, out: Out) => Z): <In, R>(self: Schedule<Out, In, R>) => Schedule<Z, In, R>; <Out, In, R, Z>(self: Schedule<Out, In, R>, zero: Z, f: (z: Z, out: Out) => Z): Schedule<Z, In, R>; }",
      description: "Returns a new schedule that folds over the outputs of this one.",
      documentation: "Returns a new schedule that folds over the outputs of this one.\n\n**Details**\n\nThis schedule transforms the output by accumulating values over time using a\nreducer function `f`. It starts with an initial value `zero` and updates it\neach time the schedule produces an output.\n\nThis is useful for tracking statistics, aggregating results, or summarizing\ndata across multiple executions.",
      examples: [],
      tags: [
        "Reducing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2408,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2408"
    },
    {
      id: "Schedule.reduceEffect",
      name: "reduceEffect",
      module: "Schedule",
      package: "effect",
      signature: "{ <Z, Out, R2>(zero: Z, f: (z: Z, out: Out) => Effect<Z, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Z, In, R2 | R>; <Out, In, R, Z, R2>(self: Schedule<Out, In, R>, zero: Z, f: (z: Z, out: Out) => Effect<Z, never, R2>): Schedule<Z, In, R | R2>; }",
      description: "Returns a new schedule that effectfully folds over the outputs of this one.",
      documentation: "Returns a new schedule that effectfully folds over the outputs of this one.\n\n**Details**\n\nThis schedule accumulates outputs over time using an effectful reducer\nfunction `f`. It starts with an initial value `zero` and updates it\nasynchronously or based on external dependencies.\n\nThis is useful for asynchronous state tracking, logging, external metrics\naggregation, or any scenario where accumulation needs to involve an effectful\ncomputation.",
      examples: [],
      tags: [
        "Reducing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2464,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2464"
    },
    {
      id: "Schedule.repeatForever",
      name: "repeatForever",
      module: "Schedule",
      package: "effect",
      signature: "Schedule<number, unknown, never>",
      description: "/\n * Alias of {@link forever}.\n *\n *",
      documentation: "/**\n * Alias of {@link forever}.\n *\n *",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2510,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2510"
    },
    {
      id: "Schedule.repetitions",
      name: "repetitions",
      module: "Schedule",
      package: "effect",
      signature: "<Out, In, R>(self: Schedule<Out, In, R>) => Schedule<number, In, R>",
      description: "Returns a new schedule that outputs the number of repetitions of this one.",
      documentation: "Returns a new schedule that outputs the number of repetitions of this one.\n\n**Details**\n\nThis schedule tracks how many times the given schedule has executed and\noutputs the count instead of the original values. The first execution starts\nat `0`, and the count increases with each recurrence.",
      examples: [],
      tags: [
        "Monitoring"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2523,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2523"
    },
    {
      id: "Schedule.resetAfter",
      name: "resetAfter",
      module: "Schedule",
      package: "effect",
      signature: "{ (duration: DurationInput): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, duration: DurationInput): Schedule<Out, In, R>; }",
      description: "Returns a new schedule that automatically resets to its initial state after a\nperiod of inactivity defined by `duration`.",
      documentation: "Returns a new schedule that automatically resets to its initial state after a\nperiod of inactivity defined by `duration`.\n\n**Details**\n\nThis function modifies a schedule so that if no inputs are received for the\nspecified `duration`, the schedule resets as if it were new.",
      examples: [],
      tags: [
        "State Management"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2538,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2538"
    },
    {
      id: "Schedule.resetWhen",
      name: "resetWhen",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out>(f: Predicate<Out>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<Out>): Schedule<Out, In, R>; }",
      description: "Resets the schedule when the specified predicate on the schedule output\nevaluates to `true`.",
      documentation: "Resets the schedule when the specified predicate on the schedule output\nevaluates to `true`.\n\n**Details**\n\nThis function modifies a schedule so that it resets to its initial state\nwhenever the provided predicate `f` returns `true` for an output value.",
      examples: [],
      tags: [
        "State Management"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2584,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2584"
    },
    {
      id: "Schedule.run",
      name: "run",
      module: "Schedule",
      package: "effect",
      signature: "{ <In>(now: number, input: Iterable<In>): <Out, R>(self: Schedule<Out, In, R>) => Effect<Chunk<Out>, never, R>; <Out, In, R>(self: Schedule<Out, In, R>, now: number, input: Iterable<In>): Effect<Chunk<Out>, never, R>; }",
      description: "Runs a schedule using the provided inputs and collects all outputs.",
      documentation: "Runs a schedule using the provided inputs and collects all outputs.\n\n**Details**\n\nThis function executes a given schedule with a sequence of input values and\naccumulates all outputs into a `Chunk`. The schedule starts execution at the\nspecified `now` timestamp and proceeds according to its defined behavior.\n\nThis is useful for batch processing, simulating execution, or testing\nschedules with predefined input sequences.",
      examples: [],
      tags: [
        "Execution"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2631,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2631"
    },
    {
      id: "Schedule.spaced",
      name: "spaced",
      module: "Schedule",
      package: "effect",
      signature: "(duration: DurationInput) => Schedule<number, unknown, never>",
      description: "Returns a schedule that recurs continuously, with each repetition\nspaced by the specified `duration` from the last run.",
      documentation: "Returns a schedule that recurs continuously, with each repetition\nspaced by the specified `duration` from the last run.\n\n**Details**\n\nThis schedule ensures that executions occur at a fixed interval,\nmaintaining a consistent delay between repetitions. The delay starts\nfrom the end of the last execution, not from the schedule start time.",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2680,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2680"
    },
    {
      id: "Schedule.stop",
      name: "stop",
      module: "Schedule",
      package: "effect",
      signature: "Schedule<void, unknown, never>",
      description: "A schedule that does not recur and stops immediately.",
      documentation: "A schedule that does not recur and stops immediately.",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2687,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2687"
    },
    {
      id: "Schedule.succeed",
      name: "succeed",
      module: "Schedule",
      package: "effect",
      signature: "<A>(value: A) => Schedule<A, unknown, never>",
      description: "Returns a schedule that recurs indefinitely, always producing the specified\nconstant value.",
      documentation: "Returns a schedule that recurs indefinitely, always producing the specified\nconstant value.",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2695,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2695"
    },
    {
      id: "Schedule.sync",
      name: "sync",
      module: "Schedule",
      package: "effect",
      signature: "<A>(evaluate: LazyArg<A>) => Schedule<A, unknown, never>",
      description: "Returns a schedule that recurs indefinitely, evaluating the given function to\nproduce a constant value.",
      documentation: "Returns a schedule that recurs indefinitely, evaluating the given function to\nproduce a constant value.",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2703,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2703"
    },
    {
      id: "Schedule.tapInput",
      name: "tapInput",
      module: "Schedule",
      package: "effect",
      signature: "{ <In2, X, R2>(f: (input: In2) => Effect<X, never, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In & In2, R2 | R>; <Out, In, R, In2, X, R2>(self: Schedule<Out, In, R>, f: (input: In2) => Effect<X, never, R2>): Schedule<Out, In & In2, R | R2>; }",
      description: "Returns a new schedule that runs the given effectful function for each input\nbefore continuing execution.",
      documentation: "Returns a new schedule that runs the given effectful function for each input\nbefore continuing execution.\n\n**Details**\n\nThis function allows side effects to be performed on each input processed by\nthe schedule. It does not modify the schedule\u2019s behavior but ensures that the\nprovided function `f` runs before each step.",
      examples: [],
      tags: [
        "Tapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2717,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2717"
    },
    {
      id: "Schedule.tapOutput",
      name: "tapOutput",
      module: "Schedule",
      package: "effect",
      signature: "{ <X, R2, Out>(f: (out: NoInfer<Out>) => Effect<X, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, X, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect<X, never, R2>): Schedule<Out, In, R | R2>; }",
      description: "Returns a new schedule that runs the given effectful function for each output\nbefore continuing execution.",
      documentation: "Returns a new schedule that runs the given effectful function for each output\nbefore continuing execution.\n\n**Details**\n\nThis function allows side effects to be performed on each output produced by\nthe schedule. It does not modify the schedule\u2019s behavior but ensures that the\nprovided function `f` runs after each step.",
      examples: [],
      tags: [
        "Tapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2760,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2760"
    },
    {
      id: "Schedule.unfold",
      name: "unfold",
      module: "Schedule",
      package: "effect",
      signature: "<A>(initial: A, f: (a: A) => A) => Schedule<A, unknown, never>",
      description: "Creates a schedule that repeatedly applies a function to transform a state\nvalue, producing a sequence of values.",
      documentation: "Creates a schedule that repeatedly applies a function to transform a state\nvalue, producing a sequence of values.\n\n**Details**\n\nThis function starts with an `initial` value and applies `f` recursively to\ngenerate the next state at each step. The schedule continues indefinitely,\nproducing a stream of values by unfolding the state over time.",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2803,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2803"
    },
    {
      id: "Schedule.union",
      name: "union",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], In & In2, R | R2>; }",
      description: "Combines two schedules, continuing execution as long as at least one of them\nallows it, using the shorter delay.",
      documentation: "Combines two schedules, continuing execution as long as at least one of them\nallows it, using the shorter delay.\n\n**Details**\n\nThis function combines two schedules into a single schedule that executes in\nparallel. If either schedule allows continuation, the merged schedule\ncontinues. When both schedules produce delays, the schedule selects the\nshorter delay to determine the next step.\n\nThe output of the new schedule is a tuple containing the outputs of both\nschedules. The input type is the intersection of both schedules' input types.\n\nThis is useful for scenarios where multiple scheduling conditions should be\nconsidered, ensuring execution proceeds if at least one schedule permits it.",
      examples: [],
      tags: [
        "Composition"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2826,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2826"
    },
    {
      id: "Schedule.unionWith",
      name: "unionWith",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out2, In2, R2>(that: Schedule<Out2, In2, R2>, f: (x: Intervals, y: Intervals) => Intervals): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>, f: (x: Intervals, y: Intervals) => Intervals): Schedule<[Out, Out2], In & In2, R | R2>; }",
      description: "/\n * Combines two schedules, continuing execution as long as at least one of them\n * wants to continue, merging their intervals using a custom merge function.\n *\n *",
      documentation: "/**\n * Combines two schedules, continuing execution as long as at least one of them\n * wants to continue, merging their intervals using a custom merge function.\n *\n * **Details**\n *\n * This function allows you to combine two schedules while defining how their\n * intervals should be merged. Unlike {@link union}, which simply selects the\n * shorter delay, this function lets you specify a custom merging strategy for\n * the schedules\u2019 intervals.\n *\n * The merged schedule continues execution as long as at least one of the input\n * schedules allows it. The next interval is determined by applying the provided\n * merge function to the intervals of both schedules.\n *\n * The output of the resulting schedule is a tuple containing the outputs of\n * both schedules. The input type is the intersection of both schedules' input\n * types.\n *\n *",
      examples: [],
      tags: [
        "Composition"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2898,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2898"
    },
    {
      id: "Schedule.untilInput",
      name: "untilInput",
      module: "Schedule",
      package: "effect",
      signature: "{ <In>(f: Predicate<In>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<In>): Schedule<Out, In, R>; }",
      description: "Returns a new schedule that stops execution when the given predicate on the\ninput evaluates to `true`.",
      documentation: "Returns a new schedule that stops execution when the given predicate on the\ninput evaluates to `true`.\n\n**Details**\n\nThis function modifies an existing schedule so that it continues executing\nonly while the provided predicate returns `false` for incoming inputs. Once\nan input satisfies the condition, the schedule terminates immediately.",
      examples: [],
      tags: [
        "Recurrence Conditions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 2965,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L2965"
    },
    {
      id: "Schedule.untilInputEffect",
      name: "untilInputEffect",
      module: "Schedule",
      package: "effect",
      signature: "{ <In, R2>(f: (input: In) => Effect<boolean, never, R2>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (input: In) => Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }",
      description: "Returns a new schedule that stops execution when the given effectful\npredicate on the input evaluates to `true`.",
      documentation: "Returns a new schedule that stops execution when the given effectful\npredicate on the input evaluates to `true`.\n\n**Details**\n\nThis function modifies an existing schedule so that it continues executing\nonly while the provided effectful predicate returns `false` for incoming\ninputs. The predicate is an `Effect`, meaning it can involve asynchronous\ncomputations or dependency-based logic.",
      examples: [],
      tags: [
        "Recurrence Conditions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 3015,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L3015"
    },
    {
      id: "Schedule.untilOutput",
      name: "untilOutput",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out>(f: Predicate<Out>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<Out>): Schedule<Out, In, R>; }",
      description: "Returns a new schedule that stops execution when the given predicate on the\noutput evaluates to `true`.",
      documentation: "Returns a new schedule that stops execution when the given predicate on the\noutput evaluates to `true`.\n\n**Details**\n\nThis function modifies an existing schedule so that it only continues\nexecuting while the given predicate returns false for its output values. Once\nthe predicate evaluates to `true`, execution stops.\n\nThe output of the resulting schedule remains the same, but its duration is\nnow constrained by a stopping condition based on its own output.",
      examples: [],
      tags: [
        "Recurrence Conditions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 3069,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L3069"
    },
    {
      id: "Schedule.untilOutputEffect",
      name: "untilOutputEffect",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out, R2>(f: (out: Out) => Effect<boolean, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }",
      description: "Returns a new schedule that stops execution when the given effectful\npredicate on the output evaluates to `true`.",
      documentation: "Returns a new schedule that stops execution when the given effectful\npredicate on the output evaluates to `true`.\n\n**Details**\n\nThis function modifies an existing schedule so that it only continues\nexecuting while the provided effectful predicate returns `false` for its\noutput values. Once the predicate returns `true`, execution stops.",
      examples: [],
      tags: [
        "Recurrence Conditions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 3124,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L3124"
    },
    {
      id: "Schedule.upTo",
      name: "upTo",
      module: "Schedule",
      package: "effect",
      signature: "{ (duration: DurationInput): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, duration: DurationInput): Schedule<Out, In, R>; }",
      description: "Returns a new schedule that limits execution to a fixed duration.",
      documentation: "Returns a new schedule that limits execution to a fixed duration.\n\n**Details**\n\nThis function modifies an existing schedule to stop execution after a\nspecified duration has passed. The schedule continues as normal until the\nduration is reached, at which point it stops automatically.",
      examples: [],
      tags: [
        "Recurrence Conditions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 3170,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L3170"
    },
    {
      id: "Schedule.whileInput",
      name: "whileInput",
      module: "Schedule",
      package: "effect",
      signature: "{ <In>(f: Predicate<In>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<In>): Schedule<Out, In, R>; }",
      description: "Returns a new schedule that continues execution as long as the given\npredicate on the input is true.",
      documentation: "Returns a new schedule that continues execution as long as the given\npredicate on the input is true.\n\n**Details**\n\nThis function modifies an existing schedule so that it only continues\nexecution while a specified predicate holds true for its input. If the\npredicate evaluates to `false` at any step, the schedule stops.",
      examples: [],
      tags: [
        "Recurrence Conditions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 3213,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L3213"
    },
    {
      id: "Schedule.whileInputEffect",
      name: "whileInputEffect",
      module: "Schedule",
      package: "effect",
      signature: "{ <In, R2>(f: (input: In) => Effect<boolean, never, R2>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (input: In) => Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }",
      description: "Returns a new schedule that continues execution for as long as the given\neffectful predicate on the input evaluates to `true`.",
      documentation: "Returns a new schedule that continues execution for as long as the given\neffectful predicate on the input evaluates to `true`.\n\n**Details**\n\nThis function modifies an existing schedule so that it only continues\nexecution while an effectful predicate holds true for its input. If the\npredicate evaluates to `false` at any step, the schedule stops.",
      examples: [],
      tags: [
        "Recurrence Conditions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 3262,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L3262"
    },
    {
      id: "Schedule.whileOutput",
      name: "whileOutput",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out>(f: Predicate<Out>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<Out>): Schedule<Out, In, R>; }",
      description: "Returns a new schedule that continues execution for as long as the given\npredicate on the output evaluates to `true`.",
      documentation: "Returns a new schedule that continues execution for as long as the given\npredicate on the output evaluates to `true`.\n\n**Details**\n\nThis function modifies an existing schedule so that it only continues\nexecution while a provided condition holds true for its output. If the\npredicate returns `false`, the schedule stops.",
      examples: [],
      tags: [
        "Recurrence Conditions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 3311,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L3311"
    },
    {
      id: "Schedule.whileOutputEffect",
      name: "whileOutputEffect",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out, R2>(f: (out: Out) => Effect<boolean, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }",
      description: "Returns a new schedule that continues execution for as long as the given\neffectful predicate on the output evaluates to `true`.",
      documentation: "Returns a new schedule that continues execution for as long as the given\neffectful predicate on the output evaluates to `true`.\n\n**Details**\n\nThis function modifies an existing schedule so that it only continues\nexecution while an effectful condition holds true for its output. If the\neffectful predicate returns `false`, the schedule stops.",
      examples: [],
      tags: [
        "Recurrence Conditions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 3360,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L3360"
    },
    {
      id: "Schedule.windowed",
      name: "windowed",
      module: "Schedule",
      package: "effect",
      signature: "(interval: DurationInput) => Schedule<number, unknown, never>",
      description: "Creates a schedule that divides time into fixed `interval`-long windows,\ntriggering execution at the start of each new window.",
      documentation: "Creates a schedule that divides time into fixed `interval`-long windows,\ntriggering execution at the start of each new window.\n\n**Details**\n\nThis function produces a schedule that waits until the next time window\nboundary before executing. Each window spans a fixed duration specified by\n`interval`. If an action completes midway through a window, the schedule\nwaits until the next full window starts before proceeding.\n\nFor example, `windowed(Duration.seconds(10))` would produce a schedule as\nfollows:\n\n```text\n     10s        10s        10s       10s\n|----------|----------|----------|----------|\n|action------|sleep---|act|-sleep|action----|\n```",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 3417,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L3417"
    },
    {
      id: "Schedule.zipLeft",
      name: "zipLeft",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Out, In & In2, R | R2>; }",
      description: "/\n * The same as {@link intersect}but ignores the right output.\n *\n *",
      documentation: "/**\n * The same as {@link intersect}but ignores the right output.\n *\n *",
      examples: [],
      tags: [
        "Composition"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 3424,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L3424"
    },
    {
      id: "Schedule.zipRight",
      name: "zipRight",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Out2, In & In2, R | R2>; }",
      description: "/\n * The same as {@link intersect}but ignores the left output.\n *\n *",
      documentation: "/**\n * The same as {@link intersect}but ignores the left output.\n *\n *",
      examples: [],
      tags: [
        "Composition"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 3446,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L3446"
    },
    {
      id: "Schedule.zipWith",
      name: "zipWith",
      module: "Schedule",
      package: "effect",
      signature: "{ <Out2, In2, R2, Out, Out3>(that: Schedule<Out2, In2, R2>, f: (out: Out, out2: Out2) => Out3): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out3, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2, Out3>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>, f: (out: Out, out2: Out2) => Out3): Schedule<Out3, In & In2, R | R2>; }",
      description: "/\n * Equivalent to {@link intersect}followed by {@link map}.\n *\n *",
      documentation: "/**\n * Equivalent to {@link intersect}followed by {@link map}.\n *\n *",
      examples: [],
      tags: [
        "Composition"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 3468,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L3468"
    },
    {
      id: "Schedule.CurrentIterationMetadata",
      name: "CurrentIterationMetadata",
      module: "Schedule",
      package: "effect",
      signature: "Reference<CurrentIterationMetadata, IterationMetadata>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "models"
      ],
      since: "3.15.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Schedule.d.ts",
      sourceLine: 3508,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Schedule.ts#L3508"
    },
    {
      id: "Layer.LayerTypeId",
      name: "LayerTypeId",
      module: "Layer",
      package: "effect",
      signature: "typeof LayerTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 44,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L44"
    },
    {
      id: "Layer.MemoMapTypeId",
      name: "MemoMapTypeId",
      module: "Layer",
      package: "effect",
      signature: "typeof MemoMapTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 102,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L102"
    },
    {
      id: "Layer.CurrentMemoMap",
      name: "CurrentMemoMap",
      module: "Layer",
      package: "effect",
      signature: "Reference<CurrentMemoMap, MemoMap>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "models"
      ],
      since: "3.13.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 126,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L126"
    },
    {
      id: "Layer.isLayer",
      name: "isLayer",
      module: "Layer",
      package: "effect",
      signature: "(u: unknown) => u is Layer<unknown, unknown, unknown>",
      description: "Returns `true` if the specified value is a `Layer`, `false` otherwise.",
      documentation: "Returns `true` if the specified value is a `Layer`, `false` otherwise.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 133,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L133"
    },
    {
      id: "Layer.isFresh",
      name: "isFresh",
      module: "Layer",
      package: "effect",
      signature: "<RIn, E, ROut>(self: Layer<ROut, E, RIn>) => boolean",
      description: "Returns `true` if the specified `Layer` is a fresh version that will not be\nshared, `false` otherwise.",
      documentation: "Returns `true` if the specified `Layer` is a fresh version that will not be\nshared, `false` otherwise.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 141,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L141"
    },
    {
      id: "Layer.annotateLogs",
      name: "annotateLogs",
      module: "Layer",
      package: "effect",
      signature: "{ (key: string, value: unknown): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>; (values: Record<string, unknown>): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>; <A, E, R>(self: Layer<A, E, R>, key: string, value: unknown): Layer<A, E, R>; <A, E, R>(self: Layer<A, E, R>, values: Record<string, unknown>): Layer<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "tracing"
      ],
      since: "3.3.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 146,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L146"
    },
    {
      id: "Layer.annotateSpans",
      name: "annotateSpans",
      module: "Layer",
      package: "effect",
      signature: "{ (key: string, value: unknown): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>; (values: Record<string, unknown>): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>; <A, E, R>(self: Layer<A, E, R>, key: string, value: unknown): Layer<A, E, R>; <A, E, R>(self: Layer<A, E, R>, values: Record<string, unknown>): Layer<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "tracing"
      ],
      since: "3.3.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 172,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L172"
    },
    {
      id: "Layer.build",
      name: "build",
      module: "Layer",
      package: "effect",
      signature: "<RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect<Context<ROut>, E, Scope | RIn>",
      description: "Builds a layer into a scoped value.",
      documentation: "Builds a layer into a scoped value.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 200,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L200"
    },
    {
      id: "Layer.buildWithScope",
      name: "buildWithScope",
      module: "Layer",
      package: "effect",
      signature: "{ (scope: Scope): <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect<Context<ROut>, E, RIn>; <RIn, E, ROut>(self: Layer<ROut, E, RIn>, scope: Scope): Effect<Context<ROut>, E, RIn>; }",
      description: "Builds a layer into an `Effect` value. Any resources associated with this\nlayer will be released when the specified scope is closed unless their scope\nhas been extended. This allows building layers where the lifetime of some of\nthe services output by the layer exceed the lifetime of the effect the\nlayer is provided to.",
      documentation: "Builds a layer into an `Effect` value. Any resources associated with this\nlayer will be released when the specified scope is closed unless their scope\nhas been extended. This allows building layers where the lifetime of some of\nthe services output by the layer exceed the lifetime of the effect the\nlayer is provided to.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 211,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L211"
    },
    {
      id: "Layer.catchAll",
      name: "catchAll",
      module: "Layer",
      package: "effect",
      signature: "{ <E, RIn2, E2, ROut2>(onError: (error: E) => Layer<ROut2, E2, RIn2>): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut & ROut2, E2, RIn2 | RIn>; <RIn, E, ROut, RIn2, E2, ROut2>(self: Layer<ROut, E, RIn>, onError: (error: E) => Layer<ROut2, E2, RIn2>): Layer<ROut & ROut2, E2, RIn | RIn2>; }",
      description: "Recovers from all errors.",
      documentation: "Recovers from all errors.",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 241,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L241"
    },
    {
      id: "Layer.catchAllCause",
      name: "catchAllCause",
      module: "Layer",
      package: "effect",
      signature: "{ <E, RIn2, E2, ROut2>(onError: (cause: Cause<E>) => Layer<ROut2, E2, RIn2>): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut & ROut2, E2, RIn2 | RIn>; <RIn, E, ROut, RIn2, E2, ROut22>(self: Layer<ROut, E, RIn>, onError: (cause: Cause<E>) => Layer<ROut22, E2, RIn2>): Layer<ROut & ROut22, E2, RIn | RIn2>; }",
      description: "Recovers from all errors.",
      documentation: "Recovers from all errors.",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 263,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L263"
    },
    {
      id: "Layer.context",
      name: "context",
      module: "Layer",
      package: "effect",
      signature: "<R>() => Layer<R, never, R>",
      description: "Constructs a `Layer` that passes along the specified context as an\noutput.",
      documentation: "Constructs a `Layer` that passes along the specified context as an\noutput.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 286,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L286"
    },
    {
      id: "Layer.die",
      name: "die",
      module: "Layer",
      package: "effect",
      signature: "(defect: unknown) => Layer<unknown, never, never>",
      description: "Constructs a layer that dies with the specified defect.",
      documentation: "Constructs a layer that dies with the specified defect.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 293,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L293"
    },
    {
      id: "Layer.dieSync",
      name: "dieSync",
      module: "Layer",
      package: "effect",
      signature: "(evaluate: LazyArg<unknown>) => Layer<unknown, never, never>",
      description: "Constructs a layer that dies with the specified defect.",
      documentation: "Constructs a layer that dies with the specified defect.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 300,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L300"
    },
    {
      id: "Layer.discard",
      name: "discard",
      module: "Layer",
      package: "effect",
      signature: "<RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Layer<never, E, RIn>",
      description: "Replaces the layer's output with `never` and includes the layer only for its\nside-effects.",
      documentation: "Replaces the layer's output with `never` and includes the layer only for its\nside-effects.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 308,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L308"
    },
    {
      id: "Layer.effect",
      name: "effect",
      module: "Layer",
      package: "effect",
      signature: "{ <I, S>(tag: Tag<I, S>): <E, R>(effect: Effect<NoInfer<S>, E, R>) => Layer<I, E, R>; <I, S, E, R>(tag: Tag<I, S>, effect: Effect<NoInfer<S>, E, R>): Layer<I, E, R>; }",
      description: "Constructs a layer from the specified effect.",
      documentation: "Constructs a layer from the specified effect.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 315,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L315"
    },
    {
      id: "Layer.effectDiscard",
      name: "effectDiscard",
      module: "Layer",
      package: "effect",
      signature: "<X, E, R>(effect: Effect<X, E, R>) => Layer<never, E, R>",
      description: "Constructs a layer from the specified effect, discarding its output.",
      documentation: "Constructs a layer from the specified effect, discarding its output.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 337,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L337"
    },
    {
      id: "Layer.effectContext",
      name: "effectContext",
      module: "Layer",
      package: "effect",
      signature: "<A, E, R>(effect: Effect<Context<A>, E, R>) => Layer<A, E, R>",
      description: "Constructs a layer from the specified effect, which must return one or more\nservices.",
      documentation: "Constructs a layer from the specified effect, which must return one or more\nservices.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 345,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L345"
    },
    {
      id: "Layer.empty",
      name: "empty",
      module: "Layer",
      package: "effect",
      signature: "Layer<never, never, never>",
      description: "A Layer that constructs an empty Context.",
      documentation: "A Layer that constructs an empty Context.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 352,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L352"
    },
    {
      id: "Layer.extendScope",
      name: "extendScope",
      module: "Layer",
      package: "effect",
      signature: "<RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut, E, Scope | RIn>",
      description: "Extends the scope of this layer, returning a new layer that when provided\nto an effect will not immediately release its associated resources when\nthat effect completes execution but instead when the scope the resulting\neffect depends on is closed.",
      documentation: "Extends the scope of this layer, returning a new layer that when provided\nto an effect will not immediately release its associated resources when\nthat effect completes execution but instead when the scope the resulting\neffect depends on is closed.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 362,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L362"
    },
    {
      id: "Layer.fail",
      name: "fail",
      module: "Layer",
      package: "effect",
      signature: "<E>(error: E) => Layer<unknown, E, never>",
      description: "Constructs a layer that fails with the specified error.",
      documentation: "Constructs a layer that fails with the specified error.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 369,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L369"
    },
    {
      id: "Layer.failSync",
      name: "failSync",
      module: "Layer",
      package: "effect",
      signature: "<E>(evaluate: LazyArg<E>) => Layer<unknown, E, never>",
      description: "Constructs a layer that fails with the specified error.",
      documentation: "Constructs a layer that fails with the specified error.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 376,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L376"
    },
    {
      id: "Layer.failCause",
      name: "failCause",
      module: "Layer",
      package: "effect",
      signature: "<E>(cause: Cause<E>) => Layer<unknown, E, never>",
      description: "Constructs a layer that fails with the specified cause.",
      documentation: "Constructs a layer that fails with the specified cause.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 383,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L383"
    },
    {
      id: "Layer.failCauseSync",
      name: "failCauseSync",
      module: "Layer",
      package: "effect",
      signature: "<E>(evaluate: LazyArg<Cause<E>>) => Layer<unknown, E, never>",
      description: "Constructs a layer that fails with the specified cause.",
      documentation: "Constructs a layer that fails with the specified cause.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 390,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L390"
    },
    {
      id: "Layer.flatMap",
      name: "flatMap",
      module: "Layer",
      package: "effect",
      signature: "{ <A, A2, E2, R2>(f: (context: Context<A>) => Layer<A2, E2, R2>): <E, R>(self: Layer<A, E, R>) => Layer<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Layer<A, E, R>, f: (context: Context<A>) => Layer<A2, E2, R2>): Layer<A2, E | E2, R | R2>; }",
      description: "Constructs a layer dynamically based on the output of this layer.",
      documentation: "Constructs a layer dynamically based on the output of this layer.",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 397,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L397"
    },
    {
      id: "Layer.flatten",
      name: "flatten",
      module: "Layer",
      package: "effect",
      signature: "{ <I, A, E2, R2>(tag: Tag<I, Layer<A, E2, R2>>): <E, R>(self: Layer<I, E, R>) => Layer<A, E2 | E, R2 | R>; <I, E, R, A, E2, R2>(self: Layer<I, E, R>, tag: Tag<I, Layer<A, E2, R2>>): Layer<A, E | E2, R | R2>; }",
      description: "Flattens layers nested in the context of an effect.",
      documentation: "Flattens layers nested in the context of an effect.",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 419,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L419"
    },
    {
      id: "Layer.fresh",
      name: "fresh",
      module: "Layer",
      package: "effect",
      signature: "<A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>",
      description: "Creates a fresh version of this layer that will not be shared.",
      documentation: "Creates a fresh version of this layer that will not be shared.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 441,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L441"
    },
    {
      id: "Layer.mock",
      name: "mock",
      module: "Layer",
      package: "effect",
      signature: "{ <I, S extends object>(tag: Tag<I, S>): (service: Simplify<{ [K in keyof S as S[K] extends Effect<any, any, any> | Stream<any, any, any> | ((...args: any) => Effect<any, any, any> | Stream<any, any, any>) ? K : never]?: S[K]; } & { [K in keyof S as S[K] extends Effect<any, any, any> | Stream<any, any, any> | ((...args: any) => Effect<any, any, any> | Stream<any, any, any>) ? never : K]: S[K]; }>) => Layer<I, never, never>; <I, S extends object>(tag: Tag<I, S>, service: Simplify<{ [K in keyof S as S[K] extends Effect<any, any, any> | Stream<any, any, any> | ((...args: any) => Effect<any, any, any> | Stream<any, any, any>) ? K : never]?: S[K]; } & { [K in keyof S as S[K] extends Effect<any, any, any> | Stream<any, any, any> | ((...args: any) => Effect<any, any, any> | Stream<any, any, any>) ? never : K]: S[K]; }>): Layer<I, never, never>; }",
      description: "Creates a mock layer for testing purposes. You can provide a partial\nimplementation of the service, and any methods not provided will\nthrow an `UnimplementedError` defect when called.",
      documentation: 'Creates a mock layer for testing purposes. You can provide a partial\nimplementation of the service, and any methods not provided will\nthrow an `UnimplementedError` defect when called.\n\n**Example**\n\n```ts\nimport { Context, Effect, Layer } from "effect"\n\nclass MyService extends Context.Tag("MyService")<\n  MyService,\n  {\n    one: Effect.Effect<number>\n    two(): Effect.Effect<number>\n  }\n>() {}\n\nconst MyServiceTest = Layer.mock(MyService, {\n  two: () => Effect.succeed(2)\n})\n```',
      examples: [
        {
          code: 'import { Context, Effect, Layer } from "effect"\n\nclass MyService extends Context.Tag("MyService")<\n  MyService,\n  {\n    one: Effect.Effect<number>\n    two(): Effect.Effect<number>\n  }\n>() {}\n\nconst MyServiceTest = Layer.mock(MyService, {\n  two: () => Effect.succeed(2)\n})'
        }
      ],
      tags: [
        "Testing"
      ],
      since: "3.17.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 477,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L477"
    },
    {
      id: "Layer.launch",
      name: "launch",
      module: "Layer",
      package: "effect",
      signature: "<RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect<never, E, RIn>",
      description: "Builds this layer and uses it until it is interrupted. This is useful when\nyour entire application is a layer, such as an HTTP server.",
      documentation: "Builds this layer and uses it until it is interrupted. This is useful when\nyour entire application is a layer, such as an HTTP server.",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 549,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L549"
    },
    {
      id: "Layer.map",
      name: "map",
      module: "Layer",
      package: "effect",
      signature: "{ <A, B>(f: (context: Context<A>) => Context<B>): <E, R>(self: Layer<A, E, R>) => Layer<B, E, R>; <A, E, R, B>(self: Layer<A, E, R>, f: (context: Context<A>) => Context<B>): Layer<B, E, R>; }",
      description: "Returns a new layer whose output is mapped by the specified function.",
      documentation: "Returns a new layer whose output is mapped by the specified function.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 556,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L556"
    },
    {
      id: "Layer.mapError",
      name: "mapError",
      module: "Layer",
      package: "effect",
      signature: "{ <E, E2>(f: (error: E) => E2): <A, R>(self: Layer<A, E, R>) => Layer<A, E2, R>; <A, E, R, E2>(self: Layer<A, E, R>, f: (error: E) => E2): Layer<A, E2, R>; }",
      description: "Returns a layer with its error channel mapped using the specified function.",
      documentation: "Returns a layer with its error channel mapped using the specified function.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 578,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L578"
    },
    {
      id: "Layer.match",
      name: "match",
      module: "Layer",
      package: "effect",
      signature: "{ <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (error: E) => Layer<A2, E2, R2>; readonly onSuccess: (context: Context<A>) => Layer<A3, E3, R3>; }): <R>(self: Layer<A, E, R>) => Layer<A2 & A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Layer<A, E, R>, options: { readonly onFailure: (error: E) => Layer<A2, E2, R2>; readonly onSuccess: (context: Context<A>) => Layer<A3, E3, R3>; }): Layer<A2 & A3, E2 | E3, R | R2 | R3>; }",
      description: "Feeds the error or output services of this layer into the input of either\nthe specified `failure` or `success` layers, resulting in a new layer with\nthe inputs of this layer, and the error or outputs of the specified layer.",
      documentation: "Feeds the error or output services of this layer into the input of either\nthe specified `failure` or `success` layers, resulting in a new layer with\nthe inputs of this layer, and the error or outputs of the specified layer.",
      examples: [],
      tags: [
        "folding"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 602,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L602"
    },
    {
      id: "Layer.matchCause",
      name: "matchCause",
      module: "Layer",
      package: "effect",
      signature: "{ <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (cause: Cause<E>) => Layer<A2, E2, R2>; readonly onSuccess: (context: Context<A>) => Layer<A3, E3, R3>; }): <R>(self: Layer<A, E, R>) => Layer<A2 & A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Layer<A, E, R>, options: { readonly onFailure: (cause: Cause<E>) => Layer<A2, E2, R2>; readonly onSuccess: (context: Context<A>) => Layer<A3, E3, R3>; }): Layer<A2 & A3, E2 | E3, R | R2 | R3>; }",
      description: "Feeds the error or output services of this layer into the input of either\nthe specified `failure` or `success` layers, resulting in a new layer with\nthe inputs of this layer, and the error or outputs of the specified layer.",
      documentation: "Feeds the error or output services of this layer into the input of either\nthe specified `failure` or `success` layers, resulting in a new layer with\nthe inputs of this layer, and the error or outputs of the specified layer.",
      examples: [],
      tags: [
        "folding"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 636,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L636"
    },
    {
      id: "Layer.memoize",
      name: "memoize",
      module: "Layer",
      package: "effect",
      signature: "<RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect<Layer<ROut, E, RIn>, never, Scope>",
      description: "Returns a scoped effect that, if evaluated, will return the lazily computed\nresult of this layer.",
      documentation: "Returns a scoped effect that, if evaluated, will return the lazily computed\nresult of this layer.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 669,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L669"
    },
    {
      id: "Layer.merge",
      name: "merge",
      module: "Layer",
      package: "effect",
      signature: "{ <RIn2, E2, ROut2>(that: Layer<ROut2, E2, RIn2>): <RIn, E1, ROut>(self: Layer<ROut, E1, RIn>) => Layer<ROut2 | ROut, E2 | E1, RIn2 | RIn>; <RIn, E1, ROut, RIn2, E2, ROut2>(self: Layer<ROut, E1, RIn>, that: Layer<ROut2, E2, RIn2>): Layer<ROut | ROut2, E1 | E2, RIn | RIn2>; }",
      description: "Merges this layer with the specified layer concurrently, producing a new layer with combined input and output types.",
      documentation: "Merges this layer with the specified layer concurrently, producing a new layer with combined input and output types.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 676,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L676"
    },
    {
      id: "Layer.mergeAll",
      name: "mergeAll",
      module: "Layer",
      package: "effect",
      signature: "<Layers extends readonly [Layer<never, any, any>, ...Array<Layer<never, any, any>>]>(...layers: Layers) => Layer<{ [k in keyof Layers]: Layer.Success<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Context<Layers[k]>; }[number]>",
      description: "Combines all the provided layers concurrently, creating a new layer with merged input, error, and output types.",
      documentation: "Combines all the provided layers concurrently, creating a new layer with merged input, error, and output types.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 698,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L698"
    },
    {
      id: "Layer.orDie",
      name: "orDie",
      module: "Layer",
      package: "effect",
      signature: "<A, E, R>(self: Layer<A, E, R>) => Layer<A, never, R>",
      description: "Translates effect failure into death of the fiber, making all failures\nunchecked and not a part of the type of the layer.",
      documentation: "Translates effect failure into death of the fiber, making all failures\nunchecked and not a part of the type of the layer.",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 712,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L712"
    },
    {
      id: "Layer.orElse",
      name: "orElse",
      module: "Layer",
      package: "effect",
      signature: "{ <A2, E2, R2>(that: LazyArg<Layer<A2, E2, R2>>): <A, E, R>(self: Layer<A, E, R>) => Layer<A & A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Layer<A, E, R>, that: LazyArg<Layer<A2, E2, R2>>): Layer<A & A2, E | E2, R | R2>; }",
      description: "Executes this layer and returns its output, if it succeeds, but otherwise\nexecutes the specified layer.",
      documentation: "Executes this layer and returns its output, if it succeeds, but otherwise\nexecutes the specified layer.",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 720,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L720"
    },
    {
      id: "Layer.passthrough",
      name: "passthrough",
      module: "Layer",
      package: "effect",
      signature: "<RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Layer<RIn | ROut, E, RIn>",
      description: "Returns a new layer that produces the outputs of this layer but also\npasses through the inputs.",
      documentation: "Returns a new layer that produces the outputs of this layer but also\npasses through the inputs.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 745,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L745"
    },
    {
      id: "Layer.project",
      name: "project",
      module: "Layer",
      package: "effect",
      signature: "{ <I1, S1, I2, S2>(tagA: Tag<I1, S1>, tagB: Tag<I2, S2>, f: (a: NoInfer<S1>) => NoInfer<S2>): <RIn, E>(self: Layer<I1, E, RIn>) => Layer<I2, E, RIn>; <RIn, E, I1, S1, I2, S2>(self: Layer<I1, E, RIn>, tagA: Tag<I1, S1>, tagB: Tag<I2, S2>, f: (a: NoInfer<S1>) => NoInfer<S2>): Layer<I2, E, RIn>; }",
      description: "Projects out part of one of the services output by this layer using the\nspecified function.",
      documentation: "Projects out part of one of the services output by this layer using the\nspecified function.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 753,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L753"
    },
    {
      id: "Layer.locallyEffect",
      name: "locallyEffect",
      module: "Layer",
      package: "effect",
      signature: "{ <RIn, E, ROut, RIn2, E2, ROut2>(f: (_: Effect<RIn, E, Context<ROut>>) => Effect<RIn2, E2, Context<ROut2>>): (self: Layer<ROut, E, RIn>) => Layer<ROut2, E2, RIn2>; <RIn, E, ROut, RIn2, E2, ROut2>(self: Layer<ROut, E, RIn>, f: (_: Effect<RIn, E, Context<ROut>>) => Effect<RIn2, E2, Context<ROut2>>): Layer<ROut2, E2, RIn2>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 775,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L775"
    },
    {
      id: "Layer.locally",
      name: "locally",
      module: "Layer",
      package: "effect",
      signature: "{ <X>(ref: FiberRef<X>, value: X): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>; <A, E, R, X>(self: Layer<A, E, R>, ref: FiberRef<X>, value: X): Layer<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 791,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L791"
    },
    {
      id: "Layer.locallyWith",
      name: "locallyWith",
      module: "Layer",
      package: "effect",
      signature: "{ <X>(ref: FiberRef<X>, value: (_: X) => X): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>; <A, E, R, X>(self: Layer<A, E, R>, ref: FiberRef<X>, value: (_: X) => X): Layer<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 807,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L807"
    },
    {
      id: "Layer.locallyScoped",
      name: "locallyScoped",
      module: "Layer",
      package: "effect",
      signature: "<A>(self: FiberRef<A>, value: A) => Layer<never, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 823,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L823"
    },
    {
      id: "Layer.fiberRefLocallyScopedWith",
      name: "fiberRefLocallyScopedWith",
      module: "Layer",
      package: "effect",
      signature: "<A>(self: FiberRef<A>, value: (_: A) => A) => Layer<never, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 828,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L828"
    },
    {
      id: "Layer.retry",
      name: "retry",
      module: "Layer",
      package: "effect",
      signature: "{ <X, E, RIn2>(schedule: Schedule<X, NoInfer<E>, RIn2>): <ROut, RIn>(self: Layer<ROut, E, RIn>) => Layer<ROut, E, RIn2 | RIn>; <ROut, E, RIn, X, RIn2>(self: Layer<ROut, E, RIn>, schedule: Schedule<X, E, RIn2>): Layer<ROut, E, RIn | RIn2>; }",
      description: "Retries constructing this layer according to the specified schedule.",
      documentation: "Retries constructing this layer according to the specified schedule.",
      examples: [],
      tags: [
        "retrying"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 835,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L835"
    },
    {
      id: "Layer.scope",
      name: "scope",
      module: "Layer",
      package: "effect",
      signature: "Layer<Scope, never, never>",
      description: "A layer that constructs a scope and closes it when the workflow the layer\nis provided to completes execution, whether by success, failure, or\ninterruption. This can be used to close a scope when providing a layer to a\nworkflow.",
      documentation: "A layer that constructs a scope and closes it when the workflow the layer\nis provided to completes execution, whether by success, failure, or\ninterruption. This can be used to close a scope when providing a layer to a\nworkflow.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 860,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L860"
    },
    {
      id: "Layer.scoped",
      name: "scoped",
      module: "Layer",
      package: "effect",
      signature: "{ <I, S>(tag: Tag<I, S>): <E, R>(effect: Effect<NoInfer<S>, E, R>) => Layer<I, E, Exclude<R, Scope>>; <I, S, E, R>(tag: Tag<I, S>, effect: Effect<NoInfer<S>, E, R>): Layer<I, E, Exclude<R, Scope>>; }",
      description: "Constructs a layer from the specified scoped effect.",
      documentation: "Constructs a layer from the specified scoped effect.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 867,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L867"
    },
    {
      id: "Layer.scopedDiscard",
      name: "scopedDiscard",
      module: "Layer",
      package: "effect",
      signature: "<X, E, R>(effect: Effect<X, E, R>) => Layer<never, E, Exclude<R, Scope>>",
      description: "Constructs a layer from the specified scoped effect.",
      documentation: "Constructs a layer from the specified scoped effect.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 889,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L889"
    },
    {
      id: "Layer.scopedContext",
      name: "scopedContext",
      module: "Layer",
      package: "effect",
      signature: "<A, E, R>(effect: Effect<Context<A>, E, R>) => Layer<A, E, Exclude<R, Scope>>",
      description: "Constructs a layer from the specified scoped effect, which must return one\nor more services.",
      documentation: "Constructs a layer from the specified scoped effect, which must return one\nor more services.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 897,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L897"
    },
    {
      id: "Layer.service",
      name: "service",
      module: "Layer",
      package: "effect",
      signature: "<I, S>(tag: Tag<I, S>) => Layer<I, never, I>",
      description: "Constructs a layer that accesses and returns the specified service from the\ncontext.",
      documentation: "Constructs a layer that accesses and returns the specified service from the\ncontext.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 905,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L905"
    },
    {
      id: "Layer.succeed",
      name: "succeed",
      module: "Layer",
      package: "effect",
      signature: "{ <I, S>(tag: Tag<I, S>): (resource: NoInfer<S>) => Layer<I, never, never>; <I, S>(tag: Tag<I, S>, resource: NoInfer<S>): Layer<I, never, never>; }",
      description: "Constructs a layer from the specified value.",
      documentation: "Constructs a layer from the specified value.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 912,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L912"
    },
    {
      id: "Layer.succeedContext",
      name: "succeedContext",
      module: "Layer",
      package: "effect",
      signature: "<A>(context: Context<A>) => Layer<A, never, never>",
      description: "Constructs a layer from the specified value, which must return one or more\nservices.",
      documentation: "Constructs a layer from the specified value, which must return one or more\nservices.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 935,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L935"
    },
    {
      id: "Layer.suspend",
      name: "suspend",
      module: "Layer",
      package: "effect",
      signature: "<RIn, E, ROut>(evaluate: LazyArg<Layer<ROut, E, RIn>>) => Layer<ROut, E, RIn>",
      description: "Lazily constructs a layer. This is useful to avoid infinite recursion when\ncreating layers that refer to themselves.",
      documentation: "Lazily constructs a layer. This is useful to avoid infinite recursion when\ncreating layers that refer to themselves.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 943,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L943"
    },
    {
      id: "Layer.sync",
      name: "sync",
      module: "Layer",
      package: "effect",
      signature: "{ <I, S>(tag: Tag<I, S>): (evaluate: LazyArg<NoInfer<S>>) => Layer<I, never, never>; <I, S>(tag: Tag<I, S>, evaluate: LazyArg<NoInfer<S>>): Layer<I, never, never>; }",
      description: "Lazily constructs a layer from the specified value.",
      documentation: "Lazily constructs a layer from the specified value.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 950,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L950"
    },
    {
      id: "Layer.syncContext",
      name: "syncContext",
      module: "Layer",
      package: "effect",
      signature: "<A>(evaluate: LazyArg<Context<A>>) => Layer<A, never, never>",
      description: "Lazily constructs a layer from the specified value, which must return one or more\nservices.",
      documentation: "Lazily constructs a layer from the specified value, which must return one or more\nservices.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 973,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L973"
    },
    {
      id: "Layer.tap",
      name: "tap",
      module: "Layer",
      package: "effect",
      signature: "{ <ROut, XR extends ROut, RIn2, E2, X>(f: (context: Context<XR>) => Effect<X, E2, RIn2>): <RIn, E>(self: Layer<ROut, E, RIn>) => Layer<ROut, E2 | E, RIn2 | RIn>; <RIn, E, ROut, XR extends ROut, RIn2, E2, X>(self: Layer<ROut, E, RIn>, f: (context: Context<XR>) => Effect<X, E2, RIn2>): Layer<ROut, E | E2, RIn | RIn2>; }",
      description: "Performs the specified effect if this layer succeeds.",
      documentation: "Performs the specified effect if this layer succeeds.",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 980,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L980"
    },
    {
      id: "Layer.tapError",
      name: "tapError",
      module: "Layer",
      package: "effect",
      signature: "{ <E, XE extends E, RIn2, E2, X>(f: (e: XE) => Effect<X, E2, RIn2>): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut, E | E2, RIn2 | RIn>; <RIn, E, XE extends E, ROut, RIn2, E2, X>(self: Layer<ROut, E, RIn>, f: (e: XE) => Effect<X, E2, RIn2>): Layer<ROut, E | E2, RIn | RIn2>; }",
      description: "Performs the specified effect if this layer fails.",
      documentation: "Performs the specified effect if this layer fails.",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1002,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1002"
    },
    {
      id: "Layer.tapErrorCause",
      name: "tapErrorCause",
      module: "Layer",
      package: "effect",
      signature: "{ <E, XE extends E, RIn2, E2, X>(f: (cause: Cause<XE>) => Effect<X, E2, RIn2>): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut, E | E2, RIn2 | RIn>; <RIn, E, XE extends E, ROut, RIn2, E2, X>(self: Layer<ROut, E, RIn>, f: (cause: Cause<XE>) => Effect<X, E2, RIn2>): Layer<ROut, E | E2, RIn | RIn2>; }",
      description: "Performs the specified effect if this layer fails.",
      documentation: "Performs the specified effect if this layer fails.",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1024,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1024"
    },
    {
      id: "Layer.toRuntime",
      name: "toRuntime",
      module: "Layer",
      package: "effect",
      signature: "<RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect<Runtime<ROut>, E, Scope | RIn>",
      description: "Converts a layer that requires no services into a scoped runtime, which can\nbe used to execute effects.",
      documentation: "Converts a layer that requires no services into a scoped runtime, which can\nbe used to execute effects.",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1047,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1047"
    },
    {
      id: "Layer.toRuntimeWithMemoMap",
      name: "toRuntimeWithMemoMap",
      module: "Layer",
      package: "effect",
      signature: "{ (memoMap: MemoMap): <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect<Runtime<ROut>, E, Scope | RIn>; <RIn, E, ROut>(self: Layer<ROut, E, RIn>, memoMap: MemoMap): Effect<Runtime<ROut>, E, Scope | RIn>; }",
      description: "Converts a layer that requires no services into a scoped runtime, which can\nbe used to execute effects.",
      documentation: "Converts a layer that requires no services into a scoped runtime, which can\nbe used to execute effects.",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1055,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1055"
    },
    {
      id: "Layer.provide",
      name: "provide",
      module: "Layer",
      package: "effect",
      signature: "{ <RIn, E, ROut>(that: Layer<ROut, E, RIn>): <RIn2, E2, ROut2>(self: Layer<ROut2, E2, RIn2>) => Layer<ROut2, E | E2, RIn | Exclude<RIn2, ROut>>; <const Layers extends readonly [Layer.Any, ...Array<Layer.Any>]>(that: Layers): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E | { [k in keyof Layers]: Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Success<Layers[k]>; }[number]>>; <RIn2, E2, ROut2, RIn, E, ROut>(self: Layer<ROut2, E2, RIn2>, that: Layer<ROut, E, RIn>): Layer<ROut2, E2 | E, RIn | Exclude<RIn2, ROut>>; <A, E, R, const Layers extends readonly [Layer.Any, ...Array<Layer.Any>]>(self: Layer<A, E, R>, that: Layers): Layer<A, E | { [k in keyof Layers]: Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Success<Layers[k]>; }[number]>>; }",
      description: "Feeds the output services of this builder into the input of the specified\nbuilder, resulting in a new builder with the inputs of this builder as\nwell as any leftover inputs, and the outputs of the specified builder.",
      documentation: "Feeds the output services of this builder into the input of the specified\nbuilder, resulting in a new builder with the inputs of this builder as\nwell as any leftover inputs, and the outputs of the specified builder.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1081,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1081"
    },
    {
      id: "Layer.provideMerge",
      name: "provideMerge",
      module: "Layer",
      package: "effect",
      signature: "{ <RIn, E, ROut>(self: Layer<ROut, E, RIn>): <RIn2, E2, ROut2>(that: Layer<ROut2, E2, RIn2>) => Layer<ROut | ROut2, E | E2, RIn | Exclude<RIn2, ROut>>; <RIn2, E2, ROut2, RIn, E, ROut>(that: Layer<ROut2, E2, RIn2>, self: Layer<ROut, E, RIn>): Layer<ROut2 | ROut, E2 | E, RIn | Exclude<RIn2, ROut>>; }",
      description: "Feeds the output services of this layer into the input of the specified\nlayer, resulting in a new layer with the inputs of this layer, and the\noutputs of both layers.",
      documentation: "Feeds the output services of this layer into the input of the specified\nlayer, resulting in a new layer with the inputs of this layer, and the\noutputs of both layers.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1139,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1139"
    },
    {
      id: "Layer.zipWith",
      name: "zipWith",
      module: "Layer",
      package: "effect",
      signature: "{ <B, E2, R2, A, C>(that: Layer<B, E2, R2>, f: (a: Context<A>, b: Context<B>) => Context<C>): <E, R>(self: Layer<A, E, R>) => Layer<C, E2 | E, R2 | R>; <A, E, R, B, E2, R2, C>(self: Layer<A, E, R>, that: Layer<B, E2, R2>, f: (a: Context<A>, b: Context<B>) => Context<C>): Layer<C, E | E2, R | R2>; }",
      description: "Combines this layer with the specified layer concurrently, creating a new layer with merged input types and\ncombined output types using the provided function.",
      documentation: "Combines this layer with the specified layer concurrently, creating a new layer with merged input types and\ncombined output types using the provided function.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1166,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1166"
    },
    {
      id: "Layer.unwrapEffect",
      name: "unwrapEffect",
      module: "Layer",
      package: "effect",
      signature: "<A, E1, R1, E, R>(self: Effect<Layer<A, E1, R1>, E, R>) => Layer<A, E1 | E, R1 | R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1188,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1188"
    },
    {
      id: "Layer.unwrapScoped",
      name: "unwrapScoped",
      module: "Layer",
      package: "effect",
      signature: "<A, E1, R1, E, R>(self: Effect<Layer<A, E1, R1>, E, R>) => Layer<A, E1 | E, R1 | Exclude<R, Scope>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1193,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1193"
    },
    {
      id: "Layer.setClock",
      name: "setClock",
      module: "Layer",
      package: "effect",
      signature: "<A extends Clock.Clock>(clock: A) => Layer<never, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "clock"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1198,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1198"
    },
    {
      id: "Layer.setConfigProvider",
      name: "setConfigProvider",
      module: "Layer",
      package: "effect",
      signature: "(configProvider: ConfigProvider) => Layer<never, never, never>",
      description: "Sets the current `ConfigProvider`.",
      documentation: "Sets the current `ConfigProvider`.",
      examples: [],
      tags: [
        "config"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1205,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1205"
    },
    {
      id: "Layer.parentSpan",
      name: "parentSpan",
      module: "Layer",
      package: "effect",
      signature: "(span: AnySpan) => Layer<ParentSpan, never, never>",
      description: "Adds the provided span to the span stack.",
      documentation: "Adds the provided span to the span stack.",
      examples: [],
      tags: [
        "tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1212,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1212"
    },
    {
      id: "Layer.setRandom",
      name: "setRandom",
      module: "Layer",
      package: "effect",
      signature: "<A extends Random.Random>(random: A) => Layer<never, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Random"
      ],
      since: "3.15.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1217,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1217"
    },
    {
      id: "Layer.setRequestBatching",
      name: "setRequestBatching",
      module: "Layer",
      package: "effect",
      signature: "(requestBatching: boolean) => Layer<never, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "requests & batching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1222,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1222"
    },
    {
      id: "Layer.setRequestCaching",
      name: "setRequestCaching",
      module: "Layer",
      package: "effect",
      signature: "(requestCaching: boolean) => Layer<never, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "requests & batching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1227,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1227"
    },
    {
      id: "Layer.setRequestCache",
      name: "setRequestCache",
      module: "Layer",
      package: "effect",
      signature: "{ <E, R>(cache: Effect<Cache, E, R>): Layer<never, E, Exclude<R, Scope>>; (cache: Cache): Layer<never, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "requests & batching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1232,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1232"
    },
    {
      id: "Layer.setScheduler",
      name: "setScheduler",
      module: "Layer",
      package: "effect",
      signature: "(scheduler: Scheduler) => Layer<never, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "scheduler"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1248,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1248"
    },
    {
      id: "Layer.span",
      name: "span",
      module: "Layer",
      package: "effect",
      signature: "(name: string, options?: SpanOptions & { readonly onEnd?: (span: Span, exit: Exit<unknown, unknown>) => Effect<void, never, never>; }) => Layer<ParentSpan, never, never>",
      description: "Create and add a span to the current span stack. The span is ended when the Layer is released.",
      documentation: "Create and add a span to the current span stack.\n\nThe span is ended when the Layer is released.",
      examples: [],
      tags: [
        "tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1257,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1257"
    },
    {
      id: "Layer.setTracer",
      name: "setTracer",
      module: "Layer",
      package: "effect",
      signature: "(tracer: Tracer) => Layer<never, never, never>",
      description: "Create a Layer that sets the current Tracer",
      documentation: "Create a Layer that sets the current Tracer",
      examples: [],
      tags: [
        "tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1266,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1266"
    },
    {
      id: "Layer.setTracerEnabled",
      name: "setTracerEnabled",
      module: "Layer",
      package: "effect",
      signature: "(enabled: boolean) => Layer<never, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1271,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1271"
    },
    {
      id: "Layer.setTracerTiming",
      name: "setTracerTiming",
      module: "Layer",
      package: "effect",
      signature: "(enabled: boolean) => Layer<never, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1276,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1276"
    },
    {
      id: "Layer.setUnhandledErrorLogLevel",
      name: "setUnhandledErrorLogLevel",
      module: "Layer",
      package: "effect",
      signature: "(level: Option<LogLevel>) => Layer<never, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "logging"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1281,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1281"
    },
    {
      id: "Layer.setVersionMismatchErrorLogLevel",
      name: "setVersionMismatchErrorLogLevel",
      module: "Layer",
      package: "effect",
      signature: "(level: Option<LogLevel>) => Layer<never, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "logging"
      ],
      since: "3.17.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1286,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1286"
    },
    {
      id: "Layer.withSpan",
      name: "withSpan",
      module: "Layer",
      package: "effect",
      signature: "{ (name: string, options?: SpanOptions & { readonly onEnd?: (span: Span, exit: Exit<unknown, unknown>) => Effect<void, never, never>; }): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, Exclude<R, ParentSpan>>; <A, E, R>(self: Layer<A, E, R>, name: string, options?: SpanOptions & { readonly onEnd?: (span: Span, exit: Exit<unknown, unknown>) => Effect<void, never, never>; }): Layer<A, E, Exclude<R, ParentSpan>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1291,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1291"
    },
    {
      id: "Layer.withParentSpan",
      name: "withParentSpan",
      module: "Layer",
      package: "effect",
      signature: "{ (span: AnySpan): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, Exclude<R, ParentSpan>>; <A, E, R>(self: Layer<A, E, R>, span: AnySpan): Layer<A, E, Exclude<R, ParentSpan>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1311,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1311"
    },
    {
      id: "Layer.makeMemoMap",
      name: "makeMemoMap",
      module: "Layer",
      package: "effect",
      signature: "Effect<MemoMap, never, never>",
      description: "Constructs a `MemoMap` that can be used to build additional layers.",
      documentation: "Constructs a `MemoMap` that can be used to build additional layers.",
      examples: [],
      tags: [
        "memo map"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1329,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1329"
    },
    {
      id: "Layer.buildWithMemoMap",
      name: "buildWithMemoMap",
      module: "Layer",
      package: "effect",
      signature: "{ (memoMap: MemoMap, scope: Scope): <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect<Context<ROut>, E, RIn>; <RIn, E, ROut>(self: Layer<ROut, E, RIn>, memoMap: MemoMap, scope: Scope): Effect<Context<ROut>, E, RIn>; }",
      description: "Builds a layer into an `Effect` value, using the specified `MemoMap` to memoize\nthe layer construction.",
      documentation: "Builds a layer into an `Effect` value, using the specified `MemoMap` to memoize\nthe layer construction.",
      examples: [],
      tags: [
        "memo map"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1337,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1337"
    },
    {
      id: "Layer.updateService",
      name: "updateService",
      module: "Layer",
      package: "effect",
      signature: "(<I, A>(tag: Tag<I, A>, f: (a: A) => A) => <A1, E1, R1>(layer: Layer<A1, E1, R1>) => Layer<A1, E1, I | R1>) & (<A1, E1, R1, I, A>(layer: Layer<A1, E1, R1>, tag: Tag<I, A>, f: (a: A) => A) => Layer<A1, E1, R1 | I>)",
      description: "Updates a service in the context with a new implementation.",
      documentation: "Updates a service in the context with a new implementation.\n\n**Details**\n\nThis function modifies the existing implementation of a service in the\ncontext. It retrieves the current service, applies the provided\ntransformation function `f`, and replaces the old service with the\ntransformed one.\n\n**When to Use**\n\nThis is useful for adapting or extending a service's behavior during the\ncreation of a layer.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "3.13.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Layer.d.ts",
      sourceLine: 1373,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Layer.ts#L1373"
    },
    {
      id: "Context.TagTypeId",
      name: "TagTypeId",
      module: "Context",
      package: "effect",
      signature: "typeof TagTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbol"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Context.d.ts",
      sourceLine: 22,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Context.ts#L22"
    },
    {
      id: "Context.ReferenceTypeId",
      name: "ReferenceTypeId",
      module: "Context",
      package: "effect",
      signature: "typeof ReferenceTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbol"
      ],
      since: "3.11.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Context.d.ts",
      sourceLine: 67,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Context.ts#L67"
    },
    {
      id: "Context.GenericTag",
      name: "GenericTag",
      module: "Context",
      package: "effect",
      signature: "<Identifier, Service = Identifier>(key: string) => Tag<Identifier, Service>",
      description: "Creates a new `Tag` instance with an optional key parameter.",
      documentation: "Creates a new `Tag` instance with an optional key parameter.",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Context } from "effect"\n\nassert.strictEqual(Context.GenericTag("PORT").key === Context.GenericTag("PORT").key, true)'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Context.d.ts",
      sourceLine: 162,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Context.ts#L162"
    },
    {
      id: "Context.unsafeMake",
      name: "unsafeMake",
      module: "Context",
      package: "effect",
      signature: "<Services>(unsafeMap: Map<string, any>) => Context<Services>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Context.d.ts",
      sourceLine: 188,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Context.ts#L188"
    },
    {
      id: "Context.isContext",
      name: "isContext",
      module: "Context",
      package: "effect",
      signature: "(input: unknown) => input is Context<never>",
      description: "Checks if the provided argument is a `Context`.",
      documentation: "Checks if the provided argument is a `Context`.",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Context } from "effect"\n\nassert.strictEqual(Context.isContext(Context.empty()), true)'
        }
      ],
      tags: [
        "guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Context.d.ts",
      sourceLine: 203,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Context.ts#L203"
    },
    {
      id: "Context.isTag",
      name: "isTag",
      module: "Context",
      package: "effect",
      signature: "(input: unknown) => input is Tag<any, any>",
      description: "Checks if the provided argument is a `Tag`.",
      documentation: "Checks if the provided argument is a `Tag`.",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Context } from "effect"\n\nassert.strictEqual(Context.isTag(Context.GenericTag("Tag")), true)'
        }
      ],
      tags: [
        "guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Context.d.ts",
      sourceLine: 218,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Context.ts#L218"
    },
    {
      id: "Context.isReference",
      name: "isReference",
      module: "Context",
      package: "effect",
      signature: "(u: unknown) => u is Reference<any, any>",
      description: "Checks if the provided argument is a `Reference`.",
      documentation: "Checks if the provided argument is a `Reference`.",
      examples: [],
      tags: [
        "guards"
      ],
      since: "3.11.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Context.d.ts",
      sourceLine: 226,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Context.ts#L226"
    },
    {
      id: "Context.empty",
      name: "empty",
      module: "Context",
      package: "effect",
      signature: "() => Context<never>",
      description: "Returns an empty `Context`.",
      documentation: "Returns an empty `Context`.",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Context } from "effect"\n\nassert.strictEqual(Context.isContext(Context.empty()), true)'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Context.d.ts",
      sourceLine: 241,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Context.ts#L241"
    },
    {
      id: "Context.make",
      name: "make",
      module: "Context",
      package: "effect",
      signature: "<I, S>(tag: Tag<I, S>, service: NoInfer<S>) => Context<I>",
      description: "Creates a new `Context` with a single service associated to the tag.",
      documentation: "Creates a new `Context` with a single service associated to the tag.",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Context } from "effect"\n\nconst Port = Context.GenericTag<{ PORT: number }>("Port")\n\nconst Services = Context.make(Port, { PORT: 8080 })\n\nassert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Context.d.ts",
      sourceLine: 260,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Context.ts#L260"
    },
    {
      id: "Context.add",
      name: "add",
      module: "Context",
      package: "effect",
      signature: "{ <I, S>(tag: Tag<I, S>, service: NoInfer<S>): <Services>(self: Context<Services>) => Context<I | Services>; <Services, I, S>(self: Context<Services>, tag: Tag<I, S>, service: NoInfer<S>): Context<Services | I>; }",
      description: "Adds a service to a given `Context`.",
      documentation: "Adds a service to a given `Context`.",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Context, pipe } from "effect"\n\nconst Port = Context.GenericTag<{ PORT: number }>("Port")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")\n\nconst someContext = Context.make(Port, { PORT: 8080 })\n\nconst Services = pipe(\n  someContext,\n  Context.add(Timeout, { TIMEOUT: 5000 })\n)\n\nassert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\nassert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Context.d.ts",
      sourceLine: 285,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Context.ts#L285"
    },
    {
      id: "Context.get",
      name: "get",
      module: "Context",
      package: "effect",
      signature: "{ <I, S>(tag: Reference<I, S>): <Services>(self: Context<Services>) => S; <Services, I extends Services, S>(tag: Tag<I, S>): (self: Context<Services>) => S; <Services, I, S>(self: Context<Services>, tag: Reference<I, S>): S; <Services, I extends Services, S>(self: Context<Services>, tag: Tag<I, S>): S; }",
      description: "Get a service from the context that corresponds to the given tag.",
      documentation: "Get a service from the context that corresponds to the given tag.",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { pipe, Context } from "effect"\n\nconst Port = Context.GenericTag<{ PORT: number }>("Port")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")\n\nconst Services = pipe(\n  Context.make(Port, { PORT: 8080 }),\n  Context.add(Timeout, { TIMEOUT: 5000 })\n)\n\nassert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })'
        }
      ],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Context.d.ts",
      sourceLine: 359,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Context.ts#L359"
    },
    {
      id: "Context.getOrElse",
      name: "getOrElse",
      module: "Context",
      package: "effect",
      signature: "{ <S, I, B>(tag: Tag<I, S>, orElse: LazyArg<B>): <Services>(self: Context<Services>) => S | B; <Services, S, I, B>(self: Context<Services>, tag: Tag<I, S>, orElse: LazyArg<B>): S | B; }",
      description: "Get a service from the context that corresponds to the given tag, or\nuse the fallback value.",
      documentation: "Get a service from the context that corresponds to the given tag, or\nuse the fallback value.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "3.7.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Context.d.ts",
      sourceLine: 460,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Context.ts#L460"
    },
    {
      id: "Context.unsafeGet",
      name: "unsafeGet",
      module: "Context",
      package: "effect",
      signature: "{ <S, I>(tag: Tag<I, S>): <Services>(self: Context<Services>) => S; <Services, S, I>(self: Context<Services>, tag: Tag<I, S>): S; }",
      description: "/\n * Get a service from the context that corresponds to the given tag.\n * This function is unsafe because if the tag is not present in the context, a runtime error will be thrown.\n *\n * For a safer version see {@link getOption}.\n *\n *",
      documentation: "/**\n * Get a service from the context that corresponds to the given tag.\n * This function is unsafe because if the tag is not present in the context, a runtime error will be thrown.\n *\n * For a safer version see {@link getOption}.\n *\n *",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Context } from "effect"\n\nconst Port = Context.GenericTag<{ PORT: number }>("Port")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")\n\nconst Services = Context.make(Port, { PORT: 8080 })\n\nassert.deepStrictEqual(Context.unsafeGet(Services, Port), { PORT: 8080 })\nassert.throws(() => Context.unsafeGet(Services, Timeout))'
        }
      ],
      tags: [
        "unsafe"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Context.d.ts",
      sourceLine: 501,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Context.ts#L501"
    },
    {
      id: "Context.getOption",
      name: "getOption",
      module: "Context",
      package: "effect",
      signature: "{ <S, I>(tag: Tag<I, S>): <Services>(self: Context<Services>) => Option<S>; <Services, S, I>(self: Context<Services>, tag: Tag<I, S>): Option<S>; }",
      description: "Get the value associated with the specified tag from the context wrapped in an `Option` object. If the tag is not\nfound, the `Option` object will be `None`.",
      documentation: "Get the value associated with the specified tag from the context wrapped in an `Option` object. If the tag is not\nfound, the `Option` object will be `None`.",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Context, Option } from "effect"\n\nconst Port = Context.GenericTag<{ PORT: number }>("Port")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")\n\nconst Services = Context.make(Port, { PORT: 8080 })\n\nassert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))\nassert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())'
        }
      ],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Context.d.ts",
      sourceLine: 572,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Context.ts#L572"
    },
    {
      id: "Context.merge",
      name: "merge",
      module: "Context",
      package: "effect",
      signature: "{ <R1>(that: Context<R1>): <Services>(self: Context<Services>) => Context<R1 | Services>; <Services, R1>(self: Context<Services>, that: Context<R1>): Context<Services | R1>; }",
      description: "Merges two `Context`s, returning a new `Context` containing the services of both.",
      documentation: "Merges two `Context`s, returning a new `Context` containing the services of both.",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Context } from "effect"\n\nconst Port = Context.GenericTag<{ PORT: number }>("Port")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")\n\nconst firstContext = Context.make(Port, { PORT: 8080 })\nconst secondContext = Context.make(Timeout, { TIMEOUT: 5000 })\n\nconst Services = Context.merge(firstContext, secondContext)\n\nassert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\nassert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Context.d.ts",
      sourceLine: 640,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Context.ts#L640"
    },
    {
      id: "Context.mergeAll",
      name: "mergeAll",
      module: "Context",
      package: "effect",
      signature: "<T extends Array<unknown>>(...ctxs: { [K in keyof T]: Context<T[K]>; }) => Context<T[number]>",
      description: "Merges any number of `Context`s, returning a new `Context` containing the services of all.",
      documentation: "Merges any number of `Context`s, returning a new `Context` containing the services of all.",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Context } from "effect"\n\nconst Port = Context.GenericTag<{ PORT: number }>("Port")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")\nconst Host = Context.GenericTag<{ HOST: string }>("Host")\n\nconst firstContext = Context.make(Port, { PORT: 8080 })\nconst secondContext = Context.make(Timeout, { TIMEOUT: 5000 })\nconst thirdContext = Context.make(Host, { HOST: "localhost" })\n\nconst Services = Context.mergeAll(firstContext, secondContext, thirdContext)\n\nassert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })\nassert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })\nassert.deepStrictEqual(Context.get(Services, Host), { HOST: "localhost" })'
        }
      ],
      tags: [],
      since: "3.12.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Context.d.ts",
      sourceLine: 713,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Context.ts#L713"
    },
    {
      id: "Context.pick",
      name: "pick",
      module: "Context",
      package: "effect",
      signature: "<Tags extends ReadonlyArray<Tag<any, any>>>(...tags: Tags) => <Services>(self: Context<Services>) => Context<Services & Tag.Identifier<Tags[number]>>",
      description: "Returns a new `Context` that contains only the specified services.",
      documentation: "Returns a new `Context` that contains only the specified services.",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { pipe, Context, Option } from "effect"\n\nconst Port = Context.GenericTag<{ PORT: number }>("Port")\nconst Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")\n\nconst someContext = pipe(\n  Context.make(Port, { PORT: 8080 }),\n  Context.add(Timeout, { TIMEOUT: 5000 })\n)\n\nconst Services = pipe(someContext, Context.pick(Port))\n\nassert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))\nassert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Context.d.ts",
      sourceLine: 740,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Context.ts#L740"
    },
    {
      id: "Context.omit",
      name: "omit",
      module: "Context",
      package: "effect",
      signature: "<Tags extends ReadonlyArray<Tag<any, any>>>(...tags: Tags) => <Services>(self: Context<Services>) => Context<Exclude<Services, Tag.Identifier<Tags[number]>>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Context.d.ts",
      sourceLine: 744,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Context.ts#L744"
    },
    {
      id: "Context.Tag",
      name: "Tag",
      module: "Context",
      package: "effect",
      signature: "<const Id extends string>(id: Id) => <Self, Shape>() => TagClass<Self, Id, Shape>",
      description: "",
      documentation: "",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Context, Layer } from "effect"\n\nclass MyTag extends Context.Tag("MyTag")<\n MyTag,\n { readonly myNum: number }\n>() {\n static Live = Layer.succeed(this, { myNum: 108 })\n}'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Context.d.ts",
      sourceLine: 762,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Context.ts#L762"
    },
    {
      id: "Context.Reference",
      name: "Reference",
      module: "Context",
      package: "effect",
      signature: "<Self>() => <const Id extends string, Service>(id: Id, options: { readonly defaultValue: () => Service; }) => ReferenceClass<Self, Id, Service>",
      description: "Creates a context tag with a default value.",
      documentation: 'Creates a context tag with a default value.\n\n**Details**\n\n`Context.Reference` allows you to create a tag that can hold a value. You can\nprovide a default value for the service, which will automatically be used\nwhen the context is accessed, or override it with a custom implementation\nwhen needed.\n\n**Example** (Declaring a Tag with a default value)\n\n```ts\nimport * as assert from "node:assert"\nimport { Context, Effect } from "effect"\n\nclass SpecialNumber extends Context.Reference<SpecialNumber>()(\n  "SpecialNumber",\n  { defaultValue: () => 2048 }\n) {}\n\n//      \u250C\u2500\u2500\u2500 Effect<void, never, never>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  const specialNumber = yield* SpecialNumber\n  console.log(`The special number is ${specialNumber}`)\n})\n\n// No need to provide the SpecialNumber implementation\nEffect.runPromise(program)\n// Output: The special number is 2048\n```\n\n**Example** (Overriding the default value)\n\n```ts\nimport { Context, Effect } from "effect"\n\nclass SpecialNumber extends Context.Reference<SpecialNumber>()(\n  "SpecialNumber",\n  { defaultValue: () => 2048 }\n) {}\n\nconst program = Effect.gen(function* () {\n  const specialNumber = yield* SpecialNumber\n  console.log(`The special number is ${specialNumber}`)\n})\n\nEffect.runPromise(program.pipe(Effect.provideService(SpecialNumber, -1)))\n// Output: The special number is -1\n```',
      examples: [
        {
          title: "Declaring a Tag with a default value",
          code: 'import * as assert from "node:assert"\nimport { Context, Effect } from "effect"\n\nclass SpecialNumber extends Context.Reference<SpecialNumber>()(\n  "SpecialNumber",\n  { defaultValue: () => 2048 }\n) {}\n\n//      \u250C\u2500\u2500\u2500 Effect<void, never, never>\n//      \u25BC\nconst program = Effect.gen(function* () {\n  const specialNumber = yield* SpecialNumber\n  console.log(`The special number is ${specialNumber}`)\n})\n\n// No need to provide the SpecialNumber implementation\nEffect.runPromise(program)\n// Output: The special number is 2048'
        },
        {
          title: "Overriding the default value",
          code: 'import { Context, Effect } from "effect"\n\nclass SpecialNumber extends Context.Reference<SpecialNumber>()(\n  "SpecialNumber",\n  { defaultValue: () => 2048 }\n) {}\n\nconst program = Effect.gen(function* () {\n  const specialNumber = yield* SpecialNumber\n  console.log(`The special number is ${specialNumber}`)\n})\n\nEffect.runPromise(program.pipe(Effect.provideService(SpecialNumber, -1)))\n// Output: The special number is -1'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "3.11.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Context.d.ts",
      sourceLine: 819,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Context.ts#L819"
    },
    {
      id: "Scope.ScopeTypeId",
      name: "ScopeTypeId",
      module: "Scope",
      package: "effect",
      signature: "typeof ScopeTypeId",
      description: "A unique identifier for the `Scope` type.",
      documentation: "A unique identifier for the `Scope` type.",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Scope.d.ts",
      sourceLine: 15,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Scope.ts#L15"
    },
    {
      id: "Scope.CloseableScopeTypeId",
      name: "CloseableScopeTypeId",
      module: "Scope",
      package: "effect",
      signature: "typeof CloseableScopeTypeId",
      description: "A unique identifier for the `CloseableScope` type.",
      documentation: "A unique identifier for the `CloseableScope` type.",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Scope.d.ts",
      sourceLine: 29,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Scope.ts#L29"
    },
    {
      id: "Scope.Scope",
      name: "Scope",
      module: "Scope",
      package: "effect",
      signature: "Tag<Scope, Scope>",
      description: "A tag representing the current `Scope` in the environment.",
      documentation: "A tag representing the current `Scope` in the environment.",
      examples: [],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Scope.d.ts",
      sourceLine: 65,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Scope.ts#L65"
    },
    {
      id: "Scope.addFinalizer",
      name: "addFinalizer",
      module: "Scope",
      package: "effect",
      signature: "(self: Scope, finalizer: Effect<unknown, never, never>) => Effect<void, never, never>",
      description: "Adds a finalizer to this scope. The finalizer is guaranteed to be run when\nthe scope is closed. Use this when the finalizer does not need to know the\n`Exit` value that the scope is closed with.",
      documentation: "Adds a finalizer to this scope. The finalizer is guaranteed to be run when\nthe scope is closed. Use this when the finalizer does not need to know the\n`Exit` value that the scope is closed with.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Scope.d.ts",
      sourceLine: 95,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Scope.ts#L95"
    },
    {
      id: "Scope.addFinalizerExit",
      name: "addFinalizerExit",
      module: "Scope",
      package: "effect",
      signature: "(self: Scope, finalizer: Scope.Finalizer) => Effect<void, never, never>",
      description: "Adds a finalizer to this scope. The finalizer receives the `Exit` value\nwhen the scope is closed, allowing it to perform different actions based\non the exit status.",
      documentation: "Adds a finalizer to this scope. The finalizer receives the `Exit` value\nwhen the scope is closed, allowing it to perform different actions based\non the exit status.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Scope.d.ts",
      sourceLine: 106,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Scope.ts#L106"
    },
    {
      id: "Scope.close",
      name: "close",
      module: "Scope",
      package: "effect",
      signature: "(self: CloseableScope, exit: Exit<unknown, unknown>) => Effect<void, never, never>",
      description: "Closes this scope with the specified exit value, running all finalizers that\nhave been added to the scope.",
      documentation: "Closes this scope with the specified exit value, running all finalizers that\nhave been added to the scope.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Scope.d.ts",
      sourceLine: 114,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Scope.ts#L114"
    },
    {
      id: "Scope.extend",
      name: "extend",
      module: "Scope",
      package: "effect",
      signature: "{ (scope: Scope): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, Exclude<R, Scope>>; <A, E, R>(effect: Effect<A, E, R>, scope: Scope): Effect<A, E, Exclude<R, Scope>>; }",
      description: "Extends the scope of an `Effect` that requires a scope into this scope.\nIt provides this scope to the effect but does not close the scope when the\neffect completes execution. This allows extending a scoped value into a\nlarger scope.",
      documentation: "Extends the scope of an `Effect` that requires a scope into this scope.\nIt provides this scope to the effect but does not close the scope when the\neffect completes execution. This allows extending a scoped value into a\nlarger scope.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Scope.d.ts",
      sourceLine: 124,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Scope.ts#L124"
    },
    {
      id: "Scope.fork",
      name: "fork",
      module: "Scope",
      package: "effect",
      signature: "(self: Scope, strategy: ExecutionStrategy) => Effect<CloseableScope, never, never>",
      description: "Forks a new child scope with the specified execution strategy. The child scope\nwill automatically be closed when this scope is closed.",
      documentation: "Forks a new child scope with the specified execution strategy. The child scope\nwill automatically be closed when this scope is closed.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Scope.d.ts",
      sourceLine: 153,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Scope.ts#L153"
    },
    {
      id: "Scope.use",
      name: "use",
      module: "Scope",
      package: "effect",
      signature: "{ (scope: CloseableScope): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, Exclude<R, Scope>>; <A, E, R>(effect: Effect<A, E, R>, scope: CloseableScope): Effect<A, E, Exclude<R, Scope>>; }",
      description: "Provides this closeable scope to an `Effect` that requires a scope,\nguaranteeing that the scope is closed with the result of that effect as\nsoon as the effect completes execution, whether by success, failure, or\ninterruption.",
      documentation: "Provides this closeable scope to an `Effect` that requires a scope,\nguaranteeing that the scope is closed with the result of that effect as\nsoon as the effect completes execution, whether by success, failure, or\ninterruption.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Scope.d.ts",
      sourceLine: 163,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Scope.ts#L163"
    },
    {
      id: "Scope.make",
      name: "make",
      module: "Scope",
      package: "effect",
      signature: "(executionStrategy?: ExecutionStrategy) => Effect<CloseableScope, never, never>",
      description: "Creates a new closeable scope where finalizers will run according to the\nspecified `ExecutionStrategy`. If no execution strategy is provided, `sequential`\nwill be used by default.",
      documentation: "Creates a new closeable scope where finalizers will run according to the\nspecified `ExecutionStrategy`. If no execution strategy is provided, `sequential`\nwill be used by default.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Scope.d.ts",
      sourceLine: 193,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Scope.ts#L193"
    },
    {
      id: "Fiber.FiberTypeId",
      name: "FiberTypeId",
      module: "Fiber",
      package: "effect",
      signature: "typeof FiberTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 28,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L28"
    },
    {
      id: "Fiber.RuntimeFiberTypeId",
      name: "RuntimeFiberTypeId",
      module: "Fiber",
      package: "effect",
      signature: "typeof RuntimeFiberTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 38,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L38"
    },
    {
      id: "Fiber.Order",
      name: "Order",
      module: "Fiber",
      package: "effect",
      signature: "Order<RuntimeFiber<unknown, unknown>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "instances"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 269,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L269"
    },
    {
      id: "Fiber.isFiber",
      name: "isFiber",
      module: "Fiber",
      package: "effect",
      signature: "(u: unknown) => u is Fiber<unknown, unknown>",
      description: "Returns `true` if the specified value is a `Fiber`, `false` otherwise.",
      documentation: "Returns `true` if the specified value is a `Fiber`, `false` otherwise.",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 276,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L276"
    },
    {
      id: "Fiber.isRuntimeFiber",
      name: "isRuntimeFiber",
      module: "Fiber",
      package: "effect",
      signature: "<A, E>(self: Fiber<A, E>) => self is RuntimeFiber<A, E>",
      description: "Returns `true` if the specified `Fiber` is a `RuntimeFiber`, `false`\notherwise.",
      documentation: "Returns `true` if the specified `Fiber` is a `RuntimeFiber`, `false`\notherwise.",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 284,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L284"
    },
    {
      id: "Fiber.id",
      name: "id",
      module: "Fiber",
      package: "effect",
      signature: "<A, E>(self: Fiber<A, E>) => FiberId",
      description: "The identity of the fiber.",
      documentation: "The identity of the fiber.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 291,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L291"
    },
    {
      id: "Fiber.awaitAll",
      name: "awaitAll",
      module: "Fiber",
      package: "effect",
      signature: '<const T extends Iterable<Fiber<any, any>>>(fibers: T) => Effect<[T] extends [readonly (infer U)[]] ? number extends T["length"] ? (U extends Fiber<infer A, infer E> ? Exit<A, E> : never)[] : { -readonly [K in keyof T]: T[K] extends Fiber<infer A, infer E> ? Exit<A, E> : never; } : (T extends Iterable<infer U> ? U extends Fiber<infer A, infer E> ? Exit<A, E> : never : never)[], never, never>',
      description: "Awaits on all fibers to be completed, successfully or not.",
      documentation: "Awaits on all fibers to be completed, successfully or not.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 308,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L308"
    },
    {
      id: "Fiber.children",
      name: "children",
      module: "Fiber",
      package: "effect",
      signature: "<A, E>(self: Fiber<A, E>) => Effect<RuntimeFiber<any, any>[], never, never>",
      description: "Retrieves the immediate children of the fiber.",
      documentation: "Retrieves the immediate children of the fiber.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 319,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L319"
    },
    {
      id: "Fiber.all",
      name: "all",
      module: "Fiber",
      package: "effect",
      signature: "<A, E>(fibers: Iterable<Fiber<A, E>>) => Fiber<readonly A[], E>",
      description: "Collects all fibers into a single fiber producing an in-order list of the\nresults.",
      documentation: "Collects all fibers into a single fiber producing an in-order list of the\nresults.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 327,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L327"
    },
    {
      id: "Fiber.done",
      name: "done",
      module: "Fiber",
      package: "effect",
      signature: "<A, E>(exit: Exit<A, E>) => Fiber<A, E>",
      description: "A fiber that is done with the specified `Exit` value.",
      documentation: "A fiber that is done with the specified `Exit` value.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 334,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L334"
    },
    {
      id: "Fiber.dump",
      name: "dump",
      module: "Fiber",
      package: "effect",
      signature: "<A, E>(self: RuntimeFiber<A, E>) => Effect<Fiber.Dump, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 339,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L339"
    },
    {
      id: "Fiber.dumpAll",
      name: "dumpAll",
      module: "Fiber",
      package: "effect",
      signature: "(fibers: Iterable<RuntimeFiber<unknown, unknown>>) => Effect<Fiber.Dump[], never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 344,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L344"
    },
    {
      id: "Fiber.fail",
      name: "fail",
      module: "Fiber",
      package: "effect",
      signature: "<E>(error: E) => Fiber<never, E>",
      description: "A fiber that has already failed with the specified value.",
      documentation: "A fiber that has already failed with the specified value.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 351,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L351"
    },
    {
      id: "Fiber.failCause",
      name: "failCause",
      module: "Fiber",
      package: "effect",
      signature: "<E>(cause: Cause<E>) => Fiber<never, E>",
      description: "Creates a `Fiber` that has already failed with the specified cause.",
      documentation: "Creates a `Fiber` that has already failed with the specified cause.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 358,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L358"
    },
    {
      id: "Fiber.fromEffect",
      name: "fromEffect",
      module: "Fiber",
      package: "effect",
      signature: "<A, E>(effect: Effect<A, E, never>) => Effect<Fiber<A, E>, never, never>",
      description: "Lifts an `Effect` into a `Fiber`.",
      documentation: "Lifts an `Effect` into a `Fiber`.",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 365,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L365"
    },
    {
      id: "Fiber.getCurrentFiber",
      name: "getCurrentFiber",
      module: "Fiber",
      package: "effect",
      signature: "() => Option<RuntimeFiber<any, any>>",
      description: "Gets the current fiber if one is running.",
      documentation: "Gets the current fiber if one is running.",
      examples: [],
      tags: [
        "utilities"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 372,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L372"
    },
    {
      id: "Fiber.inheritAll",
      name: "inheritAll",
      module: "Fiber",
      package: "effect",
      signature: "<A, E>(self: Fiber<A, E>) => Effect<void, never, never>",
      description: "Inherits values from all `FiberRef` instances into current fiber. This\nwill resume immediately.",
      documentation: "Inherits values from all `FiberRef` instances into current fiber. This\nwill resume immediately.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 380,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L380"
    },
    {
      id: "Fiber.interrupt",
      name: "interrupt",
      module: "Fiber",
      package: "effect",
      signature: "<A, E>(self: Fiber<A, E>) => Effect<Exit<A, E>, never, never>",
      description: "Interrupts the fiber from whichever fiber is calling this method. If the\nfiber has already exited, the returned effect will resume immediately.\nOtherwise, the effect will resume when the fiber exits.",
      documentation: "Interrupts the fiber from whichever fiber is calling this method. If the\nfiber has already exited, the returned effect will resume immediately.\nOtherwise, the effect will resume when the fiber exits.",
      examples: [],
      tags: [
        "interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 389,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L389"
    },
    {
      id: "Fiber.interrupted",
      name: "interrupted",
      module: "Fiber",
      package: "effect",
      signature: "(fiberId: FiberId) => Fiber<never, never>",
      description: "Constructrs a `Fiber` that is already interrupted.",
      documentation: "Constructrs a `Fiber` that is already interrupted.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 396,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L396"
    },
    {
      id: "Fiber.interruptAs",
      name: "interruptAs",
      module: "Fiber",
      package: "effect",
      signature: "{ (fiberId: FiberId): <A, E>(self: Fiber<A, E>) => Effect<Exit<A, E>, never, never>; <A, E>(self: Fiber<A, E>, fiberId: FiberId): Effect<Exit<A, E>, never, never>; }",
      description: "Interrupts the fiber as if interrupted from the specified fiber. If the\nfiber has already exited, the returned effect will resume immediately.\nOtherwise, the effect will resume when the fiber exits.",
      documentation: "Interrupts the fiber as if interrupted from the specified fiber. If the\nfiber has already exited, the returned effect will resume immediately.\nOtherwise, the effect will resume when the fiber exits.",
      examples: [],
      tags: [
        "interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 405,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L405"
    },
    {
      id: "Fiber.interruptAsFork",
      name: "interruptAsFork",
      module: "Fiber",
      package: "effect",
      signature: "{ (fiberId: FiberId): <A, E>(self: Fiber<A, E>) => Effect<void, never, never>; <A, E>(self: Fiber<A, E>, fiberId: FiberId): Effect<void, never, never>; }",
      description: "Interrupts the fiber as if interrupted from the specified fiber. If the\nfiber has already exited, the returned effect will resume immediately.\nOtherwise, the effect will resume when the fiber exits.",
      documentation: "Interrupts the fiber as if interrupted from the specified fiber. If the\nfiber has already exited, the returned effect will resume immediately.\nOtherwise, the effect will resume when the fiber exits.",
      examples: [],
      tags: [
        "interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 433,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L433"
    },
    {
      id: "Fiber.interruptAll",
      name: "interruptAll",
      module: "Fiber",
      package: "effect",
      signature: "(fibers: Iterable<Fiber<any, any>>) => Effect<void, never, never>",
      description: "Interrupts all fibers, awaiting their interruption.",
      documentation: "Interrupts all fibers, awaiting their interruption.",
      examples: [],
      tags: [
        "interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 459,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L459"
    },
    {
      id: "Fiber.interruptAllAs",
      name: "interruptAllAs",
      module: "Fiber",
      package: "effect",
      signature: "{ (fiberId: FiberId): (fibers: Iterable<Fiber<any, any>>) => Effect<void, never, never>; (fibers: Iterable<Fiber<any, any>>, fiberId: FiberId): Effect<void, never, never>; }",
      description: "Interrupts all fibers as by the specified fiber, awaiting their\ninterruption.",
      documentation: "Interrupts all fibers as by the specified fiber, awaiting their\ninterruption.",
      examples: [],
      tags: [
        "interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 467,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L467"
    },
    {
      id: "Fiber.interruptFork",
      name: "interruptFork",
      module: "Fiber",
      package: "effect",
      signature: "<A, E>(self: Fiber<A, E>) => Effect<void, never, never>",
      description: "Interrupts the fiber from whichever fiber is calling this method. The\ninterruption will happen in a separate daemon fiber, and the returned\neffect will always resume immediately without waiting.",
      documentation: "Interrupts the fiber from whichever fiber is calling this method. The\ninterruption will happen in a separate daemon fiber, and the returned\neffect will always resume immediately without waiting.",
      examples: [],
      tags: [
        "interruption"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 493,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L493"
    },
    {
      id: "Fiber.join",
      name: "join",
      module: "Fiber",
      package: "effect",
      signature: "<A, E>(self: Fiber<A, E>) => Effect<A, E, never>",
      description: 'Joins the fiber, which suspends the joining fiber until the result of the\nfiber has been determined. Attempting to join a fiber that has erred will\nresult in a catchable error. Joining an interrupted fiber will result in an\n"inner interruption" of this fiber, unlike interruption triggered by\nanother fiber, "inner interruption" can be caught and recovered.',
      documentation: 'Joins the fiber, which suspends the joining fiber until the result of the\nfiber has been determined. Attempting to join a fiber that has erred will\nresult in a catchable error. Joining an interrupted fiber will result in an\n"inner interruption" of this fiber, unlike interruption triggered by\nanother fiber, "inner interruption" can be caught and recovered.',
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 504,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L504"
    },
    {
      id: "Fiber.joinAll",
      name: "joinAll",
      module: "Fiber",
      package: "effect",
      signature: "<A, E>(fibers: Iterable<Fiber<A, E>>) => Effect<A[], E, never>",
      description: "Joins all fibers, awaiting their _successful_ completion. Attempting to\njoin a fiber that has erred will result in a catchable error, _if_ that\nerror does not result from interruption.",
      documentation: "Joins all fibers, awaiting their _successful_ completion. Attempting to\njoin a fiber that has erred will result in a catchable error, _if_ that\nerror does not result from interruption.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 513,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L513"
    },
    {
      id: "Fiber.map",
      name: "map",
      module: "Fiber",
      package: "effect",
      signature: "{ <A, B>(f: (a: A) => B): <E>(self: Fiber<A, E>) => Fiber<B, E>; <A, E, B>(self: Fiber<A, E>, f: (a: A) => B): Fiber<B, E>; }",
      description: "Maps over the value the Fiber computes.",
      documentation: "Maps over the value the Fiber computes.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 520,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L520"
    },
    {
      id: "Fiber.mapEffect",
      name: "mapEffect",
      module: "Fiber",
      package: "effect",
      signature: "{ <A, A2, E2>(f: (a: A) => Effect<A2, E2, never>): <E>(self: Fiber<A, E>) => Fiber<A2, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, f: (a: A) => Effect<A2, E2, never>): Fiber<A2, E | E2>; }",
      description: "Effectually maps over the value the fiber computes.",
      documentation: "Effectually maps over the value the fiber computes.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 542,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L542"
    },
    {
      id: "Fiber.mapFiber",
      name: "mapFiber",
      module: "Fiber",
      package: "effect",
      signature: "{ <E, E2, A, B>(f: (a: A) => Fiber<B, E2>): (self: Fiber<A, E>) => Effect<Fiber<B, E | E2>, never, never>; <A, E, E2, B>(self: Fiber<A, E>, f: (a: A) => Fiber<B, E2>): Effect<Fiber<B, E | E2>, never, never>; }",
      description: "Passes the success of this fiber to the specified callback, and continues\nwith the fiber that it returns.",
      documentation: "Passes the success of this fiber to the specified callback, and continues\nwith the fiber that it returns.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 565,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L565"
    },
    {
      id: "Fiber.match",
      name: "match",
      module: "Fiber",
      package: "effect",
      signature: "{ <A, E, Z>(options: { readonly onFiber: (fiber: Fiber<A, E>) => Z; readonly onRuntimeFiber: (fiber: RuntimeFiber<A, E>) => Z; }): (self: Fiber<A, E>) => Z; <A, E, Z>(self: Fiber<A, E>, options: { readonly onFiber: (fiber: Fiber<A, E>) => Z; readonly onRuntimeFiber: (fiber: RuntimeFiber<A, E>) => Z; }): Z; }",
      description: "Folds over the `Fiber` or `RuntimeFiber`.",
      documentation: "Folds over the `Fiber` or `RuntimeFiber`.",
      examples: [],
      tags: [
        "folding"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 589,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L589"
    },
    {
      id: "Fiber.never",
      name: "never",
      module: "Fiber",
      package: "effect",
      signature: "Fiber<never, never>",
      description: "A fiber that never fails or succeeds.",
      documentation: "A fiber that never fails or succeeds.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 617,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L617"
    },
    {
      id: "Fiber.orElse",
      name: "orElse",
      module: "Fiber",
      package: "effect",
      signature: "{ <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<A2 | A, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<A | A2, E | E2>; }",
      description: "Returns a fiber that prefers `this` fiber, but falls back to the `that` one\nwhen `this` one fails. Interrupting the returned fiber will interrupt both\nfibers, sequentially, from left to right.",
      documentation: "Returns a fiber that prefers `this` fiber, but falls back to the `that` one\nwhen `this` one fails. Interrupting the returned fiber will interrupt both\nfibers, sequentially, from left to right.",
      examples: [],
      tags: [
        "alternatives"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 626,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L626"
    },
    {
      id: "Fiber.orElseEither",
      name: "orElseEither",
      module: "Fiber",
      package: "effect",
      signature: "{ <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<Either<A2, A>, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<Either<A2, A>, E | E2>; }",
      description: "Returns a fiber that prefers `this` fiber, but falls back to the `that` one\nwhen `this` one fails. Interrupting the returned fiber will interrupt both\nfibers, sequentially, from left to right.",
      documentation: "Returns a fiber that prefers `this` fiber, but falls back to the `that` one\nwhen `this` one fails. Interrupting the returned fiber will interrupt both\nfibers, sequentially, from left to right.",
      examples: [],
      tags: [
        "alternatives"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 654,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L654"
    },
    {
      id: "Fiber.poll",
      name: "poll",
      module: "Fiber",
      package: "effect",
      signature: "<A, E>(self: Fiber<A, E>) => Effect<Option<Exit<A, E>>, never, never>",
      description: "Tentatively observes the fiber, but returns immediately if it is not\nalready done.",
      documentation: "Tentatively observes the fiber, but returns immediately if it is not\nalready done.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 681,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L681"
    },
    {
      id: "Fiber.pretty",
      name: "pretty",
      module: "Fiber",
      package: "effect",
      signature: "<A, E>(self: RuntimeFiber<A, E>) => Effect<string, never, never>",
      description: "Pretty-prints a `RuntimeFiber`.",
      documentation: "Pretty-prints a `RuntimeFiber`.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 688,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L688"
    },
    {
      id: "Fiber.roots",
      name: "roots",
      module: "Fiber",
      package: "effect",
      signature: "Effect<RuntimeFiber<any, any>[], never, never>",
      description: "Returns a chunk containing all root fibers.",
      documentation: "Returns a chunk containing all root fibers.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 695,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L695"
    },
    {
      id: "Fiber.unsafeRoots",
      name: "unsafeRoots",
      module: "Fiber",
      package: "effect",
      signature: "(_: void) => RuntimeFiber<any, any>[]",
      description: "Returns a chunk containing all root fibers.",
      documentation: "Returns a chunk containing all root fibers.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 702,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L702"
    },
    {
      id: "Fiber.scoped",
      name: "scoped",
      module: "Fiber",
      package: "effect",
      signature: "<A, E>(self: Fiber<A, E>) => Effect<Fiber<A, E>, never, Scope>",
      description: "Converts this fiber into a scoped effect. The fiber is interrupted when the\nscope is closed.",
      documentation: "Converts this fiber into a scoped effect. The fiber is interrupted when the\nscope is closed.",
      examples: [],
      tags: [
        "destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 710,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L710"
    },
    {
      id: "Fiber.status",
      name: "status",
      module: "Fiber",
      package: "effect",
      signature: "<A, E>(self: RuntimeFiber<A, E>) => Effect<FiberStatus, never, never>",
      description: "Returns the `FiberStatus` of a `RuntimeFiber`.",
      documentation: "Returns the `FiberStatus` of a `RuntimeFiber`.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 717,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L717"
    },
    {
      id: "Fiber.succeed",
      name: "succeed",
      module: "Fiber",
      package: "effect",
      signature: "<A>(value: A) => Fiber<A, never>",
      description: "Returns a fiber that has already succeeded with the specified value.",
      documentation: "Returns a fiber that has already succeeded with the specified value.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 724,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L724"
    },
    {
      id: "Fiber.zip",
      name: "zip",
      module: "Fiber",
      package: "effect",
      signature: "{ <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<[A, A2], E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<[A, A2], E | E2>; }",
      description: "Zips this fiber and the specified fiber together, producing a tuple of\ntheir output.",
      documentation: "Zips this fiber and the specified fiber together, producing a tuple of\ntheir output.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 741,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L741"
    },
    {
      id: "Fiber.zipLeft",
      name: "zipLeft",
      module: "Fiber",
      package: "effect",
      signature: "{ <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<A, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<A, E | E2>; }",
      description: "Same as `zip` but discards the output of that `Fiber`.",
      documentation: "Same as `zip` but discards the output of that `Fiber`.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 765,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L765"
    },
    {
      id: "Fiber.zipRight",
      name: "zipRight",
      module: "Fiber",
      package: "effect",
      signature: "{ <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<A2, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<A2, E | E2>; }",
      description: "Same as `zip` but discards the output of this `Fiber`.",
      documentation: "Same as `zip` but discards the output of this `Fiber`.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 787,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L787"
    },
    {
      id: "Fiber.zipWith",
      name: "zipWith",
      module: "Fiber",
      package: "effect",
      signature: "{ <B, E2, A, C>(that: Fiber<B, E2>, f: (a: A, b: B) => C): <E>(self: Fiber<A, E>) => Fiber<C, E2 | E>; <A, E, B, E2, C>(self: Fiber<A, E>, that: Fiber<B, E2>, f: (a: A, b: B) => C): Fiber<C, E | E2>; }",
      description: "Zips this fiber with the specified fiber, combining their results using the\nspecified combiner function. Both joins and interruptions are performed in\nsequential order from left to right.",
      documentation: "Zips this fiber with the specified fiber, combining their results using the\nspecified combiner function. Both joins and interruptions are performed in\nsequential order from left to right.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Fiber.d.ts",
      sourceLine: 811,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Fiber.ts#L811"
    },
    {
      id: "FiberRef.FiberRefTypeId",
      name: "FiberRefTypeId",
      module: "FiberRef",
      package: "effect",
      signature: "typeof FiberRefTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 30,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L30"
    },
    {
      id: "FiberRef.make",
      name: "make",
      module: "FiberRef",
      package: "effect",
      signature: "<A>(initial: A, options?: { readonly fork?: (a: A) => A; readonly join?: (left: A, right: A) => A; }) => Effect<FiberRef<A>, never, Scope>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 74,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L74"
    },
    {
      id: "FiberRef.makeWith",
      name: "makeWith",
      module: "FiberRef",
      package: "effect",
      signature: "<Value>(ref: LazyArg<FiberRef<Value>>) => Effect<FiberRef<Value>, never, Scope>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 82,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L82"
    },
    {
      id: "FiberRef.makeContext",
      name: "makeContext",
      module: "FiberRef",
      package: "effect",
      signature: "<A>(initial: Context<A>) => Effect<FiberRef<Context<A>>, never, Scope>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 87,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L87"
    },
    {
      id: "FiberRef.makeRuntimeFlags",
      name: "makeRuntimeFlags",
      module: "FiberRef",
      package: "effect",
      signature: "(initial: RuntimeFlags) => Effect<FiberRef<RuntimeFlags>, never, Scope>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 92,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L92"
    },
    {
      id: "FiberRef.unsafeMake",
      name: "unsafeMake",
      module: "FiberRef",
      package: "effect",
      signature: "<Value>(initial: Value, options?: { readonly fork?: (a: Value) => Value; readonly join?: (left: Value, right: Value) => Value; }) => FiberRef<Value>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 97,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L97"
    },
    {
      id: "FiberRef.unsafeMakeHashSet",
      name: "unsafeMakeHashSet",
      module: "FiberRef",
      package: "effect",
      signature: "<A>(initial: HashSet<A>) => FiberRef<HashSet<A>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 105,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L105"
    },
    {
      id: "FiberRef.unsafeMakeContext",
      name: "unsafeMakeContext",
      module: "FiberRef",
      package: "effect",
      signature: "<A>(initial: Context<A>) => FiberRef<Context<A>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 110,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L110"
    },
    {
      id: "FiberRef.unsafeMakeSupervisor",
      name: "unsafeMakeSupervisor",
      module: "FiberRef",
      package: "effect",
      signature: "(initial: Supervisor<any>) => FiberRef<Supervisor<any>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 115,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L115"
    },
    {
      id: "FiberRef.unsafeMakePatch",
      name: "unsafeMakePatch",
      module: "FiberRef",
      package: "effect",
      signature: "<Value, Patch>(initial: Value, options: { readonly differ: Differ<Value, Patch>; readonly fork: Patch; readonly join?: (oldV: Value, newV: Value) => Value; }) => FiberRef<Value>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 120,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L120"
    },
    {
      id: "FiberRef.get",
      name: "get",
      module: "FiberRef",
      package: "effect",
      signature: "<A>(self: FiberRef<A>) => Effect<A, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 129,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L129"
    },
    {
      id: "FiberRef.getAndSet",
      name: "getAndSet",
      module: "FiberRef",
      package: "effect",
      signature: "{ <A>(value: A): (self: FiberRef<A>) => Effect<A, never, never>; <A>(self: FiberRef<A>, value: A): Effect<A, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 134,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L134"
    },
    {
      id: "FiberRef.getAndUpdate",
      name: "getAndUpdate",
      module: "FiberRef",
      package: "effect",
      signature: "{ <A>(f: (a: A) => A): (self: FiberRef<A>) => Effect<A, never, never>; <A>(self: FiberRef<A>, f: (a: A) => A): Effect<A, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 150,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L150"
    },
    {
      id: "FiberRef.getAndUpdateSome",
      name: "getAndUpdateSome",
      module: "FiberRef",
      package: "effect",
      signature: "{ <A>(pf: (a: A) => Option<A>): (self: FiberRef<A>) => Effect<A, never, never>; <A>(self: FiberRef<A>, pf: (a: A) => Option<A>): Effect<A, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 166,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L166"
    },
    {
      id: "FiberRef.getWith",
      name: "getWith",
      module: "FiberRef",
      package: "effect",
      signature: "{ <A, B, E, R>(f: (a: A) => Effect<B, E, R>): (self: FiberRef<A>) => Effect<B, E, R>; <A, B, E, R>(self: FiberRef<A>, f: (a: A) => Effect<B, E, R>): Effect<B, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 182,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L182"
    },
    {
      id: "FiberRef.set",
      name: "set",
      module: "FiberRef",
      package: "effect",
      signature: "{ <A>(value: A): (self: FiberRef<A>) => Effect<void, never, never>; <A>(self: FiberRef<A>, value: A): Effect<void, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 198,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L198"
    },
    {
      id: "FiberRef.reset",
      name: "reset",
      module: "FiberRef",
      package: "effect",
      signature: "<A>(self: FiberRef<A>) => Effect<void, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 221,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L221"
    },
    {
      id: "FiberRef.modify",
      name: "modify",
      module: "FiberRef",
      package: "effect",
      signature: "{ <A, B>(f: (a: A) => readonly [B, A]): (self: FiberRef<A>) => Effect<B, never, never>; <A, B>(self: FiberRef<A>, f: (a: A) => readonly [B, A]): Effect<B, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 226,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L226"
    },
    {
      id: "FiberRef.modifySome",
      name: "modifySome",
      module: "FiberRef",
      package: "effect",
      signature: "<A, B>(self: FiberRef<A>, def: B, f: (a: A) => Option<readonly [B, A]>) => Effect<B, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 242,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L242"
    },
    {
      id: "FiberRef.update",
      name: "update",
      module: "FiberRef",
      package: "effect",
      signature: "{ <A>(f: (a: A) => A): (self: FiberRef<A>) => Effect<void, never, never>; <A>(self: FiberRef<A>, f: (a: A) => A): Effect<void, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 247,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L247"
    },
    {
      id: "FiberRef.updateSome",
      name: "updateSome",
      module: "FiberRef",
      package: "effect",
      signature: "{ <A>(pf: (a: A) => Option<A>): (self: FiberRef<A>) => Effect<void, never, never>; <A>(self: FiberRef<A>, pf: (a: A) => Option<A>): Effect<void, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 263,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L263"
    },
    {
      id: "FiberRef.updateAndGet",
      name: "updateAndGet",
      module: "FiberRef",
      package: "effect",
      signature: "{ <A>(f: (a: A) => A): (self: FiberRef<A>) => Effect<A, never, never>; <A>(self: FiberRef<A>, f: (a: A) => A): Effect<A, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 279,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L279"
    },
    {
      id: "FiberRef.updateSomeAndGet",
      name: "updateSomeAndGet",
      module: "FiberRef",
      package: "effect",
      signature: "{ <A>(pf: (a: A) => Option<A>): (self: FiberRef<A>) => Effect<A, never, never>; <A>(self: FiberRef<A>, pf: (a: A) => Option<A>): Effect<A, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 295,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L295"
    },
    {
      id: "FiberRef.currentConcurrency",
      name: "currentConcurrency",
      module: "FiberRef",
      package: "effect",
      signature: 'FiberRef<number | "unbounded">',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiberRefs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 311,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L311"
    },
    {
      id: "FiberRef.currentRequestBatchingEnabled",
      name: "currentRequestBatchingEnabled",
      module: "FiberRef",
      package: "effect",
      signature: "FiberRef<boolean>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiberRefs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 316,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L316"
    },
    {
      id: "FiberRef.currentRequestCache",
      name: "currentRequestCache",
      module: "FiberRef",
      package: "effect",
      signature: "FiberRef<Cache>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiberRefs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 321,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L321"
    },
    {
      id: "FiberRef.currentRequestCacheEnabled",
      name: "currentRequestCacheEnabled",
      module: "FiberRef",
      package: "effect",
      signature: "FiberRef<boolean>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiberRefs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 326,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L326"
    },
    {
      id: "FiberRef.currentContext",
      name: "currentContext",
      module: "FiberRef",
      package: "effect",
      signature: "FiberRef<Context<never>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiberRefs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 331,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L331"
    },
    {
      id: "FiberRef.currentSchedulingPriority",
      name: "currentSchedulingPriority",
      module: "FiberRef",
      package: "effect",
      signature: "FiberRef<number>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiberRefs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 336,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L336"
    },
    {
      id: "FiberRef.currentMaxOpsBeforeYield",
      name: "currentMaxOpsBeforeYield",
      module: "FiberRef",
      package: "effect",
      signature: "FiberRef<number>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiberRefs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 341,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L341"
    },
    {
      id: "FiberRef.unhandledErrorLogLevel",
      name: "unhandledErrorLogLevel",
      module: "FiberRef",
      package: "effect",
      signature: "FiberRef<Option<LogLevel>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiberRefs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 346,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L346"
    },
    {
      id: "FiberRef.versionMismatchErrorLogLevel",
      name: "versionMismatchErrorLogLevel",
      module: "FiberRef",
      package: "effect",
      signature: "FiberRef<Option<LogLevel>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiberRefs"
      ],
      since: "3.17.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 351,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L351"
    },
    {
      id: "FiberRef.currentLogAnnotations",
      name: "currentLogAnnotations",
      module: "FiberRef",
      package: "effect",
      signature: "FiberRef<HashMap<string, unknown>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiberRefs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 356,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L356"
    },
    {
      id: "FiberRef.currentLoggers",
      name: "currentLoggers",
      module: "FiberRef",
      package: "effect",
      signature: "FiberRef<HashSet<Logger<unknown, any>>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiberRefs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 361,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L361"
    },
    {
      id: "FiberRef.currentLogLevel",
      name: "currentLogLevel",
      module: "FiberRef",
      package: "effect",
      signature: "FiberRef<LogLevel>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiberRefs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 366,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L366"
    },
    {
      id: "FiberRef.currentMinimumLogLevel",
      name: "currentMinimumLogLevel",
      module: "FiberRef",
      package: "effect",
      signature: "FiberRef<LogLevel>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiberRefs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 371,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L371"
    },
    {
      id: "FiberRef.currentLogSpan",
      name: "currentLogSpan",
      module: "FiberRef",
      package: "effect",
      signature: "FiberRef<List<LogSpan>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiberRefs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 376,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L376"
    },
    {
      id: "FiberRef.currentRuntimeFlags",
      name: "currentRuntimeFlags",
      module: "FiberRef",
      package: "effect",
      signature: "FiberRef<RuntimeFlags>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiberRefs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 381,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L381"
    },
    {
      id: "FiberRef.currentScheduler",
      name: "currentScheduler",
      module: "FiberRef",
      package: "effect",
      signature: "FiberRef<Scheduler>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiberRefs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 386,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L386"
    },
    {
      id: "FiberRef.currentSupervisor",
      name: "currentSupervisor",
      module: "FiberRef",
      package: "effect",
      signature: "FiberRef<Supervisor<any>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiberRefs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 391,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L391"
    },
    {
      id: "FiberRef.currentMetricLabels",
      name: "currentMetricLabels",
      module: "FiberRef",
      package: "effect",
      signature: "FiberRef<readonly MetricLabel[]>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiberRefs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 396,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L396"
    },
    {
      id: "FiberRef.currentTracerEnabled",
      name: "currentTracerEnabled",
      module: "FiberRef",
      package: "effect",
      signature: "FiberRef<boolean>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiberRefs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 401,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L401"
    },
    {
      id: "FiberRef.currentTracerTimingEnabled",
      name: "currentTracerTimingEnabled",
      module: "FiberRef",
      package: "effect",
      signature: "FiberRef<boolean>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiberRefs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 406,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L406"
    },
    {
      id: "FiberRef.currentTracerSpanAnnotations",
      name: "currentTracerSpanAnnotations",
      module: "FiberRef",
      package: "effect",
      signature: "FiberRef<HashMap<string, unknown>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiberRefs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 411,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L411"
    },
    {
      id: "FiberRef.currentTracerSpanLinks",
      name: "currentTracerSpanLinks",
      module: "FiberRef",
      package: "effect",
      signature: "FiberRef<Chunk<SpanLink>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiberRefs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 416,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L416"
    },
    {
      id: "FiberRef.interruptedCause",
      name: "interruptedCause",
      module: "FiberRef",
      package: "effect",
      signature: "FiberRef<Cause<never>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiberRefs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/FiberRef.d.ts",
      sourceLine: 421,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FiberRef.ts#L421"
    },
    {
      id: "Runtime.runFork",
      name: "runFork",
      module: "Runtime",
      package: "effect",
      signature: "{ <R>(runtime: Runtime<R>): <A, E>(effect: Effect<A, E, R>, options?: RunForkOptions) => RuntimeFiber<A, E>; <R, A, E>(runtime: Runtime<R>, effect: Effect<A, E, R>, options?: RunForkOptions): RuntimeFiber<A, E>; }",
      description: "Executes the effect using the provided Scheduler or using the global\nScheduler if not provided",
      documentation: "Executes the effect using the provided Scheduler or using the global\nScheduler if not provided",
      examples: [],
      tags: [
        "execution"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Runtime.d.ts",
      sourceLine: 77,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Runtime.ts#L77"
    },
    {
      id: "Runtime.runSyncExit",
      name: "runSyncExit",
      module: "Runtime",
      package: "effect",
      signature: "{ <A, E, R>(runtime: Runtime<R>, effect: Effect<A, E, R>): Exit<A, E>; <R>(runtime: Runtime<R>): <A, E>(effect: Effect<A, E, R>) => Exit<A, E>; }",
      description: "Executes the effect synchronously returning the exit. This method is effectful and should only be invoked at the edges of your\nprogram.",
      documentation: "Executes the effect synchronously returning the exit.\n\nThis method is effectful and should only be invoked at the edges of your\nprogram.",
      examples: [],
      tags: [
        "execution"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Runtime.d.ts",
      sourceLine: 104,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Runtime.ts#L104"
    },
    {
      id: "Runtime.runSync",
      name: "runSync",
      module: "Runtime",
      package: "effect",
      signature: "{ <A, E, R>(runtime: Runtime<R>, effect: Effect<A, E, R>): A; <R>(runtime: Runtime<R>): <A, E>(effect: Effect<A, E, R>) => A; }",
      description: "Executes the effect synchronously throwing in case of errors or async boundaries. This method is effectful and should only be invoked at the edges of your\nprogram.",
      documentation: "Executes the effect synchronously throwing in case of errors or async boundaries.\n\nThis method is effectful and should only be invoked at the edges of your\nprogram.",
      examples: [],
      tags: [
        "execution"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Runtime.d.ts",
      sourceLine: 135,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Runtime.ts#L135"
    },
    {
      id: "Runtime.runCallback",
      name: "runCallback",
      module: "Runtime",
      package: "effect",
      signature: "{ <R>(runtime: Runtime<R>): <A, E>(effect: Effect<A, E, R>, options?: RunCallbackOptions<A, E>) => (fiberId?: FiberId, options?: RunCallbackOptions<A, E>) => void; <R, A, E>(runtime: Runtime<R>, effect: Effect<A, E, R>, options?: RunCallbackOptions<A, E>): (fiberId?: FiberId, options?: RunCallbackOptions<A, E>) => void; }",
      description: "Executes the effect asynchronously, eventually passing the exit value to\nthe specified callback. This method is effectful and should only be invoked at the edges of your\nprogram.",
      documentation: "Executes the effect asynchronously, eventually passing the exit value to\nthe specified callback.\n\nThis method is effectful and should only be invoked at the edges of your\nprogram.",
      examples: [],
      tags: [
        "execution"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Runtime.d.ts",
      sourceLine: 174,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Runtime.ts#L174"
    },
    {
      id: "Runtime.runPromise",
      name: "runPromise",
      module: "Runtime",
      package: "effect",
      signature: "{ <R>(runtime: Runtime<R>): <A, E>(effect: Effect<A, E, R>, options?: { readonly signal?: AbortSignal; }) => Promise<A>; <R, A, E>(runtime: Runtime<R>, effect: Effect<A, E, R>, options?: { readonly signal?: AbortSignal; }): Promise<A>; }",
      description: "Runs the `Effect`, returning a JavaScript `Promise` that will be resolved\nwith the value of the effect once the effect has been executed, or will be\nrejected with the first error or exception throw by the effect. This method is effectful and should only be used at the edges of your\nprogram.",
      documentation: "Runs the `Effect`, returning a JavaScript `Promise` that will be resolved\nwith the value of the effect once the effect has been executed, or will be\nrejected with the first error or exception throw by the effect.\n\nThis method is effectful and should only be used at the edges of your\nprogram.",
      examples: [],
      tags: [
        "execution"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Runtime.d.ts",
      sourceLine: 209,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Runtime.ts#L209"
    },
    {
      id: "Runtime.runPromiseExit",
      name: "runPromiseExit",
      module: "Runtime",
      package: "effect",
      signature: "{ <R>(runtime: Runtime<R>): <A, E>(effect: Effect<A, E, R>, options?: { readonly signal?: AbortSignal; }) => Promise<Exit<A, E>>; <R, A, E>(runtime: Runtime<R>, effect: Effect<A, E, R>, options?: { readonly signal?: AbortSignal; }): Promise<Exit<A, E>>; }",
      description: "Runs the `Effect`, returning a JavaScript `Promise` that will be resolved\nwith the `Exit` state of the effect once the effect has been executed. This method is effectful and should only be used at the edges of your\nprogram.",
      documentation: "Runs the `Effect`, returning a JavaScript `Promise` that will be resolved\nwith the `Exit` state of the effect once the effect has been executed.\n\nThis method is effectful and should only be used at the edges of your\nprogram.",
      examples: [],
      tags: [
        "execution"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Runtime.d.ts",
      sourceLine: 249,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Runtime.ts#L249"
    },
    {
      id: "Runtime.defaultRuntime",
      name: "defaultRuntime",
      module: "Runtime",
      package: "effect",
      signature: "Runtime<never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Runtime.d.ts",
      sourceLine: 281,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Runtime.ts#L281"
    },
    {
      id: "Runtime.defaultRuntimeFlags",
      name: "defaultRuntimeFlags",
      module: "Runtime",
      package: "effect",
      signature: "RuntimeFlags",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Runtime.d.ts",
      sourceLine: 286,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Runtime.ts#L286"
    },
    {
      id: "Runtime.make",
      name: "make",
      module: "Runtime",
      package: "effect",
      signature: "<R>(options: { readonly context: Context<R>; readonly runtimeFlags: RuntimeFlags; readonly fiberRefs: FiberRefs; }) => Runtime<R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Runtime.d.ts",
      sourceLine: 291,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Runtime.ts#L291"
    },
    {
      id: "Runtime.FiberFailureId",
      name: "FiberFailureId",
      module: "Runtime",
      package: "effect",
      signature: "typeof FiberFailureId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Runtime.d.ts",
      sourceLine: 300,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Runtime.ts#L300"
    },
    {
      id: "Runtime.FiberFailureCauseId",
      name: "FiberFailureCauseId",
      module: "Runtime",
      package: "effect",
      signature: "typeof FiberFailureCauseId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Runtime.d.ts",
      sourceLine: 310,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Runtime.ts#L310"
    },
    {
      id: "Runtime.isAsyncFiberException",
      name: "isAsyncFiberException",
      module: "Runtime",
      package: "effect",
      signature: "(u: unknown) => u is AsyncFiberException<unknown, unknown>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Runtime.d.ts",
      sourceLine: 328,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Runtime.ts#L328"
    },
    {
      id: "Runtime.isFiberFailure",
      name: "isFiberFailure",
      module: "Runtime",
      package: "effect",
      signature: "(u: unknown) => u is FiberFailure",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Runtime.d.ts",
      sourceLine: 333,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Runtime.ts#L333"
    },
    {
      id: "Runtime.makeFiberFailure",
      name: "makeFiberFailure",
      module: "Runtime",
      package: "effect",
      signature: "<E>(cause: Cause<E>) => FiberFailure",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Runtime.d.ts",
      sourceLine: 338,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Runtime.ts#L338"
    },
    {
      id: "Runtime.updateRuntimeFlags",
      name: "updateRuntimeFlags",
      module: "Runtime",
      package: "effect",
      signature: "{ (f: (flags: RuntimeFlags) => RuntimeFlags): <R>(self: Runtime<R>) => Runtime<R>; <R>(self: Runtime<R>, f: (flags: RuntimeFlags) => RuntimeFlags): Runtime<R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "runtime flags"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Runtime.d.ts",
      sourceLine: 343,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Runtime.ts#L343"
    },
    {
      id: "Runtime.enableRuntimeFlag",
      name: "enableRuntimeFlag",
      module: "Runtime",
      package: "effect",
      signature: "{ (flag: RuntimeFlag): <R>(self: Runtime<R>) => Runtime<R>; <R>(self: Runtime<R>, flag: RuntimeFlag): Runtime<R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "runtime flags"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Runtime.d.ts",
      sourceLine: 359,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Runtime.ts#L359"
    },
    {
      id: "Runtime.disableRuntimeFlag",
      name: "disableRuntimeFlag",
      module: "Runtime",
      package: "effect",
      signature: "{ (flag: RuntimeFlag): <R>(self: Runtime<R>) => Runtime<R>; <R>(self: Runtime<R>, flag: RuntimeFlag): Runtime<R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "runtime flags"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Runtime.d.ts",
      sourceLine: 375,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Runtime.ts#L375"
    },
    {
      id: "Runtime.updateContext",
      name: "updateContext",
      module: "Runtime",
      package: "effect",
      signature: "{ <R, R2>(f: (context: Context<R>) => Context<R2>): (self: Runtime<R>) => Runtime<R2>; <R, R2>(self: Runtime<R>, f: (context: Context<R>) => Context<R2>): Runtime<R2>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Runtime.d.ts",
      sourceLine: 391,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Runtime.ts#L391"
    },
    {
      id: "Runtime.provideService",
      name: "provideService",
      module: "Runtime",
      package: "effect",
      signature: "{ <I, S>(tag: Tag<I, S>, service: S): <R>(self: Runtime<R>) => Runtime<I | R>; <R, I, S>(self: Runtime<R>, tag: Tag<I, S>, service: S): Runtime<R | I>; }",
      description: "",
      documentation: "",
      examples: [
        {
          code: 'import { Context, Runtime } from "effect"\n\nclass Name extends Context.Tag("Name")<Name, string>() {}\n\nconst runtime: Runtime.Runtime<Name> = Runtime.defaultRuntime.pipe(\n  Runtime.provideService(Name, "John")\n)'
        }
      ],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Runtime.d.ts",
      sourceLine: 417,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Runtime.ts#L417"
    },
    {
      id: "Runtime.updateFiberRefs",
      name: "updateFiberRefs",
      module: "Runtime",
      package: "effect",
      signature: "{ (f: (fiberRefs: FiberRefs) => FiberRefs): <R>(self: Runtime<R>) => Runtime<R>; <R>(self: Runtime<R>, f: (fiberRefs: FiberRefs) => FiberRefs): Runtime<R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiber refs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Runtime.d.ts",
      sourceLine: 453,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Runtime.ts#L453"
    },
    {
      id: "Runtime.setFiberRef",
      name: "setFiberRef",
      module: "Runtime",
      package: "effect",
      signature: "{ <A>(fiberRef: FiberRef<A>, value: A): <R>(self: Runtime<R>) => Runtime<R>; <R, A>(self: Runtime<R>, fiberRef: FiberRef<A>, value: A): Runtime<R>; }",
      description: "",
      documentation: "",
      examples: [
        {
          code: 'import { Effect, FiberRef, Runtime } from "effect"\n\nconst ref = FiberRef.unsafeMake(0)\n\nconst updatedRuntime = Runtime.defaultRuntime.pipe(\n  Runtime.setFiberRef(ref, 1)\n)\n\n// returns 1\nconst result = Runtime.runSync(updatedRuntime)(FiberRef.get(ref))'
        }
      ],
      tags: [
        "fiber refs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Runtime.d.ts",
      sourceLine: 482,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Runtime.ts#L482"
    },
    {
      id: "Runtime.deleteFiberRef",
      name: "deleteFiberRef",
      module: "Runtime",
      package: "effect",
      signature: "{ <A>(fiberRef: FiberRef<A>): <R>(self: Runtime<R>) => Runtime<R>; <R, A>(self: Runtime<R>, fiberRef: FiberRef<A>): Runtime<R>; }",
      description: "",
      documentation: "",
      examples: [
        {
          code: 'import { Effect, FiberRef, Runtime } from "effect"\n\nconst ref = FiberRef.unsafeMake(0)\n\nconst updatedRuntime = Runtime.defaultRuntime.pipe(\n  Runtime.setFiberRef(ref, 1),\n  Runtime.deleteFiberRef(ref)\n)\n\n// returns 0\nconst result = Runtime.runSync(updatedRuntime)(FiberRef.get(ref))'
        }
      ],
      tags: [
        "fiber refs"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Runtime.d.ts",
      sourceLine: 538,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Runtime.ts#L538"
    },
    {
      id: "Exit.isExit",
      name: "isExit",
      module: "Exit",
      package: "effect",
      signature: "(u: unknown) => u is Exit<unknown, unknown>",
      description: "Returns `true` if the specified value is an `Exit`, `false` otherwise.",
      documentation: "Returns `true` if the specified value is an `Exit`, `false` otherwise.",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 77,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L77"
    },
    {
      id: "Exit.isFailure",
      name: "isFailure",
      module: "Exit",
      package: "effect",
      signature: "<A, E>(self: Exit<A, E>) => self is Failure<A, E>",
      description: "Returns `true` if the specified `Exit` is a `Failure`, `false` otherwise.",
      documentation: "Returns `true` if the specified `Exit` is a `Failure`, `false` otherwise.",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 84,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L84"
    },
    {
      id: "Exit.isSuccess",
      name: "isSuccess",
      module: "Exit",
      package: "effect",
      signature: "<A, E>(self: Exit<A, E>) => self is Success<A, E>",
      description: "Returns `true` if the specified `Exit` is a `Success`, `false` otherwise.",
      documentation: "Returns `true` if the specified `Exit` is a `Success`, `false` otherwise.",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 91,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L91"
    },
    {
      id: "Exit.isInterrupted",
      name: "isInterrupted",
      module: "Exit",
      package: "effect",
      signature: "<A, E>(self: Exit<A, E>) => boolean",
      description: "Returns `true` if the specified exit is a `Failure` and the `Cause` of\nthe failure was due to interruption, `false` otherwise.",
      documentation: "Returns `true` if the specified exit is a `Failure` **and** the `Cause` of\nthe failure was due to interruption, `false` otherwise.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 99,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L99"
    },
    {
      id: "Exit.as",
      name: "as",
      module: "Exit",
      package: "effect",
      signature: "{ <A2>(value: A2): <A, E>(self: Exit<A, E>) => Exit<A2, E>; <A, E, A2>(self: Exit<A, E>, value: A2): Exit<A2, E>; }",
      description: "Maps the `Success` value of the specified exit to the provided constant\nvalue.",
      documentation: "Maps the `Success` value of the specified exit to the provided constant\nvalue.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 107,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L107"
    },
    {
      id: "Exit.asVoid",
      name: "asVoid",
      module: "Exit",
      package: "effect",
      signature: "<A, E>(self: Exit<A, E>) => Exit<void, E>",
      description: "Maps the `Success` value of the specified exit to a void.",
      documentation: "Maps the `Success` value of the specified exit to a void.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 131,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L131"
    },
    {
      id: "Exit.causeOption",
      name: "causeOption",
      module: "Exit",
      package: "effect",
      signature: "<A, E>(self: Exit<A, E>) => Option<Cause<E>>",
      description: "Returns a `Some<Cause<E>>` if the specified exit is a `Failure`, `None`\notherwise.",
      documentation: "Returns a `Some<Cause<E>>` if the specified exit is a `Failure`, `None`\notherwise.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 139,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L139"
    },
    {
      id: "Exit.all",
      name: "all",
      module: "Exit",
      package: "effect",
      signature: "<A, E>(exits: Iterable<Exit<A, E>>, options?: { readonly parallel?: boolean; }) => Option<Exit<A[], E>>",
      description: "Collects all of the specified exit values into a `Some<Exit<List<A>, E>>`. If\nthe provided iterable contains no elements, `None` will be returned.",
      documentation: "Collects all of the specified exit values into a `Some<Exit<List<A>, E>>`. If\nthe provided iterable contains no elements, `None` will be returned.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 147,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L147"
    },
    {
      id: "Exit.die",
      name: "die",
      module: "Exit",
      package: "effect",
      signature: "(defect: unknown) => Exit<never, never>",
      description: "Constructs a new `Exit.Failure` from the specified unrecoverable defect.",
      documentation: "Constructs a new `Exit.Failure` from the specified unrecoverable defect.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 156,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L156"
    },
    {
      id: "Exit.exists",
      name: "exists",
      module: "Exit",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E>(self: Exit<A, E>) => self is Exit<B, never>; <A>(predicate: Predicate<NoInfer<A>>): <E>(self: Exit<A, E>) => boolean; <A, E, B extends A>(self: Exit<A, E>, refinement: Refinement<A, B>): self is Exit<B, never>; <A, E>(self: Exit<A, E>, predicate: Predicate<A>): boolean; }",
      description: "Executes the predicate on the value of the specified exit if it is a\n`Success`, otherwise returns `false`.",
      documentation: "Executes the predicate on the value of the specified exit if it is a\n`Success`, otherwise returns `false`.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 164,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L164"
    },
    {
      id: "Exit.fail",
      name: "fail",
      module: "Exit",
      package: "effect",
      signature: "<E>(error: E) => Exit<never, E>",
      description: "Constructs a new `Exit.Failure` from the specified recoverable error of type\n`E`.",
      documentation: "Constructs a new `Exit.Failure` from the specified recoverable error of type\n`E`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 205,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L205"
    },
    {
      id: "Exit.failCause",
      name: "failCause",
      module: "Exit",
      package: "effect",
      signature: "<E>(cause: Cause<E>) => Exit<never, E>",
      description: "Constructs a new `Exit.Failure` from the specified `Cause` of type `E`.",
      documentation: "Constructs a new `Exit.Failure` from the specified `Cause` of type `E`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 212,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L212"
    },
    {
      id: "Exit.flatMap",
      name: "flatMap",
      module: "Exit",
      package: "effect",
      signature: "{ <A, A2, E2>(f: (a: A) => Exit<A2, E2>): <E>(self: Exit<A, E>) => Exit<A2, E2 | E>; <A, E, E2, A2>(self: Exit<A, E>, f: (a: A) => Exit<A2, E2>): Exit<A2, E | E2>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 217,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L217"
    },
    {
      id: "Exit.flatMapEffect",
      name: "flatMapEffect",
      module: "Exit",
      package: "effect",
      signature: "{ <A, E, A2, E2, R>(f: (a: A) => Effect<Exit<A2, E>, E2, R>): (self: Exit<A, E>) => Effect<Exit<A2, E>, E2, R>; <A, E, A2, E2, R>(self: Exit<A, E>, f: (a: A) => Effect<Exit<A2, E>, E2, R>): Effect<Exit<A2, E>, E2, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 233,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L233"
    },
    {
      id: "Exit.flatten",
      name: "flatten",
      module: "Exit",
      package: "effect",
      signature: "<A, E, E2>(self: Exit<Exit<A, E>, E2>) => Exit<A, E | E2>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 249,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L249"
    },
    {
      id: "Exit.forEachEffect",
      name: "forEachEffect",
      module: "Exit",
      package: "effect",
      signature: "{ <A, B, E2, R>(f: (a: A) => Effect<B, E2, R>): <E>(self: Exit<A, E>) => Effect<Exit<B, E2 | E>, never, R>; <A, E, B, E2, R>(self: Exit<A, E>, f: (a: A) => Effect<B, E2, R>): Effect<Exit<B, E | E2>, never, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "traversing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 254,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L254"
    },
    {
      id: "Exit.fromEither",
      name: "fromEither",
      module: "Exit",
      package: "effect",
      signature: "<R, L>(either: Either<R, L>) => Exit<R, L>",
      description: "Converts an `Either<R, L>` into an `Exit<R, L>`.",
      documentation: "Converts an `Either<R, L>` into an `Exit<R, L>`.",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 272,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L272"
    },
    {
      id: "Exit.fromOption",
      name: "fromOption",
      module: "Exit",
      package: "effect",
      signature: "<A>(option: Option<A>) => Exit<A, void>",
      description: "Converts an `Option<A>` into an `Exit<void, A>`.",
      documentation: "Converts an `Option<A>` into an `Exit<void, A>`.",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 279,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L279"
    },
    {
      id: "Exit.getOrElse",
      name: "getOrElse",
      module: "Exit",
      package: "effect",
      signature: "{ <E, A2>(orElse: (cause: Cause<E>) => A2): <A>(self: Exit<A, E>) => A2 | A; <A, E, A2>(self: Exit<A, E>, orElse: (cause: Cause<E>) => A2): A | A2; }",
      description: "Returns the `A` if specified exit is a `Success`, otherwise returns the\nalternate `A` value computed from the specified function which receives the\n`Cause<E>` of the exit `Failure`.",
      documentation: "Returns the `A` if specified exit is a `Success`, otherwise returns the\nalternate `A` value computed from the specified function which receives the\n`Cause<E>` of the exit `Failure`.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 288,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L288"
    },
    {
      id: "Exit.interrupt",
      name: "interrupt",
      module: "Exit",
      package: "effect",
      signature: "(fiberId: FiberId) => Exit<never, never>",
      description: "Constructs a new `Exit.Failure` from the specified `FiberId` indicating that\nthe `Fiber` running an `Effect` workflow was terminated due to interruption.",
      documentation: "Constructs a new `Exit.Failure` from the specified `FiberId` indicating that\nthe `Fiber` running an `Effect` workflow was terminated due to interruption.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 315,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L315"
    },
    {
      id: "Exit.map",
      name: "map",
      module: "Exit",
      package: "effect",
      signature: "{ <A, B>(f: (a: A) => B): <E>(self: Exit<A, E>) => Exit<B, E>; <A, E, B>(self: Exit<A, E>, f: (a: A) => B): Exit<B, E>; }",
      description: "Maps over the `Success` value of the specified exit using the provided\nfunction.",
      documentation: "Maps over the `Success` value of the specified exit using the provided\nfunction.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 323,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L323"
    },
    {
      id: "Exit.mapBoth",
      name: "mapBoth",
      module: "Exit",
      package: "effect",
      signature: "{ <E, A, E2, A2>(options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): (self: Exit<A, E>) => Exit<A2, E2>; <A, E, E2, A2>(self: Exit<A, E>, options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): Exit<A2, E2>; }",
      description: "Maps over the `Success` and `Failure` cases of the specified exit using the\nprovided functions.",
      documentation: "Maps over the `Success` and `Failure` cases of the specified exit using the\nprovided functions.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 348,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L348"
    },
    {
      id: "Exit.mapError",
      name: "mapError",
      module: "Exit",
      package: "effect",
      signature: "{ <E, E2>(f: (e: E) => E2): <A>(self: Exit<A, E>) => Exit<A, E2>; <A, E, E2>(self: Exit<A, E>, f: (e: E) => E2): Exit<A, E2>; }",
      description: "Maps over the error contained in the `Failure` of the specified exit using\nthe provided function.",
      documentation: "Maps over the error contained in the `Failure` of the specified exit using\nthe provided function.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 379,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L379"
    },
    {
      id: "Exit.mapErrorCause",
      name: "mapErrorCause",
      module: "Exit",
      package: "effect",
      signature: "{ <E, E2>(f: (cause: Cause<E>) => Cause<E2>): <A>(self: Exit<A, E>) => Exit<A, E2>; <E, A, E2>(self: Exit<A, E>, f: (cause: Cause<E>) => Cause<E2>): Exit<A, E2>; }",
      description: "Maps over the `Cause` contained in the `Failure` of the specified exit using\nthe provided function.",
      documentation: "Maps over the `Cause` contained in the `Failure` of the specified exit using\nthe provided function.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 404,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L404"
    },
    {
      id: "Exit.match",
      name: "match",
      module: "Exit",
      package: "effect",
      signature: "{ <E, A, Z1, Z2>(options: { readonly onFailure: (cause: Cause<E>) => Z1; readonly onSuccess: (a: A) => Z2; }): (self: Exit<A, E>) => Z1 | Z2; <A, E, Z1, Z2>(self: Exit<A, E>, options: { readonly onFailure: (cause: Cause<E>) => Z1; readonly onSuccess: (a: A) => Z2; }): Z1 | Z2; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "folding"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 426,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L426"
    },
    {
      id: "Exit.matchEffect",
      name: "matchEffect",
      module: "Exit",
      package: "effect",
      signature: "{ <E, A2, E2, R, A, A3, E3, R2>(options: { readonly onFailure: (cause: Cause<E>) => Effect<A2, E2, R>; readonly onSuccess: (a: A) => Effect<A3, E3, R2>; }): (self: Exit<A, E>) => Effect<A2 | A3, E2 | E3, R | R2>; <A, E, A2, E2, R, A3, E3, R2>(self: Exit<A, E>, options: { readonly onFailure: (cause: Cause<E>) => Effect<A2, E2, R>; readonly onSuccess: (a: A) => Effect<A3, E3, R2>; }): Effect<A2 | A3, E2 | E3, R | R2>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "folding"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 448,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L448"
    },
    {
      id: "Exit.succeed",
      name: "succeed",
      module: "Exit",
      package: "effect",
      signature: "<A>(value: A) => Exit<A, never>",
      description: "Constructs a new `Exit.Success` containing the specified value of type `A`.",
      documentation: "Constructs a new `Exit.Success` containing the specified value of type `A`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 472,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L472"
    },
    {
      id: "Exit.zip",
      name: "zip",
      module: "Exit",
      package: "effect",
      signature: "{ <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<[A, A2], E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<[A, A2], E | E2>; }",
      description: "Sequentially zips the this result with the specified result or else returns\nthe failed `Cause<E | E2>`.",
      documentation: "Sequentially zips the this result with the specified result or else returns\nthe failed `Cause<E | E2>`.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 489,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L489"
    },
    {
      id: "Exit.zipLeft",
      name: "zipLeft",
      module: "Exit",
      package: "effect",
      signature: "{ <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A, E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A, E | E2>; }",
      description: "Sequentially zips the this result with the specified result discarding the\nsecond element of the tuple or else returns the failed `Cause<E | E2>`.",
      documentation: "Sequentially zips the this result with the specified result discarding the\nsecond element of the tuple or else returns the failed `Cause<E | E2>`.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 514,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L514"
    },
    {
      id: "Exit.zipRight",
      name: "zipRight",
      module: "Exit",
      package: "effect",
      signature: "{ <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A2, E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A2, E | E2>; }",
      description: "Sequentially zips the this result with the specified result discarding the\nfirst element of the tuple or else returns the failed `Cause<E | E2>`.",
      documentation: "Sequentially zips the this result with the specified result discarding the\nfirst element of the tuple or else returns the failed `Cause<E | E2>`.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 539,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L539"
    },
    {
      id: "Exit.zipPar",
      name: "zipPar",
      module: "Exit",
      package: "effect",
      signature: "{ <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<[A, A2], E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<[A, A2], E | E2>; }",
      description: "Parallelly zips the this result with the specified result or else returns\nthe failed `Cause<E | E2>`.",
      documentation: "Parallelly zips the this result with the specified result or else returns\nthe failed `Cause<E | E2>`.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 564,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L564"
    },
    {
      id: "Exit.zipParLeft",
      name: "zipParLeft",
      module: "Exit",
      package: "effect",
      signature: "{ <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A, E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A, E | E2>; }",
      description: "Parallelly zips the this result with the specified result discarding the\nsecond element of the tuple or else returns the failed `Cause<E | E2>`.",
      documentation: "Parallelly zips the this result with the specified result discarding the\nsecond element of the tuple or else returns the failed `Cause<E | E2>`.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 589,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L589"
    },
    {
      id: "Exit.zipParRight",
      name: "zipParRight",
      module: "Exit",
      package: "effect",
      signature: "{ <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A2, E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A2, E | E2>; }",
      description: "Parallelly zips the this result with the specified result discarding the\nfirst element of the tuple or else returns the failed `Cause<E | E2>`.",
      documentation: "Parallelly zips the this result with the specified result discarding the\nfirst element of the tuple or else returns the failed `Cause<E | E2>`.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 614,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L614"
    },
    {
      id: "Exit.zipWith",
      name: "zipWith",
      module: "Exit",
      package: "effect",
      signature: "{ <B, E2, A, C, E>(that: Exit<B, E2>, options: { readonly onSuccess: (a: A, b: B) => C; readonly onFailure: (cause: Cause<E>, cause2: Cause<E2>) => Cause<any>; }): (self: Exit<A, E>) => Exit<C, any>; <A, E, B, E2, C>(self: Exit<A, E>, that: Exit<B, E2>, options: { readonly onSuccess: (a: A, b: B) => C; readonly onFailure: (cause: Cause<E>, cause2: Cause<E2>) => Cause<E | E2>; }): Exit<C, E | E2>; }",
      description: "Zips this exit together with that exit using the specified combination\nfunctions.",
      documentation: "Zips this exit together with that exit using the specified combination\nfunctions.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Exit.d.ts",
      sourceLine: 639,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Exit.ts#L639"
    },
    {
      id: "Cause.CauseTypeId",
      name: "CauseTypeId",
      module: "Cause",
      package: "effect",
      signature: "typeof CauseTypeId",
      description: "A unique symbol identifying the `Cause` type.",
      documentation: "A unique symbol identifying the `Cause` type.\n\n**Details**\n\nThis provides a symbol that helps identify instances of the `Cause` data\ntype. This can be used for advanced operations such as refining types or\nbuilding internal utilities that check whether an unknown value is a `Cause`.",
      examples: [],
      tags: [
        "Symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 53,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L53"
    },
    {
      id: "Cause.RuntimeExceptionTypeId",
      name: "RuntimeExceptionTypeId",
      module: "Cause",
      package: "effect",
      signature: "typeof RuntimeExceptionTypeId",
      description: "A unique symbol identifying the `RuntimeException` type.",
      documentation: "A unique symbol identifying the `RuntimeException` type.\n\n**Details**\n\nThis provides a symbol that identifies a `RuntimeException`. This is\ntypically used internally by the library to recognize checked exceptions that\noccur during runtime.",
      examples: [],
      tags: [
        "Symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 73,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L73"
    },
    {
      id: "Cause.InterruptedExceptionTypeId",
      name: "InterruptedExceptionTypeId",
      module: "Cause",
      package: "effect",
      signature: "typeof InterruptedExceptionTypeId",
      description: "A unique symbol identifying the `InterruptedException` type.",
      documentation: "A unique symbol identifying the `InterruptedException` type.\n\n**Details**\n\nThis provides a symbol that identifies an `InterruptedException`. This is\ntypically used internally to recognize when a fiber has been interrupted,\nhelping the framework handle interruption logic correctly.",
      examples: [],
      tags: [
        "Symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 93,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L93"
    },
    {
      id: "Cause.IllegalArgumentExceptionTypeId",
      name: "IllegalArgumentExceptionTypeId",
      module: "Cause",
      package: "effect",
      signature: "typeof IllegalArgumentExceptionTypeId",
      description: "A unique symbol identifying the `IllegalArgumentException` type.",
      documentation: "A unique symbol identifying the `IllegalArgumentException` type.\n\n**Details**\n\nThis provides a symbol that identifies an `IllegalArgumentException`. This is\noften used in scenarios where invalid arguments are supplied to methods that\nexpect specific input.",
      examples: [],
      tags: [
        "Symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 113,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L113"
    },
    {
      id: "Cause.NoSuchElementExceptionTypeId",
      name: "NoSuchElementExceptionTypeId",
      module: "Cause",
      package: "effect",
      signature: "typeof NoSuchElementExceptionTypeId",
      description: "A unique symbol identifying the `NoSuchElementException` type.",
      documentation: "A unique symbol identifying the `NoSuchElementException` type.\n\n**Details**\n\nThis provides a symbol that identifies a `NoSuchElementException`. It helps\ndifferentiate cases where a required element is missing within a data\nstructure.",
      examples: [],
      tags: [
        "Symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 133,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L133"
    },
    {
      id: "Cause.InvalidPubSubCapacityExceptionTypeId",
      name: "InvalidPubSubCapacityExceptionTypeId",
      module: "Cause",
      package: "effect",
      signature: "typeof InvalidPubSubCapacityExceptionTypeId",
      description: "A unique symbol identifying the `InvalidPubSubCapacityException` type.",
      documentation: "A unique symbol identifying the `InvalidPubSubCapacityException` type.\n\n**Details**\n\nThis provides a symbol that identifies an `InvalidPubSubCapacityException`.\nIt indicates an error related to an invalid capacity passed to a `PubSub`\nstructure.",
      examples: [],
      tags: [
        "Symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 153,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L153"
    },
    {
      id: "Cause.ExceededCapacityExceptionTypeId",
      name: "ExceededCapacityExceptionTypeId",
      module: "Cause",
      package: "effect",
      signature: "typeof ExceededCapacityExceptionTypeId",
      description: "A unique symbol identifying the `ExceededCapacityException` type.",
      documentation: "A unique symbol identifying the `ExceededCapacityException` type.\n\n**Details**\n\nThis provides a symbol that identifies an `ExceededCapacityException`. It\ndenotes situations where a resource has exceeded its configured capacity\nlimit.",
      examples: [],
      tags: [
        "Symbols"
      ],
      since: "3.5.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 173,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L173"
    },
    {
      id: "Cause.TimeoutExceptionTypeId",
      name: "TimeoutExceptionTypeId",
      module: "Cause",
      package: "effect",
      signature: "typeof TimeoutExceptionTypeId",
      description: "A unique symbol identifying the `TimeoutException` type.",
      documentation: "A unique symbol identifying the `TimeoutException` type.\n\n**Details**\n\nThis provides a symbol that identifies a `TimeoutException`. It helps the\nframework recognize errors related to operations that fail to complete within\na given timeframe.",
      examples: [],
      tags: [
        "Symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 193,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L193"
    },
    {
      id: "Cause.UnknownExceptionTypeId",
      name: "UnknownExceptionTypeId",
      module: "Cause",
      package: "effect",
      signature: "typeof UnknownExceptionTypeId",
      description: "A unique symbol identifying the `UnknownException` type.",
      documentation: "A unique symbol identifying the `UnknownException` type.\n\n**Details**\n\nThis provides a symbol that identifies an `UnknownException`. It is typically\nused for generic or unexpected errors that do not fit other specific\nexception categories.",
      examples: [],
      tags: [
        "Symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 213,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L213"
    },
    {
      id: "Cause.YieldableError",
      name: "YieldableError",
      module: "Cause",
      package: "effect",
      signature: "new (message?: string) => YieldableError",
      description: "Creates an error that occurs at runtime, extendable for other exception\ntypes.",
      documentation: "Creates an error that occurs at runtime, extendable for other exception\ntypes.",
      examples: [],
      tags: [
        "Errors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 295,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L295"
    },
    {
      id: "Cause.empty",
      name: "empty",
      module: "Cause",
      package: "effect",
      signature: "Cause<never>",
      description: "Creates an `Empty` cause.",
      documentation: 'Creates an `Empty` cause.\n\n**Details**\n\nThis function returns a cause that signifies "no error." It\'s commonly used\nto represent an absence of failure conditions.',
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 529,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L529"
    },
    {
      id: "Cause.fail",
      name: "fail",
      module: "Cause",
      package: "effect",
      signature: "<E>(error: E) => Cause<E>",
      description: "Creates a `Fail` cause from an expected error.",
      documentation: "Creates a `Fail` cause from an expected error.\n\n**Details**\n\nThis function constructs a `Cause` carrying an error of type `E`. It's used\nwhen you want to represent a known or anticipated failure in your effectful\ncomputations.",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 544,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L544"
    },
    {
      id: "Cause.die",
      name: "die",
      module: "Cause",
      package: "effect",
      signature: "(defect: unknown) => Cause<never>",
      description: "Creates a `Die` cause from an unexpected error.",
      documentation: "Creates a `Die` cause from an unexpected error.\n\n**Details**\n\nThis function wraps an unhandled or unknown defect (like a runtime crash)\ninto a `Cause`. It's useful for capturing unforeseen issues in a structured\nway.",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 559,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L559"
    },
    {
      id: "Cause.interrupt",
      name: "interrupt",
      module: "Cause",
      package: "effect",
      signature: "(fiberId: FiberId) => Cause<never>",
      description: "Creates an `Interrupt` cause from a `FiberId`.",
      documentation: "Creates an `Interrupt` cause from a `FiberId`.\n\n**Details**\n\nThis function represents a fiber that has been interrupted. It stores the\nidentifier of the interrupted fiber, enabling precise tracking of concurrent\ncancellations.",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 574,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L574"
    },
    {
      id: "Cause.parallel",
      name: "parallel",
      module: "Cause",
      package: "effect",
      signature: "<E, E2>(left: Cause<E>, right: Cause<E2>) => Cause<E | E2>",
      description: "Combines two `Cause`s in parallel.",
      documentation: "Combines two `Cause`s in parallel.\n\n**Details**\n\nThis function merges two errors that occurred simultaneously. Instead of\ndiscarding one error, both are retained, allowing for richer error reporting\nand debugging.",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 589,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L589"
    },
    {
      id: "Cause.sequential",
      name: "sequential",
      module: "Cause",
      package: "effect",
      signature: "<E, E2>(left: Cause<E>, right: Cause<E2>) => Cause<E | E2>",
      description: "Combines two `Cause`s sequentially.",
      documentation: "Combines two `Cause`s sequentially.\n\n**Details**\n\nThis function merges two errors that occurred in sequence, such as a main\nerror followed by a finalization error. It preserves both errors for complete\nfailure information.",
      examples: [],
      tags: [
        "Constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 604,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L604"
    },
    {
      id: "Cause.isCause",
      name: "isCause",
      module: "Cause",
      package: "effect",
      signature: "(u: unknown) => u is Cause<unknown>",
      description: "Checks if a value is a `Cause`.",
      documentation: "Checks if a value is a `Cause`.",
      examples: [],
      tags: [
        "Guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 611,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L611"
    },
    {
      id: "Cause.isEmptyType",
      name: "isEmptyType",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<E>) => self is Empty",
      description: "Checks if a `Cause` is an `Empty` type.",
      documentation: "Checks if a `Cause` is an `Empty` type.",
      examples: [],
      tags: [
        "Guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 620,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L620"
    },
    {
      id: "Cause.isFailType",
      name: "isFailType",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<E>) => self is Fail<E>",
      description: "Checks if a `Cause` is a `Fail` type.",
      documentation: "Checks if a `Cause` is a `Fail` type.",
      examples: [],
      tags: [
        "Guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 629,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L629"
    },
    {
      id: "Cause.isDieType",
      name: "isDieType",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<E>) => self is Die",
      description: "Checks if a `Cause` is a `Die` type.",
      documentation: "Checks if a `Cause` is a `Die` type.",
      examples: [],
      tags: [
        "Guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 638,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L638"
    },
    {
      id: "Cause.isInterruptType",
      name: "isInterruptType",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<E>) => self is Interrupt",
      description: "Checks if a `Cause` is an `Interrupt` type.",
      documentation: "Checks if a `Cause` is an `Interrupt` type.",
      examples: [],
      tags: [
        "Guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 647,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L647"
    },
    {
      id: "Cause.isSequentialType",
      name: "isSequentialType",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<E>) => self is Sequential<E>",
      description: "Checks if a `Cause` is a `Sequential` type.",
      documentation: "Checks if a `Cause` is a `Sequential` type.",
      examples: [],
      tags: [
        "Guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 656,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L656"
    },
    {
      id: "Cause.isParallelType",
      name: "isParallelType",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<E>) => self is Parallel<E>",
      description: "Checks if a `Cause` is a `Parallel` type.",
      documentation: "Checks if a `Cause` is a `Parallel` type.",
      examples: [],
      tags: [
        "Guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 665,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L665"
    },
    {
      id: "Cause.size",
      name: "size",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<E>) => number",
      description: "Calculates the size of a `Cause`.",
      documentation: "Calculates the size of a `Cause`.\n\n**Details**\n\nThis function returns the total number of `Cause` nodes in the semiring\nstructure, reflecting how many individual error elements are recorded.",
      examples: [],
      tags: [
        "Getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 677,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L677"
    },
    {
      id: "Cause.isEmpty",
      name: "isEmpty",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<E>) => boolean",
      description: "Checks if a `Cause` is entirely empty.",
      documentation: "Checks if a `Cause` is entirely empty.\n\n**Details**\n\nThis function returns `true` if the `Cause` contains no errors, defects, or\ninterruptions. It's helpful for verifying if a computation truly had no\nfailures.",
      examples: [],
      tags: [
        "Getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 690,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L690"
    },
    {
      id: "Cause.isFailure",
      name: "isFailure",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<E>) => boolean",
      description: "Checks if a `Cause` contains a failure.",
      documentation: "Checks if a `Cause` contains a failure.\n\n**Details**\n\nThis function returns `true` if the `Cause` includes any `Fail` error. It's\ncommonly used to confirm whether a workflow encountered an anticipated error\nversus just defects or interruptions.",
      examples: [],
      tags: [
        "Getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 703,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L703"
    },
    {
      id: "Cause.isDie",
      name: "isDie",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<E>) => boolean",
      description: "Checks if a `Cause` contains a defect.",
      documentation: "Checks if a `Cause` contains a defect.\n\n**Details**\n\nThis function returns `true` if the `Cause` includes any unexpected or\nunhandled errors (`Die`). It's useful for differentiating known failures from\nunexpected ones.",
      examples: [],
      tags: [
        "Getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 716,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L716"
    },
    {
      id: "Cause.isInterrupted",
      name: "isInterrupted",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<E>) => boolean",
      description: "Checks if a `Cause` contains an interruption.",
      documentation: "Checks if a `Cause` contains an interruption.\n\n**Details**\n\nThis function returns `true` if the `Cause` includes any fiber interruptions.",
      examples: [],
      tags: [
        "Getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 727,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L727"
    },
    {
      id: "Cause.isInterruptedOnly",
      name: "isInterruptedOnly",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<E>) => boolean",
      description: "Checks if a `Cause` contains only interruptions.",
      documentation: 'Checks if a `Cause` contains only interruptions.\n\n**Details**\n\nThis function returns `true` if the `Cause` has been interrupted but does not\ncontain any other failures, such as `Fail` or `Die`. It\'s helpful for\nverifying purely "cancellation" scenarios.',
      examples: [],
      tags: [
        "Getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 740,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L740"
    },
    {
      id: "Cause.failures",
      name: "failures",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<E>) => Chunk<E>",
      description: "Extracts all recoverable errors of type `E` from a `Cause`.",
      documentation: "Extracts all recoverable errors of type `E` from a `Cause`.\n\n**Details**\n\nThis function returns a chunk of errors, providing a list of all `Fail`\nvalues found in the cause. It's useful for collecting all known failures for\nlogging or combined error handling.",
      examples: [],
      tags: [
        "Getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 753,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L753"
    },
    {
      id: "Cause.defects",
      name: "defects",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<E>) => Chunk<unknown>",
      description: "Extracts all unrecoverable defects from a `Cause`.",
      documentation: "Extracts all unrecoverable defects from a `Cause`.\n\n**Details**\n\nThis function returns a chunk of values representing unexpected errors\n(`Die`). It's handy for capturing or logging unanticipated failures that\nmight need special handling, such as bug reports.",
      examples: [],
      tags: [
        "Getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 766,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L766"
    },
    {
      id: "Cause.interruptors",
      name: "interruptors",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<E>) => HashSet<FiberId>",
      description: "Collects all `FiberId`s responsible for interrupting a fiber.",
      documentation: "Collects all `FiberId`s responsible for interrupting a fiber.\n\n**Details**\n\nThis function returns a set of IDs indicating which fibers caused\ninterruptions within this `Cause`. It's useful for debugging concurrency\nissues or tracing cancellations.",
      examples: [],
      tags: [
        "Getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 779,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L779"
    },
    {
      id: "Cause.failureOption",
      name: "failureOption",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<E>) => Option<E>",
      description: "Retrieves the first `Fail` error in a `Cause`, if present.",
      documentation: "Retrieves the first `Fail` error in a `Cause`, if present.\n\n**Details**\n\nThis function returns an `Option` containing the first recoverable error\n(`E`) from the cause. It's often used to quickly check if there's a primary\nerror to handle or display.",
      examples: [],
      tags: [
        "Getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 792,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L792"
    },
    {
      id: "Cause.failureOrCause",
      name: "failureOrCause",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<E>) => Either<Cause<never>, E>",
      description: "Splits a `Cause` into either its first `Fail` error or the rest of the cause\n(which might only contain `Die` or `Interrupt`).",
      documentation: "Splits a `Cause` into either its first `Fail` error or the rest of the cause\n(which might only contain `Die` or `Interrupt`).\n\n**Details**\n\nThis function either returns the checked error (`E`) or the remaining\n`Cause<never>` with defects/interruptions. It helps you decide if there's a\nrecoverable path or if only unhandled issues remain.",
      examples: [],
      tags: [
        "Getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 806,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L806"
    },
    {
      id: "Cause.flipCauseOption",
      name: "flipCauseOption",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<Option<E>>) => Option<Cause<E>>",
      description: "Strips out failures with an error of `None` from a `Cause<Option<E>>`.",
      documentation: "Strips out failures with an error of `None` from a `Cause<Option<E>>`.\n\n**Details**\n\nThis function turns a `Cause<Option<E>>` into an `Option<Cause<E>>`. If the\ncause only contains failures of `None`, it becomes `None`; otherwise, it\nreturns a `Cause` of the remaining errors. It's helpful when working with\noptional errors and filtering out certain error paths.",
      examples: [],
      tags: [
        "Getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 820,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L820"
    },
    {
      id: "Cause.dieOption",
      name: "dieOption",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<E>) => Option<unknown>",
      description: "Retrieves the first `Die` defect in a `Cause`, if present.",
      documentation: "Retrieves the first `Die` defect in a `Cause`, if present.\n\n**Details**\n\nThis function returns an `Option` containing the first unexpected failure\n(`Die`) discovered. It's helpful for diagnosing the primary defect in a chain\nof errors.",
      examples: [],
      tags: [
        "Getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 833,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L833"
    },
    {
      id: "Cause.interruptOption",
      name: "interruptOption",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<E>) => Option<FiberId>",
      description: "Retrieves the first `Interrupt` in a `Cause`, if present.",
      documentation: "Retrieves the first `Interrupt` in a `Cause`, if present.\n\n**Details**\n\nThis function returns an `Option` with the first fiber interruption\ndiscovered. This is particularly useful for concurrency analysis or debugging\ncancellations.",
      examples: [],
      tags: [
        "Getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 846,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L846"
    },
    {
      id: "Cause.keepDefects",
      name: "keepDefects",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<E>) => Option<Cause<never>>",
      description: "Removes all `Fail` and `Interrupt` nodes, keeping only defects (`Die`) in a\n`Cause`.",
      documentation: "Removes all `Fail` and `Interrupt` nodes, keeping only defects (`Die`) in a\n`Cause`.\n\n**Details**\n\nThis function strips a cause of recoverable errors and interruptions, leaving\nonly unexpected failures. If no defects remain, it returns `None`. It's\nvaluable for focusing only on unanticipated problems when both known errors\nand defects could occur.",
      examples: [],
      tags: [
        "Getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 861,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L861"
    },
    {
      id: "Cause.linearize",
      name: "linearize",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<E>) => HashSet<Cause<E>>",
      description: "Linearizes a `Cause` into a set of parallel causes, each containing a\nsequential chain of failures.",
      documentation: "Linearizes a `Cause` into a set of parallel causes, each containing a\nsequential chain of failures.\n\n**Details**\n\nThis function reorganizes the cause structure so that you can analyze each\nparallel branch separately, even if they have multiple sequential errors.",
      examples: [],
      tags: [
        "Getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 874,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L874"
    },
    {
      id: "Cause.stripFailures",
      name: "stripFailures",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<E>) => Cause<never>",
      description: "Removes `Fail` and `Interrupt` nodes from a `Cause`, keeping only defects\n(`Die`).",
      documentation: "Removes `Fail` and `Interrupt` nodes from a `Cause`, keeping only defects\n(`Die`).\n\n**Details**\n\nThis function is similar to `keepDefects` but returns a `Cause<never>`\ndirectly, which can still store `Die` or finalizer-related defects. It's\nhelpful for analyzing only the irrecoverable portion of the error.",
      examples: [],
      tags: [
        "Getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 888,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L888"
    },
    {
      id: "Cause.stripSomeDefects",
      name: "stripSomeDefects",
      module: "Cause",
      package: "effect",
      signature: "{ (pf: (defect: unknown) => Option<unknown>): <E>(self: Cause<E>) => Option<Cause<E>>; <E>(self: Cause<E>, pf: (defect: unknown) => Option<unknown>): Option<Cause<E>>; }",
      description: "Removes matching defects from a `Cause` using a partial function, returning\nthe remainder.",
      documentation: "Removes matching defects from a `Cause` using a partial function, returning\nthe remainder.\n\n**Details**\n\nThis function applies a user-defined extraction function to each defect\n(`Die`). If the function matches the defect, that defect is removed. If all\ndefects match, the result is `None`. Otherwise, you get a `Cause` with the\nunmatched defects.",
      examples: [],
      tags: [
        "Getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 903,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L903"
    },
    {
      id: "Cause.as",
      name: "as",
      module: "Cause",
      package: "effect",
      signature: "{ <E2>(error: E2): <E>(self: Cause<E>) => Cause<E2>; <E, E2>(self: Cause<E>, error: E2): Cause<E2>; }",
      description: "Replaces any errors in a `Cause` with a provided constant error.",
      documentation: "Replaces any errors in a `Cause` with a provided constant error.\n\n**Details**\n\nThis function transforms all `Fail` errors into the specified error value,\npreserving the structure of the `Cause`. It's useful when you no longer need\nthe original error details but still want to keep the cause shape.",
      examples: [],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 949,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L949"
    },
    {
      id: "Cause.map",
      name: "map",
      module: "Cause",
      package: "effect",
      signature: "{ <E, E2>(f: (e: E) => E2): (self: Cause<E>) => Cause<E2>; <E, E2>(self: Cause<E>, f: (e: E) => E2): Cause<E2>; }",
      description: "Transforms the errors in a `Cause` using a user-provided function.",
      documentation: "Transforms the errors in a `Cause` using a user-provided function.\n\n**Details**\n\nThis function applies `f` to each `Fail` error while leaving defects (`Die`)\nand interruptions untouched. It's useful for changing or simplifying error\ntypes in your effectful workflows.",
      examples: [],
      tags: [
        "Mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 995,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L995"
    },
    {
      id: "Cause.flatMap",
      name: "flatMap",
      module: "Cause",
      package: "effect",
      signature: "{ <E, E2>(f: (e: E) => Cause<E2>): (self: Cause<E>) => Cause<E2>; <E, E2>(self: Cause<E>, f: (e: E) => Cause<E2>): Cause<E2>; }",
      description: "Transforms errors in a `Cause` into new causes.",
      documentation: "Transforms errors in a `Cause` into new causes.\n\n**Details**\n\nThis function applies a function `f` to each `Fail` error, converting it into\na new `Cause`. This is especially powerful for merging or restructuring error\ntypes while preserving or combining cause information.",
      examples: [],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1041,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1041"
    },
    {
      id: "Cause.andThen",
      name: "andThen",
      module: "Cause",
      package: "effect",
      signature: "{ <E, E2>(f: (e: E) => Cause<E2>): (self: Cause<E>) => Cause<E2>; <E2>(f: Cause<E2>): <E>(self: Cause<E>) => Cause<E2>; <E, E2>(self: Cause<E>, f: (e: E) => Cause<E2>): Cause<E2>; <E, E2>(self: Cause<E>, f: Cause<E2>): Cause<E2>; }",
      description: "Sequences two `Cause`s. The second `Cause` can be dependent on the result of\nthe first `Cause`.",
      documentation: "Sequences two `Cause`s. The second `Cause` can be dependent on the result of\nthe first `Cause`.",
      examples: [],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1080,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1080"
    },
    {
      id: "Cause.flatten",
      name: "flatten",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<Cause<E>>) => Cause<E>",
      description: "Flattens a nested `Cause` structure.",
      documentation: "Flattens a nested `Cause` structure.\n\n**Details**\n\nThis function takes a `Cause<Cause<E>>` and merges the layers into a single\n`Cause<E>`. It's useful for eliminating additional nesting created by\nrepeated transformations or compositions.",
      examples: [],
      tags: [
        "Sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1128,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1128"
    },
    {
      id: "Cause.contains",
      name: "contains",
      module: "Cause",
      package: "effect",
      signature: "{ <E2>(that: Cause<E2>): <E>(self: Cause<E>) => boolean; <E, E2>(self: Cause<E>, that: Cause<E2>): boolean; }",
      description: "Checks if the current `Cause` contains or is equal to another `Cause`.",
      documentation: "Checks if the current `Cause` contains or is equal to another `Cause`.\n\n**Details**\n\nThis function returns `true` if `that` cause is part of or the same as\nthe current `Cause`. It's useful when you need to check for specific\nerror patterns or deduplicate repeated failures.",
      examples: [],
      tags: [
        "Elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1141,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1141"
    },
    {
      id: "Cause.squash",
      name: "squash",
      module: "Cause",
      package: "effect",
      signature: "<E>(self: Cause<E>) => unknown",
      description: 'Extracts the most "important" defect from a `Cause`.',
      documentation: 'Extracts the most "important" defect from a `Cause`.\n\n**Details**\n\nThis function reduces a `Cause` to a single, prioritized defect. It evaluates\nthe `Cause` in the following order of priority:\n\n1. If the `Cause` contains a failure (e.g., from `Effect.fail`), it returns\n   the raw error value.\n2. If there is no failure, it looks for the first defect (e.g., from\n   `Effect.die`).\n3. If neither of the above is present, and the `Cause` stems from an\n   interruption, it creates and returns an `InterruptedException`.\n\nThis function ensures you can always extract a meaningful representation of\nthe primary issue from a potentially complex `Cause` structure.\n\n**When to Use**\n\nUse this function when you need to extract the most relevant error or defect\nfrom a `Cause`, especially in scenarios where multiple errors or defects may\nbe present. It\'s particularly useful for simplifying error reporting or\nlogging.',
      examples: [],
      tags: [
        "Destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1199,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1199"
    },
    {
      id: "Cause.squashWith",
      name: "squashWith",
      module: "Cause",
      package: "effect",
      signature: "{ <E>(f: (error: E) => unknown): (self: Cause<E>) => unknown; <E>(self: Cause<E>, f: (error: E) => unknown): unknown; }",
      description: 'Extracts the most "important" defect from a `Cause`, transforming failures\ninto defects using a provided function.',
      documentation: 'Extracts the most "important" defect from a `Cause`, transforming failures\ninto defects using a provided function.\n\n**Details**\n\nThis function reduces a `Cause` to a single, prioritized defect, while\nallowing you to transform recoverable failures into defects through a custom\nfunction. It processes the `Cause` in the following order:\n\n1. If the `Cause` contains a failure (e.g., from `Effect.fail`), it applies\n   the provided function `f` to the error to transform it into a defect.\n2. If there is no failure, it looks for the first defect (e.g., from\n   `Effect.die`) and returns it.\n3. If neither is present and the `Cause` stems from an interruption, it\n   returns an `InterruptedException`.\n\nThis function is particularly useful when you need custom handling or\ntransformation of errors while processing a `Cause`.',
      examples: [],
      tags: [
        "Destructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1225,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1225"
    },
    {
      id: "Cause.find",
      name: "find",
      module: "Cause",
      package: "effect",
      signature: "{ <E, Z>(pf: (cause: Cause<E>) => Option<Z>): (self: Cause<E>) => Option<Z>; <E, Z>(self: Cause<E>, pf: (cause: Cause<E>) => Option<Z>): Option<Z>; }",
      description: "Searches a `Cause` using a partial function to extract information.",
      documentation: "Searches a `Cause` using a partial function to extract information.\n\n**Details**\n\nThis function allows you to search through a `Cause` using a custom partial\nfunction. The partial function is applied to the `Cause`, and if it matches,\nthe result is returned wrapped in a `Some`. If no match is found, the result\nis `None`.\n\nThis is particularly useful when you are only interested in specific types of\nerrors, defects, or interruption causes within a potentially complex `Cause`\nstructure. By leveraging a partial function, you can focus on extracting only\nthe relevant information you care about.\n\nThe partial function should return an `Option` indicating whether it matched\nand the value it extracted.",
      examples: [],
      tags: [
        "Elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1300,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1300"
    },
    {
      id: "Cause.filter",
      name: "filter",
      module: "Cause",
      package: "effect",
      signature: "{ <E, EB extends E>(refinement: Refinement<Cause<NoInfer<E>>, Cause<EB>>): (self: Cause<E>) => Cause<EB>; <E>(predicate: Predicate<Cause<NoInfer<E>>>): (self: Cause<E>) => Cause<E>; <E, EB extends E>(self: Cause<E>, refinement: Refinement<Cause<E>, Cause<EB>>): Cause<EB>; <E>(self: Cause<E>, predicate: Predicate<Cause<E>>): Cause<E>; }",
      description: "Preserves parts of a `Cause` that match a given predicate.",
      documentation: "Preserves parts of a `Cause` that match a given predicate.\n\n**Details**\n\nThis function allows you to retain only the parts of a `Cause` structure that\nmatch a specified predicate or refinement. Any parts of the `Cause` that do\nnot match the provided condition are excluded from the result.\n\nYou can use this function in two ways:\n- With a `Predicate`: A function that evaluates whether a `Cause` should be\n  retained based on its value.\n- With a `Refinement`: A more specific predicate that can refine the type of\n  the `Cause`.\n\nThis is useful when you need to extract specific types of errors, defects, or\ninterruptions from a `Cause` while discarding unrelated parts.",
      examples: [],
      tags: [
        "Filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1367,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1367"
    },
    {
      id: "Cause.match",
      name: "match",
      module: "Cause",
      package: "effect",
      signature: "{ <Z, E>(options: { readonly onEmpty: Z; readonly onFail: (error: E) => Z; readonly onDie: (defect: unknown) => Z; readonly onInterrupt: (fiberId: FiberId) => Z; readonly onSequential: (left: Z, right: Z) => Z; readonly onParallel: (left: Z, right: Z) => Z; }): (self: Cause<E>) => Z; <Z, E>(self: Cause<E>, options: { readonly onEmpty: Z; readonly onFail: (error: E) => Z; readonly onDie: (defect: unknown) => Z; readonly onInterrupt: (fiberId: FiberId) => Z; readonly onSequential: (left: Z, right: Z) => Z; readonly onParallel: (left: Z, right: Z) => Z; }): Z; }",
      description: "Transforms a `Cause` into a single value using custom handlers for each\npossible case.",
      documentation: "Transforms a `Cause` into a single value using custom handlers for each\npossible case.\n\n**Details**\n\nThis function processes a `Cause` by applying a set of custom handlers to\neach possible type of cause: `Empty`, `Fail`, `Die`, `Interrupt`,\n`Sequential`, and `Parallel`. The result of this function is a single value\nof type `Z`. This function allows you to define exactly how to handle each\npart of a `Cause`, whether it's a failure, defect, interruption, or a\ncombination of these.\n\nThe options parameter provides handlers for:\n- `onEmpty`: Handles the case where the cause is `Empty`, meaning no errors\n  occurred.\n- `onFail`: Processes a failure with an error of type `E`.\n- `onDie`: Processes a defect (unexpected error).\n- `onInterrupt`: Handles a fiber interruption, providing the `FiberId` of the\n  interruption.\n- `onSequential`: Combines two sequential causes into a single value of type\n  `Z`.\n- `onParallel`: Combines two parallel causes into a single value of type `Z`.",
      examples: [],
      tags: [
        "Matching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1484,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1484"
    },
    {
      id: "Cause.reduce",
      name: "reduce",
      module: "Cause",
      package: "effect",
      signature: "{ <Z, E>(zero: Z, pf: (accumulator: Z, cause: Cause<E>) => Option<Z>): (self: Cause<E>) => Z; <Z, E>(self: Cause<E>, zero: Z, pf: (accumulator: Z, cause: Cause<E>) => Option<Z>): Z; }",
      description: "Combines all parts of a `Cause` into a single value by starting with an\ninitial value.",
      documentation: "Combines all parts of a `Cause` into a single value by starting with an\ninitial value.\n\n**Details**\n\nThis function processes a `Cause` by starting with an initial value (`zero`)\nand applying a custom function (`pf`) to combine all elements of the `Cause`\ninto a single result of type `Z`. The custom function determines how each\npart of the `Cause` contributes to the final result. The function can return\nan `Option` to either continue combining values or skip specific parts of the\n`Cause`.\n\nThis function is useful for tasks such as:\n- Aggregating error messages from a `Cause` into a single string.\n- Summarizing the structure of a `Cause` into a simplified result.\n- Filtering or processing only specific parts of a `Cause`.\n\nThe reduction proceeds in a top-down manner, visiting all nodes in the\n`Cause` structure. This gives you complete control over how each part of the\n`Cause` contributes to the final result.",
      examples: [],
      tags: [
        "Reducing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1581,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1581"
    },
    {
      id: "Cause.reduceWithContext",
      name: "reduceWithContext",
      module: "Cause",
      package: "effect",
      signature: "{ <C, E, Z>(context: C, reducer: CauseReducer<C, E, Z>): (self: Cause<E>) => Z; <C, E, Z>(self: Cause<E>, context: C, reducer: CauseReducer<C, E, Z>): Z; }",
      description: "Combines all parts of a `Cause` into a single value using a custom reducer\nand a context.",
      documentation: "Combines all parts of a `Cause` into a single value using a custom reducer\nand a context.\n\n**Details**\n\nThis function allows you to reduce a `Cause` into a single value of type `Z`\nusing a custom `CauseReducer`. A `CauseReducer` provides methods to handle\nspecific parts of the `Cause`, such as failures, defects, or interruptions.\nAdditionally, this function provides access to a `context` value, which can\nbe used to carry information or maintain state during the reduction process.\n\nThis is particularly useful when the reduction process needs additional\ncontext or configuration, such as:\n- Aggregating error details with dynamic formatting.\n- Collecting logs or statistics about the `Cause`.\n- Performing stateful transformations based on the `context`.",
      examples: [],
      tags: [
        "Reducing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1658,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1658"
    },
    {
      id: "Cause.InterruptedException",
      name: "InterruptedException",
      module: "Cause",
      package: "effect",
      signature: "new (message?: string) => InterruptedException",
      description: "Creates an error that indicates a `Fiber` was interrupted.",
      documentation: "Creates an error that indicates a `Fiber` was interrupted.\n\n**Details**\n\nThis function constructs an `InterruptedException` recognized by the Effect\nruntime. It is usually thrown or returned when a fiber's execution is\ninterrupted by external events or by another fiber. This is particularly\nhelpful in concurrent programs where fibers may halt each other before\ncompletion.",
      examples: [],
      tags: [
        "Errors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1722,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1722"
    },
    {
      id: "Cause.isInterruptedException",
      name: "isInterruptedException",
      module: "Cause",
      package: "effect",
      signature: "(u: unknown) => u is InterruptedException",
      description: "Checks if a given unknown value is an `InterruptedException`.",
      documentation: "Checks if a given unknown value is an `InterruptedException`.",
      examples: [],
      tags: [
        "Guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1729,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1729"
    },
    {
      id: "Cause.IllegalArgumentException",
      name: "IllegalArgumentException",
      module: "Cause",
      package: "effect",
      signature: "new (message?: string) => IllegalArgumentException",
      description: "Creates an error indicating an invalid method argument.",
      documentation: "Creates an error indicating an invalid method argument.\n\n**Details**\n\nThis function constructs an `IllegalArgumentException`. It is typically\nthrown or returned when an operation receives improper inputs, such as\nout-of-range values or invalid object states.",
      examples: [],
      tags: [
        "Errors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1742,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1742"
    },
    {
      id: "Cause.isIllegalArgumentException",
      name: "isIllegalArgumentException",
      module: "Cause",
      package: "effect",
      signature: "(u: unknown) => u is IllegalArgumentException",
      description: "Checks if a given unknown value is an `IllegalArgumentException`.",
      documentation: "Checks if a given unknown value is an `IllegalArgumentException`.",
      examples: [],
      tags: [
        "Guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1749,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1749"
    },
    {
      id: "Cause.NoSuchElementException",
      name: "NoSuchElementException",
      module: "Cause",
      package: "effect",
      signature: "new (message?: string) => NoSuchElementException",
      description: "Creates an error indicating a missing element.",
      documentation: "Creates an error indicating a missing element.\n\n**Details**\n\nThis function constructs a `NoSuchElementException`. It helps you clearly\ncommunicate that a required element is unavailable.",
      examples: [],
      tags: [
        "Errors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1761,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1761"
    },
    {
      id: "Cause.isNoSuchElementException",
      name: "isNoSuchElementException",
      module: "Cause",
      package: "effect",
      signature: "(u: unknown) => u is NoSuchElementException",
      description: "Checks if a given unknown value is a `NoSuchElementException`.",
      documentation: "Checks if a given unknown value is a `NoSuchElementException`.",
      examples: [],
      tags: [
        "Guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1768,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1768"
    },
    {
      id: "Cause.RuntimeException",
      name: "RuntimeException",
      module: "Cause",
      package: "effect",
      signature: "new (message?: string) => RuntimeException",
      description: "Creates an error for general runtime errors.",
      documentation: "Creates an error for general runtime errors.\n\n**Details**\n\nThis function constructs a `RuntimeException`, for errors that occur at\nruntime but are not specifically typed or categorized as interruptions,\nmissing elements, or invalid arguments. It helps unify a wide range of\nunexpected conditions under a single, recognizable error type.",
      examples: [],
      tags: [
        "Errors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1782,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1782"
    },
    {
      id: "Cause.isRuntimeException",
      name: "isRuntimeException",
      module: "Cause",
      package: "effect",
      signature: "(u: unknown) => u is RuntimeException",
      description: "Checks if a given unknown value is a `RuntimeException`.",
      documentation: "Checks if a given unknown value is a `RuntimeException`.",
      examples: [],
      tags: [
        "Guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1789,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1789"
    },
    {
      id: "Cause.TimeoutException",
      name: "TimeoutException",
      module: "Cause",
      package: "effect",
      signature: "new (message?: string) => TimeoutException",
      description: "Creates an error for operations that exceed their expected time.",
      documentation: "Creates an error for operations that exceed their expected time.\n\n**Details**\n\nThis function constructs a `TimeoutException`. It is typically used to signal\nthat an operation or fiber did not complete within a designated time limit,\nallowing you to handle slow or hanging processes.",
      examples: [],
      tags: [
        "Errors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1802,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1802"
    },
    {
      id: "Cause.isTimeoutException",
      name: "isTimeoutException",
      module: "Cause",
      package: "effect",
      signature: "(u: unknown) => u is TimeoutException",
      description: "Checks if a given unknown value is a `TimeoutException`.",
      documentation: "Checks if a given unknown value is a `TimeoutException`.",
      examples: [],
      tags: [
        "Guards"
      ],
      since: "3.15.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1809,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1809"
    },
    {
      id: "Cause.UnknownException",
      name: "UnknownException",
      module: "Cause",
      package: "effect",
      signature: "new (error: unknown, message?: string) => UnknownException",
      description: "Creates an instance of `UnknownException`, an error object used to handle\nunknown errors such as those from rejected promises.",
      documentation: 'Creates an instance of `UnknownException`, an error object used to handle\nunknown errors such as those from rejected promises.\n\n**Details**\n\nThis function constructs an `UnknownException` with flexible behavior for\nmanaging the error message and cause.\n\nThe required `error` argument is passed as the `cause` to the global `Error`\nconstructor, ensuring that the original cause is preserved in the error chain\nfor debugging purposes. This ensures that the origin stack trace is\npreserved.\n\nThe `error` argument is always stored in the `error` property of the\n`UnknownException` instance for reference, regardless of its type.\n\nAdditionally, if you provide a `message` argument, it is used as the error\nmessage. If no `message` is provided, the error message defaults to `"An\nunknown error occurred"`.\n\n**When to Use**\n\nUse this function when you need to handle unexpected or unknown errors in\nyour application, particularly when the source of the error might not provide\na clear message. This is useful for wrapping generic errors thrown from\npromises or external APIs.',
      examples: [],
      tags: [
        "Errors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1841,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1841"
    },
    {
      id: "Cause.isUnknownException",
      name: "isUnknownException",
      module: "Cause",
      package: "effect",
      signature: "(u: unknown) => u is UnknownException",
      description: "Checks if a given unknown value is an `UnknownException`.",
      documentation: "Checks if a given unknown value is an `UnknownException`.",
      examples: [],
      tags: [
        "Guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1848,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1848"
    },
    {
      id: "Cause.ExceededCapacityException",
      name: "ExceededCapacityException",
      module: "Cause",
      package: "effect",
      signature: "new (message?: string) => ExceededCapacityException",
      description: "Creates an error indicating resource capacity has been exceeded.",
      documentation: "Creates an error indicating resource capacity has been exceeded.\n\n**Details**\n\nThis function constructs an `ExceededCapacityException`, signifying that an\noperation or resource usage surpassed established limits. This can be\nessential for concurrency or resource management situations, ensuring your\napplication doesn't go beyond acceptable thresholds.",
      examples: [],
      tags: [
        "Errors"
      ],
      since: "3.5.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1862,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1862"
    },
    {
      id: "Cause.isExceededCapacityException",
      name: "isExceededCapacityException",
      module: "Cause",
      package: "effect",
      signature: "(u: unknown) => u is ExceededCapacityException",
      description: "Checks if a given unknown value is an `ExceededCapacityException`.",
      documentation: "Checks if a given unknown value is an `ExceededCapacityException`.",
      examples: [],
      tags: [
        "Guards"
      ],
      since: "3.5.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1869,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1869"
    },
    {
      id: "Cause.pretty",
      name: "pretty",
      module: "Cause",
      package: "effect",
      signature: "<E>(cause: Cause<E>, options?: { readonly renderErrorCause?: boolean; }) => string",
      description: "Converts a `Cause` into a human-readable string.",
      documentation: "Converts a `Cause` into a human-readable string.\n\n**Details**\n\nThis function pretty-prints the entire `Cause`, including any failures,\ndefects, and interruptions. It can be especially helpful for logging,\ndebugging, or displaying structured errors to users.\n\nYou can optionally pass `options` to configure how the error cause is\nrendered. By default, it includes essential details of all errors in the\n`Cause`.",
      examples: [],
      tags: [
        "Formatting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1888,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1888"
    },
    {
      id: "Cause.prettyErrors",
      name: "prettyErrors",
      module: "Cause",
      package: "effect",
      signature: "<E>(cause: Cause<E>) => PrettyError[]",
      description: "Returns a list of prettified errors (`PrettyError`) from a `Cause`.",
      documentation: "Returns a list of prettified errors (`PrettyError`) from a `Cause`.\n\n**Details**\n\nThis function inspects the entire `Cause` and produces an array of\n`PrettyError` objects. Each object may include additional metadata, such as a\n`Span`, to provide deeper insights into where and how the error occurred.",
      examples: [],
      tags: [
        "Formatting"
      ],
      since: "3.2.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1912,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1912"
    },
    {
      id: "Cause.originalError",
      name: "originalError",
      module: "Cause",
      package: "effect",
      signature: "<E>(obj: E) => E",
      description: "Retrieves the original, unproxied error instance from an error object.",
      documentation: "Retrieves the original, unproxied error instance from an error object.\n\n**Details**\n\nThis function returns the underlying error object without any\nlibrary-specific wrapping or proxying that might occur during error handling.\nThis can be essential if you need direct access to the error's native\nproperties, such as stack traces or custom data fields, for detailed\ndebugging or integration with external systems.",
      examples: [],
      tags: [
        "Errors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cause.d.ts",
      sourceLine: 1927,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cause.ts#L1927"
    },
    {
      id: "Config.ConfigTypeId",
      name: "ConfigTypeId",
      module: "Config",
      package: "effect",
      signature: "typeof ConfigTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 23,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L23"
    },
    {
      id: "Config.all",
      name: "all",
      module: "Config",
      package: "effect",
      signature: "<const Arg extends Iterable<Config<any>> | Record<string, Config<any>>>(arg: Arg) => Config<[Arg] extends [readonly Config<any>[]] ? { -readonly [K in keyof Arg]: [Arg[K]] extends [Config<infer A>] ? A : never; } : [Arg] extends [Iterable<Config<infer A>>] ? A[] : [Arg] extends [Record<string, Config<any>>] ? { -readonly [K in keyof Arg]: [Arg[K]] extends [Config<infer A>] ? A : never; } : never>",
      description: "Constructs a config from a tuple / struct / arguments of configs.",
      documentation: "Constructs a config from a tuple / struct / arguments of configs.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 89,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L89"
    },
    {
      id: "Config.array",
      name: "array",
      module: "Config",
      package: "effect",
      signature: "<A>(config: Config<A>, name?: string) => Config<A[]>",
      description: "Constructs a config for an array of values.",
      documentation: "Constructs a config for an array of values.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 102,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L102"
    },
    {
      id: "Config.boolean",
      name: "boolean",
      module: "Config",
      package: "effect",
      signature: "(name?: string) => Config<boolean>",
      description: "Constructs a config for a boolean value.",
      documentation: "Constructs a config for a boolean value.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 109,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L109"
    },
    {
      id: "Config.port",
      name: "port",
      module: "Config",
      package: "effect",
      signature: "(name?: string) => Config<number>",
      description: "Constructs a config for a network port [1, 65535].",
      documentation: "Constructs a config for a network port [1, 65535].",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "3.16.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 116,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L116"
    },
    {
      id: "Config.url",
      name: "url",
      module: "Config",
      package: "effect",
      signature: "(name?: string) => Config<URL>",
      description: "Constructs a config for an URL value.",
      documentation: "Constructs a config for an URL value.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "3.11.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 123,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L123"
    },
    {
      id: "Config.chunk",
      name: "chunk",
      module: "Config",
      package: "effect",
      signature: "<A>(config: Config<A>, name?: string) => Config<Chunk<A>>",
      description: "Constructs a config for a sequence of values.",
      documentation: "Constructs a config for a sequence of values.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 130,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L130"
    },
    {
      id: "Config.date",
      name: "date",
      module: "Config",
      package: "effect",
      signature: "(name?: string) => Config<Date>",
      description: "Constructs a config for a date value.",
      documentation: "Constructs a config for a date value.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 137,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L137"
    },
    {
      id: "Config.fail",
      name: "fail",
      module: "Config",
      package: "effect",
      signature: "(message: string) => Config<never>",
      description: "Constructs a config that fails with the specified message.",
      documentation: "Constructs a config that fails with the specified message.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 144,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L144"
    },
    {
      id: "Config.number",
      name: "number",
      module: "Config",
      package: "effect",
      signature: "(name?: string) => Config<number>",
      description: "Constructs a config for a float value.",
      documentation: "Constructs a config for a float value.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 151,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L151"
    },
    {
      id: "Config.integer",
      name: "integer",
      module: "Config",
      package: "effect",
      signature: "(name?: string) => Config<number>",
      description: "Constructs a config for a integer value.",
      documentation: "Constructs a config for a integer value.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 158,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L158"
    },
    {
      id: "Config.literal",
      name: "literal",
      module: "Config",
      package: "effect",
      signature: "<Literals extends ReadonlyArray<LiteralValue>>(...literals: Literals) => (name?: string) => Config<Literals[number]>",
      description: "Constructs a config for a literal value.",
      documentation: 'Constructs a config for a literal value.\n\n**Example**\n\n```ts\nimport { Config } from "effect"\n\nconst config = Config.literal("http", "https")("PROTOCOL")\n```',
      examples: [
        {
          code: 'import { Config } from "effect"\n\nconst config = Config.literal("http", "https")("PROTOCOL")'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 173,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L173"
    },
    {
      id: "Config.logLevel",
      name: "logLevel",
      module: "Config",
      package: "effect",
      signature: "(name?: string) => Config<LogLevel>",
      description: "Constructs a config for a `LogLevel` value.",
      documentation: "Constructs a config for a `LogLevel` value.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 180,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L180"
    },
    {
      id: "Config.duration",
      name: "duration",
      module: "Config",
      package: "effect",
      signature: "(name?: string) => Config<Duration>",
      description: "Constructs a config for a duration value.",
      documentation: "Constructs a config for a duration value.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.5.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 187,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L187"
    },
    {
      id: "Config.isConfig",
      name: "isConfig",
      module: "Config",
      package: "effect",
      signature: "(u: unknown) => u is Config<unknown>",
      description: "This function returns `true` if the specified value is an `Config` value,\n`false` otherwise. This function can be useful for checking the type of a value before\nattempting to operate on it as an `Config` value. For example, you could\nuse `isConfig` to check the type of a value before using it as an\nargument to a function that expects an `Config` value.",
      documentation: "This function returns `true` if the specified value is an `Config` value,\n`false` otherwise.\n\nThis function can be useful for checking the type of a value before\nattempting to operate on it as an `Config` value. For example, you could\nuse `isConfig` to check the type of a value before using it as an\nargument to a function that expects an `Config` value.",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 200,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L200"
    },
    {
      id: "Config.map",
      name: "map",
      module: "Config",
      package: "effect",
      signature: "{ <A, B>(f: (a: A) => B): (self: Config<A>) => Config<B>; <A, B>(self: Config<A>, f: (a: A) => B): Config<B>; }",
      description: "Returns a  config whose structure is the same as this one, but which produces\na different value, constructed using the specified function.",
      documentation: "Returns a  config whose structure is the same as this one, but which produces\na different value, constructed using the specified function.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 208,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L208"
    },
    {
      id: "Config.mapAttempt",
      name: "mapAttempt",
      module: "Config",
      package: "effect",
      signature: "{ <A, B>(f: (a: A) => B): (self: Config<A>) => Config<B>; <A, B>(self: Config<A>, f: (a: A) => B): Config<B>; }",
      description: "Returns a config whose structure is the same as this one, but which may\nproduce a different value, constructed using the specified function, which\nmay throw exceptions that will be translated into validation errors.",
      documentation: "Returns a config whose structure is the same as this one, but which may\nproduce a different value, constructed using the specified function, which\nmay throw exceptions that will be translated into validation errors.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 234,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L234"
    },
    {
      id: "Config.mapOrFail",
      name: "mapOrFail",
      module: "Config",
      package: "effect",
      signature: "{ <A, B>(f: (a: A) => Either<B, ConfigError>): (self: Config<A>) => Config<B>; <A, B>(self: Config<A>, f: (a: A) => Either<B, ConfigError>): Config<B>; }",
      description: "Returns a new config whose structure is the samea as this one, but which\nmay produce a different value, constructed using the specified fallible\nfunction.",
      documentation: "Returns a new config whose structure is the samea as this one, but which\nmay produce a different value, constructed using the specified fallible\nfunction.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 262,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L262"
    },
    {
      id: "Config.nested",
      name: "nested",
      module: "Config",
      package: "effect",
      signature: "{ (name: string): <A>(self: Config<A>) => Config<A>; <A>(self: Config<A>, name: string): Config<A>; }",
      description: "Returns a config that has this configuration nested as a property of the\nspecified name.",
      documentation: "Returns a config that has this configuration nested as a property of the\nspecified name.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 289,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L289"
    },
    {
      id: "Config.orElse",
      name: "orElse",
      module: "Config",
      package: "effect",
      signature: "{ <A2>(that: LazyArg<Config<A2>>): <A>(self: Config<A>) => Config<A2 | A>; <A, A2>(self: Config<A>, that: LazyArg<Config<A2>>): Config<A | A2>; }",
      description: "Returns a config whose structure is preferentially described by this\nconfig, but which falls back to the specified config if there is an issue\nreading from this config.",
      documentation: "Returns a config whose structure is preferentially described by this\nconfig, but which falls back to the specified config if there is an issue\nreading from this config.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 315,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L315"
    },
    {
      id: "Config.orElseIf",
      name: "orElseIf",
      module: "Config",
      package: "effect",
      signature: "{ <A2>(options: { readonly if: Predicate<ConfigError>; readonly orElse: LazyArg<Config<A2>>; }): <A>(self: Config<A>) => Config<A>; <A, A2>(self: Config<A>, options: { readonly if: Predicate<ConfigError>; readonly orElse: LazyArg<Config<A2>>; }): Config<A>; }",
      description: "Returns configuration which reads from this configuration, but which falls\nback to the specified configuration if reading from this configuration\nfails with an error satisfying the specified predicate.",
      documentation: "Returns configuration which reads from this configuration, but which falls\nback to the specified configuration if reading from this configuration\nfails with an error satisfying the specified predicate.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 343,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L343"
    },
    {
      id: "Config.option",
      name: "option",
      module: "Config",
      package: "effect",
      signature: "<A>(self: Config<A>) => Config<Option<A>>",
      description: "Returns an optional version of this config, which will be `None` if the\ndata is missing from configuration, and `Some` otherwise.",
      documentation: "Returns an optional version of this config, which will be `None` if the\ndata is missing from configuration, and `Some` otherwise.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 376,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L376"
    },
    {
      id: "Config.primitive",
      name: "primitive",
      module: "Config",
      package: "effect",
      signature: "<A>(description: string, parse: (text: string) => Either<A, ConfigError>) => Config<A>",
      description: "Constructs a new primitive config.",
      documentation: "Constructs a new primitive config.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 383,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L383"
    },
    {
      id: "Config.repeat",
      name: "repeat",
      module: "Config",
      package: "effect",
      signature: "<A>(self: Config<A>) => Config<A[]>",
      description: "Returns a config that describes a sequence of values, each of which has the\nstructure of this config.",
      documentation: "Returns a config that describes a sequence of values, each of which has the\nstructure of this config.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 391,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L391"
    },
    {
      id: "Config.secret",
      name: "secret",
      module: "Config",
      package: "effect",
      signature: "(name?: string) => Config<Secret>",
      description: "Constructs a config for a secret value.",
      documentation: "Constructs a config for a secret value.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      deprecated: "",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 399,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L399"
    },
    {
      id: "Config.redacted",
      name: "redacted",
      module: "Config",
      package: "effect",
      signature: "{ (name?: string): Config<Redacted<string>>; <A>(config: Config<A>): Config<Redacted<A>>; }",
      description: "Constructs a config for a redacted value.",
      documentation: "Constructs a config for a redacted value.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 406,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L406"
    },
    {
      id: "Config.branded",
      name: "branded",
      module: "Config",
      package: "effect",
      signature: "{ <A, B extends Brand.Branded<A, any>>(constructor: Brand.Constructor<B>): (config: Config<A>) => Config<B>; <B extends Brand.Branded<string, any>>(name: string, constructor: Brand.Constructor<B>): Config<B>; <A, B extends Brand.Branded<A, any>>(config: Config<A>, constructor: Brand.Constructor<B>): Config<B>; }",
      description: "Constructs a config for a branded value.",
      documentation: "Constructs a config for a branded value.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "3.16.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 428,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L428"
    },
    {
      id: "Config.hashSet",
      name: "hashSet",
      module: "Config",
      package: "effect",
      signature: "<A>(config: Config<A>, name?: string) => Config<HashSet<A>>",
      description: "Constructs a config for a sequence of values.",
      documentation: "Constructs a config for a sequence of values.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 457,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L457"
    },
    {
      id: "Config.string",
      name: "string",
      module: "Config",
      package: "effect",
      signature: "(name?: string) => Config<string>",
      description: "Constructs a config for a string value.",
      documentation: "Constructs a config for a string value.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 464,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L464"
    },
    {
      id: "Config.nonEmptyString",
      name: "nonEmptyString",
      module: "Config",
      package: "effect",
      signature: "(name?: string) => Config<string>",
      description: "Constructs a config for a non-empty string value.",
      documentation: "Constructs a config for a non-empty string value.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "3.7.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 471,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L471"
    },
    {
      id: "Config.succeed",
      name: "succeed",
      module: "Config",
      package: "effect",
      signature: "<A>(value: A) => Config<A>",
      description: "Constructs a config which contains the specified value.",
      documentation: "Constructs a config which contains the specified value.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 478,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L478"
    },
    {
      id: "Config.suspend",
      name: "suspend",
      module: "Config",
      package: "effect",
      signature: "<A>(config: LazyArg<Config<A>>) => Config<A>",
      description: "Lazily constructs a config.",
      documentation: "Lazily constructs a config.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 485,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L485"
    },
    {
      id: "Config.sync",
      name: "sync",
      module: "Config",
      package: "effect",
      signature: "<A>(value: LazyArg<A>) => Config<A>",
      description: "Constructs a config which contains the specified lazy value.",
      documentation: "Constructs a config which contains the specified lazy value.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 492,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L492"
    },
    {
      id: "Config.hashMap",
      name: "hashMap",
      module: "Config",
      package: "effect",
      signature: "<A>(config: Config<A>, name?: string) => Config<HashMap<string, A>>",
      description: "Constructs a config for a sequence of values.",
      documentation: "Constructs a config for a sequence of values.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 499,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L499"
    },
    {
      id: "Config.unwrap",
      name: "unwrap",
      module: "Config",
      package: "effect",
      signature: "<A>(wrapped: Config.Wrap<A>) => Config<A>",
      description: "Constructs a config from some configuration wrapped with the `Wrap<A>` utility type. For example:",
      documentation: 'Constructs a config from some configuration wrapped with the `Wrap<A>` utility type.\n\nFor example:\n\n```\nimport { Config, unwrap } from "./Config"\n\ninterface Options { key: string }\n\nconst makeConfig = (config: Config.Wrap<Options>): Config<Options> => unwrap(config)\n```',
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 516,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L516"
    },
    {
      id: "Config.validate",
      name: "validate",
      module: "Config",
      package: "effect",
      signature: "{ <A, B extends A>(options: { readonly message: string; readonly validation: Refinement<A, B>; }): (self: Config<A>) => Config<B>; <A>(options: { readonly message: string; readonly validation: Predicate<A>; }): (self: Config<A>) => Config<A>; <A, B extends A>(self: Config<A>, options: { readonly message: string; readonly validation: Refinement<A, B>; }): Config<B>; <A>(self: Config<A>, options: { readonly message: string; readonly validation: Predicate<A>; }): Config<A>; }",
      description: "Returns a config that describes the same structure as this one, but which\nperforms validation during loading.",
      documentation: "Returns a config that describes the same structure as this one, but which\nperforms validation during loading.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 524,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L524"
    },
    {
      id: "Config.withDefault",
      name: "withDefault",
      module: "Config",
      package: "effect",
      signature: "{ <const A2>(def: A2): <A>(self: Config<A>) => Config<A2 | A>; <A, const A2>(self: Config<A>, def: A2): Config<A | A2>; }",
      description: "Returns a config that describes the same structure as this one, but has the\nspecified default value in case the information cannot be found.",
      documentation: "Returns a config that describes the same structure as this one, but has the\nspecified default value in case the information cannot be found.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 577,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L577"
    },
    {
      id: "Config.withDescription",
      name: "withDescription",
      module: "Config",
      package: "effect",
      signature: "{ (description: string): <A>(self: Config<A>) => Config<A>; <A>(self: Config<A>, description: string): Config<A>; }",
      description: "Adds a description to this configuration, which is intended for humans.",
      documentation: "Adds a description to this configuration, which is intended for humans.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 601,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L601"
    },
    {
      id: "Config.zip",
      name: "zip",
      module: "Config",
      package: "effect",
      signature: "{ <B>(that: Config<B>): <A>(self: Config<A>) => Config<[A, B]>; <A, B>(self: Config<A>, that: Config<B>): Config<[A, B]>; }",
      description: "Returns a config that is the composition of this config and the specified\nconfig.",
      documentation: "Returns a config that is the composition of this config and the specified\nconfig.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 624,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L624"
    },
    {
      id: "Config.zipWith",
      name: "zipWith",
      module: "Config",
      package: "effect",
      signature: "{ <B, A, C>(that: Config<B>, f: (a: A, b: B) => C): (self: Config<A>) => Config<C>; <A, B, C>(self: Config<A>, that: Config<B>, f: (a: A, b: B) => C): Config<C>; }",
      description: "Returns a config that is the composes this config and the specified config\nusing the provided function.",
      documentation: "Returns a config that is the composes this config and the specified config\nusing the provided function.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Config.d.ts",
      sourceLine: 649,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Config.ts#L649"
    },
    {
      id: "ConfigProvider.ConfigProviderTypeId",
      name: "ConfigProviderTypeId",
      module: "ConfigProvider",
      package: "effect",
      signature: "typeof ConfigProviderTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/ConfigProvider.d.ts",
      sourceLine: 16,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ConfigProvider.ts#L16"
    },
    {
      id: "ConfigProvider.FlatConfigProviderTypeId",
      name: "FlatConfigProviderTypeId",
      module: "ConfigProvider",
      package: "effect",
      signature: "typeof FlatConfigProviderTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/ConfigProvider.d.ts",
      sourceLine: 26,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ConfigProvider.ts#L26"
    },
    {
      id: "ConfigProvider.ConfigProvider",
      name: "ConfigProvider",
      module: "ConfigProvider",
      package: "effect",
      signature: "Tag<ConfigProvider, ConfigProvider>",
      description: "The service tag for `ConfigProvider`.",
      documentation: "The service tag for `ConfigProvider`.",
      examples: [],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/ConfigProvider.d.ts",
      sourceLine: 119,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ConfigProvider.ts#L119"
    },
    {
      id: "ConfigProvider.make",
      name: "make",
      module: "ConfigProvider",
      package: "effect",
      signature: "(options: { readonly load: <A>(config: Config<A>) => Effect<A, ConfigError, never>; readonly flattened: ConfigProvider.Flat; }) => ConfigProvider",
      description: "Creates a new config provider.",
      documentation: "Creates a new config provider.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/ConfigProvider.d.ts",
      sourceLine: 126,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ConfigProvider.ts#L126"
    },
    {
      id: "ConfigProvider.makeFlat",
      name: "makeFlat",
      module: "ConfigProvider",
      package: "effect",
      signature: "(options: { readonly load: <A>(path: readonly string[], config: Config.Primitive<A>, split: boolean) => Effect<A[], ConfigError, never>; readonly enumerateChildren: (path: readonly string[]) => Effect<HashSet<string>, ConfigError, never>; readonly patch: PathPatch; }) => ConfigProvider.Flat",
      description: "Creates a new flat config provider.",
      documentation: "Creates a new flat config provider.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/ConfigProvider.d.ts",
      sourceLine: 136,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ConfigProvider.ts#L136"
    },
    {
      id: "ConfigProvider.fromEnv",
      name: "fromEnv",
      module: "ConfigProvider",
      package: "effect",
      signature: "(options?: Partial<ConfigProvider.FromEnvConfig>) => ConfigProvider",
      description: 'A config provider that loads configuration from context variables Options: - `pathDelim`: The delimiter for the path segments (default: `"_"`).\n- `seqDelim`: The delimiter for the sequence of values (default: `","`).',
      documentation: 'A config provider that loads configuration from context variables\n\n**Options**:\n\n- `pathDelim`: The delimiter for the path segments (default: `"_"`).\n- `seqDelim`: The delimiter for the sequence of values (default: `","`).',
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/ConfigProvider.d.ts",
      sourceLine: 152,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ConfigProvider.ts#L152"
    },
    {
      id: "ConfigProvider.fromFlat",
      name: "fromFlat",
      module: "ConfigProvider",
      package: "effect",
      signature: "(flat: ConfigProvider.Flat) => ConfigProvider",
      description: "Constructs a new `ConfigProvider` from a key/value (flat) provider, where\nnesting is embedded into the string keys.",
      documentation: "Constructs a new `ConfigProvider` from a key/value (flat) provider, where\nnesting is embedded into the string keys.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/ConfigProvider.d.ts",
      sourceLine: 160,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ConfigProvider.ts#L160"
    },
    {
      id: "ConfigProvider.fromJson",
      name: "fromJson",
      module: "ConfigProvider",
      package: "effect",
      signature: "(json: unknown) => ConfigProvider",
      description: "Constructs a new `ConfigProvider` from a JSON object.",
      documentation: "Constructs a new `ConfigProvider` from a JSON object.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/ConfigProvider.d.ts",
      sourceLine: 167,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ConfigProvider.ts#L167"
    },
    {
      id: "ConfigProvider.fromMap",
      name: "fromMap",
      module: "ConfigProvider",
      package: "effect",
      signature: "(map: Map<string, string>, config?: Partial<ConfigProvider.FromMapConfig>) => ConfigProvider",
      description: "Constructs a ConfigProvider using a map and the specified delimiter string,\nwhich determines how to split the keys in the map into path segments.",
      documentation: "Constructs a ConfigProvider using a map and the specified delimiter string,\nwhich determines how to split the keys in the map into path segments.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/ConfigProvider.d.ts",
      sourceLine: 175,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ConfigProvider.ts#L175"
    },
    {
      id: "ConfigProvider.constantCase",
      name: "constantCase",
      module: "ConfigProvider",
      package: "effect",
      signature: "(self: ConfigProvider) => ConfigProvider",
      description: "Returns a new config provider that will automatically convert all property\nnames to constant case. This can be utilized to adapt the names of\nconfiguration properties from the default naming convention of camel case\nto the naming convention of a config provider.",
      documentation: "Returns a new config provider that will automatically convert all property\nnames to constant case. This can be utilized to adapt the names of\nconfiguration properties from the default naming convention of camel case\nto the naming convention of a config provider.",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/ConfigProvider.d.ts",
      sourceLine: 185,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ConfigProvider.ts#L185"
    },
    {
      id: "ConfigProvider.mapInputPath",
      name: "mapInputPath",
      module: "ConfigProvider",
      package: "effect",
      signature: "{ (f: (path: string) => string): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, f: (path: string) => string): ConfigProvider; }",
      description: "Returns a new config provider that will automatically tranform all path\nconfiguration names with the specified function. This can be utilized to\nadapt the names of configuration properties from one naming convention to\nanother.",
      documentation: "Returns a new config provider that will automatically tranform all path\nconfiguration names with the specified function. This can be utilized to\nadapt the names of configuration properties from one naming convention to\nanother.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/ConfigProvider.d.ts",
      sourceLine: 195,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ConfigProvider.ts#L195"
    },
    {
      id: "ConfigProvider.kebabCase",
      name: "kebabCase",
      module: "ConfigProvider",
      package: "effect",
      signature: "(self: ConfigProvider) => ConfigProvider",
      description: "Returns a new config provider that will automatically convert all property\nnames to kebab case. This can be utilized to adapt the names of\nconfiguration properties from the default naming convention of camel case\nto the naming convention of a config provider.",
      documentation: "Returns a new config provider that will automatically convert all property\nnames to kebab case. This can be utilized to adapt the names of\nconfiguration properties from the default naming convention of camel case\nto the naming convention of a config provider.",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/ConfigProvider.d.ts",
      sourceLine: 226,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ConfigProvider.ts#L226"
    },
    {
      id: "ConfigProvider.lowerCase",
      name: "lowerCase",
      module: "ConfigProvider",
      package: "effect",
      signature: "(self: ConfigProvider) => ConfigProvider",
      description: "Returns a new config provider that will automatically convert all property\nnames to lower case. This can be utilized to adapt the names of\nconfiguration properties from the default naming convention of camel case\nto the naming convention of a config provider.",
      documentation: "Returns a new config provider that will automatically convert all property\nnames to lower case. This can be utilized to adapt the names of\nconfiguration properties from the default naming convention of camel case\nto the naming convention of a config provider.",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/ConfigProvider.d.ts",
      sourceLine: 236,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ConfigProvider.ts#L236"
    },
    {
      id: "ConfigProvider.nested",
      name: "nested",
      module: "ConfigProvider",
      package: "effect",
      signature: "{ (name: string): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, name: string): ConfigProvider; }",
      description: "Returns a new config provider that will automatically nest all\nconfiguration under the specified property name. This can be utilized to\naggregate separate configuration sources that are all required to load a\nsingle configuration value.",
      documentation: "Returns a new config provider that will automatically nest all\nconfiguration under the specified property name. This can be utilized to\naggregate separate configuration sources that are all required to load a\nsingle configuration value.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/ConfigProvider.d.ts",
      sourceLine: 246,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ConfigProvider.ts#L246"
    },
    {
      id: "ConfigProvider.orElse",
      name: "orElse",
      module: "ConfigProvider",
      package: "effect",
      signature: "{ (that: LazyArg<ConfigProvider>): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, that: LazyArg<ConfigProvider>): ConfigProvider; }",
      description: "Returns a new config provider that preferentially loads configuration data\nfrom this one, but which will fall back to the specified alternate provider\nif there are any issues loading the configuration from this provider.",
      documentation: "Returns a new config provider that preferentially loads configuration data\nfrom this one, but which will fall back to the specified alternate provider\nif there are any issues loading the configuration from this provider.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/ConfigProvider.d.ts",
      sourceLine: 276,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ConfigProvider.ts#L276"
    },
    {
      id: "ConfigProvider.unnested",
      name: "unnested",
      module: "ConfigProvider",
      package: "effect",
      signature: "{ (name: string): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, name: string): ConfigProvider; }",
      description: "Returns a new config provider that will automatically un-nest all\nconfiguration under the specified property name. This can be utilized to\nde-aggregate separate configuration sources that are all required to load a\nsingle configuration value.",
      documentation: "Returns a new config provider that will automatically un-nest all\nconfiguration under the specified property name. This can be utilized to\nde-aggregate separate configuration sources that are all required to load a\nsingle configuration value.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/ConfigProvider.d.ts",
      sourceLine: 305,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ConfigProvider.ts#L305"
    },
    {
      id: "ConfigProvider.snakeCase",
      name: "snakeCase",
      module: "ConfigProvider",
      package: "effect",
      signature: "(self: ConfigProvider) => ConfigProvider",
      description: "Returns a new config provider that will automatically convert all property\nnames to upper case. This can be utilized to adapt the names of\nconfiguration properties from the default naming convention of camel case\nto the naming convention of a config provider.",
      documentation: "Returns a new config provider that will automatically convert all property\nnames to upper case. This can be utilized to adapt the names of\nconfiguration properties from the default naming convention of camel case\nto the naming convention of a config provider.",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/ConfigProvider.d.ts",
      sourceLine: 336,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ConfigProvider.ts#L336"
    },
    {
      id: "ConfigProvider.upperCase",
      name: "upperCase",
      module: "ConfigProvider",
      package: "effect",
      signature: "(self: ConfigProvider) => ConfigProvider",
      description: "Returns a new config provider that will automatically convert all property\nnames to upper case. This can be utilized to adapt the names of\nconfiguration properties from the default naming convention of camel case\nto the naming convention of a config provider.",
      documentation: "Returns a new config provider that will automatically convert all property\nnames to upper case. This can be utilized to adapt the names of\nconfiguration properties from the default naming convention of camel case\nto the naming convention of a config provider.",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/ConfigProvider.d.ts",
      sourceLine: 346,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ConfigProvider.ts#L346"
    },
    {
      id: "ConfigProvider.within",
      name: "within",
      module: "ConfigProvider",
      package: "effect",
      signature: "{ (path: readonly string[], f: (self: ConfigProvider) => ConfigProvider): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, path: readonly string[], f: (self: ConfigProvider) => ConfigProvider): ConfigProvider; }",
      description: "Returns a new config provider that transforms the config provider with the\nspecified function within the specified path.",
      documentation: "Returns a new config provider that transforms the config provider with the\nspecified function within the specified path.",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/ConfigProvider.d.ts",
      sourceLine: 354,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ConfigProvider.ts#L354"
    },
    {
      id: "Logger.LoggerTypeId",
      name: "LoggerTypeId",
      module: "Logger",
      package: "effect",
      signature: "typeof LoggerTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 23,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L23"
    },
    {
      id: "Logger.make",
      name: "make",
      module: "Logger",
      package: "effect",
      signature: "<Message, Output>(log: (options: Logger.Options<Message>) => Output) => Logger<Message, Output>",
      description: "Creates a custom logger that formats log messages according to the provided\nfunction.",
      documentation: "Creates a custom logger that formats log messages according to the provided\nfunction.",
      examples: [
        {
          code: 'import { Effect, Logger, LogLevel } from "effect"\n\nconst logger = Logger.make(({ logLevel, message }) => {\n  globalThis.console.log(`[${logLevel.label}] ${message}`)\n})\n\nconst task1 = Effect.logDebug("task1 done")\nconst task2 = Effect.logDebug("task2 done")\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log("start")\n  yield* task1\n  yield* task2\n  yield* Effect.log("done")\n}).pipe(\n  Logger.withMinimumLogLevel(LogLevel.Debug),\n  Effect.provide(Logger.replace(Logger.defaultLogger, logger))\n)\n\nEffect.runFork(program)\n// [INFO] start\n// [DEBUG] task1 done\n// [DEBUG] task2 done\n// [INFO] done'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 100,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L100"
    },
    {
      id: "Logger.add",
      name: "add",
      module: "Logger",
      package: "effect",
      signature: "<B>(logger: Logger<unknown, B>) => Layer<never, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 105,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L105"
    },
    {
      id: "Logger.addEffect",
      name: "addEffect",
      module: "Logger",
      package: "effect",
      signature: "<A, E, R>(effect: Effect<Logger<unknown, A>, E, R>) => Layer<never, E, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 110,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L110"
    },
    {
      id: "Logger.addScoped",
      name: "addScoped",
      module: "Logger",
      package: "effect",
      signature: "<A, E, R>(effect: Effect<Logger<unknown, A>, E, R>) => Layer<never, E, Exclude<R, Scope>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 115,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L115"
    },
    {
      id: "Logger.mapInput",
      name: "mapInput",
      module: "Logger",
      package: "effect",
      signature: "{ <Message, Message2>(f: (message: Message2) => Message): <Output>(self: Logger<Message, Output>) => Logger<Message2, Output>; <Output, Message, Message2>(self: Logger<Message, Output>, f: (message: Message2) => Message): Logger<Message2, Output>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 120,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L120"
    },
    {
      id: "Logger.mapInputOptions",
      name: "mapInputOptions",
      module: "Logger",
      package: "effect",
      signature: "{ <Message, Message2>(f: (options: Logger.Options<Message2>) => Logger.Options<Message>): <Output>(self: Logger<Message, Output>) => Logger<Message2, Output>; <Output, Message, Message2>(self: Logger<Message, Output>, f: (options: Logger.Options<Message2>) => Logger.Options<Message>): Logger<Message2, Output>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 136,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L136"
    },
    {
      id: "Logger.filterLogLevel",
      name: "filterLogLevel",
      module: "Logger",
      package: "effect",
      signature: "{ (f: (logLevel: LogLevel) => boolean): <Message, Output>(self: Logger<Message, Output>) => Logger<Message, Option<Output>>; <Message, Output>(self: Logger<Message, Output>, f: (logLevel: LogLevel) => boolean): Logger<Message, Option<Output>>; }",
      description: "Returns a version of this logger that only logs messages when the log level\nsatisfies the specified predicate.",
      documentation: "Returns a version of this logger that only logs messages when the log level\nsatisfies the specified predicate.",
      examples: [],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 155,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L155"
    },
    {
      id: "Logger.map",
      name: "map",
      module: "Logger",
      package: "effect",
      signature: "{ <Output, Output2>(f: (output: Output) => Output2): <Message>(self: Logger<Message, Output>) => Logger<Message, Output2>; <Message, Output, Output2>(self: Logger<Message, Output>, f: (output: Output) => Output2): Logger<Message, Output2>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 177,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L177"
    },
    {
      id: "Logger.batched",
      name: "batched",
      module: "Logger",
      package: "effect",
      signature: "{ <Output, R>(window: DurationInput, f: (messages: NoInfer<Output>[]) => Effect<void, never, R>): <Message>(self: Logger<Message, Output>) => Effect<Logger<Message, void>, never, Scope | R>; <Message, Output, R>(self: Logger<Message, Output>, window: DurationInput, f: (messages: NoInfer<Output>[]) => Effect<void, never, R>): Effect<Logger<Message, void>, never, Scope | R>; }",
      description: "Creates a batched logger that groups log messages together and processes them\nin intervals.",
      documentation: "Creates a batched logger that groups log messages together and processes them\nin intervals.",
      examples: [
        {
          code: 'import { Console, Effect, Logger } from "effect"\n\nconst LoggerLive = Logger.replaceScoped(\n  Logger.defaultLogger,\n  Logger.logfmtLogger.pipe(\n    Logger.batched("500 millis", (messages) => Console.log("BATCH", `[\\n${messages.join("\\n")}\\n]`))\n  )\n)\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log("one")\n  yield* Effect.log("two")\n  yield* Effect.log("three")\n}).pipe(Effect.provide(LoggerLive))\n\nEffect.runFork(program)\n// BATCH [\n// timestamp=... level=INFO fiber=#0 message=one\n// timestamp=... level=INFO fiber=#0 message=two\n// timestamp=... level=INFO fiber=#0 message=three\n// ]'
        }
      ],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 221,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L221"
    },
    {
      id: "Logger.withConsoleLog",
      name: "withConsoleLog",
      module: "Logger",
      package: "effect",
      signature: "<M, O>(self: Logger<M, O>) => Logger<M, void>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "console"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 293,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L293"
    },
    {
      id: "Logger.withLeveledConsole",
      name: "withLeveledConsole",
      module: "Logger",
      package: "effect",
      signature: "<M, O>(self: Logger<M, O>) => Logger<M, void>",
      description: "Takes a `Logger<M, O>` and returns a logger that calls the respective `Console` method\nbased on the log level.",
      documentation: "Takes a `Logger<M, O>` and returns a logger that calls the respective `Console` method\nbased on the log level.",
      examples: [
        {
          code: 'import { Logger, Effect } from "effect"\n\nconst loggerLayer = Logger.replace(\n  Logger.defaultLogger,\n  Logger.withLeveledConsole(Logger.stringLogger),\n)\n\nEffect.gen(function* () {\n  yield* Effect.logError("an error")\n  yield* Effect.logInfo("an info")\n}).pipe(Effect.provide(loggerLayer))'
        }
      ],
      tags: [
        "console"
      ],
      since: "3.8.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 316,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L316"
    },
    {
      id: "Logger.withConsoleError",
      name: "withConsoleError",
      module: "Logger",
      package: "effect",
      signature: "<M, O>(self: Logger<M, O>) => Logger<M, void>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "console"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 321,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L321"
    },
    {
      id: "Logger.none",
      name: "none",
      module: "Logger",
      package: "effect",
      signature: "Logger<unknown, void>",
      description: "A logger that does nothing in response to logging events.",
      documentation: "A logger that does nothing in response to logging events.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 328,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L328"
    },
    {
      id: "Logger.remove",
      name: "remove",
      module: "Logger",
      package: "effect",
      signature: "<A>(logger: Logger<unknown, A>) => Layer<never, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 333,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L333"
    },
    {
      id: "Logger.replace",
      name: "replace",
      module: "Logger",
      package: "effect",
      signature: "{ <B>(that: Logger<unknown, B>): <A>(self: Logger<unknown, A>) => Layer<never, never, never>; <A, B>(self: Logger<unknown, A>, that: Logger<unknown, B>): Layer<never, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 338,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L338"
    },
    {
      id: "Logger.replaceEffect",
      name: "replaceEffect",
      module: "Logger",
      package: "effect",
      signature: "{ <B, E, R>(that: Effect<Logger<unknown, B>, E, R>): <A>(self: Logger<unknown, A>) => Layer<never, E, R>; <A, B, E, R>(self: Logger<unknown, A>, that: Effect<Logger<unknown, B>, E, R>): Layer<never, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 354,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L354"
    },
    {
      id: "Logger.replaceScoped",
      name: "replaceScoped",
      module: "Logger",
      package: "effect",
      signature: "{ <B, E, R>(that: Effect<Logger<unknown, B>, E, R>): <A>(self: Logger<unknown, A>) => Layer<never, E, Exclude<R, Scope>>; <A, B, E, R>(self: Logger<unknown, A>, that: Effect<Logger<unknown, B>, E, R>): Layer<never, E, Exclude<R, Scope>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 370,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L370"
    },
    {
      id: "Logger.simple",
      name: "simple",
      module: "Logger",
      package: "effect",
      signature: "<A, B>(log: (a: A) => B) => Logger<A, B>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 386,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L386"
    },
    {
      id: "Logger.succeed",
      name: "succeed",
      module: "Logger",
      package: "effect",
      signature: "<A>(value: A) => Logger<unknown, A>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 391,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L391"
    },
    {
      id: "Logger.sync",
      name: "sync",
      module: "Logger",
      package: "effect",
      signature: "<A>(evaluate: LazyArg<A>) => Logger<unknown, A>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 396,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L396"
    },
    {
      id: "Logger.test",
      name: "test",
      module: "Logger",
      package: "effect",
      signature: "{ <Message>(input: Message): <Output>(self: Logger<Message, Output>) => Output; <Message, Output>(self: Logger<Message, Output>, input: Message): Output; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 401,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L401"
    },
    {
      id: "Logger.withMinimumLogLevel",
      name: "withMinimumLogLevel",
      module: "Logger",
      package: "effect",
      signature: "{ (level: LogLevel): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, level: LogLevel): Effect<A, E, R>; }",
      description: "Sets the minimum log level for subsequent logging operations, allowing\ncontrol over which log messages are displayed based on their severity.",
      documentation: "Sets the minimum log level for subsequent logging operations, allowing\ncontrol over which log messages are displayed based on their severity.",
      examples: [
        {
          code: 'import { Effect, Logger, LogLevel } from "effect"\n\nconst program = Effect.logDebug("message1").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))\n\nEffect.runFork(program)\n// timestamp=... level=DEBUG fiber=#0 message=message1'
        }
      ],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 430,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L430"
    },
    {
      id: "Logger.withSpanAnnotations",
      name: "withSpanAnnotations",
      module: "Logger",
      package: "effect",
      signature: "<Message, Output>(self: Logger<Message, Output>) => Logger<Message, Output>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "tracing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 472,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L472"
    },
    {
      id: "Logger.zip",
      name: "zip",
      module: "Logger",
      package: "effect",
      signature: "{ <Message2, Output2>(that: Logger<Message2, Output2>): <Message, Output>(self: Logger<Message, Output>) => Logger<Message & Message2, [Output, Output2]>; <Message, Output, Message2, Output2>(self: Logger<Message, Output>, that: Logger<Message2, Output2>): Logger<Message & Message2, [Output, Output2]>; }",
      description: "Combines this logger with the specified logger to produce a new logger that\nlogs to both this logger and that logger.",
      documentation: "Combines this logger with the specified logger to produce a new logger that\nlogs to both this logger and that logger.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 480,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L480"
    },
    {
      id: "Logger.zipLeft",
      name: "zipLeft",
      module: "Logger",
      package: "effect",
      signature: "{ <Message2, Output2>(that: Logger<Message2, Output2>): <Message, Output>(self: Logger<Message, Output>) => Logger<Message & Message2, Output>; <Message, Output, Message2, Output2>(self: Logger<Message, Output>, that: Logger<Message2, Output2>): Logger<Message & Message2, Output>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 502,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L502"
    },
    {
      id: "Logger.zipRight",
      name: "zipRight",
      module: "Logger",
      package: "effect",
      signature: "{ <Message2, Output2>(that: Logger<Message2, Output2>): <Message, Output>(self: Logger<Message, Output>) => Logger<Message & Message2, Output2>; <Message, Output, Message2, Output2>(self: Logger<Message, Output>, that: Logger<Message2, Output2>): Logger<Message & Message2, Output2>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 518,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L518"
    },
    {
      id: "Logger.defaultLogger",
      name: "defaultLogger",
      module: "Logger",
      package: "effect",
      signature: "Logger<unknown, void>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 534,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L534"
    },
    {
      id: "Logger.jsonLogger",
      name: "jsonLogger",
      module: "Logger",
      package: "effect",
      signature: "Logger<unknown, string>",
      description: "The `jsonLogger` logger formats log entries as JSON objects, making them easy to\nintegrate with logging systems that consume JSON data.",
      documentation: "The `jsonLogger` logger formats log entries as JSON objects, making them easy to\nintegrate with logging systems that consume JSON data.",
      examples: [
        {
          code: 'import { Effect, Logger } from "effect"\n\nconst program = Effect.log("message1", "message2").pipe(\n  Effect.annotateLogs({ key1: "value1", key2: "value2" }),\n  Effect.withLogSpan("myspan")\n)\n\nEffect.runFork(program.pipe(Effect.provide(Logger.json)))\n// {"message":["message1","message2"],"logLevel":"INFO","timestamp":"...","annotations":{"key2":"value2","key1":"value1"},"spans":{"myspan":0},"fiberId":"#0"}'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 555,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L555"
    },
    {
      id: "Logger.logfmtLogger",
      name: "logfmtLogger",
      module: "Logger",
      package: "effect",
      signature: "Logger<unknown, string>",
      description: "This logger outputs logs in a human-readable format that is easy to read\nduring development or in a production console.",
      documentation: "This logger outputs logs in a human-readable format that is easy to read\nduring development or in a production console.",
      examples: [
        {
          code: 'import { Effect, Logger } from "effect"\n\nconst program = Effect.log("message1", "message2").pipe(\n  Effect.annotateLogs({ key1: "value1", key2: "value2" }),\n  Effect.withLogSpan("myspan")\n)\n\nEffect.runFork(program.pipe(Effect.provide(Logger.logFmt)))\n// timestamp=... level=INFO fiber=#0 message=message1 message=message2 myspan=0ms key2=value2 key1=value1'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 576,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L576"
    },
    {
      id: "Logger.stringLogger",
      name: "stringLogger",
      module: "Logger",
      package: "effect",
      signature: "Logger<unknown, string>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 581,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L581"
    },
    {
      id: "Logger.prettyLogger",
      name: "prettyLogger",
      module: "Logger",
      package: "effect",
      signature: '(options?: { readonly colors?: boolean | "auto"; readonly stderr?: boolean; readonly formatDate?: (date: Date) => string; readonly mode?: "auto" | "browser" | "tty"; }) => Logger<unknown, void>',
      description: "The pretty logger utilizes the capabilities of the console API to generate\nvisually engaging and color-enhanced log outputs. This feature is\nparticularly useful for improving the readability of log messages during\ndevelopment and debugging processes.",
      documentation: "The pretty logger utilizes the capabilities of the console API to generate\nvisually engaging and color-enhanced log outputs. This feature is\nparticularly useful for improving the readability of log messages during\ndevelopment and debugging processes.",
      examples: [
        {
          code: 'import { Effect, Logger } from "effect"\n\nconst program = Effect.log("message1", "message2").pipe(\n  Effect.annotateLogs({ key1: "value1", key2: "value2" }),\n  Effect.withLogSpan("myspan")\n)\n\nEffect.runFork(program.pipe(Effect.provide(Logger.pretty)))\n//         green --v                      v-- bold and cyan\n// [07:51:54.434] INFO (#0) myspan=1ms: message1\n//   message2\n//    v-- bold\n//   key2: value2\n//   key1: value1'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "3.5.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 609,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L609"
    },
    {
      id: "Logger.prettyLoggerDefault",
      name: "prettyLoggerDefault",
      module: "Logger",
      package: "effect",
      signature: "Logger<unknown, void>",
      description: "A default version of the pretty logger.",
      documentation: "A default version of the pretty logger.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "3.8.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 621,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L621"
    },
    {
      id: "Logger.structuredLogger",
      name: "structuredLogger",
      module: "Logger",
      package: "effect",
      signature: "Logger<unknown, { readonly logLevel: string; readonly fiberId: string; readonly timestamp: string; readonly message: unknown; readonly cause: string; readonly annotations: Record<string, unknown>; readonly spans: Record<string, number>; }>",
      description: "The structured logger provides detailed log outputs, structured in a way that\nretains comprehensive traceability of the events, suitable for deeper\nanalysis and troubleshooting.",
      documentation: "The structured logger provides detailed log outputs, structured in a way that\nretains comprehensive traceability of the events, suitable for deeper\nanalysis and troubleshooting.",
      examples: [
        {
          code: `import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.structured)))
// {
//   message: [ 'message1', 'message2' ],
//   logLevel: 'INFO',
//   timestamp: '2024-07-09T14:05:41.623Z',
//   cause: undefined,
//   annotations: { key2: 'value2', key1: 'value1' },
//   spans: { myspan: 0 },
//   fiberId: '#0'
// }`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 651,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L651"
    },
    {
      id: "Logger.tracerLogger",
      name: "tracerLogger",
      module: "Logger",
      package: "effect",
      signature: "Logger<unknown, void>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 664,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L664"
    },
    {
      id: "Logger.json",
      name: "json",
      module: "Logger",
      package: "effect",
      signature: "Layer<never, never, never>",
      description: "The `json` logger formats log entries as JSON objects, making them easy to\nintegrate with logging systems that consume JSON data.",
      documentation: "The `json` logger formats log entries as JSON objects, making them easy to\nintegrate with logging systems that consume JSON data.",
      examples: [
        {
          code: 'import { Effect, Logger } from "effect"\n\nconst program = Effect.log("message1", "message2").pipe(\n  Effect.annotateLogs({ key1: "value1", key2: "value2" }),\n  Effect.withLogSpan("myspan")\n)\n\nEffect.runFork(program.pipe(Effect.provide(Logger.json)))\n// {"message":["message1","message2"],"logLevel":"INFO","timestamp":"...","annotations":{"key2":"value2","key1":"value1"},"spans":{"myspan":0},"fiberId":"#0"}'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 685,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L685"
    },
    {
      id: "Logger.logFmt",
      name: "logFmt",
      module: "Logger",
      package: "effect",
      signature: "Layer<never, never, never>",
      description: "This logger outputs logs in a human-readable format that is easy to read\nduring development or in a production console.",
      documentation: "This logger outputs logs in a human-readable format that is easy to read\nduring development or in a production console.",
      examples: [
        {
          code: 'import { Effect, Logger } from "effect"\n\nconst program = Effect.log("message1", "message2").pipe(\n  Effect.annotateLogs({ key1: "value1", key2: "value2" }),\n  Effect.withLogSpan("myspan")\n)\n\nEffect.runFork(program.pipe(Effect.provide(Logger.logFmt)))\n// timestamp=... level=INFO fiber=#0 message=message1 message=message2 myspan=0ms key2=value2 key1=value1'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 706,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L706"
    },
    {
      id: "Logger.pretty",
      name: "pretty",
      module: "Logger",
      package: "effect",
      signature: "Layer<never, never, never>",
      description: "The pretty logger utilizes the capabilities of the console API to generate\nvisually engaging and color-enhanced log outputs. This feature is\nparticularly useful for improving the readability of log messages during\ndevelopment and debugging processes.",
      documentation: "The pretty logger utilizes the capabilities of the console API to generate\nvisually engaging and color-enhanced log outputs. This feature is\nparticularly useful for improving the readability of log messages during\ndevelopment and debugging processes.",
      examples: [
        {
          code: 'import { Effect, Logger } from "effect"\n\nconst program = Effect.log("message1", "message2").pipe(\n  Effect.annotateLogs({ key1: "value1", key2: "value2" }),\n  Effect.withLogSpan("myspan")\n)\n\nEffect.runFork(program.pipe(Effect.provide(Logger.pretty)))\n//         green --v                      v-- bold and cyan\n// [07:51:54.434] INFO (#0) myspan=1ms: message1\n//   message2\n//    v-- bold\n//   key2: value2\n//   key1: value1'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "3.5.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 734,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L734"
    },
    {
      id: "Logger.structured",
      name: "structured",
      module: "Logger",
      package: "effect",
      signature: "Layer<never, never, never>",
      description: "The structured logger provides detailed log outputs, structured in a way that\nretains comprehensive traceability of the events, suitable for deeper\nanalysis and troubleshooting.",
      documentation: "The structured logger provides detailed log outputs, structured in a way that\nretains comprehensive traceability of the events, suitable for deeper\nanalysis and troubleshooting.",
      examples: [
        {
          code: `import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.structured)))
// {
//   message: [ 'message1', 'message2' ],
//   logLevel: 'INFO',
//   timestamp: '2024-07-09T14:05:41.623Z',
//   cause: undefined,
//   annotations: { key2: 'value2', key1: 'value1' },
//   spans: { myspan: 0 },
//   fiberId: '#0'
// }`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 764,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L764"
    },
    {
      id: "Logger.minimumLogLevel",
      name: "minimumLogLevel",
      module: "Logger",
      package: "effect",
      signature: "(level: LogLevel) => Layer<never, never, never>",
      description: "Sets the minimum log level for logging operations, allowing control over\nwhich log messages are displayed based on their severity.",
      documentation: "Sets the minimum log level for logging operations, allowing control over\nwhich log messages are displayed based on their severity.",
      examples: [
        {
          code: 'import { Effect, Logger, LogLevel } from "effect"\n\nconst program = Effect.gen(function*() {\n  yield* Effect.log("Executing task...")\n  yield* Effect.sleep("100 millis")\n  console.log("task done")\n})\n\n// Logging disabled using a layer\nEffect.runFork(program.pipe(Effect.provide(Logger.minimumLogLevel(LogLevel.None))))\n// task done'
        }
      ],
      tags: [
        "context"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 787,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L787"
    },
    {
      id: "Logger.isLogger",
      name: "isLogger",
      module: "Logger",
      package: "effect",
      signature: "(u: unknown) => u is Logger<unknown, unknown>",
      description: "Returns `true` if the specified value is a `Logger`, otherwise returns `false`.",
      documentation: "Returns `true` if the specified value is a `Logger`, otherwise returns `false`.",
      examples: [],
      tags: [
        "guards"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Logger.d.ts",
      sourceLine: 794,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Logger.ts#L794"
    },
    {
      id: "Metric.MetricTypeId",
      name: "MetricTypeId",
      module: "Metric",
      package: "effect",
      signature: "typeof MetricTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 20,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L20"
    },
    {
      id: "Metric.globalMetricRegistry",
      name: "globalMetricRegistry",
      module: "Metric",
      package: "effect",
      signature: "MetricRegistry",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "globals"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 115,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L115"
    },
    {
      id: "Metric.make",
      name: "make",
      module: "Metric",
      package: "effect",
      signature: "MetricApply",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 120,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L120"
    },
    {
      id: "Metric.mapInput",
      name: "mapInput",
      module: "Metric",
      package: "effect",
      signature: "{ <In, In2>(f: (input: In2) => In): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, In2, Out>; <Type, In, Out, In2>(self: Metric<Type, In, Out>, f: (input: In2) => In): Metric<Type, In2, Out>; }",
      description: "Returns a new metric that is powered by this one, but which accepts updates\nof the specified new type, which must be transformable to the input type of\nthis metric.",
      documentation: "Returns a new metric that is powered by this one, but which accepts updates\nof the specified new type, which must be transformable to the input type of\nthis metric.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 129,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L129"
    },
    {
      id: "Metric.counter",
      name: "counter",
      module: "Metric",
      package: "effect",
      signature: "{ (name: string, options?: { readonly description?: string; readonly bigint?: false; readonly incremental?: boolean; }): Metric.Counter<number>; (name: string, options: { readonly description?: string; readonly bigint: true; readonly incremental?: boolean; }): Metric.Counter<bigint>; }",
      description: "Represents a Counter metric that tracks cumulative numerical values over time.\nCounters can be incremented and decremented and provide a running total of changes. Options - description - A description of the counter.\n- bigint - Indicates if the counter uses 'bigint' data type.\n- incremental - Set to 'true' for a counter that only increases. With this configuration, Effect ensures that non-incremental updates have no impact on the counter, making it exclusively suitable for counting upwards.",
      documentation: "Represents a Counter metric that tracks cumulative numerical values over time.\nCounters can be incremented and decremented and provide a running total of changes.\n\n**Options**\n\n- description - A description of the counter.\n- bigint - Indicates if the counter uses 'bigint' data type.\n- incremental - Set to 'true' for a counter that only increases. With this configuration, Effect ensures that non-incremental updates have no impact on the counter, making it exclusively suitable for counting upwards.",
      examples: [
        {
          code: 'import { Metric } from "effect"\n\nconst numberCounter = Metric.counter("count", {\n  description: "A number counter"\n});\n\nconst bigintCounter = Metric.counter("count", {\n  description: "A bigint counter",\n  bigint: true\n});'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 176,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L176"
    },
    {
      id: "Metric.frequency",
      name: "frequency",
      module: "Metric",
      package: "effect",
      signature: "(name: string, options?: { readonly description?: string; readonly preregisteredWords?: readonly string[]; }) => Metric.Frequency<string>",
      description: "Creates a Frequency metric to count occurrences of events.\nFrequency metrics are used to count the number of times specific events or incidents occur.",
      documentation: "Creates a Frequency metric to count occurrences of events.\nFrequency metrics are used to count the number of times specific events or incidents occur.",
      examples: [
        {
          code: 'import { Metric } from "effect"\n\nconst errorFrequency = Metric.frequency("error_frequency", {\n   description: "Counts the occurrences of errors."\n});'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 258,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L258"
    },
    {
      id: "Metric.withConstantInput",
      name: "withConstantInput",
      module: "Metric",
      package: "effect",
      signature: "{ <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, unknown, Out>; <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Metric<Type, unknown, Out>; }",
      description: "Returns a new metric that is powered by this one, but which accepts updates\nof any type, and translates them to updates with the specified constant\nupdate value.",
      documentation: "Returns a new metric that is powered by this one, but which accepts updates\nof any type, and translates them to updates with the specified constant\nupdate value.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 270,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L270"
    },
    {
      id: "Metric.fromMetricKey",
      name: "fromMetricKey",
      module: "Metric",
      package: "effect",
      signature: "<Type extends MetricKeyType.MetricKeyType<any, any>>(key: MetricKey<Type>) => Metric<Type, MetricKeyType.InType<Type>, MetricKeyType.OutType<Type>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 294,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L294"
    },
    {
      id: "Metric.gauge",
      name: "gauge",
      module: "Metric",
      package: "effect",
      signature: "{ (name: string, options?: { readonly description?: string; readonly bigint?: false; }): Metric.Gauge<number>; (name: string, options: { readonly description?: string; readonly bigint: true; }): Metric.Gauge<bigint>; }",
      description: "Represents a Gauge metric that tracks and reports a single numerical value at a specific moment.\nGauges are suitable for metrics that represent instantaneous values, such as memory usage or CPU load. Options - description - A description of the gauge metric.\n- bigint - Indicates if the counter uses 'bigint' data type.",
      documentation: "Represents a Gauge metric that tracks and reports a single numerical value at a specific moment.\nGauges are suitable for metrics that represent instantaneous values, such as memory usage or CPU load.\n\n**Options**\n\n- description - A description of the gauge metric.\n- bigint - Indicates if the counter uses 'bigint' data type.",
      examples: [
        {
          code: 'import { Metric } from "effect"\n\nconst numberGauge = Metric.gauge("memory_usage", {\n  description: "A gauge for memory usage"\n});\n\nconst bigintGauge = Metric.gauge("cpu_load", {\n  description: "A gauge for CPU load",\n  bigint: true\n});'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 321,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L321"
    },
    {
      id: "Metric.histogram",
      name: "histogram",
      module: "Metric",
      package: "effect",
      signature: "(name: string, boundaries: MetricBoundaries, description?: string) => Metric<MetricKeyType.Histogram, number, MetricState.Histogram>",
      description: "Represents a Histogram metric that records observations in specified value boundaries.\nHistogram metrics are useful for measuring the distribution of values within a range.",
      documentation: "Represents a Histogram metric that records observations in specified value boundaries.\nHistogram metrics are useful for measuring the distribution of values within a range.",
      examples: [
        {
          code: 'import { Metric, MetricBoundaries } from "effect"\n\nconst latencyHistogram = Metric.histogram("latency_histogram",\n  MetricBoundaries.linear({ start: 0, width: 10, count: 11 }),\n  "Measures the distribution of request latency."\n);'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 400,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L400"
    },
    {
      id: "Metric.increment",
      name: "increment",
      module: "Metric",
      package: "effect",
      signature: "(self: Metric.Counter<number> | Metric.Counter<bigint> | Metric.Gauge<number> | Metric.Gauge<bigint>) => Effect<void, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 405,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L405"
    },
    {
      id: "Metric.incrementBy",
      name: "incrementBy",
      module: "Metric",
      package: "effect",
      signature: "{ (amount: number): (self: Metric.Counter<number>) => Effect<void, never, never>; (amount: bigint): (self: Metric.Counter<bigint> | Metric.Gauge<bigint>) => Effect<void, never, never>; (self: Metric.Counter<number> | Metric.Gauge<number>, amount: number): Effect<void, never, never>; (self: Metric.Counter<bigint> | Metric.Gauge<bigint>, amount: bigint): Effect<void, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 410,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L410"
    },
    {
      id: "Metric.map",
      name: "map",
      module: "Metric",
      package: "effect",
      signature: "{ <Out, Out2>(f: (out: Out) => Out2): <Type, In>(self: Metric<Type, In, Out>) => Metric<Type, In, Out2>; <Type, In, Out, Out2>(self: Metric<Type, In, Out>, f: (out: Out) => Out2): Metric<Type, In, Out2>; }",
      description: "Returns a new metric that is powered by this one, but which outputs a new\nstate type, determined by transforming the state type of this metric by the\nspecified function.",
      documentation: "Returns a new metric that is powered by this one, but which outputs a new\nstate type, determined by transforming the state type of this metric by the\nspecified function.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 440,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L440"
    },
    {
      id: "Metric.mapType",
      name: "mapType",
      module: "Metric",
      package: "effect",
      signature: "{ <Type, Type2>(f: (type: Type) => Type2): <In, Out>(self: Metric<Type, In, Out>) => Metric<Type2, In, Out>; <Type, In, Out, Type2>(self: Metric<Type, In, Out>, f: (type: Type) => Type2): Metric<Type2, In, Out>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 464,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L464"
    },
    {
      id: "Metric.modify",
      name: "modify",
      module: "Metric",
      package: "effect",
      signature: "{ <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Effect<void, never, never>; <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Effect<void, never, never>; }",
      description: "Modifies the metric with the specified update message. For example, if the\nmetric were a gauge, the update would increment the method by the provided\namount.",
      documentation: "Modifies the metric with the specified update message. For example, if the\nmetric were a gauge, the update would increment the method by the provided\namount.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "3.6.5",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 484,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L484"
    },
    {
      id: "Metric.set",
      name: "set",
      module: "Metric",
      package: "effect",
      signature: "{ (value: number): (self: Metric.Gauge<number>) => Effect<void, never, never>; (value: bigint): (self: Metric.Gauge<bigint>) => Effect<void, never, never>; (self: Metric.Gauge<number>, value: number): Effect<void, never, never>; (self: Metric.Gauge<bigint>, value: bigint): Effect<void, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "aspects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 508,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L508"
    },
    {
      id: "Metric.snapshot",
      name: "snapshot",
      module: "Metric",
      package: "effect",
      signature: "Effect<MetricPair.Untyped[], never, never>",
      description: "Captures a snapshot of all metrics recorded by the application.",
      documentation: "Captures a snapshot of all metrics recorded by the application.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 536,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L536"
    },
    {
      id: "Metric.succeed",
      name: "succeed",
      module: "Metric",
      package: "effect",
      signature: "<Out>(out: Out) => Metric<void, unknown, Out>",
      description: "Creates a metric that ignores input and produces constant output.",
      documentation: "Creates a metric that ignores input and produces constant output.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 543,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L543"
    },
    {
      id: "Metric.sync",
      name: "sync",
      module: "Metric",
      package: "effect",
      signature: "<Out>(evaluate: LazyArg<Out>) => Metric<void, unknown, Out>",
      description: "Creates a metric that ignores input and produces constant output.",
      documentation: "Creates a metric that ignores input and produces constant output.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 550,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L550"
    },
    {
      id: "Metric.summary",
      name: "summary",
      module: "Metric",
      package: "effect",
      signature: "(options: { readonly name: string; readonly maxAge: DurationInput; readonly maxSize: number; readonly error: number; readonly quantiles: readonly number[]; readonly description?: string; }) => Metric.Summary<number>",
      description: "Creates a Summary metric that records observations and calculates quantiles.\nSummary metrics provide statistical information about a set of values, including quantiles. Options - name - The name of the Summary metric.\n- maxAge - The maximum age of observations to retain.\n- maxSize - The maximum number of observations to keep.\n- error - The error percentage when calculating quantiles.\n- quantiles - An `Chunk` of quantiles to calculate (e.g., [0.5, 0.9]).\n- description - An optional description of the Summary metric.",
      documentation: "Creates a Summary metric that records observations and calculates quantiles.\nSummary metrics provide statistical information about a set of values, including quantiles.\n\n**Options**\n\n- name - The name of the Summary metric.\n- maxAge - The maximum age of observations to retain.\n- maxSize - The maximum number of observations to keep.\n- error - The error percentage when calculating quantiles.\n- quantiles - An `Chunk` of quantiles to calculate (e.g., [0.5, 0.9]).\n- description - An optional description of the Summary metric.",
      examples: [
        {
          code: 'import { Metric, Chunk } from "effect"\n\nconst responseTimesSummary = Metric.summary({\n  name: "response_times_summary",\n  maxAge: "60 seconds", // Retain observations for 60 seconds.\n  maxSize: 1000, // Keep a maximum of 1000 observations.\n  error: 0.01, // Allow a 1% error when calculating quantiles.\n  quantiles: [0.5, 0.9, 0.99], // Calculate 50th, 90th, and 99th percentiles.\n  description: "Measures the distribution of response times."\n});'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 581,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L581"
    },
    {
      id: "Metric.summaryTimestamp",
      name: "summaryTimestamp",
      module: "Metric",
      package: "effect",
      signature: "(options: { readonly name: string; readonly maxAge: DurationInput; readonly maxSize: number; readonly error: number; readonly quantiles: readonly number[]; readonly description?: string; }) => Metric.Summary<readonly [value: number, timestamp: number]>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 593,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L593"
    },
    {
      id: "Metric.tagged",
      name: "tagged",
      module: "Metric",
      package: "effect",
      signature: "{ <Type, In, Out>(key: string, value: string): (self: Metric<Type, In, Out>) => Metric<Type, In, Out>; <Type, In, Out>(self: Metric<Type, In, Out>, key: string, value: string): Metric<Type, In, Out>; }",
      description: "Returns a new metric, which is identical in every way to this one, except\nthe specified tags have been added to the tags of this metric.",
      documentation: "Returns a new metric, which is identical in every way to this one, except\nthe specified tags have been added to the tags of this metric.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 608,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L608"
    },
    {
      id: "Metric.taggedWithLabelsInput",
      name: "taggedWithLabelsInput",
      module: "Metric",
      package: "effect",
      signature: "{ <In>(f: (input: In) => Iterable<MetricLabel>): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, In, void>; <Type, In, Out>(self: Metric<Type, In, Out>, f: (input: In) => Iterable<MetricLabel>): Metric<Type, In, void>; }",
      description: "Returns a new metric, which is identical in every way to this one, except\ndynamic tags are added based on the update values. Note that the metric\nreturned by this method does not return any useful information, due to the\ndynamic nature of the added tags.",
      documentation: "Returns a new metric, which is identical in every way to this one, except\ndynamic tags are added based on the update values. Note that the metric\nreturned by this method does not return any useful information, due to the\ndynamic nature of the added tags.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 635,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L635"
    },
    {
      id: "Metric.taggedWithLabels",
      name: "taggedWithLabels",
      module: "Metric",
      package: "effect",
      signature: "{ <Type, In, Out>(extraTags: Iterable<MetricLabel>): (self: Metric<Type, In, Out>) => Metric<Type, In, Out>; <Type, In, Out>(self: Metric<Type, In, Out>, extraTags: Iterable<MetricLabel>): Metric<Type, In, Out>; }",
      description: "Returns a new metric, which is identical in every way to this one, except\nthe specified tags have been added to the tags of this metric.",
      documentation: "Returns a new metric, which is identical in every way to this one, except\nthe specified tags have been added to the tags of this metric.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 664,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L664"
    },
    {
      id: "Metric.timer",
      name: "timer",
      module: "Metric",
      package: "effect",
      signature: "(name: string, description?: string) => Metric<MetricKeyType.Histogram, Duration, MetricState.Histogram>",
      description: 'Creates a timer metric, based on a histogram, which keeps track of\ndurations in milliseconds. The unit of time will automatically be added to\nthe metric as a tag (i.e. `"time_unit: milliseconds"`).',
      documentation: 'Creates a timer metric, based on a histogram, which keeps track of\ndurations in milliseconds. The unit of time will automatically be added to\nthe metric as a tag (i.e. `"time_unit: milliseconds"`).',
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 690,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L690"
    },
    {
      id: "Metric.timerWithBoundaries",
      name: "timerWithBoundaries",
      module: "Metric",
      package: "effect",
      signature: "(name: string, boundaries: readonly number[], description?: string) => Metric<MetricKeyType.Histogram, Duration, MetricState.Histogram>",
      description: 'Creates a timer metric, based on a histogram created from the provided\nboundaries, which keeps track of durations in milliseconds. The unit of time\nwill automatically be added to the metric as a tag (i.e.\n`"time_unit: milliseconds"`).',
      documentation: 'Creates a timer metric, based on a histogram created from the provided\nboundaries, which keeps track of durations in milliseconds. The unit of time\nwill automatically be added to the metric as a tag (i.e.\n`"time_unit: milliseconds"`).',
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 700,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L700"
    },
    {
      id: "Metric.trackAll",
      name: "trackAll",
      module: "Metric",
      package: "effect",
      signature: "{ <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <Type, In, Out>(self: Metric<Type, In, Out>, input: In): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; }",
      description: "Returns an aspect that will update this metric with the specified constant\nvalue every time the aspect is applied to an effect, regardless of whether\nthat effect fails or succeeds.",
      documentation: "Returns an aspect that will update this metric with the specified constant\nvalue every time the aspect is applied to an effect, regardless of whether\nthat effect fails or succeeds.",
      examples: [],
      tags: [
        "aspects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 709,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L709"
    },
    {
      id: "Metric.trackDefect",
      name: "trackDefect",
      module: "Metric",
      package: "effect",
      signature: "{ <Type, Out>(metric: Metric<Type, unknown, Out>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, Type, Out>(self: Effect<A, E, R>, metric: Metric<Type, unknown, Out>): Effect<A, E, R>; }",
      description: "Returns an aspect that will update this metric with the defects of the\neffects that it is applied to.",
      documentation: "Returns an aspect that will update this metric with the defects of the\neffects that it is applied to.",
      examples: [],
      tags: [
        "aspects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 736,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L736"
    },
    {
      id: "Metric.trackDefectWith",
      name: "trackDefectWith",
      module: "Metric",
      package: "effect",
      signature: "{ <Type, In, Out>(metric: Metric<Type, In, Out>, f: (defect: unknown) => In): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, Type, In, Out>(self: Effect<A, E, R>, metric: Metric<Type, In, Out>, f: (defect: unknown) => In): Effect<A, E, R>; }",
      description: "Returns an aspect that will update this metric with the result of applying\nthe specified function to the defect throwables of the effects that the\naspect is applied to.",
      documentation: "Returns an aspect that will update this metric with the result of applying\nthe specified function to the defect throwables of the effects that the\naspect is applied to.",
      examples: [],
      tags: [
        "aspects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 762,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L762"
    },
    {
      id: "Metric.trackDuration",
      name: "trackDuration",
      module: "Metric",
      package: "effect",
      signature: "{ <Type, Out>(metric: Metric<Type, Duration, Out>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, Type, Out>(self: Effect<A, E, R>, metric: Metric<Type, Duration, Out>): Effect<A, E, R>; }",
      description: "Returns an aspect that will update this metric with the duration that the\neffect takes to execute. To call this method, the input type of the metric\nmust be `Duration`.",
      documentation: "Returns an aspect that will update this metric with the duration that the\neffect takes to execute. To call this method, the input type of the metric\nmust be `Duration`.",
      examples: [],
      tags: [
        "aspects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 790,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L790"
    },
    {
      id: "Metric.trackDurationWith",
      name: "trackDurationWith",
      module: "Metric",
      package: "effect",
      signature: "{ <Type, In, Out>(metric: Metric<Type, In, Out>, f: (duration: Duration) => In): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, Type, In, Out>(self: Effect<A, E, R>, metric: Metric<Type, In, Out>, f: (duration: Duration) => In): Effect<A, E, R>; }",
      description: "Returns an aspect that will update this metric with the duration that the\neffect takes to execute. To call this method, you must supply a function\nthat can convert the `Duration` to the input type of this metric.",
      documentation: "Returns an aspect that will update this metric with the duration that the\neffect takes to execute. To call this method, you must supply a function\nthat can convert the `Duration` to the input type of this metric.",
      examples: [],
      tags: [
        "aspects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 818,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L818"
    },
    {
      id: "Metric.trackError",
      name: "trackError",
      module: "Metric",
      package: "effect",
      signature: "{ <Type, In, Out>(metric: Metric<Type, In, Out>): <A, E extends In, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E extends In, R, Type, In, Out>(self: Effect<A, E, R>, metric: Metric<Type, In, Out>): Effect<A, E, R>; }",
      description: "Returns an aspect that will update this metric with the failure value of\nthe effects that it is applied to.",
      documentation: "Returns an aspect that will update this metric with the failure value of\nthe effects that it is applied to.",
      examples: [],
      tags: [
        "aspects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 845,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L845"
    },
    {
      id: "Metric.trackErrorWith",
      name: "trackErrorWith",
      module: "Metric",
      package: "effect",
      signature: "{ <Type, In, Out, In2>(metric: Metric<Type, In, Out>, f: (error: In2) => In): <A, E extends In2, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E extends In2, R, Type, In, Out, In2>(self: Effect<A, E, R>, metric: Metric<Type, In, Out>, f: (error: In2) => In): Effect<A, E, R>; }",
      description: "Returns an aspect that will update this metric with the result of applying\nthe specified function to the error value of the effects that the aspect is\napplied to.",
      documentation: "Returns an aspect that will update this metric with the result of applying\nthe specified function to the error value of the effects that the aspect is\napplied to.",
      examples: [],
      tags: [
        "aspects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 871,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L871"
    },
    {
      id: "Metric.trackSuccess",
      name: "trackSuccess",
      module: "Metric",
      package: "effect",
      signature: "{ <Type, In, Out>(metric: Metric<Type, In, Out>): <A extends In, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A extends In, E, R, Type, In, Out>(self: Effect<A, E, R>, metric: Metric<Type, In, Out>): Effect<A, E, R>; }",
      description: "Returns an aspect that will update this metric with the success value of\nthe effects that it is applied to.",
      documentation: "Returns an aspect that will update this metric with the success value of\nthe effects that it is applied to.",
      examples: [],
      tags: [
        "aspects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 898,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L898"
    },
    {
      id: "Metric.trackSuccessWith",
      name: "trackSuccessWith",
      module: "Metric",
      package: "effect",
      signature: "{ <Type, In, Out, A>(metric: Metric<Type, In, Out>, f: (value: NoInfer<A>) => In): <E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, Type, In, Out>(self: Effect<A, E, R>, metric: Metric<Type, In, Out>, f: (value: NoInfer<A>) => In): Effect<A, E, R>; }",
      description: "Returns an aspect that will update this metric with the result of applying\nthe specified function to the success value of the effects that the aspect is\napplied to.",
      documentation: "Returns an aspect that will update this metric with the result of applying\nthe specified function to the success value of the effects that the aspect is\napplied to.",
      examples: [],
      tags: [
        "aspects"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 924,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L924"
    },
    {
      id: "Metric.update",
      name: "update",
      module: "Metric",
      package: "effect",
      signature: "{ <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Effect<void, never, never>; <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Effect<void, never, never>; }",
      description: "Updates the metric with the specified update message. For example, if the\nmetric were a counter, the update would increment the method by the\nprovided amount.",
      documentation: "Updates the metric with the specified update message. For example, if the\nmetric were a counter, the update would increment the method by the\nprovided amount.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 952,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L952"
    },
    {
      id: "Metric.value",
      name: "value",
      module: "Metric",
      package: "effect",
      signature: "<Type, In, Out>(self: Metric<Type, In, Out>) => Effect<Out, never, never>",
      description: "Retrieves a snapshot of the value of the metric at this moment in time.",
      documentation: "Retrieves a snapshot of the value of the metric at this moment in time.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 978,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L978"
    },
    {
      id: "Metric.withNow",
      name: "withNow",
      module: "Metric",
      package: "effect",
      signature: "<Type, In, Out>(self: Metric<Type, readonly [In, number], Out>) => Metric<Type, In, Out>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 983,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L983"
    },
    {
      id: "Metric.zip",
      name: "zip",
      module: "Metric",
      package: "effect",
      signature: "{ <Type2, In2, Out2>(that: Metric<Type2, In2, Out2>): <Type, In, Out>(self: Metric<Type, In, Out>) => Metric<readonly [Type, Type2], readonly [In, In2], [Out, Out2]>; <Type, In, Out, Type2, In2, Out2>(self: Metric<Type, In, Out>, that: Metric<Type2, In2, Out2>): Metric<readonly [Type, Type2], readonly [In, In2], [Out, Out2]>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 988,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L988"
    },
    {
      id: "Metric.unsafeSnapshot",
      name: "unsafeSnapshot",
      module: "Metric",
      package: "effect",
      signature: "(_: void) => readonly MetricPair.Untyped[]",
      description: "Unsafely captures a snapshot of all metrics recorded by the application.",
      documentation: "Unsafely captures a snapshot of all metrics recorded by the application.",
      examples: [],
      tags: [
        "unsafe"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 1016,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L1016"
    },
    {
      id: "Metric.fiberStarted",
      name: "fiberStarted",
      module: "Metric",
      package: "effect",
      signature: "Metric.Counter<number>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "metrics"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 1021,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L1021"
    },
    {
      id: "Metric.fiberSuccesses",
      name: "fiberSuccesses",
      module: "Metric",
      package: "effect",
      signature: "Metric.Counter<number>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "metrics"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 1026,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L1026"
    },
    {
      id: "Metric.fiberFailures",
      name: "fiberFailures",
      module: "Metric",
      package: "effect",
      signature: "Metric.Counter<number>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "metrics"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 1031,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L1031"
    },
    {
      id: "Metric.fiberLifetimes",
      name: "fiberLifetimes",
      module: "Metric",
      package: "effect",
      signature: "Metric<MetricKeyType.Histogram, number, MetricState.Histogram>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "metrics"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 1036,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L1036"
    },
    {
      id: "Metric.fiberActive",
      name: "fiberActive",
      module: "Metric",
      package: "effect",
      signature: "Metric.Counter<number>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "metrics"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Metric.d.ts",
      sourceLine: 1041,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Metric.ts#L1041"
    },
    {
      id: "Resource.ResourceTypeId",
      name: "ResourceTypeId",
      module: "Resource",
      package: "effect",
      signature: "typeof ResourceTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Resource.d.ts",
      sourceLine: 13,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Resource.ts#L13"
    },
    {
      id: "Resource.auto",
      name: "auto",
      module: "Resource",
      package: "effect",
      signature: "<A, E, R, Out, R2>(acquire: Effect<A, E, R>, policy: Schedule<Out, unknown, R2>) => Effect<Resource<A, E>, never, R | R2 | Scope>",
      description: "Creates a new `Resource` value that is automatically refreshed according to\nthe specified policy. Note that error retrying is not performed\nautomatically, so if you want to retry on errors, you should first apply\nretry policies to the acquisition effect before passing it to this\nconstructor.",
      documentation: "Creates a new `Resource` value that is automatically refreshed according to\nthe specified policy. Note that error retrying is not performed\nautomatically, so if you want to retry on errors, you should first apply\nretry policies to the acquisition effect before passing it to this\nconstructor.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Resource.d.ts",
      sourceLine: 72,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Resource.ts#L72"
    },
    {
      id: "Resource.get",
      name: "get",
      module: "Resource",
      package: "effect",
      signature: "<A, E>(self: Resource<A, E>) => Effect<A, E, never>",
      description: "Retrieves the current value stored in the cache.",
      documentation: "Retrieves the current value stored in the cache.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Resource.d.ts",
      sourceLine: 79,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Resource.ts#L79"
    },
    {
      id: "Resource.manual",
      name: "manual",
      module: "Resource",
      package: "effect",
      signature: "<A, E, R>(acquire: Effect<A, E, R>) => Effect<Resource<A, E>, never, Scope | R>",
      description: "Creates a new `Resource` value that must be manually refreshed by calling\nthe refresh method. Note that error retrying is not performed\nautomatically, so if you want to retry on errors, you should first apply\nretry policies to the acquisition effect before passing it to this\nconstructor.",
      documentation: "Creates a new `Resource` value that must be manually refreshed by calling\nthe refresh method. Note that error retrying is not performed\nautomatically, so if you want to retry on errors, you should first apply\nretry policies to the acquisition effect before passing it to this\nconstructor.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Resource.d.ts",
      sourceLine: 90,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Resource.ts#L90"
    },
    {
      id: "Resource.refresh",
      name: "refresh",
      module: "Resource",
      package: "effect",
      signature: "<A, E>(self: Resource<A, E>) => Effect<void, E, never>",
      description: "Refreshes the cache. This method will not return until either the refresh\nis successful, or the refresh operation fails.",
      documentation: "Refreshes the cache. This method will not return until either the refresh\nis successful, or the refresh operation fails.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Resource.d.ts",
      sourceLine: 98,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Resource.ts#L98"
    },
    {
      id: "Pool.PoolTypeId",
      name: "PoolTypeId",
      module: "Pool",
      package: "effect",
      signature: "typeof PoolTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Pool.d.ts",
      sourceLine: 14,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Pool.ts#L14"
    },
    {
      id: "Pool.isPool",
      name: "isPool",
      module: "Pool",
      package: "effect",
      signature: "(u: unknown) => u is Pool<unknown, unknown>",
      description: "Returns `true` if the specified value is a `Pool`, `false` otherwise.",
      documentation: "Returns `true` if the specified value is a `Pool`, `false` otherwise.",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Pool.d.ts",
      sourceLine: 82,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Pool.ts#L82"
    },
    {
      id: "Pool.make",
      name: "make",
      module: "Pool",
      package: "effect",
      signature: "<A, E, R>(options: { readonly acquire: Effect<A, E, R>; readonly size: number; readonly concurrency?: number; readonly targetUtilization?: number; }) => Effect<Pool<A, E>, never, R | Scope>",
      description: "Makes a new pool of the specified fixed size. The pool is returned in a\n`Scope`, which governs the lifetime of the pool. When the pool is shutdown\nbecause the `Scope` is closed, the individual items allocated by the pool\nwill be released in some unspecified order. By setting the `concurrency` parameter, you can control the level of concurrent\naccess per pool item. By default, the number of permits is set to `1`. `targetUtilization` determines when to create new pool items. It is a value\nbetween 0 and 1, where 1 means only create new pool items when all the existing\nitems are fully utilized. A `targetUtilization` of 0.5 will create new pool items when the existing items are\n50% utilized.",
      documentation: "Makes a new pool of the specified fixed size. The pool is returned in a\n`Scope`, which governs the lifetime of the pool. When the pool is shutdown\nbecause the `Scope` is closed, the individual items allocated by the pool\nwill be released in some unspecified order.\n\nBy setting the `concurrency` parameter, you can control the level of concurrent\naccess per pool item. By default, the number of permits is set to `1`.\n\n`targetUtilization` determines when to create new pool items. It is a value\nbetween 0 and 1, where 1 means only create new pool items when all the existing\nitems are fully utilized.\n\nA `targetUtilization` of 0.5 will create new pool items when the existing items are\n50% utilized.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Pool.d.ts",
      sourceLine: 102,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Pool.ts#L102"
    },
    {
      id: "Pool.makeWithTTL",
      name: "makeWithTTL",
      module: "Pool",
      package: "effect",
      signature: '<A, E, R>(options: { readonly acquire: Effect<A, E, R>; readonly min: number; readonly max: number; readonly concurrency?: number; readonly targetUtilization?: number; readonly timeToLive: DurationInput; readonly timeToLiveStrategy?: "creation" | "usage"; }) => Effect<Pool<A, E>, never, Scope | R>',
      description: 'Makes a new pool with the specified minimum and maximum sizes and time to\nlive before a pool whose excess items are not being used will be shrunk\ndown to the minimum size. The pool is returned in a `Scope`, which governs\nthe lifetime of the pool. When the pool is shutdown because the `Scope` is\nused, the individual items allocated by the pool will be released in some\nunspecified order. By setting the `concurrency` parameter, you can control the level of concurrent\naccess per pool item. By default, the number of permits is set to `1`. `targetUtilization` determines when to create new pool items. It is a value\nbetween 0 and 1, where 1 means only create new pool items when all the existing\nitems are fully utilized. A `targetUtilization` of 0.5 will create new pool items when the existing items are\n50% utilized. The `timeToLiveStrategy` determines how items are invalidated. If set to\n"creation", then items are invalidated based on their creation time. If set\nto "usage", then items are invalidated based on pool usage. By default, the `timeToLiveStrategy` is set to "usage".',
      documentation: 'Makes a new pool with the specified minimum and maximum sizes and time to\nlive before a pool whose excess items are not being used will be shrunk\ndown to the minimum size. The pool is returned in a `Scope`, which governs\nthe lifetime of the pool. When the pool is shutdown because the `Scope` is\nused, the individual items allocated by the pool will be released in some\nunspecified order.\n\nBy setting the `concurrency` parameter, you can control the level of concurrent\naccess per pool item. By default, the number of permits is set to `1`.\n\n`targetUtilization` determines when to create new pool items. It is a value\nbetween 0 and 1, where 1 means only create new pool items when all the existing\nitems are fully utilized.\n\nA `targetUtilization` of 0.5 will create new pool items when the existing items are\n50% utilized.\n\nThe `timeToLiveStrategy` determines how items are invalidated. If set to\n"creation", then items are invalidated based on their creation time. If set\nto "usage", then items are invalidated based on pool usage.\n\nBy default, the `timeToLiveStrategy` is set to "usage".\n\n```ts skip-type-checking\nimport { createConnection } from "mysql2";\nimport { Duration, Effect, Pool } from "effect"\n\nconst acquireDBConnection = Effect.acquireRelease(\n  Effect.sync(() => createConnection(\'mysql://...\')),\n  (connection) => Effect.sync(() => connection.end(() => {})),\n)\n\nconst connectionPool = Effect.flatMap(\n Pool.makeWithTTL({\n    acquire: acquireDBConnection,\n    min: 10,\n    max: 20,\n    timeToLive: Duration.seconds(60)\n  }),\n  (pool) => pool.get\n)\n```',
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Pool.d.ts",
      sourceLine: 155,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Pool.ts#L155"
    },
    {
      id: "Pool.get",
      name: "get",
      module: "Pool",
      package: "effect",
      signature: "<A, E>(self: Pool<A, E>) => Effect<A, E, Scope>",
      description: "Retrieves an item from the pool in a scoped effect. Note that if\nacquisition fails, then the returned effect will fail for that same reason.\nRetrying a failed acquisition attempt will repeat the acquisition attempt.",
      documentation: "Retrieves an item from the pool in a scoped effect. Note that if\nacquisition fails, then the returned effect will fail for that same reason.\nRetrying a failed acquisition attempt will repeat the acquisition attempt.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Pool.d.ts",
      sourceLine: 172,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Pool.ts#L172"
    },
    {
      id: "Pool.invalidate",
      name: "invalidate",
      module: "Pool",
      package: "effect",
      signature: "{ <A>(value: A): <E>(self: Pool<A, E>) => Effect<void, never, Scope>; <A, E>(self: Pool<A, E>, value: A): Effect<void, never, Scope>; }",
      description: "Invalidates the specified item. This will cause the pool to eventually\nreallocate the item, although this reallocation may occur lazily rather\nthan eagerly.",
      documentation: "Invalidates the specified item. This will cause the pool to eventually\nreallocate the item, although this reallocation may occur lazily rather\nthan eagerly.",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Pool.d.ts",
      sourceLine: 181,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Pool.ts#L181"
    },
    {
      id: "Cache.CacheTypeId",
      name: "CacheTypeId",
      module: "Cache",
      package: "effect",
      signature: "typeof CacheTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cache.d.ts",
      sourceLine: 15,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cache.ts#L15"
    },
    {
      id: "Cache.ConsumerCacheTypeId",
      name: "ConsumerCacheTypeId",
      module: "Cache",
      package: "effect",
      signature: "typeof ConsumerCacheTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "3.6.4",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cache.d.ts",
      sourceLine: 25,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cache.ts#L25"
    },
    {
      id: "Cache.make",
      name: "make",
      module: "Cache",
      package: "effect",
      signature: "<Key, Value, Error = never, Environment = never>(options: { readonly capacity: number; readonly timeToLive: DurationInput; readonly lookup: Lookup<Key, Value, Error, Environment>; }) => Effect<Cache<Key, Value, Error>, never, Environment>",
      description: "Constructs a new cache with the specified capacity, time to live, and\nlookup function.",
      documentation: "Constructs a new cache with the specified capacity, time to live, and\nlookup function.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cache.d.ts",
      sourceLine: 175,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cache.ts#L175"
    },
    {
      id: "Cache.makeWith",
      name: "makeWith",
      module: "Cache",
      package: "effect",
      signature: "<Key, Value, Error = never, Environment = never>(options: { readonly capacity: number; readonly lookup: Lookup<Key, Value, Error, Environment>; readonly timeToLive: (exit: Exit<Value, Error>) => DurationInput; }) => Effect<Cache<Key, Value, Error>, never, Environment>",
      description: "Constructs a new cache with the specified capacity, time to live, and\nlookup function, where the time to live can depend on the `Exit` value\nreturned by the lookup function.",
      documentation: "Constructs a new cache with the specified capacity, time to live, and\nlookup function, where the time to live can depend on the `Exit` value\nreturned by the lookup function.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cache.d.ts",
      sourceLine: 188,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cache.ts#L188"
    },
    {
      id: "Cache.makeCacheStats",
      name: "makeCacheStats",
      module: "Cache",
      package: "effect",
      signature: "(options: { readonly hits: number; readonly misses: number; readonly size: number; }) => CacheStats",
      description: "Constructs a new `CacheStats` from the specified values.",
      documentation: "Constructs a new `CacheStats` from the specified values.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cache.d.ts",
      sourceLine: 211,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cache.ts#L211"
    },
    {
      id: "Cache.makeEntryStats",
      name: "makeEntryStats",
      module: "Cache",
      package: "effect",
      signature: "(loadedMillis: number) => EntryStats",
      description: "Constructs a new `EntryStats` from the specified values.",
      documentation: "Constructs a new `EntryStats` from the specified values.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Cache.d.ts",
      sourceLine: 231,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cache.ts#L231"
    },
    {
      id: "Deferred.DeferredTypeId",
      name: "DeferredTypeId",
      module: "Deferred",
      package: "effect",
      signature: "typeof DeferredTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Deferred.d.ts",
      sourceLine: 16,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Deferred.ts#L16"
    },
    {
      id: "Deferred.make",
      name: "make",
      module: "Deferred",
      package: "effect",
      signature: "<A, E = never>() => Effect<Deferred<A, E>, never, never>",
      description: "Creates a new `Deferred`.",
      documentation: "Creates a new `Deferred`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Deferred.d.ts",
      sourceLine: 76,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Deferred.ts#L76"
    },
    {
      id: "Deferred.makeAs",
      name: "makeAs",
      module: "Deferred",
      package: "effect",
      signature: "<A, E = never>(fiberId: FiberId) => Effect<Deferred<A, E>, never, never>",
      description: "Creates a new `Deferred` from the specified `FiberId`.",
      documentation: "Creates a new `Deferred` from the specified `FiberId`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Deferred.d.ts",
      sourceLine: 83,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Deferred.ts#L83"
    },
    {
      id: "Deferred.complete",
      name: "complete",
      module: "Deferred",
      package: "effect",
      signature: "{ <A, E>(effect: Effect<A, E, never>): (self: Deferred<A, E>) => Effect<boolean, never, never>; <A, E>(self: Deferred<A, E>, effect: Effect<A, E, never>): Effect<boolean, never, never>; }",
      description: "Completes the deferred with the result of the specified effect. If the\ndeferred has already been completed, the method will produce false. Note that `Deferred.completeWith` will be much faster, so consider using\nthat if you do not need to memoize the result of the specified effect.",
      documentation: "Completes the deferred with the result of the specified effect. If the\ndeferred has already been completed, the method will produce false.\n\nNote that `Deferred.completeWith` will be much faster, so consider using\nthat if you do not need to memoize the result of the specified effect.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Deferred.d.ts",
      sourceLine: 104,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Deferred.ts#L104"
    },
    {
      id: "Deferred.completeWith",
      name: "completeWith",
      module: "Deferred",
      package: "effect",
      signature: "{ <A, E>(effect: Effect<A, E, never>): (self: Deferred<A, E>) => Effect<boolean, never, never>; <A, E>(self: Deferred<A, E>, effect: Effect<A, E, never>): Effect<boolean, never, never>; }",
      description: "Completes the deferred with the result of the specified effect. If the\ndeferred has already been completed, the method will produce false.",
      documentation: "Completes the deferred with the result of the specified effect. If the\ndeferred has already been completed, the method will produce false.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Deferred.d.ts",
      sourceLine: 135,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Deferred.ts#L135"
    },
    {
      id: "Deferred.done",
      name: "done",
      module: "Deferred",
      package: "effect",
      signature: "{ <A, E>(exit: Exit<A, E>): (self: Deferred<A, E>) => Effect<boolean, never, never>; <A, E>(self: Deferred<A, E>, exit: Exit<A, E>): Effect<boolean, never, never>; }",
      description: "Exits the `Deferred` with the specified `Exit` value, which will be\npropagated to all fibers waiting on the value of the `Deferred`.",
      documentation: "Exits the `Deferred` with the specified `Exit` value, which will be\npropagated to all fibers waiting on the value of the `Deferred`.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Deferred.d.ts",
      sourceLine: 160,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Deferred.ts#L160"
    },
    {
      id: "Deferred.fail",
      name: "fail",
      module: "Deferred",
      package: "effect",
      signature: "{ <E>(error: E): <A>(self: Deferred<A, E>) => Effect<boolean, never, never>; <A, E>(self: Deferred<A, E>, error: E): Effect<boolean, never, never>; }",
      description: "Fails the `Deferred` with the specified error, which will be propagated to\nall fibers waiting on the value of the `Deferred`.",
      documentation: "Fails the `Deferred` with the specified error, which will be propagated to\nall fibers waiting on the value of the `Deferred`.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Deferred.d.ts",
      sourceLine: 185,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Deferred.ts#L185"
    },
    {
      id: "Deferred.failSync",
      name: "failSync",
      module: "Deferred",
      package: "effect",
      signature: "{ <E>(evaluate: LazyArg<E>): <A>(self: Deferred<A, E>) => Effect<boolean, never, never>; <A, E>(self: Deferred<A, E>, evaluate: LazyArg<E>): Effect<boolean, never, never>; }",
      description: "Fails the `Deferred` with the specified error, which will be propagated to\nall fibers waiting on the value of the `Deferred`.",
      documentation: "Fails the `Deferred` with the specified error, which will be propagated to\nall fibers waiting on the value of the `Deferred`.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Deferred.d.ts",
      sourceLine: 210,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Deferred.ts#L210"
    },
    {
      id: "Deferred.failCause",
      name: "failCause",
      module: "Deferred",
      package: "effect",
      signature: "{ <E>(cause: Cause<E>): <A>(self: Deferred<A, E>) => Effect<boolean, never, never>; <A, E>(self: Deferred<A, E>, cause: Cause<E>): Effect<boolean, never, never>; }",
      description: "Fails the `Deferred` with the specified `Cause`, which will be propagated to\nall fibers waiting on the value of the `Deferred`.",
      documentation: "Fails the `Deferred` with the specified `Cause`, which will be propagated to\nall fibers waiting on the value of the `Deferred`.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Deferred.d.ts",
      sourceLine: 235,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Deferred.ts#L235"
    },
    {
      id: "Deferred.failCauseSync",
      name: "failCauseSync",
      module: "Deferred",
      package: "effect",
      signature: "{ <E>(evaluate: LazyArg<Cause<E>>): <A>(self: Deferred<A, E>) => Effect<boolean, never, never>; <A, E>(self: Deferred<A, E>, evaluate: LazyArg<Cause<E>>): Effect<boolean, never, never>; }",
      description: "Fails the `Deferred` with the specified `Cause`, which will be propagated to\nall fibers waiting on the value of the `Deferred`.",
      documentation: "Fails the `Deferred` with the specified `Cause`, which will be propagated to\nall fibers waiting on the value of the `Deferred`.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Deferred.d.ts",
      sourceLine: 260,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Deferred.ts#L260"
    },
    {
      id: "Deferred.die",
      name: "die",
      module: "Deferred",
      package: "effect",
      signature: "{ (defect: unknown): <A, E>(self: Deferred<A, E>) => Effect<boolean, never, never>; <A, E>(self: Deferred<A, E>, defect: unknown): Effect<boolean, never, never>; }",
      description: "Kills the `Deferred` with the specified defect, which will be propagated to\nall fibers waiting on the value of the `Deferred`.",
      documentation: "Kills the `Deferred` with the specified defect, which will be propagated to\nall fibers waiting on the value of the `Deferred`.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Deferred.d.ts",
      sourceLine: 285,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Deferred.ts#L285"
    },
    {
      id: "Deferred.dieSync",
      name: "dieSync",
      module: "Deferred",
      package: "effect",
      signature: "{ (evaluate: LazyArg<unknown>): <A, E>(self: Deferred<A, E>) => Effect<boolean, never, never>; <A, E>(self: Deferred<A, E>, evaluate: LazyArg<unknown>): Effect<boolean, never, never>; }",
      description: "Kills the `Deferred` with the specified defect, which will be propagated to\nall fibers waiting on the value of the `Deferred`.",
      documentation: "Kills the `Deferred` with the specified defect, which will be propagated to\nall fibers waiting on the value of the `Deferred`.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Deferred.d.ts",
      sourceLine: 310,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Deferred.ts#L310"
    },
    {
      id: "Deferred.interrupt",
      name: "interrupt",
      module: "Deferred",
      package: "effect",
      signature: "<A, E>(self: Deferred<A, E>) => Effect<boolean, never, never>",
      description: "Completes the `Deferred` with interruption. This will interrupt all fibers\nwaiting on the value of the `Deferred` with the `FiberId` of the fiber\ncalling this method.",
      documentation: "Completes the `Deferred` with interruption. This will interrupt all fibers\nwaiting on the value of the `Deferred` with the `FiberId` of the fiber\ncalling this method.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Deferred.d.ts",
      sourceLine: 336,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Deferred.ts#L336"
    },
    {
      id: "Deferred.interruptWith",
      name: "interruptWith",
      module: "Deferred",
      package: "effect",
      signature: "{ (fiberId: FiberId): <A, E>(self: Deferred<A, E>) => Effect<boolean, never, never>; <A, E>(self: Deferred<A, E>, fiberId: FiberId): Effect<boolean, never, never>; }",
      description: "Completes the `Deferred` with interruption. This will interrupt all fibers\nwaiting on the value of the `Deferred` with the specified `FiberId`.",
      documentation: "Completes the `Deferred` with interruption. This will interrupt all fibers\nwaiting on the value of the `Deferred` with the specified `FiberId`.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Deferred.d.ts",
      sourceLine: 344,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Deferred.ts#L344"
    },
    {
      id: "Deferred.isDone",
      name: "isDone",
      module: "Deferred",
      package: "effect",
      signature: "<A, E>(self: Deferred<A, E>) => Effect<boolean, never, never>",
      description: "Returns `true` if this `Deferred` has already been completed with a value or\nan error, `false` otherwise.",
      documentation: "Returns `true` if this `Deferred` has already been completed with a value or\nan error, `false` otherwise.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Deferred.d.ts",
      sourceLine: 369,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Deferred.ts#L369"
    },
    {
      id: "Deferred.poll",
      name: "poll",
      module: "Deferred",
      package: "effect",
      signature: "<A, E>(self: Deferred<A, E>) => Effect<Option<Effect<A, E, never>>, never, never>",
      description: "Returns a `Some<Effect<A, E, R>>` from the `Deferred` if this `Deferred` has\nalready been completed, `None` otherwise.",
      documentation: "Returns a `Some<Effect<A, E, R>>` from the `Deferred` if this `Deferred` has\nalready been completed, `None` otherwise.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Deferred.d.ts",
      sourceLine: 377,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Deferred.ts#L377"
    },
    {
      id: "Deferred.succeed",
      name: "succeed",
      module: "Deferred",
      package: "effect",
      signature: "{ <A>(value: A): <E>(self: Deferred<A, E>) => Effect<boolean, never, never>; <A, E>(self: Deferred<A, E>, value: A): Effect<boolean, never, never>; }",
      description: "Completes the `Deferred` with the specified value.",
      documentation: "Completes the `Deferred` with the specified value.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Deferred.d.ts",
      sourceLine: 384,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Deferred.ts#L384"
    },
    {
      id: "Deferred.sync",
      name: "sync",
      module: "Deferred",
      package: "effect",
      signature: "{ <A>(evaluate: LazyArg<A>): <E>(self: Deferred<A, E>) => Effect<boolean, never, never>; <A, E>(self: Deferred<A, E>, evaluate: LazyArg<A>): Effect<boolean, never, never>; }",
      description: "Completes the `Deferred` with the specified lazily evaluated value.",
      documentation: "Completes the `Deferred` with the specified lazily evaluated value.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Deferred.d.ts",
      sourceLine: 406,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Deferred.ts#L406"
    },
    {
      id: "Deferred.unsafeMake",
      name: "unsafeMake",
      module: "Deferred",
      package: "effect",
      signature: "<A, E = never>(fiberId: FiberId) => Deferred<A, E>",
      description: "Unsafely creates a new `Deferred` from the specified `FiberId`.",
      documentation: "Unsafely creates a new `Deferred` from the specified `FiberId`.",
      examples: [],
      tags: [
        "unsafe"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Deferred.d.ts",
      sourceLine: 428,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Deferred.ts#L428"
    },
    {
      id: "Deferred.unsafeDone",
      name: "unsafeDone",
      module: "Deferred",
      package: "effect",
      signature: "<A, E>(self: Deferred<A, E>, effect: Effect<A, E, never>) => void",
      description: "Unsafely exits the `Deferred` with the specified `Exit` value, which will be\npropagated to all fibers waiting on the value of the `Deferred`.",
      documentation: "Unsafely exits the `Deferred` with the specified `Exit` value, which will be\npropagated to all fibers waiting on the value of the `Deferred`.",
      examples: [],
      tags: [
        "unsafe"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Deferred.d.ts",
      sourceLine: 436,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Deferred.ts#L436"
    },
    {
      id: "PubSub.bounded",
      name: "bounded",
      module: "PubSub",
      package: "effect",
      signature: "<A>(capacity: number | { readonly capacity: number; readonly replay?: number; }) => Effect<PubSub<A>, never, never>",
      description: "Creates a bounded `PubSub` with the back pressure strategy. The `PubSub` will retain\nmessages until they have been taken by all subscribers, applying back\npressure to publishers if the `PubSub` is at capacity. For best performance use capacities that are powers of two.",
      documentation: "Creates a bounded `PubSub` with the back pressure strategy. The `PubSub` will retain\nmessages until they have been taken by all subscribers, applying back\npressure to publishers if the `PubSub` is at capacity.\n\nFor best performance use capacities that are powers of two.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/PubSub.d.ts",
      sourceLine: 44,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/PubSub.ts#L44"
    },
    {
      id: "PubSub.dropping",
      name: "dropping",
      module: "PubSub",
      package: "effect",
      signature: "<A>(capacity: number | { readonly capacity: number; readonly replay?: number; }) => Effect<PubSub<A>, never, never>",
      description: "Creates a bounded `PubSub` with the dropping strategy. The `PubSub` will drop new\nmessages if the `PubSub` is at capacity. For best performance use capacities that are powers of two.",
      documentation: "Creates a bounded `PubSub` with the dropping strategy. The `PubSub` will drop new\nmessages if the `PubSub` is at capacity.\n\nFor best performance use capacities that are powers of two.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/PubSub.d.ts",
      sourceLine: 57,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/PubSub.ts#L57"
    },
    {
      id: "PubSub.sliding",
      name: "sliding",
      module: "PubSub",
      package: "effect",
      signature: "<A>(capacity: number | { readonly capacity: number; readonly replay?: number; }) => Effect<PubSub<A>, never, never>",
      description: "Creates a bounded `PubSub` with the sliding strategy. The `PubSub` will add new\nmessages and drop old messages if the `PubSub` is at capacity. For best performance use capacities that are powers of two.",
      documentation: "Creates a bounded `PubSub` with the sliding strategy. The `PubSub` will add new\nmessages and drop old messages if the `PubSub` is at capacity.\n\nFor best performance use capacities that are powers of two.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/PubSub.d.ts",
      sourceLine: 70,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/PubSub.ts#L70"
    },
    {
      id: "PubSub.unbounded",
      name: "unbounded",
      module: "PubSub",
      package: "effect",
      signature: "<A>(options?: { readonly replay?: number; }) => Effect<PubSub<A>, never, never>",
      description: "Creates an unbounded `PubSub`.",
      documentation: "Creates an unbounded `PubSub`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/PubSub.d.ts",
      sourceLine: 80,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/PubSub.ts#L80"
    },
    {
      id: "PubSub.capacity",
      name: "capacity",
      module: "PubSub",
      package: "effect",
      signature: "<A>(self: PubSub<A>) => number",
      description: "Returns the number of elements the queue can hold.",
      documentation: "Returns the number of elements the queue can hold.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/PubSub.d.ts",
      sourceLine: 89,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/PubSub.ts#L89"
    },
    {
      id: "PubSub.size",
      name: "size",
      module: "PubSub",
      package: "effect",
      signature: "<A>(self: PubSub<A>) => Effect<number, never, never>",
      description: "Retrieves the size of the queue, which is equal to the number of elements\nin the queue. This may be negative if fibers are suspended waiting for\nelements to be added to the queue.",
      documentation: "Retrieves the size of the queue, which is equal to the number of elements\nin the queue. This may be negative if fibers are suspended waiting for\nelements to be added to the queue.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/PubSub.d.ts",
      sourceLine: 98,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/PubSub.ts#L98"
    },
    {
      id: "PubSub.isFull",
      name: "isFull",
      module: "PubSub",
      package: "effect",
      signature: "<A>(self: PubSub<A>) => Effect<boolean, never, never>",
      description: "Returns `true` if the `Queue` contains at least one element, `false`\notherwise.",
      documentation: "Returns `true` if the `Queue` contains at least one element, `false`\notherwise.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/PubSub.d.ts",
      sourceLine: 106,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/PubSub.ts#L106"
    },
    {
      id: "PubSub.isEmpty",
      name: "isEmpty",
      module: "PubSub",
      package: "effect",
      signature: "<A>(self: PubSub<A>) => Effect<boolean, never, never>",
      description: "Returns `true` if the `Queue` contains zero elements, `false` otherwise.",
      documentation: "Returns `true` if the `Queue` contains zero elements, `false` otherwise.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/PubSub.d.ts",
      sourceLine: 113,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/PubSub.ts#L113"
    },
    {
      id: "PubSub.shutdown",
      name: "shutdown",
      module: "PubSub",
      package: "effect",
      signature: "<A>(self: PubSub<A>) => Effect<void, never, never>",
      description: "Interrupts any fibers that are suspended on `offer` or `take`. Future calls\nto `offer*` and `take*` will be interrupted immediately.",
      documentation: "Interrupts any fibers that are suspended on `offer` or `take`. Future calls\nto `offer*` and `take*` will be interrupted immediately.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/PubSub.d.ts",
      sourceLine: 121,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/PubSub.ts#L121"
    },
    {
      id: "PubSub.isShutdown",
      name: "isShutdown",
      module: "PubSub",
      package: "effect",
      signature: "<A>(self: PubSub<A>) => Effect<boolean, never, never>",
      description: "Returns `true` if `shutdown` has been called, otherwise returns `false`.",
      documentation: "Returns `true` if `shutdown` has been called, otherwise returns `false`.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/PubSub.d.ts",
      sourceLine: 128,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/PubSub.ts#L128"
    },
    {
      id: "PubSub.awaitShutdown",
      name: "awaitShutdown",
      module: "PubSub",
      package: "effect",
      signature: "<A>(self: PubSub<A>) => Effect<void, never, never>",
      description: "Waits until the queue is shutdown. The `Effect` returned by this method will\nnot resume until the queue has been shutdown. If the queue is already\nshutdown, the `Effect` will resume right away.",
      documentation: "Waits until the queue is shutdown. The `Effect` returned by this method will\nnot resume until the queue has been shutdown. If the queue is already\nshutdown, the `Effect` will resume right away.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/PubSub.d.ts",
      sourceLine: 137,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/PubSub.ts#L137"
    },
    {
      id: "PubSub.publish",
      name: "publish",
      module: "PubSub",
      package: "effect",
      signature: "{ <A>(value: A): (self: PubSub<A>) => Effect<boolean, never, never>; <A>(self: PubSub<A>, value: A): Effect<boolean, never, never>; }",
      description: "Publishes a message to the `PubSub`, returning whether the message was published\nto the `PubSub`.",
      documentation: "Publishes a message to the `PubSub`, returning whether the message was published\nto the `PubSub`.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/PubSub.d.ts",
      sourceLine: 145,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/PubSub.ts#L145"
    },
    {
      id: "PubSub.publishAll",
      name: "publishAll",
      module: "PubSub",
      package: "effect",
      signature: "{ <A>(elements: Iterable<A>): (self: PubSub<A>) => Effect<boolean, never, never>; <A>(self: PubSub<A>, elements: Iterable<A>): Effect<boolean, never, never>; }",
      description: "Publishes all of the specified messages to the `PubSub`, returning whether they\nwere published to the `PubSub`.",
      documentation: "Publishes all of the specified messages to the `PubSub`, returning whether they\nwere published to the `PubSub`.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/PubSub.d.ts",
      sourceLine: 170,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/PubSub.ts#L170"
    },
    {
      id: "PubSub.subscribe",
      name: "subscribe",
      module: "PubSub",
      package: "effect",
      signature: "<A>(self: PubSub<A>) => Effect<Dequeue<A>, never, Scope>",
      description: "Subscribes to receive messages from the `PubSub`. The resulting subscription can\nbe evaluated multiple times within the scope to take a message from the `PubSub`\neach time.",
      documentation: "Subscribes to receive messages from the `PubSub`. The resulting subscription can\nbe evaluated multiple times within the scope to take a message from the `PubSub`\neach time.",
      examples: [],
      tags: [
        "utils"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/PubSub.d.ts",
      sourceLine: 196,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/PubSub.ts#L196"
    },
    {
      id: "Chunk.getEquivalence",
      name: "getEquivalence",
      module: "Chunk",
      package: "effect",
      signature: "<A>(isEquivalent: Equivalence<A>) => Equivalence<Chunk<A>>",
      description: "Compares the two chunks of equal length using the specified function",
      documentation: "Compares the two chunks of equal length using the specified function",
      examples: [],
      tags: [
        "equivalence"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 52,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L52"
    },
    {
      id: "Chunk.isChunk",
      name: "isChunk",
      module: "Chunk",
      package: "effect",
      signature: "{ <A>(u: Iterable<A>): u is Chunk<A>; (u: unknown): u is Chunk<unknown>; }",
      description: "Checks if `u` is a `Chunk<unknown>`",
      documentation: "Checks if `u` is a `Chunk<unknown>`",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 59,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L59"
    },
    {
      id: "Chunk.empty",
      name: "empty",
      module: "Chunk",
      package: "effect",
      signature: "<A = never>() => Chunk<A>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 79,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L79"
    },
    {
      id: "Chunk.make",
      name: "make",
      module: "Chunk",
      package: "effect",
      signature: "<As extends readonly [any, ...ReadonlyArray<any>]>(...as: As) => NonEmptyChunk<As[number]>",
      description: "Builds a `NonEmptyChunk` from an non-empty collection of elements.",
      documentation: "Builds a `NonEmptyChunk` from an non-empty collection of elements.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 86,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L86"
    },
    {
      id: "Chunk.of",
      name: "of",
      module: "Chunk",
      package: "effect",
      signature: "<A>(a: A) => NonEmptyChunk<A>",
      description: "Builds a `NonEmptyChunk` from a single element.",
      documentation: "Builds a `NonEmptyChunk` from a single element.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 93,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L93"
    },
    {
      id: "Chunk.fromIterable",
      name: "fromIterable",
      module: "Chunk",
      package: "effect",
      signature: "<A>(self: Iterable<A>) => Chunk<A>",
      description: "Creates a new `Chunk` from an iterable collection of values.",
      documentation: "Creates a new `Chunk` from an iterable collection of values.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 100,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L100"
    },
    {
      id: "Chunk.toArray",
      name: "toArray",
      module: "Chunk",
      package: "effect",
      signature: "<S extends Chunk<any>>(self: S) => S extends NonEmptyChunk<any> ? [Chunk.Infer<S>, ...Chunk.Infer<S>[]] : Chunk.Infer<S>[]",
      description: "Converts a `Chunk` into an `Array`. If the provided `Chunk` is non-empty\n(`NonEmptyChunk`), the function will return a `NonEmptyArray`, ensuring the\nnon-empty property is preserved.",
      documentation: "Converts a `Chunk` into an `Array`. If the provided `Chunk` is non-empty\n(`NonEmptyChunk`), the function will return a `NonEmptyArray`, ensuring the\nnon-empty property is preserved.",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 109,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L109"
    },
    {
      id: "Chunk.toReadonlyArray",
      name: "toReadonlyArray",
      module: "Chunk",
      package: "effect",
      signature: "<S extends Chunk<any>>(self: S) => S extends NonEmptyChunk<any> ? readonly [Chunk.Infer<S>, ...Chunk.Infer<S>[]] : readonly Chunk.Infer<S>[]",
      description: "Converts a `Chunk` into a `ReadonlyArray`. If the provided `Chunk` is\nnon-empty (`NonEmptyChunk`), the function will return a\n`NonEmptyReadonlyArray`, ensuring the non-empty property is preserved.",
      documentation: "Converts a `Chunk` into a `ReadonlyArray`. If the provided `Chunk` is\nnon-empty (`NonEmptyChunk`), the function will return a\n`NonEmptyReadonlyArray`, ensuring the non-empty property is preserved.",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 118,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L118"
    },
    {
      id: "Chunk.reverse",
      name: "reverse",
      module: "Chunk",
      package: "effect",
      signature: "<S extends Chunk<any>>(self: S) => Chunk.With<S, Chunk.Infer<S>>",
      description: "Reverses the order of elements in a `Chunk`.\nImportantly, if the input chunk is a `NonEmptyChunk`, the reversed chunk will also be a `NonEmptyChunk`.",
      documentation: "Reverses the order of elements in a `Chunk`.\nImportantly, if the input chunk is a `NonEmptyChunk`, the reversed chunk will also be a `NonEmptyChunk`.\n\n**Example**\n\n```ts\nimport { Chunk } from \"effect\"\n\nconst chunk = Chunk.make(1, 2, 3)\nconst result = Chunk.reverse(chunk)\n\nconsole.log(result)\n// { _id: 'Chunk', values: [ 3, 2, 1 ] }\n```",
      examples: [
        {
          code: `import { Chunk } from "effect"

const chunk = Chunk.make(1, 2, 3)
const result = Chunk.reverse(chunk)

console.log(result)
// { _id: 'Chunk', values: [ 3, 2, 1 ] }`
        }
      ],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 138,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L138"
    },
    {
      id: "Chunk.get",
      name: "get",
      module: "Chunk",
      package: "effect",
      signature: "{ (index: number): <A>(self: Chunk<A>) => Option<A>; <A>(self: Chunk<A>, index: number): Option<A>; }",
      description: "This function provides a safe way to read a value at a particular index from a `Chunk`.",
      documentation: "This function provides a safe way to read a value at a particular index from a `Chunk`.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 145,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L145"
    },
    {
      id: "Chunk.unsafeFromArray",
      name: "unsafeFromArray",
      module: "Chunk",
      package: "effect",
      signature: "<A>(self: readonly A[]) => Chunk<A>",
      description: "Wraps an array into a chunk without copying, unsafe on mutable arrays",
      documentation: "Wraps an array into a chunk without copying, unsafe on mutable arrays",
      examples: [],
      tags: [
        "unsafe"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 167,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L167"
    },
    {
      id: "Chunk.unsafeFromNonEmptyArray",
      name: "unsafeFromNonEmptyArray",
      module: "Chunk",
      package: "effect",
      signature: "<A>(self: readonly [A, ...A[]]) => NonEmptyChunk<A>",
      description: "Wraps an array into a chunk without copying, unsafe on mutable arrays",
      documentation: "Wraps an array into a chunk without copying, unsafe on mutable arrays",
      examples: [],
      tags: [
        "unsafe"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 174,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L174"
    },
    {
      id: "Chunk.unsafeGet",
      name: "unsafeGet",
      module: "Chunk",
      package: "effect",
      signature: "{ (index: number): <A>(self: Chunk<A>) => A; <A>(self: Chunk<A>, index: number): A; }",
      description: "Gets an element unsafely, will throw on out of bounds",
      documentation: "Gets an element unsafely, will throw on out of bounds",
      examples: [],
      tags: [
        "unsafe"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 181,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L181"
    },
    {
      id: "Chunk.append",
      name: "append",
      module: "Chunk",
      package: "effect",
      signature: "{ <A2>(a: A2): <A>(self: Chunk<A>) => NonEmptyChunk<A2 | A>; <A, A2>(self: Chunk<A>, a: A2): NonEmptyChunk<A | A2>; }",
      description: "Appends the specified element to the end of the `Chunk`.",
      documentation: "Appends the specified element to the end of the `Chunk`.",
      examples: [],
      tags: [
        "concatenating"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 203,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L203"
    },
    {
      id: "Chunk.prepend",
      name: "prepend",
      module: "Chunk",
      package: "effect",
      signature: "{ <B>(elem: B): <A>(self: Chunk<A>) => NonEmptyChunk<B | A>; <A, B>(self: Chunk<A>, elem: B): NonEmptyChunk<A | B>; }",
      description: "Prepend an element to the front of a `Chunk`, creating a new `NonEmptyChunk`.",
      documentation: "Prepend an element to the front of a `Chunk`, creating a new `NonEmptyChunk`.",
      examples: [],
      tags: [
        "concatenating"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 225,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L225"
    },
    {
      id: "Chunk.take",
      name: "take",
      module: "Chunk",
      package: "effect",
      signature: "{ (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A>; }",
      description: "Takes the first up to `n` elements from the chunk",
      documentation: "Takes the first up to `n` elements from the chunk",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 246,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L246"
    },
    {
      id: "Chunk.drop",
      name: "drop",
      module: "Chunk",
      package: "effect",
      signature: "{ (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A>; }",
      description: "Drops the first up to `n` elements from the chunk",
      documentation: "Drops the first up to `n` elements from the chunk",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 265,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L265"
    },
    {
      id: "Chunk.dropRight",
      name: "dropRight",
      module: "Chunk",
      package: "effect",
      signature: "{ (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A>; }",
      description: "Drops the last `n` elements.",
      documentation: "Drops the last `n` elements.",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 284,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L284"
    },
    {
      id: "Chunk.dropWhile",
      name: "dropWhile",
      module: "Chunk",
      package: "effect",
      signature: "{ <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>; }",
      description: "Drops all elements so long as the predicate returns true.",
      documentation: "Drops all elements so long as the predicate returns true.",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 303,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L303"
    },
    {
      id: "Chunk.prependAll",
      name: "prependAll",
      module: "Chunk",
      package: "effect",
      signature: "{ <S extends Chunk<any>, T extends Chunk<any>>(that: T): (self: S) => Chunk.OrNonEmpty<S, T, Chunk.Infer<S> | Chunk.Infer<T>>; <A, B>(self: Chunk<A>, that: NonEmptyChunk<B>): NonEmptyChunk<A | B>; <A, B>(self: NonEmptyChunk<A>, that: Chunk<B>): NonEmptyChunk<A | B>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>; }",
      description: "Prepends the specified prefix chunk to the beginning of the specified chunk.\nIf either chunk is non-empty, the result is also a non-empty chunk.",
      documentation: 'Prepends the specified prefix chunk to the beginning of the specified chunk.\nIf either chunk is non-empty, the result is also a non-empty chunk.\n\n**Example**\n\n```ts\nimport { Chunk } from "effect"\n\nconst result = Chunk.make(1, 2).pipe(Chunk.prependAll(Chunk.make("a", "b")), Chunk.toArray)\n\nconsole.log(result)\n// [ "a", "b", 1, 2 ]\n```',
      examples: [
        {
          code: 'import { Chunk } from "effect"\n\nconst result = Chunk.make(1, 2).pipe(Chunk.prependAll(Chunk.make("a", "b")), Chunk.toArray)\n\nconsole.log(result)\n// [ "a", "b", 1, 2 ]'
        }
      ],
      tags: [
        "concatenating"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 335,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L335"
    },
    {
      id: "Chunk.appendAll",
      name: "appendAll",
      module: "Chunk",
      package: "effect",
      signature: "{ <S extends Chunk<any>, T extends Chunk<any>>(that: T): (self: S) => Chunk.OrNonEmpty<S, T, Chunk.Infer<S> | Chunk.Infer<T>>; <A, B>(self: Chunk<A>, that: NonEmptyChunk<B>): NonEmptyChunk<A | B>; <A, B>(self: NonEmptyChunk<A>, that: Chunk<B>): NonEmptyChunk<A | B>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>; }",
      description: "Concatenates two chunks, combining their elements.\nIf either chunk is non-empty, the result is also a non-empty chunk.",
      documentation: 'Concatenates two chunks, combining their elements.\nIf either chunk is non-empty, the result is also a non-empty chunk.\n\n**Example**\n\n```ts\nimport { Chunk } from "effect"\n\nconst result = Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make("a", "b")), Chunk.toArray)\n\nconsole.log(result)\n// [ 1, 2, "a", "b" ]\n```',
      examples: [
        {
          code: 'import { Chunk } from "effect"\n\nconst result = Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make("a", "b")), Chunk.toArray)\n\nconsole.log(result)\n// [ 1, 2, "a", "b" ]'
        }
      ],
      tags: [
        "concatenating"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 431,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L431"
    },
    {
      id: "Chunk.filterMap",
      name: "filterMap",
      module: "Chunk",
      package: "effect",
      signature: "{ <A, B>(f: (a: A, i: number) => Option<B>): (self: Chunk<A>) => Chunk<B>; <A, B>(self: Chunk<A>, f: (a: A, i: number) => Option<B>): Chunk<B>; }",
      description: "Returns a filtered and mapped subset of the elements.",
      documentation: "Returns a filtered and mapped subset of the elements.",
      examples: [],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 515,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L515"
    },
    {
      id: "Chunk.filter",
      name: "filter",
      module: "Chunk",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Chunk<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>; <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Chunk<B>; <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>; }",
      description: "Returns a filtered and mapped subset of the elements.",
      documentation: "Returns a filtered and mapped subset of the elements.",
      examples: [],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 537,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L537"
    },
    {
      id: "Chunk.filterMapWhile",
      name: "filterMapWhile",
      module: "Chunk",
      package: "effect",
      signature: "{ <A, B>(f: (a: A) => Option<B>): (self: Chunk<A>) => Chunk<B>; <A, B>(self: Chunk<A>, f: (a: A) => Option<B>): Chunk<B>; }",
      description: "Transforms all elements of the chunk for as long as the specified function returns some value",
      documentation: "Transforms all elements of the chunk for as long as the specified function returns some value",
      examples: [],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 573,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L573"
    },
    {
      id: "Chunk.compact",
      name: "compact",
      module: "Chunk",
      package: "effect",
      signature: "<A>(self: Chunk<Option<A>>) => Chunk<A>",
      description: "Filter out optional values",
      documentation: "Filter out optional values",
      examples: [],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 595,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L595"
    },
    {
      id: "Chunk.flatMap",
      name: "flatMap",
      module: "Chunk",
      package: "effect",
      signature: "{ <S extends Chunk<any>, T extends Chunk<any>>(f: (a: Chunk.Infer<S>, i: number) => T): (self: S) => Chunk.AndNonEmpty<S, T, Chunk.Infer<T>>; <A, B>(self: NonEmptyChunk<A>, f: (a: A, i: number) => NonEmptyChunk<B>): NonEmptyChunk<B>; <A, B>(self: Chunk<A>, f: (a: A, i: number) => Chunk<B>): Chunk<B>; }",
      description: "Applies a function to each element in a chunk and returns a new chunk containing the concatenated mapped elements.",
      documentation: "Applies a function to each element in a chunk and returns a new chunk containing the concatenated mapped elements.",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 602,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L602"
    },
    {
      id: "Chunk.forEach",
      name: "forEach",
      module: "Chunk",
      package: "effect",
      signature: "{ <A, B>(f: (a: A, index: number) => B): (self: Chunk<A>) => void; <A, B>(self: Chunk<A>, f: (a: A, index: number) => B): void; }",
      description: "Iterates over each element of a `Chunk` and applies a function to it.",
      documentation: "Iterates over each element of a `Chunk` and applies a function to it.\n\n**Details**\n\nThis function processes every element of the given `Chunk`, calling the\nprovided function `f` on each element. It does not return a new value;\ninstead, it is primarily used for side effects, such as logging or\naccumulating data in an external variable.",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 638,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L638"
    },
    {
      id: "Chunk.flatten",
      name: "flatten",
      module: "Chunk",
      package: "effect",
      signature: "<S extends Chunk<Chunk<any>>>(self: S) => Chunk.Flatten<S>",
      description: "Flattens a chunk of chunks into a single chunk by concatenating all chunks.",
      documentation: "Flattens a chunk of chunks into a single chunk by concatenating all chunks.",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 674,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L674"
    },
    {
      id: "Chunk.chunksOf",
      name: "chunksOf",
      module: "Chunk",
      package: "effect",
      signature: "{ (n: number): <A>(self: Chunk<A>) => Chunk<Chunk<A>>; <A>(self: Chunk<A>, n: number): Chunk<Chunk<A>>; }",
      description: "Groups elements in chunks of up to `n` elements.",
      documentation: "Groups elements in chunks of up to `n` elements.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 681,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L681"
    },
    {
      id: "Chunk.intersection",
      name: "intersection",
      module: "Chunk",
      package: "effect",
      signature: "{ <A>(that: Chunk<A>): <B>(self: Chunk<B>) => Chunk<A & B>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A & B>; }",
      description: "Creates a Chunk of unique values that are included in all given Chunks. The order and references of result values are determined by the Chunk.",
      documentation: "Creates a Chunk of unique values that are included in all given Chunks.\n\nThe order and references of result values are determined by the Chunk.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 705,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L705"
    },
    {
      id: "Chunk.isEmpty",
      name: "isEmpty",
      module: "Chunk",
      package: "effect",
      signature: "<A>(self: Chunk<A>) => boolean",
      description: "Determines if the chunk is empty.",
      documentation: "Determines if the chunk is empty.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 731,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L731"
    },
    {
      id: "Chunk.isNonEmpty",
      name: "isNonEmpty",
      module: "Chunk",
      package: "effect",
      signature: "<A>(self: Chunk<A>) => self is NonEmptyChunk<A>",
      description: "Determines if the chunk is not empty.",
      documentation: "Determines if the chunk is not empty.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 738,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L738"
    },
    {
      id: "Chunk.head",
      name: "head",
      module: "Chunk",
      package: "effect",
      signature: "<A>(self: Chunk<A>) => Option<A>",
      description: "Returns the first element of this chunk if it exists.",
      documentation: "Returns the first element of this chunk if it exists.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 745,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L745"
    },
    {
      id: "Chunk.unsafeHead",
      name: "unsafeHead",
      module: "Chunk",
      package: "effect",
      signature: "<A>(self: Chunk<A>) => A",
      description: "Returns the first element of this chunk. It will throw an error if the chunk is empty.",
      documentation: "Returns the first element of this chunk.\n\nIt will throw an error if the chunk is empty.",
      examples: [],
      tags: [
        "unsafe"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 754,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L754"
    },
    {
      id: "Chunk.headNonEmpty",
      name: "headNonEmpty",
      module: "Chunk",
      package: "effect",
      signature: "<A>(self: NonEmptyChunk<A>) => A",
      description: "Returns the first element of this non empty chunk.",
      documentation: "Returns the first element of this non empty chunk.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 761,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L761"
    },
    {
      id: "Chunk.last",
      name: "last",
      module: "Chunk",
      package: "effect",
      signature: "<A>(self: Chunk<A>) => Option<A>",
      description: "Returns the last element of this chunk if it exists.",
      documentation: "Returns the last element of this chunk if it exists.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 768,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L768"
    },
    {
      id: "Chunk.unsafeLast",
      name: "unsafeLast",
      module: "Chunk",
      package: "effect",
      signature: "<A>(self: Chunk<A>) => A",
      description: "Returns the last element of this chunk. It will throw an error if the chunk is empty.",
      documentation: "Returns the last element of this chunk.\n\nIt will throw an error if the chunk is empty.",
      examples: [],
      tags: [
        "unsafe"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 777,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L777"
    },
    {
      id: "Chunk.lastNonEmpty",
      name: "lastNonEmpty",
      module: "Chunk",
      package: "effect",
      signature: "<A>(self: NonEmptyChunk<A>) => A",
      description: "Returns the last element of this non empty chunk.",
      documentation: "Returns the last element of this non empty chunk.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "3.4.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 784,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L784"
    },
    {
      id: "Chunk.map",
      name: "map",
      module: "Chunk",
      package: "effect",
      signature: "{ <S extends Chunk<any>, B>(f: (a: Chunk.Infer<S>, i: number) => B): (self: S) => Chunk.With<S, B>; <A, B>(self: NonEmptyChunk<A>, f: (a: A, i: number) => B): NonEmptyChunk<B>; <A, B>(self: Chunk<A>, f: (a: A, i: number) => B): Chunk<B>; }",
      description: "Transforms the elements of a chunk using the specified mapping function.\nIf the input chunk is non-empty, the resulting chunk will also be non-empty.",
      documentation: "Transforms the elements of a chunk using the specified mapping function.\nIf the input chunk is non-empty, the resulting chunk will also be non-empty.\n\n**Example**\n\n```ts\nimport { Chunk } from \"effect\"\n\nconst result = Chunk.map(Chunk.make(1, 2), (n) => n + 1)\n\nconsole.log(result)\n// { _id: 'Chunk', values: [ 2, 3 ] }\n```",
      examples: [
        {
          code: `import { Chunk } from "effect"

const result = Chunk.map(Chunk.make(1, 2), (n) => n + 1)

console.log(result)
// { _id: 'Chunk', values: [ 2, 3 ] }`
        }
      ],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 828,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L828"
    },
    {
      id: "Chunk.mapAccum",
      name: "mapAccum",
      module: "Chunk",
      package: "effect",
      signature: "{ <S, A, B>(s: S, f: (s: S, a: A) => readonly [S, B]): (self: Chunk<A>) => [S, Chunk<B>]; <S, A, B>(self: Chunk<A>, s: S, f: (s: S, a: A) => readonly [S, B]): [S, Chunk<B>]; }",
      description: "Statefully maps over the chunk, producing new elements of type `B`.",
      documentation: "Statefully maps over the chunk, producing new elements of type `B`.",
      examples: [],
      tags: [
        "folding"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 893,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L893"
    },
    {
      id: "Chunk.partition",
      name: "partition",
      module: "Chunk",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Chunk<A>) => [excluded: Chunk<Exclude<A, B>>, satisfying: Chunk<B>]; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Chunk<A>) => [excluded: Chunk<A>, satisfying: Chunk<A>]; <A, B extends A>(self: Chunk<A>, refinement: (a: A, i: number) => a is B): [excluded: Chunk<Exclude<A, B>>, satisfying: Chunk<B>]; <A>(self: Chunk<A>, predicate: (a: A, i: number) => boolean): [excluded: Chunk<A>, satisfying: Chunk<A>]; }",
      description: "Separate elements based on a predicate that also exposes the index of the element.",
      documentation: "Separate elements based on a predicate that also exposes the index of the element.",
      examples: [],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 915,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L915"
    },
    {
      id: "Chunk.partitionMap",
      name: "partitionMap",
      module: "Chunk",
      package: "effect",
      signature: "{ <A, B, C>(f: (a: A) => Either<C, B>): (self: Chunk<A>) => [left: Chunk<B>, right: Chunk<C>]; <A, B, C>(self: Chunk<A>, f: (a: A) => Either<C, B>): [left: Chunk<B>, right: Chunk<C>]; }",
      description: "Partitions the elements of this chunk into two chunks using f.",
      documentation: "Partitions the elements of this chunk into two chunks using f.",
      examples: [],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 951,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L951"
    },
    {
      id: "Chunk.separate",
      name: "separate",
      module: "Chunk",
      package: "effect",
      signature: "<A, B>(self: Chunk<Either<B, A>>) => [Chunk<A>, Chunk<B>]",
      description: "Partitions the elements of this chunk into two chunks.",
      documentation: "Partitions the elements of this chunk into two chunks.",
      examples: [],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 973,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L973"
    },
    {
      id: "Chunk.size",
      name: "size",
      module: "Chunk",
      package: "effect",
      signature: "<A>(self: Chunk<A>) => number",
      description: "Retireves the size of the chunk",
      documentation: "Retireves the size of the chunk",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 980,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L980"
    },
    {
      id: "Chunk.sort",
      name: "sort",
      module: "Chunk",
      package: "effect",
      signature: "{ <B>(O: Order<B>): <A extends B>(self: Chunk<A>) => Chunk<A>; <A extends B, B>(self: Chunk<A>, O: Order<B>): Chunk<A>; }",
      description: "Sort the elements of a Chunk in increasing order, creating a new Chunk.",
      documentation: "Sort the elements of a Chunk in increasing order, creating a new Chunk.",
      examples: [],
      tags: [
        "sorting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 987,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L987"
    },
    {
      id: "Chunk.sortWith",
      name: "sortWith",
      module: "Chunk",
      package: "effect",
      signature: "{ <A, B>(f: (a: A) => B, order: Order<B>): (self: Chunk<A>) => Chunk<A>; <A, B>(self: Chunk<A>, f: (a: A) => B, order: Order<B>): Chunk<A>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "sorting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1007,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1007"
    },
    {
      id: "Chunk.splitAt",
      name: "splitAt",
      module: "Chunk",
      package: "effect",
      signature: "{ (n: number): <A>(self: Chunk<A>) => [beforeIndex: Chunk<A>, fromIndex: Chunk<A>]; <A>(self: Chunk<A>, n: number): [beforeIndex: Chunk<A>, fromIndex: Chunk<A>]; }",
      description: "Returns two splits of this chunk at the specified index.",
      documentation: "Returns two splits of this chunk at the specified index.",
      examples: [],
      tags: [
        "splitting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1025,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1025"
    },
    {
      id: "Chunk.splitNonEmptyAt",
      name: "splitNonEmptyAt",
      module: "Chunk",
      package: "effect",
      signature: "{ (n: number): <A>(self: NonEmptyChunk<A>) => [beforeIndex: NonEmptyChunk<A>, fromIndex: Chunk<A>]; <A>(self: NonEmptyChunk<A>, n: number): [beforeIndex: NonEmptyChunk<A>, fromIndex: Chunk<A>]; }",
      description: "Splits a `NonEmptyChunk` into two segments, with the first segment containing a maximum of `n` elements.\nThe value of `n` must be `>= 1`.",
      documentation: "Splits a `NonEmptyChunk` into two segments, with the first segment containing a maximum of `n` elements.\nThe value of `n` must be `>= 1`.",
      examples: [],
      tags: [
        "splitting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1048,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1048"
    },
    {
      id: "Chunk.split",
      name: "split",
      module: "Chunk",
      package: "effect",
      signature: "{ (n: number): <A>(self: Chunk<A>) => Chunk<Chunk<A>>; <A>(self: Chunk<A>, n: number): Chunk<Chunk<A>>; }",
      description: "Splits this chunk into `n` equally sized chunks.",
      documentation: "Splits this chunk into `n` equally sized chunks.",
      examples: [],
      tags: [
        "splitting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1072,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1072"
    },
    {
      id: "Chunk.splitWhere",
      name: "splitWhere",
      module: "Chunk",
      package: "effect",
      signature: "{ <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => [beforeMatch: Chunk<A>, fromMatch: Chunk<A>]; <A>(self: Chunk<A>, predicate: Predicate<A>): [beforeMatch: Chunk<A>, fromMatch: Chunk<A>]; }",
      description: "Splits this chunk on the first element that matches this predicate.\nReturns a tuple containing two chunks: the first one is before the match, and the second one is from the match onward.",
      documentation: "Splits this chunk on the first element that matches this predicate.\nReturns a tuple containing two chunks: the first one is before the match, and the second one is from the match onward.",
      examples: [],
      tags: [
        "splitting"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1095,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1095"
    },
    {
      id: "Chunk.tail",
      name: "tail",
      module: "Chunk",
      package: "effect",
      signature: "<A>(self: Chunk<A>) => Option<Chunk<A>>",
      description: "Returns every elements after the first.",
      documentation: "Returns every elements after the first.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1119,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1119"
    },
    {
      id: "Chunk.tailNonEmpty",
      name: "tailNonEmpty",
      module: "Chunk",
      package: "effect",
      signature: "<A>(self: NonEmptyChunk<A>) => Chunk<A>",
      description: "Returns every elements after the first.",
      documentation: "Returns every elements after the first.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1126,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1126"
    },
    {
      id: "Chunk.takeRight",
      name: "takeRight",
      module: "Chunk",
      package: "effect",
      signature: "{ (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A>; }",
      description: "Takes the last `n` elements.",
      documentation: "Takes the last `n` elements.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1133,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1133"
    },
    {
      id: "Chunk.takeWhile",
      name: "takeWhile",
      module: "Chunk",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Chunk<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>; <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Chunk<B>; <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>; }",
      description: "Takes all elements so long as the predicate returns true.",
      documentation: "Takes all elements so long as the predicate returns true.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1155,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1155"
    },
    {
      id: "Chunk.union",
      name: "union",
      module: "Chunk",
      package: "effect",
      signature: "{ <A>(that: Chunk<A>): <B>(self: Chunk<B>) => Chunk<A | B>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>; }",
      description: "Creates a Chunks of unique values, in order, from all given Chunks.",
      documentation: "Creates a Chunks of unique values, in order, from all given Chunks.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1191,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1191"
    },
    {
      id: "Chunk.dedupe",
      name: "dedupe",
      module: "Chunk",
      package: "effect",
      signature: "<A>(self: Chunk<A>) => Chunk<A>",
      description: "Remove duplicates from an array, keeping the first occurrence of an element.",
      documentation: "Remove duplicates from an array, keeping the first occurrence of an element.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1213,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1213"
    },
    {
      id: "Chunk.dedupeAdjacent",
      name: "dedupeAdjacent",
      module: "Chunk",
      package: "effect",
      signature: "<A>(self: Chunk<A>) => Chunk<A>",
      description: "Deduplicates adjacent elements that are identical.",
      documentation: "Deduplicates adjacent elements that are identical.",
      examples: [],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1220,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1220"
    },
    {
      id: "Chunk.unzip",
      name: "unzip",
      module: "Chunk",
      package: "effect",
      signature: "<A, B>(self: Chunk<readonly [A, B]>) => [Chunk<A>, Chunk<B>]",
      description: "Takes a `Chunk` of pairs and return two corresponding `Chunk`s. Note: The function is reverse of `zip`.",
      documentation: "Takes a `Chunk` of pairs and return two corresponding `Chunk`s.\n\nNote: The function is reverse of `zip`.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1229,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1229"
    },
    {
      id: "Chunk.zipWith",
      name: "zipWith",
      module: "Chunk",
      package: "effect",
      signature: "{ <A, B, C>(that: Chunk<B>, f: (a: A, b: B) => C): (self: Chunk<A>) => Chunk<C>; <A, B, C>(self: Chunk<A>, that: Chunk<B>, f: (a: A, b: B) => C): Chunk<C>; }",
      description: "Zips this chunk pointwise with the specified chunk using the specified combiner.",
      documentation: "Zips this chunk pointwise with the specified chunk using the specified combiner.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1236,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1236"
    },
    {
      id: "Chunk.zip",
      name: "zip",
      module: "Chunk",
      package: "effect",
      signature: "{ <B>(that: Chunk<B>): <A>(self: Chunk<A>) => Chunk<[A, B]>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<[A, B]>; }",
      description: "Zips this chunk pointwise with the specified chunk.",
      documentation: "Zips this chunk pointwise with the specified chunk.",
      examples: [],
      tags: [
        "zipping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1258,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1258"
    },
    {
      id: "Chunk.remove",
      name: "remove",
      module: "Chunk",
      package: "effect",
      signature: "{ (i: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, i: number): Chunk<A>; }",
      description: "Delete the element at the specified index, creating a new `Chunk`.",
      documentation: "Delete the element at the specified index, creating a new `Chunk`.",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1279,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1279"
    },
    {
      id: "Chunk.removeOption",
      name: "removeOption",
      module: "Chunk",
      package: "effect",
      signature: "{ (i: number): <A>(self: Chunk<A>) => Option<Chunk<A>>; <A>(self: Chunk<A>, i: number): Option<Chunk<A>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "3.16.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1296,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1296"
    },
    {
      id: "Chunk.modifyOption",
      name: "modifyOption",
      module: "Chunk",
      package: "effect",
      signature: "{ <A, B>(i: number, f: (a: A) => B): (self: Chunk<A>) => Option<Chunk<A | B>>; <A, B>(self: Chunk<A>, i: number, f: (a: A) => B): Option<Chunk<A | B>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1309,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1309"
    },
    {
      id: "Chunk.modify",
      name: "modify",
      module: "Chunk",
      package: "effect",
      signature: "{ <A, B>(i: number, f: (a: A) => B): (self: Chunk<A>) => Chunk<A | B>; <A, B>(self: Chunk<A>, i: number, f: (a: A) => B): Chunk<A | B>; }",
      description: "Apply a function to the element at the specified index, creating a new `Chunk`,\nor returning the input if the index is out of bounds.",
      documentation: "Apply a function to the element at the specified index, creating a new `Chunk`,\nor returning the input if the index is out of bounds.",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1325,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1325"
    },
    {
      id: "Chunk.replace",
      name: "replace",
      module: "Chunk",
      package: "effect",
      signature: "{ <B>(i: number, b: B): <A>(self: Chunk<A>) => Chunk<B | A>; <A, B>(self: Chunk<A>, i: number, b: B): Chunk<A | B>; }",
      description: "Change the element at the specified index, creating a new `Chunk`,\nor returning the input if the index is out of bounds.",
      documentation: "Change the element at the specified index, creating a new `Chunk`,\nor returning the input if the index is out of bounds.",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1347,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1347"
    },
    {
      id: "Chunk.replaceOption",
      name: "replaceOption",
      module: "Chunk",
      package: "effect",
      signature: "{ <B>(i: number, b: B): <A>(self: Chunk<A>) => Option<Chunk<B | A>>; <A, B>(self: Chunk<A>, i: number, b: B): Option<Chunk<A | B>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1366,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1366"
    },
    {
      id: "Chunk.makeBy",
      name: "makeBy",
      module: "Chunk",
      package: "effect",
      signature: "{ <A>(f: (i: number) => A): (n: number) => NonEmptyChunk<A>; <A>(n: number, f: (i: number) => A): NonEmptyChunk<A>; }",
      description: "Return a Chunk of length n with element i initialized with f(i). Note. `n` is normalized to an integer >= 1.",
      documentation: "Return a Chunk of length n with element i initialized with f(i).\n\n**Note**. `n` is normalized to an integer >= 1.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1384,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1384"
    },
    {
      id: "Chunk.range",
      name: "range",
      module: "Chunk",
      package: "effect",
      signature: "(start: number, end: number) => NonEmptyChunk<number>",
      description: "Create a non empty `Chunk` containing a range of integers, including both endpoints.",
      documentation: "Create a non empty `Chunk` containing a range of integers, including both endpoints.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1410,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1410"
    },
    {
      id: "Chunk.contains",
      name: "contains",
      module: "Chunk",
      package: "effect",
      signature: "{ <A>(a: A): (self: Chunk<A>) => boolean; <A>(self: Chunk<A>, a: A): boolean; }",
      description: "Returns a function that checks if a `Chunk` contains a given value using the default `Equivalence`.",
      documentation: "Returns a function that checks if a `Chunk` contains a given value using the default `Equivalence`.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1417,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1417"
    },
    {
      id: "Chunk.containsWith",
      name: "containsWith",
      module: "Chunk",
      package: "effect",
      signature: "<A>(isEquivalent: (self: A, that: A) => boolean) => { (a: A): (self: Chunk<A>) => boolean; (self: Chunk<A>, a: A): boolean; }",
      description: "Returns a function that checks if a `Chunk` contains a given value using a provided `isEquivalent` function.",
      documentation: "Returns a function that checks if a `Chunk` contains a given value using a provided `isEquivalent` function.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1439,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1439"
    },
    {
      id: "Chunk.findFirst",
      name: "findFirst",
      module: "Chunk",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Option<A>; <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Option<B>; <A>(self: Chunk<A>, predicate: Predicate<A>): Option<A>; }",
      description: "Returns the first element that satisfies the specified\npredicate, or `None` if no such element exists.",
      documentation: "Returns the first element that satisfies the specified\npredicate, or `None` if no such element exists.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1450,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1450"
    },
    {
      id: "Chunk.findFirstIndex",
      name: "findFirstIndex",
      module: "Chunk",
      package: "effect",
      signature: "{ <A>(predicate: Predicate<A>): (self: Chunk<A>) => Option<number>; <A>(self: Chunk<A>, predicate: Predicate<A>): Option<number>; }",
      description: "Return the first index for which a predicate holds.",
      documentation: "Return the first index for which a predicate holds.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1490,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1490"
    },
    {
      id: "Chunk.findLast",
      name: "findLast",
      module: "Chunk",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Option<A>; <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Option<B>; <A>(self: Chunk<A>, predicate: Predicate<A>): Option<A>; }",
      description: "Find the last element for which a predicate holds.",
      documentation: "Find the last element for which a predicate holds.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1512,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1512"
    },
    {
      id: "Chunk.findLastIndex",
      name: "findLastIndex",
      module: "Chunk",
      package: "effect",
      signature: "{ <A>(predicate: Predicate<A>): (self: Chunk<A>) => Option<number>; <A>(self: Chunk<A>, predicate: Predicate<A>): Option<number>; }",
      description: "Return the last index for which a predicate holds.",
      documentation: "Return the last index for which a predicate holds.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1548,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1548"
    },
    {
      id: "Chunk.every",
      name: "every",
      module: "Chunk",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => self is Chunk<B>; <A>(predicate: Predicate<A>): (self: Chunk<A>) => boolean; <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): self is Chunk<B>; <A>(self: Chunk<A>, predicate: Predicate<A>): boolean; }",
      description: "Check if a predicate holds true for every `Chunk` element.",
      documentation: "Check if a predicate holds true for every `Chunk` element.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1570,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1570"
    },
    {
      id: "Chunk.some",
      name: "some",
      module: "Chunk",
      package: "effect",
      signature: "{ <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => self is NonEmptyChunk<A>; <A>(self: Chunk<A>, predicate: Predicate<A>): self is NonEmptyChunk<A>; }",
      description: "Check if a predicate holds true for some `Chunk` element.",
      documentation: "Check if a predicate holds true for some `Chunk` element.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1606,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1606"
    },
    {
      id: "Chunk.join",
      name: "join",
      module: "Chunk",
      package: "effect",
      signature: "{ (sep: string): (self: Chunk<string>) => string; (self: Chunk<string>, sep: string): string; }",
      description: 'Joins the elements together with "sep" in the middle.',
      documentation: 'Joins the elements together with "sep" in the middle.',
      examples: [],
      tags: [
        "folding"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1628,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1628"
    },
    {
      id: "Chunk.reduce",
      name: "reduce",
      module: "Chunk",
      package: "effect",
      signature: "{ <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Chunk<A>) => B; <A, B>(self: Chunk<A>, b: B, f: (b: B, a: A, i: number) => B): B; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "folding"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1648,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1648"
    },
    {
      id: "Chunk.reduceRight",
      name: "reduceRight",
      module: "Chunk",
      package: "effect",
      signature: "{ <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Chunk<A>) => B; <A, B>(self: Chunk<A>, b: B, f: (b: B, a: A, i: number) => B): B; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "folding"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1664,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1664"
    },
    {
      id: "Chunk.differenceWith",
      name: "differenceWith",
      module: "Chunk",
      package: "effect",
      signature: "<A>(isEquivalent: (self: A, that: A) => boolean) => { (that: Chunk<A>): (self: Chunk<A>) => Chunk<A>; (self: Chunk<A>, that: Chunk<A>): Chunk<A>; }",
      description: "Creates a `Chunk` of values not included in the other given `Chunk` using the provided `isEquivalent` function.\nThe order and references of result values are determined by the first `Chunk`.",
      documentation: "Creates a `Chunk` of values not included in the other given `Chunk` using the provided `isEquivalent` function.\nThe order and references of result values are determined by the first `Chunk`.",
      examples: [],
      tags: [],
      since: "3.2.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1682,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1682"
    },
    {
      id: "Chunk.difference",
      name: "difference",
      module: "Chunk",
      package: "effect",
      signature: "{ <A>(that: Chunk<A>): (self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, that: Chunk<A>): Chunk<A>; }",
      description: "Creates a `Chunk` of values not included in the other given `Chunk`.\nThe order and references of result values are determined by the first `Chunk`.",
      documentation: "Creates a `Chunk` of values not included in the other given `Chunk`.\nThe order and references of result values are determined by the first `Chunk`.",
      examples: [],
      tags: [],
      since: "3.2.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Chunk.d.ts",
      sourceLine: 1692,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Chunk.ts#L1692"
    },
    {
      id: "HashMap.isHashMap",
      name: "isHashMap",
      module: "HashMap",
      package: "effect",
      signature: "{ <K, V>(u: Iterable<readonly [K, V]>): u is HashMap<K, V>; (u: unknown): u is HashMap<unknown, unknown>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 88,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L88"
    },
    {
      id: "HashMap.empty",
      name: "empty",
      module: "HashMap",
      package: "effect",
      signature: "<K = never, V = never>() => HashMap<K, V>",
      description: "Creates a new `HashMap`.",
      documentation: "Creates a new `HashMap`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 106,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L106"
    },
    {
      id: "HashMap.make",
      name: "make",
      module: "HashMap",
      package: "effect",
      signature: "<Entries extends ReadonlyArray<readonly [any, any]>>(...entries: Entries) => HashMap<Entries[number] extends readonly [infer K, any] ? K : never, Entries[number] extends readonly [any, infer V] ? V : never>",
      description: "Constructs a new `HashMap` from an array of key/value pairs.",
      documentation: "Constructs a new `HashMap` from an array of key/value pairs.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 113,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L113"
    },
    {
      id: "HashMap.fromIterable",
      name: "fromIterable",
      module: "HashMap",
      package: "effect",
      signature: "<K, V>(entries: Iterable<readonly [K, V]>) => HashMap<K, V>",
      description: "Creates a new `HashMap` from an iterable collection of key/value pairs.",
      documentation: "Creates a new `HashMap` from an iterable collection of key/value pairs.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 120,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L120"
    },
    {
      id: "HashMap.isEmpty",
      name: "isEmpty",
      module: "HashMap",
      package: "effect",
      signature: "<K, V>(self: HashMap<K, V>) => boolean",
      description: "Checks if the `HashMap` contains any entries.",
      documentation: "Checks if the `HashMap` contains any entries.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 127,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L127"
    },
    {
      id: "HashMap.get",
      name: "get",
      module: "HashMap",
      package: "effect",
      signature: "{ <K1 extends K, K>(key: K1): <V>(self: HashMap<K, V>) => Option<V>; <K1 extends K, K, V>(self: HashMap<K, V>, key: K1): Option<V>; }",
      description: "Safely lookup the value for the specified key in the `HashMap` using the\ninternal hashing function.",
      documentation: "Safely lookup the value for the specified key in the `HashMap` using the\ninternal hashing function.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 135,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L135"
    },
    {
      id: "HashMap.getHash",
      name: "getHash",
      module: "HashMap",
      package: "effect",
      signature: "{ <K1 extends K, K>(key: K1, hash: number): <V>(self: HashMap<K, V>) => Option<V>; <K1 extends K, K, V>(self: HashMap<K, V>, key: K1, hash: number): Option<V>; }",
      description: "Lookup the value for the specified key in the `HashMap` using a custom hash.",
      documentation: "Lookup the value for the specified key in the `HashMap` using a custom hash.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 159,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L159"
    },
    {
      id: "HashMap.unsafeGet",
      name: "unsafeGet",
      module: "HashMap",
      package: "effect",
      signature: "{ <K1 extends K, K>(key: K1): <V>(self: HashMap<K, V>) => V; <K1 extends K, K, V>(self: HashMap<K, V>, key: K1): V; }",
      description: "Unsafely lookup the value for the specified key in the `HashMap` using the\ninternal hashing function.",
      documentation: "Unsafely lookup the value for the specified key in the `HashMap` using the\ninternal hashing function.",
      examples: [],
      tags: [
        "unsafe"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 182,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L182"
    },
    {
      id: "HashMap.has",
      name: "has",
      module: "HashMap",
      package: "effect",
      signature: "{ <K1 extends K, K>(key: K1): <K, V>(self: HashMap<K, V>) => boolean; <K1 extends K, K, V>(self: HashMap<K, V>, key: K1): boolean; }",
      description: "Checks if the specified key has an entry in the `HashMap`.",
      documentation: "Checks if the specified key has an entry in the `HashMap`.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 206,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L206"
    },
    {
      id: "HashMap.hasHash",
      name: "hasHash",
      module: "HashMap",
      package: "effect",
      signature: "{ <K1 extends K, K>(key: K1, hash: number): <V>(self: HashMap<K, V>) => boolean; <K1 extends K, K, V>(self: HashMap<K, V>, key: K1, hash: number): boolean; }",
      description: "Checks if the specified key has an entry in the `HashMap` using a custom\nhash.",
      documentation: "Checks if the specified key has an entry in the `HashMap` using a custom\nhash.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 229,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L229"
    },
    {
      id: "HashMap.hasBy",
      name: "hasBy",
      module: "HashMap",
      package: "effect",
      signature: "{ <K, V>(predicate: (value: NoInfer<V>, key: NoInfer<K>) => boolean): (self: HashMap<K, V>) => boolean; <K, V>(self: HashMap<K, V>, predicate: (value: NoInfer<V>, key: NoInfer<K>) => boolean): boolean; }",
      description: "Checks if an element matching the given predicate exists in the given `HashMap`.",
      documentation: "Checks if an element matching the given predicate exists in the given `HashMap`.",
      examples: [
        {
          code: `import { HashMap } from "effect"

const hm = HashMap.make([1, 'a'])
HashMap.hasBy(hm, (value, key) => value === 'a' && key === 1); // -> true
HashMap.hasBy(hm, (value) => value === 'b'); // -> false`
        }
      ],
      tags: [
        "elements"
      ],
      since: "3.16.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 263,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L263"
    },
    {
      id: "HashMap.set",
      name: "set",
      module: "HashMap",
      package: "effect",
      signature: "{ <K, V>(key: K, value: V): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K, value: V): HashMap<K, V>; }",
      description: "Sets the specified key to the specified value using the internal hashing\nfunction.",
      documentation: "Sets the specified key to the specified value using the internal hashing\nfunction.",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 305,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L305"
    },
    {
      id: "HashMap.keys",
      name: "keys",
      module: "HashMap",
      package: "effect",
      signature: "<K, V>(self: HashMap<K, V>) => IterableIterator<K>",
      description: "Returns an `IterableIterator` of the keys within the `HashMap`.",
      documentation: "Returns an `IterableIterator` of the keys within the `HashMap`.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 327,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L327"
    },
    {
      id: "HashMap.keySet",
      name: "keySet",
      module: "HashMap",
      package: "effect",
      signature: "<K, V>(self: HashMap<K, V>) => HashSet<K>",
      description: "Returns a `HashSet` of keys within the `HashMap`.",
      documentation: "Returns a `HashSet` of keys within the `HashMap`.",
      examples: [],
      tags: [
        "getter"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 334,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L334"
    },
    {
      id: "HashMap.values",
      name: "values",
      module: "HashMap",
      package: "effect",
      signature: "<K, V>(self: HashMap<K, V>) => IterableIterator<V>",
      description: "Returns an `IterableIterator` of the values within the `HashMap`.",
      documentation: "Returns an `IterableIterator` of the values within the `HashMap`.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 341,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L341"
    },
    {
      id: "HashMap.toValues",
      name: "toValues",
      module: "HashMap",
      package: "effect",
      signature: "<K, V>(self: HashMap<K, V>) => V[]",
      description: "Returns an `Array` of the values within the `HashMap`.",
      documentation: "Returns an `Array` of the values within the `HashMap`.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "3.13.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 348,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L348"
    },
    {
      id: "HashMap.entries",
      name: "entries",
      module: "HashMap",
      package: "effect",
      signature: "<K, V>(self: HashMap<K, V>) => IterableIterator<[K, V]>",
      description: "Returns an `IterableIterator` of the entries within the `HashMap`.",
      documentation: "Returns an `IterableIterator` of the entries within the `HashMap`.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 355,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L355"
    },
    {
      id: "HashMap.toEntries",
      name: "toEntries",
      module: "HashMap",
      package: "effect",
      signature: "<K, V>(self: HashMap<K, V>) => [K, V][]",
      description: "Returns an `Array<[K, V]>` of the entries within the `HashMap`.",
      documentation: "Returns an `Array<[K, V]>` of the entries within the `HashMap`.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 362,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L362"
    },
    {
      id: "HashMap.size",
      name: "size",
      module: "HashMap",
      package: "effect",
      signature: "<K, V>(self: HashMap<K, V>) => number",
      description: "Returns the number of entries within the `HashMap`.",
      documentation: "Returns the number of entries within the `HashMap`.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 369,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L369"
    },
    {
      id: "HashMap.countBy",
      name: "countBy",
      module: "HashMap",
      package: "effect",
      signature: "{ <K, V>(predicate: (value: NoInfer<V>, key: NoInfer<K>) => boolean): (self: HashMap<K, V>) => number; <K, V>(self: HashMap<K, V>, predicate: (value: NoInfer<V>, key: NoInfer<K>) => boolean): number; }",
      description: "Counts all the element of the given HashMap that pass the given predicate",
      documentation: 'Counts all the element of the given HashMap that pass the given predicate\n\n**Example**\n\n```ts\nimport { HashMap } from "effect"\n\nconst map = HashMap.make([1, "a"], [2, "b"], [3, "c"])\nconst result = HashMap.countBy(map, (_v, key) => key % 2 === 1)\nconsole.log(result) // 2\n```',
      examples: [
        {
          code: 'import { HashMap } from "effect"\n\nconst map = HashMap.make([1, "a"], [2, "b"], [3, "c"])\nconst result = HashMap.countBy(map, (_v, key) => key % 2 === 1)\nconsole.log(result) // 2'
        }
      ],
      tags: [
        "folding"
      ],
      since: "3.17.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 386,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L386"
    },
    {
      id: "HashMap.beginMutation",
      name: "beginMutation",
      module: "HashMap",
      package: "effect",
      signature: "<K, V>(self: HashMap<K, V>) => HashMap<K, V>",
      description: "Marks the `HashMap` as mutable.",
      documentation: "Marks the `HashMap` as mutable.",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 427,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L427"
    },
    {
      id: "HashMap.endMutation",
      name: "endMutation",
      module: "HashMap",
      package: "effect",
      signature: "<K, V>(self: HashMap<K, V>) => HashMap<K, V>",
      description: "Marks the `HashMap` as immutable.",
      documentation: "Marks the `HashMap` as immutable.",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 433,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L433"
    },
    {
      id: "HashMap.mutate",
      name: "mutate",
      module: "HashMap",
      package: "effect",
      signature: "{ <K, V>(f: (self: HashMap<K, V>) => void): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, f: (self: HashMap<K, V>) => void): HashMap<K, V>; }",
      description: "Mutates the `HashMap` within the context of the provided function.",
      documentation: "Mutates the `HashMap` within the context of the provided function.",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 439,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L439"
    },
    {
      id: "HashMap.modifyAt",
      name: "modifyAt",
      module: "HashMap",
      package: "effect",
      signature: "{ <K, V>(key: K, f: HashMap.UpdateFn<V>): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K, f: HashMap.UpdateFn<V>): HashMap<K, V>; }",
      description: "Set or remove the specified key in the `HashMap` using the specified\nupdate function. The value of the specified key will be computed using the\nprovided hash. The update function will be invoked with the current value of the key if it\nexists, or `None` if no such value exists.",
      documentation: "Set or remove the specified key in the `HashMap` using the specified\nupdate function. The value of the specified key will be computed using the\nprovided hash.\n\nThe update function will be invoked with the current value of the key if it\nexists, or `None` if no such value exists.",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 463,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L463"
    },
    {
      id: "HashMap.modifyHash",
      name: "modifyHash",
      module: "HashMap",
      package: "effect",
      signature: "{ <K, V>(key: K, hash: number, f: HashMap.UpdateFn<V>): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K, hash: number, f: HashMap.UpdateFn<V>): HashMap<K, V>; }",
      description: "Alter the value of the specified key in the `HashMap` using the specified\nupdate function. The value of the specified key will be computed using the\nprovided hash. The update function will be invoked with the current value of the key if it\nexists, or `None` if no such value exists. This function will always either update or insert a value into the `HashMap`.",
      documentation: "Alter the value of the specified key in the `HashMap` using the specified\nupdate function. The value of the specified key will be computed using the\nprovided hash.\n\nThe update function will be invoked with the current value of the key if it\nexists, or `None` if no such value exists.\n\nThis function will always either update or insert a value into the `HashMap`.",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 499,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L499"
    },
    {
      id: "HashMap.modify",
      name: "modify",
      module: "HashMap",
      package: "effect",
      signature: "{ <K, V>(key: K, f: (v: V) => V): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K, f: (v: V) => V): HashMap<K, V>; }",
      description: "Updates the value of the specified key within the `HashMap` if it exists.",
      documentation: "Updates the value of the specified key within the `HashMap` if it exists.",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 532,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L532"
    },
    {
      id: "HashMap.union",
      name: "union",
      module: "HashMap",
      package: "effect",
      signature: "{ <K1, V1>(that: HashMap<K1, V1>): <K0, V0>(self: HashMap<K0, V0>) => HashMap<K1 | K0, V1 | V0>; <K0, V0, K1, V1>(self: HashMap<K0, V0>, that: HashMap<K1, V1>): HashMap<K0 | K1, V0 | V1>; }",
      description: "Performs a union of this `HashMap` and that `HashMap`.",
      documentation: "Performs a union of this `HashMap` and that `HashMap`.",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 551,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L551"
    },
    {
      id: "HashMap.remove",
      name: "remove",
      module: "HashMap",
      package: "effect",
      signature: "{ <K>(key: K): <V>(self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K): HashMap<K, V>; }",
      description: "Remove the entry for the specified key in the `HashMap` using the internal\nhashing function.",
      documentation: "Remove the entry for the specified key in the `HashMap` using the internal\nhashing function.",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 571,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L571"
    },
    {
      id: "HashMap.removeMany",
      name: "removeMany",
      module: "HashMap",
      package: "effect",
      signature: "{ <K>(keys: Iterable<K>): <V>(self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, keys: Iterable<K>): HashMap<K, V>; }",
      description: "Removes all entries in the `HashMap` which have the specified keys.",
      documentation: "Removes all entries in the `HashMap` which have the specified keys.",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 592,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L592"
    },
    {
      id: "HashMap.map",
      name: "map",
      module: "HashMap",
      package: "effect",
      signature: "{ <A, V, K>(f: (value: V, key: K) => A): (self: HashMap<K, V>) => HashMap<K, A>; <K, V, A>(self: HashMap<K, V>, f: (value: V, key: K) => A): HashMap<K, A>; }",
      description: "Maps over the entries of the `HashMap` using the specified function.",
      documentation: "Maps over the entries of the `HashMap` using the specified function.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 612,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L612"
    },
    {
      id: "HashMap.flatMap",
      name: "flatMap",
      module: "HashMap",
      package: "effect",
      signature: "{ <A, K, B>(f: (value: A, key: K) => HashMap<K, B>): (self: HashMap<K, A>) => HashMap<K, B>; <K, A, B>(self: HashMap<K, A>, f: (value: A, key: K) => HashMap<K, B>): HashMap<K, B>; }",
      description: "Chains over the entries of the `HashMap` using the specified function. NOTE: the hash and equal of both maps have to be the same.",
      documentation: "Chains over the entries of the `HashMap` using the specified function.\n\n**NOTE**: the hash and equal of both maps have to be the same.",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 636,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L636"
    },
    {
      id: "HashMap.forEach",
      name: "forEach",
      module: "HashMap",
      package: "effect",
      signature: "{ <V, K>(f: (value: V, key: K) => void): (self: HashMap<K, V>) => void; <V, K>(self: HashMap<K, V>, f: (value: V, key: K) => void): void; }",
      description: "Applies the specified function to the entries of the `HashMap`.",
      documentation: "Applies the specified function to the entries of the `HashMap`.",
      examples: [],
      tags: [
        "traversing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 662,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L662"
    },
    {
      id: "HashMap.reduce",
      name: "reduce",
      module: "HashMap",
      package: "effect",
      signature: "{ <Z, V, K>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z): (self: HashMap<K, V>) => Z; <K, V, Z>(self: HashMap<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z): Z; }",
      description: "Reduces the specified state over the entries of the `HashMap`.",
      documentation: "Reduces the specified state over the entries of the `HashMap`.",
      examples: [],
      tags: [
        "folding"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 684,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L684"
    },
    {
      id: "HashMap.filter",
      name: "filter",
      module: "HashMap",
      package: "effect",
      signature: "{ <K, A, B extends A>(f: (a: NoInfer<A>, k: K) => a is B): (self: HashMap<K, A>) => HashMap<K, B>; <K, A>(f: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => HashMap<K, A>; <K, A, B extends A>(self: HashMap<K, A>, f: (a: A, k: K) => a is B): HashMap<K, B>; <K, A>(self: HashMap<K, A>, f: (a: A, k: K) => boolean): HashMap<K, A>; }",
      description: "Filters entries out of a `HashMap` using the specified predicate.",
      documentation: "Filters entries out of a `HashMap` using the specified predicate.",
      examples: [],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 706,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L706"
    },
    {
      id: "HashMap.compact",
      name: "compact",
      module: "HashMap",
      package: "effect",
      signature: "<K, A>(self: HashMap<K, Option<A>>) => HashMap<K, A>",
      description: "Filters out `None` values from a `HashMap` of `Options`s.",
      documentation: "Filters out `None` values from a `HashMap` of `Options`s.",
      examples: [],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 742,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L742"
    },
    {
      id: "HashMap.filterMap",
      name: "filterMap",
      module: "HashMap",
      package: "effect",
      signature: "{ <A, K, B>(f: (value: A, key: K) => Option<B>): (self: HashMap<K, A>) => HashMap<K, B>; <K, A, B>(self: HashMap<K, A>, f: (value: A, key: K) => Option<B>): HashMap<K, B>; }",
      description: "Maps over the entries of the `HashMap` using the specified partial function\nand filters out `None` values.",
      documentation: "Maps over the entries of the `HashMap` using the specified partial function\nand filters out `None` values.",
      examples: [],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 750,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L750"
    },
    {
      id: "HashMap.findFirst",
      name: "findFirst",
      module: "HashMap",
      package: "effect",
      signature: "{ <K, A, B extends A>(predicate: (a: NoInfer<A>, k: K) => a is B): (self: HashMap<K, A>) => Option<[K, B]>; <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => Option<[K, A]>; <K, A, B extends A>(self: HashMap<K, A>, predicate: (a: A, k: K) => a is B): Option<[K, B]>; <K, A>(self: HashMap<K, A>, predicate: (a: A, k: K) => boolean): Option<[K, A]>; }",
      description: "Returns the first element that satisfies the specified\npredicate, or `None` if no such element exists.",
      documentation: "Returns the first element that satisfies the specified\npredicate, or `None` if no such element exists.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 775,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L775"
    },
    {
      id: "HashMap.some",
      name: "some",
      module: "HashMap",
      package: "effect",
      signature: "{ <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => boolean; <K, A>(self: HashMap<K, A>, predicate: (a: A, k: K) => boolean): boolean; }",
      description: "Checks if any entry in a hashmap meets a specific condition.",
      documentation: "Checks if any entry in a hashmap meets a specific condition.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "3.13.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 815,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L815"
    },
    {
      id: "HashMap.every",
      name: "every",
      module: "HashMap",
      package: "effect",
      signature: "{ <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => boolean; <K, A>(self: HashMap<K, A>, predicate: (a: A, k: K) => boolean): boolean; }",
      description: "Checks if all entries in a hashmap meets a specific condition.",
      documentation: "Checks if all entries in a hashmap meets a specific condition.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "3.14.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashMap.d.ts",
      sourceLine: 840,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashMap.ts#L840"
    },
    {
      id: "HashSet.isHashSet",
      name: "isHashSet",
      module: "HashSet",
      package: "effect",
      signature: "{ <A>(u: Iterable<A>): u is HashSet<A>; (u: unknown): u is HashSet<unknown>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 288,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L288"
    },
    {
      id: "HashSet.empty",
      name: "empty",
      module: "HashSet",
      package: "effect",
      signature: "<A = never>() => HashSet<A>",
      description: "Creates an empty `HashSet`. Time complexity: `O(1)`",
      documentation: "Creates an empty `HashSet`.\n\nTime complexity: **`O(1)`**",
      examples: [
        {
          code: 'import { HashSet, pipe } from "effect"\n\nconsole.log(\n  pipe(\n    // Provide a type argument to create a HashSet of a specific type\n    HashSet.empty<number>(),\n    HashSet.add(1),\n    HashSet.add(1), // Notice the duplicate\n    HashSet.add(2),\n    HashSet.toValues\n  )\n) // Output: [1, 2]'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 367,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L367"
    },
    {
      id: "HashSet.fromIterable",
      name: "fromIterable",
      module: "HashSet",
      package: "effect",
      signature: "<A>(elements: Iterable<A>) => HashSet<A>",
      description: "Creates a new `HashSet` from an iterable collection of values. Time complexity: `O(n)` where n is the number of elements in the iterable",
      documentation: "Creates a new `HashSet` from an iterable collection of values.\n\nTime complexity: **`O(n)`** where n is the number of elements in the iterable",
      examples: [
        {
          code: '// Creating a HashSet from an Array\nimport { HashSet, pipe } from "effect"\n\nconsole.log(\n  pipe(\n    [1, 2, 3, 4, 5, 1, 2, 3], // Array<number> is an Iterable<number>;  Note the duplicates.\n    HashSet.fromIterable,\n    HashSet.toValues\n  )\n) // Output: [1, 2, 3, 4, 5]'
        },
        {
          code: '// Creating a HashSet from a Set\nimport { HashSet, pipe } from "effect"\n\nconsole.log(\n  pipe(\n    new Set(["apple", "banana", "orange", "apple"]), // Set<string> is an Iterable<string>\n    HashSet.fromIterable,\n    HashSet.toValues\n  )\n) // Output: ["apple", "banana", "orange"]'
        },
        {
          code: '// Creating a HashSet from a Generator\nimport { HashSet } from "effect"\n\n// Generator functions return iterables\nfunction* fibonacci(n: number): Generator<number, void, unknown> {\n  let [a, b] = [0, 1]\n  for (let i = 0; i < n; i++) {\n    yield a\n    ;[a, b] = [b, a + b]\n  }\n}\n\n// Create a HashSet from the first 10 Fibonacci numbers\nconst fibonacciSet = HashSet.fromIterable(fibonacci(10))\n\nconsole.log(HashSet.toValues(fibonacciSet))\n// Outputs: [0, 1, 2, 3, 5, 8, 13, 21, 34] but in unsorted order'
        },
        {
          code: '//  Creating a HashSet from another HashSet\nimport { HashSet, pipe } from "effect"\n\nconsole.log(\n  pipe(\n    // since HashSet implements the Iterable interface, we can use it to create a new HashSet\n    HashSet.make(1, 2, 3, 4),\n    HashSet.fromIterable,\n    HashSet.toValues // turns the HashSet back into an array\n  )\n) // Output: [1, 2, 3, 4]'
        },
        {
          code: `// Creating a HashSet from other Effect's data structures like Chunk
import { Chunk, HashSet, pipe } from "effect"

console.log(
  pipe(
    Chunk.make(1, 2, 3, 4), // Iterable<number>
    HashSet.fromIterable,
    HashSet.toValues // turns the HashSet back into an array
  )
) // Outputs: [1, 2, 3, 4]`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 461,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L461"
    },
    {
      id: "HashSet.make",
      name: "make",
      module: "HashSet",
      package: "effect",
      signature: "<As extends ReadonlyArray<any>>(...elements: As) => HashSet<As[number]>",
      description: "Construct a new `HashSet` from a variable number of values. Time complexity: `O(n)` where n is the number of elements",
      documentation: "Construct a new `HashSet` from a variable number of values.\n\nTime complexity: **`O(n)`** where n is the number of elements",
      examples: [
        {
          code: 'import { Equal, Hash, HashSet, pipe } from "effect"\nimport assert from "node:assert/strict"\n\nclass Character implements Equal.Equal {\n  readonly name: string\n  readonly trait: string\n\n  constructor(name: string, trait: string) {\n    this.name = name\n    this.trait = trait\n  }\n\n  // Define equality based on name, and trait\n  [Equal.symbol](that: Equal.Equal): boolean {\n    if (that instanceof Character) {\n      return (\n        Equal.equals(this.name, that.name) &&\n        Equal.equals(this.trait, that.trait)\n      )\n    }\n    return false\n  }\n\n  // Generate a hash code based on the sum of the character\'s name and trait\n  [Hash.symbol](): number {\n    return Hash.hash(this.name + this.trait)\n  }\n\n  static readonly of = (name: string, trait: string): Character => {\n    return new Character(name, trait)\n  }\n}\n\nassert.strictEqual(\n  Equal.equals(\n    HashSet.make(\n      Character.of("Alice", "Curious"),\n      Character.of("Alice", "Curious"),\n      Character.of("White Rabbit", "Always late"),\n      Character.of("Mad Hatter", "Tea enthusiast")\n    ),\n    // Is the same as adding each character to an empty set\n    pipe(\n      HashSet.empty(),\n      HashSet.add(Character.of("Alice", "Curious")),\n      HashSet.add(Character.of("Alice", "Curious")), // Alice tried to attend twice!\n      HashSet.add(Character.of("White Rabbit", "Always late")),\n      HashSet.add(Character.of("Mad Hatter", "Tea enthusiast"))\n    )\n  ),\n  true,\n  "`HashSet.make` and `HashSet.empty() + HashSet.add()` should be equal"\n)\n\nassert.strictEqual(\n  Equal.equals(\n    HashSet.make(\n      Character.of("Alice", "Curious"),\n      Character.of("Alice", "Curious"),\n      Character.of("White Rabbit", "Always late"),\n      Character.of("Mad Hatter", "Tea enthusiast")\n    ),\n    HashSet.fromIterable([\n      Character.of("Alice", "Curious"),\n      Character.of("Alice", "Curious"),\n      Character.of("White Rabbit", "Always late"),\n      Character.of("Mad Hatter", "Tea enthusiast")\n    ])\n  ),\n  true,\n  "`HashSet.make` and `HashSet.fromIterable` should be equal"\n)'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 549,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L549"
    },
    {
      id: "HashSet.has",
      name: "has",
      module: "HashSet",
      package: "effect",
      signature: "{ <A>(value: A): (self: HashSet<A>) => boolean; <A>(self: HashSet<A>, value: A): boolean; }",
      description: "Checks if the specified value exists in the `HashSet`. Time complexity: `O(1)` average",
      documentation: "Checks if the specified value exists in the `HashSet`.\n\nTime complexity: **`O(1)`** average",
      examples: [
        {
          code: '// Syntax\nimport { HashSet, pipe } from "effect"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(HashSet.make(0, 1, 2), HashSet.has(3)) // false\n\n// or piped with the pipe function\nHashSet.make(0, 1, 2).pipe(HashSet.has(3)) // false\n\n// or with `data-first` API\nHashSet.has(HashSet.make(0, 1, 2), 3) // false'
        }
      ],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 577,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L577"
    },
    {
      id: "HashSet.some",
      name: "some",
      module: "HashSet",
      package: "effect",
      signature: "{ <A>(f: Predicate<A>): (self: HashSet<A>) => boolean; <A>(self: HashSet<A>, f: Predicate<A>): boolean; }",
      description: "Check if a predicate holds true for some `HashSet` element. Time complexity: `O(n)` where n is the number of elements in the set",
      documentation: "Check if a predicate holds true for some `HashSet` element.\n\nTime complexity: **`O(n)`** where n is the number of elements in the set",
      examples: [
        {
          code: '// Syntax\nimport { HashSet, pipe } from "effect"\n\nconst set: HashSet.HashSet<number> = HashSet.make(0, 1, 2)\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(\n  set,\n  HashSet.some((n) => n > 0)\n) // true\n\n// or piped with the pipe function\nset.pipe(HashSet.some((n) => n > 0)) // true\n\n// or with `data-first` API\nHashSet.some(set, (n) => n > 0) // true'
        }
      ],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 644,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L644"
    },
    {
      id: "HashSet.every",
      name: "every",
      module: "HashSet",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: HashSet<A>) => self is HashSet<B>; <A>(predicate: Predicate<A>): (self: HashSet<A>) => boolean; <A, B extends A>(self: HashSet<A>, refinement: Refinement<A, B>): self is HashSet<B>; <A>(self: HashSet<A>, predicate: Predicate<A>): boolean; }",
      description: "Check if a predicate holds true for every `HashSet` element. Time complexity is `O(n)` as it needs to traverse the whole HashSet\ncollection",
      documentation: "Check if a predicate holds true for every `HashSet` element.\n\nTime complexity is **`O(n)`** as it needs to traverse the whole HashSet\ncollection",
      examples: [
        {
          code: '// Syntax with Refinement\nimport { HashSet, pipe, Predicate } from "effect"\n\nconst numberOrString = HashSet.make(1, "1", "one", "uno")\n\n// with `data-last`, a.k.a. `pipeable` API and `Refinement`\npipe(\n  numberOrString, // HashSet.HashSet<number | string>\n  HashSet.every(Predicate.isString)\n) // HashSet.HashSet<string>\n\n// or piped with the pipe function and  `Refinement`\nnumberOrString // HashSet.HashSet<number | string>\n  .pipe(HashSet.every(Predicate.isString)) // HashSet.HashSet<string>\n\n// or with `data-first` API and `Refinement`\nHashSet.every(\n  numberOrString, // HashSet.HashSet<number | string>\n  Predicate.isString\n) // HashSet.HashSet<string>'
        },
        {
          code: '// Syntax with Predicate\nimport { HashSet, pipe } from "effect"\n\nconst set = HashSet.make(1, 2, 3)\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(\n  set,\n  HashSet.every((n) => n >= 0)\n) // true\n\n// or piped with the pipe function\nset.pipe(HashSet.every((n) => n >= 0)) // true\n\n// or with `data-first` API\nHashSet.every(set, (n) => n >= 0) // true'
        }
      ],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 755,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L755"
    },
    {
      id: "HashSet.isSubset",
      name: "isSubset",
      module: "HashSet",
      package: "effect",
      signature: "{ <A>(that: HashSet<A>): (self: HashSet<A>) => boolean; <A>(self: HashSet<A>, that: HashSet<A>): boolean; }",
      description: "Returns `true` if and only if every element in the this `HashSet` is an\nelement of the second set, NOTE: the hash and equal of both sets must be the same. Time complexity analysis is of `O(n)`",
      documentation: "Returns `true` if and only if every element in the this `HashSet` is an\nelement of the second set,\n\n**NOTE**: the hash and equal of both sets must be the same.\n\nTime complexity analysis is of **`O(n)`**",
      examples: [
        {
          code: '// Syntax\nimport { HashSet, pipe } from "effect"\n\nconst set1 = HashSet.make(0, 1)\nconst set2 = HashSet.make(1, 2)\nconst set3 = HashSet.make(0, 1, 2)\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(set1, HashSet.isSubset(set2)) // false\npipe(set1, HashSet.isSubset(set3)) // true\n\n// or piped with the pipe function\nset1.pipe(HashSet.isSubset(set2)) // false\nset1.pipe(HashSet.isSubset(set3)) // true\n\n// or with `data-first` API\nHashSet.isSubset(set1, set2) // false\nHashSet.isSubset(set1, set3) // true)'
        }
      ],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 876,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L876"
    },
    {
      id: "HashSet.values",
      name: "values",
      module: "HashSet",
      package: "effect",
      signature: "<A>(self: HashSet<A>) => IterableIterator<A>",
      description: "Returns an `IterableIterator` of the values in the `HashSet`. Time complexity: `O(1)`",
      documentation: "Returns an `IterableIterator` of the values in the `HashSet`.\n\nTime complexity: **`O(1)`**",
      examples: [
        {
          code: 'import { HashSet, pipe } from "effect"\n\nconst numberIterable = pipe(\n  HashSet.make(0, 1, 1, 2), // HashSet.HashSet<number>\n  HashSet.values // takes an HashSet<A> and returns an IterableIterator<A>\n)\n\nfor (const number of numberIterable) {\n  console.log(number) // it will logs: 0, 1, 2\n}'
        }
      ],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 941,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L941"
    },
    {
      id: "HashSet.toValues",
      name: "toValues",
      module: "HashSet",
      package: "effect",
      signature: "<A>(self: HashSet<A>) => A[]",
      description: "Returns an `Array` of the values within the `HashSet`. Time complexity: `O(n)` where n is the number of elements in the set",
      documentation: "Returns an `Array` of the values within the `HashSet`.\n\nTime complexity: **`O(n)`** where n is the number of elements in the set",
      examples: [
        {
          code: 'import { HashSet, pipe } from "effect"\nimport { deepStrictEqual } from "node:assert/strict"\n\ndeepStrictEqual(\n  pipe(\n    HashSet.make(0, 1, 1, 2), // HashSet<number>\n    HashSet.toValues // takes an HashSet<A> and returns an Array<A>\n  ),\n  Array.of(0, 1, 2)\n)'
        }
      ],
      tags: [
        "getters"
      ],
      since: "3.13.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 967,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L967"
    },
    {
      id: "HashSet.size",
      name: "size",
      module: "HashSet",
      package: "effect",
      signature: "<A>(self: HashSet<A>) => number",
      description: "Calculates the number of values in the `HashSet`. Time complexity: `O(1)`",
      documentation: "Calculates the number of values in the `HashSet`.\n\nTime complexity: **`O(1)`**",
      examples: [
        {
          code: 'import { HashSet, pipe } from "effect"\nimport assert from "node:assert/strict"\n\nassert.deepStrictEqual(pipe(HashSet.empty(), HashSet.size), 0)\n\nassert.deepStrictEqual(\n  pipe(HashSet.make(1, 2, 2, 3, 4, 3), HashSet.size),\n  4\n)'
        }
      ],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 992,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L992"
    },
    {
      id: "HashSet.beginMutation",
      name: "beginMutation",
      module: "HashSet",
      package: "effect",
      signature: "<A>(self: HashSet<A>) => HashSet<A>",
      description: "/\n * Creates a new mutable version of the `HashSet`\n *\n * When a `HashSet` is mutable, operations like {@link add}and {@link remove}* modify the data structure in place instead of creating a new one, which is\n * more efficient when performing multiple operations.\n *\n *",
      documentation: "/**\n * Creates a new mutable version of the `HashSet`\n *\n * When a `HashSet` is mutable, operations like {@link add}and {@link remove}* modify the data structure in place instead of creating a new one, which is\n * more efficient when performing multiple operations.\n *\n *",
      examples: [
        {
          code: 'import { HashSet } from "effect"\nimport assert from "node:assert/strict"\n\nconst UPPER_BOUND = 10_000\n\nconst immutableSet = HashSet.empty<number>().pipe(HashSet.add(0))\n\n// Create a mutable version of the immutableSet\nconst mutableSet = HashSet.beginMutation(immutableSet)\n\nfor (let i = 1; i < UPPER_BOUND; i++) {\n  // Operations now modify the set in place instead of creating new instances\n  // This is more efficient when making multiple changes\n  const pointerToMutableSet = HashSet.add(mutableSet, i)\n\n  // the two sets have the same identity, hence `add` is mutating mutableSet and not returning a new HashSet instance\n  assert(Object.is(mutableSet, pointerToMutableSet))\n  assert.equal(HashSet.has(mutableSet, i), true) // `i` is in the mutableSet\n  assert.equal(HashSet.has(immutableSet, i), false) // `i` is not in the immutableSet\n}\n\nconst next = UPPER_BOUND + 1\n// When done, mark the set as immutable again\nHashSet.endMutation(mutableSet).pipe(\n  HashSet.add(next) // since this returns a new HashSet, it will not be logged as part of the mutableSet\n)\nassert.equal(HashSet.has(mutableSet, next), false)\n\nconsole.log(HashSet.toValues(immutableSet)) // [0]\nconsole.log(HashSet.toValues(mutableSet).sort((a, b) => a - b)) // [0, 1, 2, 3, ...rest]'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 1039,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L1039"
    },
    {
      id: "HashSet.endMutation",
      name: "endMutation",
      module: "HashSet",
      package: "effect",
      signature: "<A>(self: HashSet<A>) => HashSet<A>",
      description: "/\n * Makes the `HashSet` immutable again.\n *\n * After calling `endMutation`, operations like {@link add}and {@link remove}* will create new instances of the `HashSet` instead of modifying the existing\n * one.\n *\n *",
      documentation: "/**\n * Makes the `HashSet` immutable again.\n *\n * After calling `endMutation`, operations like {@link add}and {@link remove}* will create new instances of the `HashSet` instead of modifying the existing\n * one.\n *\n *",
      examples: [
        {
          code: 'import { HashSet } from "effect"\nimport assert from "node:assert/strict"\n\n// Create a mutable set\nconst mutableSet = HashSet.beginMutation(HashSet.empty<number>())\n\n// Add some elements to the mutable set\nHashSet.add(mutableSet, 1)\nHashSet.add(mutableSet, 2)\n\n// Before endMutation, operations modify the set in place\nconst sameSet = HashSet.add(mutableSet, 3)\nassert(Object.is(mutableSet, sameSet)) // true - same object reference\nassert.deepStrictEqual(HashSet.toValues(mutableSet).sort(), [1, 2, 3])\n\n// Make the set immutable again\nconst immutableSet = HashSet.endMutation(mutableSet)\n\n// endMutation returns the same set instance, now made immutable\nassert(Object.is(mutableSet, immutableSet)) // true - same object reference\n\n// After endMutation, operations create new instances\nconst newSet = HashSet.add(immutableSet, 4)\nassert(!Object.is(immutableSet, newSet)) // false - different object references\n\n// The original set remains unchanged\nassert.deepStrictEqual(HashSet.toValues(immutableSet).sort(), [1, 2, 3])\n\n// The new set contains the added element\nassert.deepStrictEqual(HashSet.toValues(newSet).sort(), [1, 2, 3, 4])'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 1086,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L1086"
    },
    {
      id: "HashSet.mutate",
      name: "mutate",
      module: "HashSet",
      package: "effect",
      signature: "{ <A>(f: (set: HashSet<A>) => void): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, f: (set: HashSet<A>) => void): HashSet<A>; }",
      description: "/\n * Mutates the `HashSet` within the context of the provided function.\n *\n * You can consider it a functional abstraction on top of the lower-level\n * mutation primitives of {@link module:HashSet.beginMutation}`->` `mutable\n * context` `->` {@link HashSet.endMutation}.\n *\n *",
      documentation: "/**\n * Mutates the `HashSet` within the context of the provided function.\n *\n * You can consider it a functional abstraction on top of the lower-level\n * mutation primitives of {@link module:HashSet.beginMutation}`->` `mutable\n * context` `->` {@link HashSet.endMutation}.\n *\n *",
      examples: [
        {
          code: '// Syntax\nimport { HashSet, pipe } from "effect"\n\n// with data-last, a.k.a. pipeable API\npipe(\n  HashSet.make(1, 2, 3),\n  HashSet.mutate((set) => {\n    HashSet.add(set, 4)\n    HashSet.remove(set, 1)\n  })\n)\n\n// or piped with the pipe function\nHashSet.make(1, 2, 3).pipe(\n  HashSet.mutate((set) => {\n    HashSet.add(set, 4)\n    HashSet.remove(set, 1)\n  })\n)\n\n// or with data-first API\nHashSet.mutate(HashSet.make(1, 2, 3), (set) => {\n  HashSet.add(set, 4)\n  HashSet.remove(set, 1)\n})'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 1128,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L1128"
    },
    {
      id: "HashSet.add",
      name: "add",
      module: "HashSet",
      package: "effect",
      signature: "{ <A>(value: A): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, value: A): HashSet<A>; }",
      description: "Adds a value to the `HashSet`. Time complexity: `O(1)` average",
      documentation: "Adds a value to the `HashSet`.\n\nTime complexity: **`O(1)`** average",
      examples: [
        {
          code: '// Syntax\nimport { HashSet, pipe } from "effect"\n\n// with data-last, a.k.a. pipeable API\npipe(HashSet.empty(), HashSet.add(0), HashSet.add(0))\n\n// or piped with the pipe function\nHashSet.empty().pipe(HashSet.add(0))\n\n// or with data-first API\nHashSet.add(HashSet.empty(), 0)'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 1228,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L1228"
    },
    {
      id: "HashSet.remove",
      name: "remove",
      module: "HashSet",
      package: "effect",
      signature: "{ <A>(value: A): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, value: A): HashSet<A>; }",
      description: "Removes a value from the `HashSet`. Time complexity: `O(1)` average",
      documentation: "Removes a value from the `HashSet`.\n\nTime complexity: **`O(1)`** average",
      examples: [
        {
          code: '// Syntax\nimport { HashSet, pipe } from "effect"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(HashSet.make(0, 1, 2), HashSet.remove(0))\n\n// or piped with the pipe function\nHashSet.make(0, 1, 2).pipe(HashSet.remove(0))\n\n// or with `data-first` API\nHashSet.remove(HashSet.make(0, 1, 2), 0)'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 1295,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L1295"
    },
    {
      id: "HashSet.difference",
      name: "difference",
      module: "HashSet",
      package: "effect",
      signature: "{ <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>; }",
      description: "Computes the set difference `(A - B)` between this `HashSet` and the\nspecified `Iterable<A>`. Time complexity: `O(n)` where n is the number of elements in the set NOTE: the hash and equal of the values in both the set and the iterable\nmust be the same; meaning we cannot compute a difference between a `HashSet\nof bananas` and a `HashSet of elephants` as they are not the same type and\nwon't implement the Equal trait in the same way.",
      documentation: "Computes the set difference `(A - B)` between this `HashSet` and the\nspecified `Iterable<A>`.\n\nTime complexity: **`O(n)`** where n is the number of elements in the set\n\n**NOTE**: the hash and equal of the values in both the set and the iterable\nmust be the same; meaning we cannot compute a difference between a `HashSet\nof bananas` and a `HashSet of elephants` as they are not the same type and\nwon't implement the Equal trait in the same way.",
      examples: [
        {
          code: '// Syntax\nimport { HashSet, pipe } from "effect"\n\n// with data-last, a.k.a. pipeable API\npipe(HashSet.make(1, 2, 3), HashSet.difference(HashSet.make(3, 4, 5)))\n\n// or piped with the pipe function\nHashSet.make(1, 2, 3).pipe(HashSet.difference(HashSet.make(3, 4, 5)))\n\n// or with data-first API\nHashSet.difference(HashSet.make(1, 2, 3), HashSet.make(3, 4, 5))'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 1364,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L1364"
    },
    {
      id: "HashSet.intersection",
      name: "intersection",
      module: "HashSet",
      package: "effect",
      signature: "{ <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>; }",
      description: "Returns a `HashSet` of values which are present in both this set and that\n`Iterable<A>`. Computes set intersection (A \u2229 B) Time complexity: `O(n)` where n is the number of elements in the smaller\nset NOTE: the hash and equal of the values in both the set and the iterable\nmust be the same.",
      documentation: "Returns a `HashSet` of values which are present in both this set and that\n`Iterable<A>`. Computes set intersection (A \u2229 B)\n\nTime complexity: **`O(n)`** where n is the number of elements in the smaller\nset\n\n**NOTE**: the hash and equal of the values in both the set and the iterable\nmust be the same.",
      examples: [
        {
          code: '// Syntax\nimport { HashSet, pipe } from "effect"\n\n// with data-last, a.k.a. pipeable API\npipe(HashSet.make(1, 2, 3), HashSet.intersection(HashSet.make(2, 3, 4)))\n\n// or piped with the pipe function\nHashSet.make(1, 2, 3).pipe(HashSet.intersection(HashSet.make(2, 3, 4)))\n\n// or with data-first API\nHashSet.intersection(HashSet.make(1, 2, 3), HashSet.make(2, 3, 4))'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 1458,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L1458"
    },
    {
      id: "HashSet.union",
      name: "union",
      module: "HashSet",
      package: "effect",
      signature: "{ <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>; }",
      description: "Computes the set union `( self \u222A that )` between this `HashSet` and the\nspecified `Iterable<A>`. Time complexity: `O(n)` where n is the number of elements in the set NOTE: the hash and equal of the values in both the set and the iterable\nmust be the same.",
      documentation: "Computes the set union `( self \u222A that )` between this `HashSet` and the\nspecified `Iterable<A>`.\n\nTime complexity: **`O(n)`** where n is the number of elements in the set\n\n**NOTE**: the hash and equal of the values in both the set and the iterable\nmust be the same.",
      examples: [
        {
          code: '// Syntax\nimport { HashSet, pipe } from "effect"\n\n// with data-last, a.k.a. pipeable API\npipe(HashSet.make(1, 2, 3), HashSet.union(HashSet.make(3, 4, 5)))\n\n// or piped with the pipe function\nHashSet.make(1, 2, 3).pipe(HashSet.union(HashSet.make(3, 4, 5)))\n\n// or with data-first API\nHashSet.union(HashSet.make(1, 2, 3), HashSet.make(3, 4, 5))'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 1551,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L1551"
    },
    {
      id: "HashSet.toggle",
      name: "toggle",
      module: "HashSet",
      package: "effect",
      signature: "{ <A>(value: A): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, value: A): HashSet<A>; }",
      description: "Checks if a value is present in the `HashSet`. If it is present, the value\nwill be removed from the `HashSet`, otherwise the value will be added to the\n`HashSet`. Time complexity: `O(1)` average",
      documentation: "Checks if a value is present in the `HashSet`. If it is present, the value\nwill be removed from the `HashSet`, otherwise the value will be added to the\n`HashSet`.\n\nTime complexity: **`O(1)`** average",
      examples: [
        {
          code: '// Syntax\nimport { HashSet, pipe } from "effect"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(HashSet.make(0, 1, 2), HashSet.toggle(0))\n\n// or piped with the pipe function\nHashSet.make(0, 1, 2).pipe(HashSet.toggle(0))\n\n// or with `data-first` API\nHashSet.toggle(HashSet.make(0, 1, 2), 0)'
        }
      ],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 1656,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L1656"
    },
    {
      id: "HashSet.map",
      name: "map",
      module: "HashSet",
      package: "effect",
      signature: "{ <A, B>(f: (a: A) => B): (self: HashSet<A>) => HashSet<B>; <A, B>(self: HashSet<A>, f: (a: A) => B): HashSet<B>; }",
      description: "Maps over the values of the `HashSet` using the specified function. The time complexity is of `O(n)`.",
      documentation: "Maps over the values of the `HashSet` using the specified function.\n\nThe time complexity is of **`O(n)`**.",
      examples: [
        {
          code: '// Syntax\nimport { HashSet, pipe } from "effect"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(\n  HashSet.make(0, 1, 2), // HashSet.HashSet<number>\n  HashSet.map(String) // HashSet.HashSet<string>\n)\n\n// or piped with the pipe method\nHashSet.make(0, 1, 2).pipe(HashSet.map(String))\n\n// or with `data-first` API\nHashSet.map(HashSet.make(0, 1, 2), String)'
        }
      ],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 1741,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L1741"
    },
    {
      id: "HashSet.flatMap",
      name: "flatMap",
      module: "HashSet",
      package: "effect",
      signature: "{ <A, B>(f: (a: A) => Iterable<B>): (self: HashSet<A>) => HashSet<B>; <A, B>(self: HashSet<A>, f: (a: A) => Iterable<B>): HashSet<B>; }",
      description: "Chains over the values of the `HashSet` using the specified function. The time complexity is of `O(n)`.",
      documentation: "Chains over the values of the `HashSet` using the specified function.\n\nThe time complexity is of **`O(n)`**.",
      examples: [
        {
          code: '// Syntax\nimport { HashSet, pipe } from "effect"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(\n  HashSet.make(0, 1, 2), // HashSet.HashSet<number>\n  HashSet.flatMap((n) => Array.of(String(n))) // HashSet.HashSet<string>\n)\n\n// or piped with the pipe method\nHashSet.make(0, 1, 2) // HashSet.HashSet<number>\n  .pipe(\n    HashSet.flatMap((n) => Array.of(String(n))) // HashSet.HashSet<string>\n  )\n\n// or with `data-first` API\nHashSet.flatMap(HashSet.make(0, 1, 2), (n) => Array.of(String(n)))'
        }
      ],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 1807,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L1807"
    },
    {
      id: "HashSet.forEach",
      name: "forEach",
      module: "HashSet",
      package: "effect",
      signature: "{ <A>(f: (value: A) => void): (self: HashSet<A>) => void; <A>(self: HashSet<A>, f: (value: A) => void): void; }",
      description: "Applies the specified function to the values of the `HashSet`. The time complexity is of `O(n)`.",
      documentation: "Applies the specified function to the values of the `HashSet`.\n\nThe time complexity is of **`O(n)`**.",
      examples: [
        {
          code: '// Syntax\nimport { HashSet, pipe } from "effect"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(HashSet.make(0, 1, 2), HashSet.forEach(console.log)) // logs: 0 1 2\n\n// or piped with the pipe method\nHashSet.make(0, 1, 2).pipe(HashSet.forEach(console.log)) // logs: 0 1 2\n\n// or with `data-first` API\nHashSet.forEach(HashSet.make(0, 1, 2), console.log) // logs: 0 1 2'
        }
      ],
      tags: [
        "traversing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 1866,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L1866"
    },
    {
      id: "HashSet.reduce",
      name: "reduce",
      module: "HashSet",
      package: "effect",
      signature: "{ <A, Z>(zero: Z, f: (accumulator: Z, value: A) => Z): (self: HashSet<A>) => Z; <A, Z>(self: HashSet<A>, zero: Z, f: (accumulator: Z, value: A) => Z): Z; }",
      description: "Reduces the specified state over the values of the `HashSet`. The time complexity is of `O(n)`.",
      documentation: "Reduces the specified state over the values of the `HashSet`.\n\nThe time complexity is of **`O(n)`**.",
      examples: [
        {
          code: '// Syntax\nimport { HashSet, pipe } from "effect"\n\nconst sum = (a: number, b: number): number => a + b\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(HashSet.make(0, 1, 2), HashSet.reduce(0, sum))\n\n// or with the pipe method\nHashSet.make(0, 1, 2).pipe(HashSet.reduce(0, sum))\n\n// or with `data-first` API\nHashSet.reduce(HashSet.make(0, 1, 2), 0, sum)'
        }
      ],
      tags: [
        "folding"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 1931,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L1931"
    },
    {
      id: "HashSet.filter",
      name: "filter",
      module: "HashSet",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: HashSet<A>) => HashSet<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: HashSet<A>) => HashSet<A>; <A, B extends A>(self: HashSet<A>, refinement: Refinement<A, B>): HashSet<B>; <A>(self: HashSet<A>, predicate: Predicate<A>): HashSet<A>; }",
      description: "Filters values out of a `HashSet` using the specified predicate. The time complexity is of `O(n)`.",
      documentation: "Filters values out of a `HashSet` using the specified predicate.\n\nThe time complexity is of **`O(n)`**.",
      examples: [
        {
          code: '// Syntax with  Predicate\nimport { HashSet, type Predicate, pipe } from "effect"\n\nconst filterPositiveNumbers: Predicate.Predicate<number> = (n) => n > 0\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(\n  HashSet.make(-2, -1, 0, 1, 2),\n  HashSet.filter(filterPositiveNumbers)\n)\n\n// or with the pipe method\nHashSet.make(-2, -1, 0, 1, 2).pipe(HashSet.filter(filterPositiveNumbers))\n\n// or with `data-first` API\nHashSet.filter(HashSet.make(-2, -1, 0, 1, 2), filterPositiveNumbers)'
        },
        {
          code: '/// Syntax with Refinement\nimport { HashSet, pipe } from "effect"\n\nconst stringRefinement = (value: unknown): value is string =>\n  typeof value === "string"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(\n  HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier"), // // HashSet.HashSet<number | string>\n  HashSet.filter(stringRefinement)\n) // HashSet.HashSet<string>\n\n// or with the pipe method\nHashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier") // HashSet.HashSet<number | string>\n  .pipe(HashSet.filter(stringRefinement)) // HashSet.HashSet<string>\n\n// or with `data-first` API\nHashSet.filter(\n  HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier"), // HashSet.HashSet<number | string>\n  stringRefinement\n) // HashSet.HashSet<string>'
        }
      ],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 2023,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L2023"
    },
    {
      id: "HashSet.partition",
      name: "partition",
      module: "HashSet",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: HashSet<A>) => [excluded: HashSet<Exclude<A, B>>, satisfying: HashSet<B>]; <A>(predicate: Predicate<NoInfer<A>>): (self: HashSet<A>) => [excluded: HashSet<A>, satisfying: HashSet<A>]; <A, B extends A>(self: HashSet<A>, refinement: Refinement<A, B>): [excluded: HashSet<Exclude<A, B>>, satisfying: HashSet<B>]; <A>(self: HashSet<A>, predicate: Predicate<A>): [excluded: HashSet<A>, satisfying: HashSet<A>]; }",
      description: "Partition the values of a `HashSet` using the specified predicate. If a value matches the predicate, it will be placed into the `HashSet` on the\nright side of the resulting `Tuple`, otherwise the value will be placed into\nthe left side. Time complexity is of `O(n)`.",
      documentation: "Partition the values of a `HashSet` using the specified predicate.\n\nIf a value matches the predicate, it will be placed into the `HashSet` on the\nright side of the resulting `Tuple`, otherwise the value will be placed into\nthe left side.\n\nTime complexity is of **`O(n)`**.",
      examples: [
        {
          code: '// Syntax with Predicate\nimport { HashSet, pipe, Predicate } from "effect"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(\n  HashSet.make(0, 1, 2, 3, 4, 5),\n  HashSet.partition((n) => n % 2 === 0)\n)\n\n// or with the pipe method\nHashSet.make(0, 1, 2, 3, 4, 5).pipe(\n  HashSet.partition((n) => n % 2 === 0)\n)\n\n// or with `data-first` API\nHashSet.partition(HashSet.make(0, 1, 2, 3, 4, 5), (n) => n % 2 === 0)'
        },
        {
          code: '// Syntax with Refinement\nimport { HashSet, pipe, Predicate } from "effect"\n\nconst stringRefinement: Predicate.Refinement<string | number, string> = (\n  value\n) => typeof value === "string"\n\n// with `data-last`, a.k.a. `pipeable` API\npipe(\n  HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier"),\n  HashSet.partition(stringRefinement)\n)\n\n// or with the pipe method\nHashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier").pipe(\n  HashSet.partition(stringRefinement)\n)\n\n// or with `data-first` API\nHashSet.partition(\n  HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier"),\n  stringRefinement\n)'
        }
      ],
      tags: [
        "partitioning"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/HashSet.d.ts",
      sourceLine: 2172,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HashSet.ts#L2172"
    },
    {
      id: "List.TypeId",
      name: "TypeId",
      module: "List",
      package: "effect",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbol"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 38,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L38"
    },
    {
      id: "List.toArray",
      name: "toArray",
      module: "List",
      package: "effect",
      signature: "<A>(self: List<A>) => A[]",
      description: "Converts the specified `List` to an `Array`.",
      documentation: "Converts the specified `List` to an `Array`.",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 68,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L68"
    },
    {
      id: "List.getEquivalence",
      name: "getEquivalence",
      module: "List",
      package: "effect",
      signature: "<A>(isEquivalent: Equivalence<A>) => Equivalence<List<A>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "equivalence"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 73,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L73"
    },
    {
      id: "List.isList",
      name: "isList",
      module: "List",
      package: "effect",
      signature: "{ <A>(u: Iterable<A>): u is List<A>; (u: unknown): u is List<unknown>; }",
      description: "Returns `true` if the specified value is a `List`, `false` otherwise.",
      documentation: "Returns `true` if the specified value is a `List`, `false` otherwise.",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 80,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L80"
    },
    {
      id: "List.isNil",
      name: "isNil",
      module: "List",
      package: "effect",
      signature: "<A>(self: List<A>) => self is Nil<A>",
      description: "Returns `true` if the specified value is a `List.Nil<A>`, `false` otherwise.",
      documentation: "Returns `true` if the specified value is a `List.Nil<A>`, `false` otherwise.",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 102,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L102"
    },
    {
      id: "List.isCons",
      name: "isCons",
      module: "List",
      package: "effect",
      signature: "<A>(self: List<A>) => self is Cons<A>",
      description: "Returns `true` if the specified value is a `List.Cons<A>`, `false` otherwise.",
      documentation: "Returns `true` if the specified value is a `List.Cons<A>`, `false` otherwise.",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 109,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L109"
    },
    {
      id: "List.size",
      name: "size",
      module: "List",
      package: "effect",
      signature: "<A>(self: List<A>) => number",
      description: "Returns the number of elements contained in the specified `List`",
      documentation: "Returns the number of elements contained in the specified `List`",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 116,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L116"
    },
    {
      id: "List.nil",
      name: "nil",
      module: "List",
      package: "effect",
      signature: "<A = never>() => List<A>",
      description: "Constructs a new empty `List<A>`.",
      documentation: "Constructs a new empty `List<A>`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 123,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L123"
    },
    {
      id: "List.cons",
      name: "cons",
      module: "List",
      package: "effect",
      signature: "<A>(head: A, tail: List<A>) => Cons<A>",
      description: "Constructs a new `List.Cons<A>` from the specified `head` and `tail` values.",
      documentation: "Constructs a new `List.Cons<A>` from the specified `head` and `tail` values.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 130,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L130"
    },
    {
      id: "List.empty",
      name: "empty",
      module: "List",
      package: "effect",
      signature: "<A = never>() => List<A>",
      description: "/\n * Constructs a new empty `List<A>`.\n *\n * Alias of {@link nil}.\n *\n *",
      documentation: "/**\n * Constructs a new empty `List<A>`.\n *\n * Alias of {@link nil}.\n *\n *",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 139,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L139"
    },
    {
      id: "List.of",
      name: "of",
      module: "List",
      package: "effect",
      signature: "<A>(value: A) => Cons<A>",
      description: "Constructs a new `List<A>` from the specified value.",
      documentation: "Constructs a new `List<A>` from the specified value.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 146,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L146"
    },
    {
      id: "List.fromIterable",
      name: "fromIterable",
      module: "List",
      package: "effect",
      signature: "<A>(prefix: Iterable<A>) => List<A>",
      description: "Creates a new `List` from an iterable collection of values.",
      documentation: "Creates a new `List` from an iterable collection of values.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 153,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L153"
    },
    {
      id: "List.make",
      name: "make",
      module: "List",
      package: "effect",
      signature: "<Elements extends readonly [any, ...Array<any>]>(...elements: Elements) => Cons<Elements[number]>",
      description: "Constructs a new `List<A>` from the specified values.",
      documentation: "Constructs a new `List<A>` from the specified values.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 160,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L160"
    },
    {
      id: "List.append",
      name: "append",
      module: "List",
      package: "effect",
      signature: "{ <B>(element: B): <A>(self: List<A>) => Cons<B | A>; <A, B>(self: List<A>, element: B): Cons<A | B>; }",
      description: "Appends the specified element to the end of the `List`, creating a new `Cons`.",
      documentation: "Appends the specified element to the end of the `List`, creating a new `Cons`.",
      examples: [],
      tags: [
        "concatenating"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 167,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L167"
    },
    {
      id: "List.appendAll",
      name: "appendAll",
      module: "List",
      package: "effect",
      signature: "{ <S extends List<any>, T extends List<any>>(that: T): (self: S) => List.OrNonEmpty<S, T, List.Infer<S> | List.Infer<T>>; <A, B>(self: List<A>, that: Cons<B>): Cons<A | B>; <A, B>(self: Cons<A>, that: List<B>): Cons<A | B>; <A, B>(self: List<A>, that: List<B>): List<A | B>; }",
      description: "Concatenates two lists, combining their elements.\nIf either list is non-empty, the result is also a non-empty list.",
      documentation: "Concatenates two lists, combining their elements.\nIf either list is non-empty, the result is also a non-empty list.",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { List } from "effect"\n\nassert.deepStrictEqual(\n  List.make(1, 2).pipe(List.appendAll(List.make("a", "b")), List.toArray),\n  [1, 2, "a", "b"]\n)'
        }
      ],
      tags: [
        "concatenating"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 201,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L201"
    },
    {
      id: "List.prepend",
      name: "prepend",
      module: "List",
      package: "effect",
      signature: "{ <B>(element: B): <A>(self: List<A>) => Cons<B | A>; <A, B>(self: List<A>, element: B): Cons<A | B>; }",
      description: "Prepends the specified element to the beginning of the list.",
      documentation: "Prepends the specified element to the beginning of the list.",
      examples: [],
      tags: [
        "concatenating"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 285,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L285"
    },
    {
      id: "List.prependAll",
      name: "prependAll",
      module: "List",
      package: "effect",
      signature: "{ <S extends List<any>, T extends List<any>>(that: T): (self: S) => List.OrNonEmpty<S, T, List.Infer<S> | List.Infer<T>>; <A, B>(self: List<A>, that: Cons<B>): Cons<A | B>; <A, B>(self: Cons<A>, that: List<B>): Cons<A | B>; <A, B>(self: List<A>, that: List<B>): List<A | B>; }",
      description: "Prepends the specified prefix list to the beginning of the specified list.\nIf either list is non-empty, the result is also a non-empty list.",
      documentation: "Prepends the specified prefix list to the beginning of the specified list.\nIf either list is non-empty, the result is also a non-empty list.",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { List } from "effect"\n\nassert.deepStrictEqual(\n  List.make(1, 2).pipe(List.prependAll(List.make("a", "b")), List.toArray),\n  ["a", "b", 1, 2]\n)'
        }
      ],
      tags: [
        "concatenating"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 319,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L319"
    },
    {
      id: "List.prependAllReversed",
      name: "prependAllReversed",
      module: "List",
      package: "effect",
      signature: "{ <B>(prefix: List<B>): <A>(self: List<A>) => List<B | A>; <A, B>(self: List<A>, prefix: List<B>): List<A | B>; }",
      description: "Prepends the specified prefix list (in reverse order) to the beginning of the\nspecified list.",
      documentation: "Prepends the specified prefix list (in reverse order) to the beginning of the\nspecified list.",
      examples: [],
      tags: [
        "concatenating"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 404,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L404"
    },
    {
      id: "List.drop",
      name: "drop",
      module: "List",
      package: "effect",
      signature: "{ (n: number): <A>(self: List<A>) => List<A>; <A>(self: List<A>, n: number): List<A>; }",
      description: "Drops the first `n` elements from the specified list.",
      documentation: "Drops the first `n` elements from the specified list.",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 428,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L428"
    },
    {
      id: "List.every",
      name: "every",
      module: "List",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => self is List<B>; <A>(predicate: Predicate<A>): (self: List<A>) => boolean; <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): self is List<B>; <A>(self: List<A>, predicate: Predicate<A>): boolean; }",
      description: "Check if a predicate holds true for every `List` element.",
      documentation: "Check if a predicate holds true for every `List` element.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 450,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L450"
    },
    {
      id: "List.some",
      name: "some",
      module: "List",
      package: "effect",
      signature: "{ <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => self is Cons<A>; <A>(self: List<A>, predicate: Predicate<A>): self is Cons<A>; }",
      description: "Check if a predicate holds true for some `List` element.",
      documentation: "Check if a predicate holds true for some `List` element.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 486,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L486"
    },
    {
      id: "List.filter",
      name: "filter",
      module: "List",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => List<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => List<A>; <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): List<B>; <A>(self: List<A>, predicate: Predicate<A>): List<A>; }",
      description: "Filters a list using the specified predicate.",
      documentation: "Filters a list using the specified predicate.",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 508,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L508"
    },
    {
      id: "List.filterMap",
      name: "filterMap",
      module: "List",
      package: "effect",
      signature: "{ <A, B>(f: (a: A) => Option<B>): (self: List<A>) => List<B>; <A, B>(self: List<A>, f: (a: A) => Option<B>): List<B>; }",
      description: "Filters and maps a list using the specified partial function. The resulting\nlist may be smaller than the input list due to the possibility of the partial\nfunction not being defined for some elements.",
      documentation: "Filters and maps a list using the specified partial function. The resulting\nlist may be smaller than the input list due to the possibility of the partial\nfunction not being defined for some elements.",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 546,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L546"
    },
    {
      id: "List.compact",
      name: "compact",
      module: "List",
      package: "effect",
      signature: "<A>(self: List<Option<A>>) => List<A>",
      description: "Removes all `None` values from the specified list.",
      documentation: "Removes all `None` values from the specified list.",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 572,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L572"
    },
    {
      id: "List.findFirst",
      name: "findFirst",
      module: "List",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => Option<A>; <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): Option<B>; <A>(self: List<A>, predicate: Predicate<A>): Option<A>; }",
      description: "Returns the first element that satisfies the specified\npredicate, or `None` if no such element exists.",
      documentation: "Returns the first element that satisfies the specified\npredicate, or `None` if no such element exists.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 580,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L580"
    },
    {
      id: "List.flatMap",
      name: "flatMap",
      module: "List",
      package: "effect",
      signature: "{ <S extends List<any>, T extends List<any>>(f: (a: List.Infer<S>, i: number) => T): (self: S) => List.AndNonEmpty<S, T, List.Infer<T>>; <A, B>(self: Cons<A>, f: (a: A, i: number) => Cons<B>): Cons<B>; <A, B>(self: List<A>, f: (a: A, i: number) => List<B>): List<B>; }",
      description: "Applies a function to each element in a list and returns a new list containing the concatenated mapped elements.",
      documentation: "Applies a function to each element in a list and returns a new list containing the concatenated mapped elements.",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 620,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L620"
    },
    {
      id: "List.forEach",
      name: "forEach",
      module: "List",
      package: "effect",
      signature: "{ <A, B>(f: (a: A) => B): (self: List<A>) => void; <A, B>(self: List<A>, f: (a: A) => B): void; }",
      description: "Applies the specified function to each element of the `List`.",
      documentation: "Applies the specified function to each element of the `List`.",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 649,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L649"
    },
    {
      id: "List.head",
      name: "head",
      module: "List",
      package: "effect",
      signature: "<A>(self: List<A>) => Option<A>",
      description: "Returns the first element of the specified list, or `None` if the list is\nempty.",
      documentation: "Returns the first element of the specified list, or `None` if the list is\nempty.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 672,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L672"
    },
    {
      id: "List.last",
      name: "last",
      module: "List",
      package: "effect",
      signature: "<A>(self: List<A>) => Option<A>",
      description: "Returns the last element of the specified list, or `None` if the list is\nempty.",
      documentation: "Returns the last element of the specified list, or `None` if the list is\nempty.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 680,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L680"
    },
    {
      id: "List.map",
      name: "map",
      module: "List",
      package: "effect",
      signature: "{ <S extends List<any>, B>(f: (a: List.Infer<S>, i: number) => B): (self: S) => List.With<S, B>; <S extends List<any>, B>(self: S, f: (a: List.Infer<S>, i: number) => B): List.With<S, B>; }",
      description: "Applies the specified mapping function to each element of the list.",
      documentation: "Applies the specified mapping function to each element of the list.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 708,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L708"
    },
    {
      id: "List.partition",
      name: "partition",
      module: "List",
      package: "effect",
      signature: "{ <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => [excluded: List<Exclude<A, B>>, satisfying: List<B>]; <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => [excluded: List<A>, satisfying: List<A>]; <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): [excluded: List<Exclude<A, B>>, satisfying: List<B>]; <A>(self: List<A>, predicate: Predicate<A>): [excluded: List<A>, satisfying: List<A>]; }",
      description: "Partition a list into two lists, where the first list contains all elements\nthat did not satisfy the specified predicate, and the second list contains\nall elements that did satisfy the specified predicate.",
      documentation: "Partition a list into two lists, where the first list contains all elements\nthat did not satisfy the specified predicate, and the second list contains\nall elements that did satisfy the specified predicate.",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 732,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L732"
    },
    {
      id: "List.partitionMap",
      name: "partitionMap",
      module: "List",
      package: "effect",
      signature: "{ <A, B, C>(f: (a: A) => Either<C, B>): (self: List<A>) => [left: List<B>, right: List<C>]; <A, B, C>(self: List<A>, f: (a: A) => Either<C, B>): [left: List<B>, right: List<C>]; }",
      description: "Partition a list into two lists, where the first list contains all elements\nfor which the specified function returned a `Left`, and the second list\ncontains all elements for which the specified function returned a `Right`.",
      documentation: "Partition a list into two lists, where the first list contains all elements\nfor which the specified function returned a `Left`, and the second list\ncontains all elements for which the specified function returned a `Right`.",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 778,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L778"
    },
    {
      id: "List.reduce",
      name: "reduce",
      module: "List",
      package: "effect",
      signature: "{ <Z, A>(zero: Z, f: (b: Z, a: A) => Z): (self: List<A>) => Z; <A, Z>(self: List<A>, zero: Z, f: (b: Z, a: A) => Z): Z; }",
      description: "Folds over the elements of the list using the specified function, using the\nspecified initial value.",
      documentation: "Folds over the elements of the list using the specified function, using the\nspecified initial value.",
      examples: [],
      tags: [
        "folding"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 805,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L805"
    },
    {
      id: "List.reduceRight",
      name: "reduceRight",
      module: "List",
      package: "effect",
      signature: "{ <Z, A>(zero: Z, f: (accumulator: Z, value: A) => Z): (self: List<A>) => Z; <Z, A>(self: List<A>, zero: Z, f: (accumulator: Z, value: A) => Z): Z; }",
      description: "Folds over the elements of the list using the specified function, beginning\nwith the last element of the list, using the specified initial value.",
      documentation: "Folds over the elements of the list using the specified function, beginning\nwith the last element of the list, using the specified initial value.",
      examples: [],
      tags: [
        "folding"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 830,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L830"
    },
    {
      id: "List.reverse",
      name: "reverse",
      module: "List",
      package: "effect",
      signature: "<A>(self: List<A>) => List<A>",
      description: "Returns a new list with the elements of the specified list in reverse order.",
      documentation: "Returns a new list with the elements of the specified list in reverse order.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 854,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L854"
    },
    {
      id: "List.splitAt",
      name: "splitAt",
      module: "List",
      package: "effect",
      signature: "{ (n: number): <A>(self: List<A>) => [beforeIndex: List<A>, fromIndex: List<A>]; <A>(self: List<A>, n: number): [beforeIndex: List<A>, fromIndex: List<A>]; }",
      description: "Splits the specified list into two lists at the specified index.",
      documentation: "Splits the specified list into two lists at the specified index.",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 861,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L861"
    },
    {
      id: "List.tail",
      name: "tail",
      module: "List",
      package: "effect",
      signature: "<A>(self: List<A>) => Option<List<A>>",
      description: "Returns the tail of the specified list, or `None` if the list is empty.",
      documentation: "Returns the tail of the specified list, or `None` if the list is empty.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 883,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L883"
    },
    {
      id: "List.take",
      name: "take",
      module: "List",
      package: "effect",
      signature: "{ (n: number): <A>(self: List<A>) => List<A>; <A>(self: List<A>, n: number): List<A>; }",
      description: "Takes the specified number of elements from the beginning of the specified\nlist.",
      documentation: "Takes the specified number of elements from the beginning of the specified\nlist.",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 891,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L891"
    },
    {
      id: "List.toChunk",
      name: "toChunk",
      module: "List",
      package: "effect",
      signature: "<A>(self: List<A>) => Chunk<A>",
      description: "Converts the specified `List` to a `Chunk`.",
      documentation: "Converts the specified `List` to a `Chunk`.",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 915,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L915"
    },
    {
      id: "List.unsafeHead",
      name: "unsafeHead",
      module: "List",
      package: "effect",
      signature: "<A>(self: List<A>) => A",
      description: "Unsafely returns the first element of the specified `List`.",
      documentation: "Unsafely returns the first element of the specified `List`.",
      examples: [],
      tags: [
        "unsafe"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 922,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L922"
    },
    {
      id: "List.unsafeLast",
      name: "unsafeLast",
      module: "List",
      package: "effect",
      signature: "<A>(self: List<A>) => A",
      description: "Unsafely returns the last element of the specified `List`.",
      documentation: "Unsafely returns the last element of the specified `List`.",
      examples: [],
      tags: [
        "unsafe"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 929,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L929"
    },
    {
      id: "List.unsafeTail",
      name: "unsafeTail",
      module: "List",
      package: "effect",
      signature: "<A>(self: List<A>) => List<A>",
      description: "Unsafely returns the tail of the specified `List`.",
      documentation: "Unsafely returns the tail of the specified `List`.",
      examples: [],
      tags: [
        "unsafe"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/List.d.ts",
      sourceLine: 936,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/List.ts#L936"
    },
    {
      id: "SortedMap.isSortedMap",
      name: "isSortedMap",
      module: "SortedMap",
      package: "effect",
      signature: "{ <K, V>(u: Iterable<readonly [K, V]>): u is SortedMap<K, V>; (u: unknown): u is SortedMap<unknown, unknown>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedMap.d.ts",
      sourceLine: 30,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedMap.ts#L30"
    },
    {
      id: "SortedMap.empty",
      name: "empty",
      module: "SortedMap",
      package: "effect",
      signature: "<K, V = never>(ord: Order<K>) => SortedMap<K, V>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedMap.d.ts",
      sourceLine: 46,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedMap.ts#L46"
    },
    {
      id: "SortedMap.fromIterable",
      name: "fromIterable",
      module: "SortedMap",
      package: "effect",
      signature: "{ <B>(ord: Order<B>): <K extends B, V>(iterable: Iterable<readonly [K, V]>) => SortedMap<K, V>; <K extends B, V, B>(iterable: Iterable<readonly [K, V]>, ord: Order<B>): SortedMap<K, V>; }",
      description: "Creates a new `SortedMap` from an iterable collection of key/value pairs.",
      documentation: "Creates a new `SortedMap` from an iterable collection of key/value pairs.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedMap.d.ts",
      sourceLine: 53,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedMap.ts#L53"
    },
    {
      id: "SortedMap.make",
      name: "make",
      module: "SortedMap",
      package: "effect",
      signature: "<K>(ord: Order<K>) => <Entries extends ReadonlyArray<readonly [K, any]>>(...entries: Entries) => SortedMap<K, Entries[number] extends readonly [any, infer V] ? V : never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedMap.d.ts",
      sourceLine: 73,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedMap.ts#L73"
    },
    {
      id: "SortedMap.isEmpty",
      name: "isEmpty",
      module: "SortedMap",
      package: "effect",
      signature: "<K, V>(self: SortedMap<K, V>) => boolean",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "predicates"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedMap.d.ts",
      sourceLine: 78,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedMap.ts#L78"
    },
    {
      id: "SortedMap.isNonEmpty",
      name: "isNonEmpty",
      module: "SortedMap",
      package: "effect",
      signature: "<K, V>(self: SortedMap<K, V>) => boolean",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "predicates"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedMap.d.ts",
      sourceLine: 83,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedMap.ts#L83"
    },
    {
      id: "SortedMap.get",
      name: "get",
      module: "SortedMap",
      package: "effect",
      signature: "{ <K>(key: K): <V>(self: SortedMap<K, V>) => Option<V>; <K, V>(self: SortedMap<K, V>, key: K): Option<V>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedMap.d.ts",
      sourceLine: 88,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedMap.ts#L88"
    },
    {
      id: "SortedMap.getOrder",
      name: "getOrder",
      module: "SortedMap",
      package: "effect",
      signature: "<K, V>(self: SortedMap<K, V>) => Order<K>",
      description: "Gets the `Order<K>` that the `SortedMap<K, V>` is using.",
      documentation: "Gets the `Order<K>` that the `SortedMap<K, V>` is using.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedMap.d.ts",
      sourceLine: 106,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedMap.ts#L106"
    },
    {
      id: "SortedMap.has",
      name: "has",
      module: "SortedMap",
      package: "effect",
      signature: "{ <K>(key: K): <V>(self: SortedMap<K, V>) => boolean; <K, V>(self: SortedMap<K, V>, key: K): boolean; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedMap.d.ts",
      sourceLine: 111,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedMap.ts#L111"
    },
    {
      id: "SortedMap.headOption",
      name: "headOption",
      module: "SortedMap",
      package: "effect",
      signature: "<K, V>(self: SortedMap<K, V>) => Option<[K, V]>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedMap.d.ts",
      sourceLine: 127,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedMap.ts#L127"
    },
    {
      id: "SortedMap.map",
      name: "map",
      module: "SortedMap",
      package: "effect",
      signature: "{ <A, K, B>(f: (a: A, k: K) => B): (self: SortedMap<K, A>) => SortedMap<K, B>; <K, A, B>(self: SortedMap<K, A>, f: (a: A, k: K) => B): SortedMap<K, B>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedMap.d.ts",
      sourceLine: 132,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedMap.ts#L132"
    },
    {
      id: "SortedMap.reduce",
      name: "reduce",
      module: "SortedMap",
      package: "effect",
      signature: "{ <B, A, K>(zero: B, f: (acc: B, value: A, key: K) => B): (self: SortedMap<K, A>) => B; <K, A, B>(self: SortedMap<K, A>, zero: B, f: (acc: B, value: A, key: K) => B): B; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "folding"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedMap.d.ts",
      sourceLine: 148,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedMap.ts#L148"
    },
    {
      id: "SortedMap.remove",
      name: "remove",
      module: "SortedMap",
      package: "effect",
      signature: "{ <K>(key: K): <V>(self: SortedMap<K, V>) => SortedMap<K, V>; <K, V>(self: SortedMap<K, V>, key: K): SortedMap<K, V>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedMap.d.ts",
      sourceLine: 164,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedMap.ts#L164"
    },
    {
      id: "SortedMap.set",
      name: "set",
      module: "SortedMap",
      package: "effect",
      signature: "{ <K, V>(key: K, value: V): (self: SortedMap<K, V>) => SortedMap<K, V>; <K, V>(self: SortedMap<K, V>, key: K, value: V): SortedMap<K, V>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedMap.d.ts",
      sourceLine: 180,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedMap.ts#L180"
    },
    {
      id: "SortedMap.size",
      name: "size",
      module: "SortedMap",
      package: "effect",
      signature: "<K, V>(self: SortedMap<K, V>) => number",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedMap.d.ts",
      sourceLine: 196,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedMap.ts#L196"
    },
    {
      id: "SortedMap.keys",
      name: "keys",
      module: "SortedMap",
      package: "effect",
      signature: "<K, V>(self: SortedMap<K, V>) => IterableIterator<K>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedMap.d.ts",
      sourceLine: 201,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedMap.ts#L201"
    },
    {
      id: "SortedMap.values",
      name: "values",
      module: "SortedMap",
      package: "effect",
      signature: "<K, V>(self: SortedMap<K, V>) => IterableIterator<V>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedMap.d.ts",
      sourceLine: 206,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedMap.ts#L206"
    },
    {
      id: "SortedMap.entries",
      name: "entries",
      module: "SortedMap",
      package: "effect",
      signature: "<K, V>(self: SortedMap<K, V>) => IterableIterator<[K, V]>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedMap.d.ts",
      sourceLine: 211,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedMap.ts#L211"
    },
    {
      id: "SortedMap.lastOption",
      name: "lastOption",
      module: "SortedMap",
      package: "effect",
      signature: "<K, V>(self: SortedMap<K, V>) => Option<[K, V]>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "elements"
      ],
      since: "3.1.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedMap.d.ts",
      sourceLine: 216,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedMap.ts#L216"
    },
    {
      id: "SortedMap.partition",
      name: "partition",
      module: "SortedMap",
      package: "effect",
      signature: "{ <K, V>(predicate: (a: NoInfer<K>) => boolean): (self: SortedMap<K, V>) => [excluded: SortedMap<K, V>, satisfying: SortedMap<K, V>]; <K, V>(self: SortedMap<K, V>, predicate: (a: K) => boolean): [excluded: SortedMap<K, V>, satisfying: SortedMap<K, V>]; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "filtering"
      ],
      since: "3.1.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedMap.d.ts",
      sourceLine: 221,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedMap.ts#L221"
    },
    {
      id: "SortedSet.isSortedSet",
      name: "isSortedSet",
      module: "SortedSet",
      package: "effect",
      signature: "{ <A>(u: Iterable<A>): u is SortedSet<A>; (u: unknown): u is SortedSet<unknown>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedSet.d.ts",
      sourceLine: 30,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedSet.ts#L30"
    },
    {
      id: "SortedSet.empty",
      name: "empty",
      module: "SortedSet",
      package: "effect",
      signature: "<A>(O: Order<A>) => SortedSet<A>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedSet.d.ts",
      sourceLine: 46,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedSet.ts#L46"
    },
    {
      id: "SortedSet.fromIterable",
      name: "fromIterable",
      module: "SortedSet",
      package: "effect",
      signature: "{ <B>(ord: Order<B>): <A extends B>(iterable: Iterable<A>) => SortedSet<A>; <A extends B, B>(iterable: Iterable<A>, ord: Order<B>): SortedSet<A>; }",
      description: "Creates a new `SortedSet` from an iterable collection of values.",
      documentation: "Creates a new `SortedSet` from an iterable collection of values.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedSet.d.ts",
      sourceLine: 53,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedSet.ts#L53"
    },
    {
      id: "SortedSet.make",
      name: "make",
      module: "SortedSet",
      package: "effect",
      signature: "<K>(ord: Order<K>) => <Entries extends ReadonlyArray<K>>(...entries: Entries) => SortedSet<Entries[number]>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedSet.d.ts",
      sourceLine: 73,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedSet.ts#L73"
    },
    {
      id: "SortedSet.add",
      name: "add",
      module: "SortedSet",
      package: "effect",
      signature: "{ <A>(value: A): (self: SortedSet<A>) => SortedSet<A>; <A>(self: SortedSet<A>, value: A): SortedSet<A>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedSet.d.ts",
      sourceLine: 78,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedSet.ts#L78"
    },
    {
      id: "SortedSet.difference",
      name: "difference",
      module: "SortedSet",
      package: "effect",
      signature: "{ <A, B extends A>(that: Iterable<B>): (self: SortedSet<A>) => SortedSet<A>; <A, B extends A>(self: SortedSet<A>, that: Iterable<B>): SortedSet<A>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedSet.d.ts",
      sourceLine: 93,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedSet.ts#L93"
    },
    {
      id: "SortedSet.every",
      name: "every",
      module: "SortedSet",
      package: "effect",
      signature: "{ <A>(predicate: Predicate<A>): (self: SortedSet<A>) => boolean; <A>(self: SortedSet<A>, predicate: Predicate<A>): boolean; }",
      description: "Check if a predicate holds true for every `SortedSet` element.",
      documentation: "Check if a predicate holds true for every `SortedSet` element.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedSet.d.ts",
      sourceLine: 109,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedSet.ts#L109"
    },
    {
      id: "SortedSet.filter",
      name: "filter",
      module: "SortedSet",
      package: "effect",
      signature: "{ <A, B extends A>(predicate: Predicate<B>): (self: SortedSet<A>) => SortedSet<A>; <A>(self: SortedSet<A>, predicate: Predicate<A>): SortedSet<A>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedSet.d.ts",
      sourceLine: 129,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedSet.ts#L129"
    },
    {
      id: "SortedSet.flatMap",
      name: "flatMap",
      module: "SortedSet",
      package: "effect",
      signature: "{ <B, A>(O: Order<B>, f: (a: A) => Iterable<B>): (self: SortedSet<A>) => SortedSet<B>; <A, B>(self: SortedSet<A>, O: Order<B>, f: (a: A) => Iterable<B>): SortedSet<B>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "sequencing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedSet.d.ts",
      sourceLine: 145,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedSet.ts#L145"
    },
    {
      id: "SortedSet.forEach",
      name: "forEach",
      module: "SortedSet",
      package: "effect",
      signature: "{ <A>(f: (a: A) => void): (self: SortedSet<A>) => void; <A>(self: SortedSet<A>, f: (a: A) => void): void; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "traversing"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedSet.d.ts",
      sourceLine: 161,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedSet.ts#L161"
    },
    {
      id: "SortedSet.has",
      name: "has",
      module: "SortedSet",
      package: "effect",
      signature: "{ <A>(value: A): (self: SortedSet<A>) => boolean; <A>(self: SortedSet<A>, value: A): boolean; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedSet.d.ts",
      sourceLine: 177,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedSet.ts#L177"
    },
    {
      id: "SortedSet.intersection",
      name: "intersection",
      module: "SortedSet",
      package: "effect",
      signature: "{ <A>(that: Iterable<A>): (self: SortedSet<A>) => SortedSet<A>; <A>(self: SortedSet<A>, that: Iterable<A>): SortedSet<A>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedSet.d.ts",
      sourceLine: 192,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedSet.ts#L192"
    },
    {
      id: "SortedSet.isSubset",
      name: "isSubset",
      module: "SortedSet",
      package: "effect",
      signature: "{ <A>(that: SortedSet<A>): (self: SortedSet<A>) => boolean; <A>(self: SortedSet<A>, that: SortedSet<A>): boolean; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedSet.d.ts",
      sourceLine: 206,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedSet.ts#L206"
    },
    {
      id: "SortedSet.map",
      name: "map",
      module: "SortedSet",
      package: "effect",
      signature: "{ <B, A>(O: Order<B>, f: (a: A) => B): (self: SortedSet<A>) => SortedSet<B>; <B, A>(self: SortedSet<A>, O: Order<B>, f: (a: A) => B): SortedSet<B>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedSet.d.ts",
      sourceLine: 222,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedSet.ts#L222"
    },
    {
      id: "SortedSet.partition",
      name: "partition",
      module: "SortedSet",
      package: "effect",
      signature: "{ <A>(predicate: (a: NoInfer<A>) => boolean): (self: SortedSet<A>) => [excluded: SortedSet<A>, satisfying: SortedSet<A>]; <A>(self: SortedSet<A>, predicate: (a: A) => boolean): [excluded: SortedSet<A>, satisfying: SortedSet<A>]; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "filtering"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedSet.d.ts",
      sourceLine: 238,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedSet.ts#L238"
    },
    {
      id: "SortedSet.remove",
      name: "remove",
      module: "SortedSet",
      package: "effect",
      signature: "{ <A>(value: A): (self: SortedSet<A>) => SortedSet<A>; <A>(self: SortedSet<A>, value: A): SortedSet<A>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedSet.d.ts",
      sourceLine: 254,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedSet.ts#L254"
    },
    {
      id: "SortedSet.size",
      name: "size",
      module: "SortedSet",
      package: "effect",
      signature: "<A>(self: SortedSet<A>) => number",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedSet.d.ts",
      sourceLine: 270,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedSet.ts#L270"
    },
    {
      id: "SortedSet.some",
      name: "some",
      module: "SortedSet",
      package: "effect",
      signature: "{ <A>(predicate: Predicate<A>): (self: SortedSet<A>) => boolean; <A>(self: SortedSet<A>, predicate: Predicate<A>): boolean; }",
      description: "Check if a predicate holds true for some `SortedSet` element.",
      documentation: "Check if a predicate holds true for some `SortedSet` element.",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedSet.d.ts",
      sourceLine: 277,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedSet.ts#L277"
    },
    {
      id: "SortedSet.toggle",
      name: "toggle",
      module: "SortedSet",
      package: "effect",
      signature: "{ <A>(value: A): (self: SortedSet<A>) => SortedSet<A>; <A>(self: SortedSet<A>, value: A): SortedSet<A>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "elements"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedSet.d.ts",
      sourceLine: 297,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedSet.ts#L297"
    },
    {
      id: "SortedSet.union",
      name: "union",
      module: "SortedSet",
      package: "effect",
      signature: "{ <A>(that: Iterable<A>): (self: SortedSet<A>) => SortedSet<A>; <A>(self: SortedSet<A>, that: Iterable<A>): SortedSet<A>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedSet.d.ts",
      sourceLine: 312,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedSet.ts#L312"
    },
    {
      id: "SortedSet.values",
      name: "values",
      module: "SortedSet",
      package: "effect",
      signature: "<A>(self: SortedSet<A>) => IterableIterator<A>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedSet.d.ts",
      sourceLine: 326,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedSet.ts#L326"
    },
    {
      id: "SortedSet.getEquivalence",
      name: "getEquivalence",
      module: "SortedSet",
      package: "effect",
      signature: "<A>() => Equivalence<SortedSet<A>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "equivalence"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/SortedSet.d.ts",
      sourceLine: 331,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SortedSet.ts#L331"
    },
    {
      id: "Duration.decode",
      name: "decode",
      module: "Duration",
      package: "effect",
      signature: "(input: DurationInput) => Duration",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 50,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L50"
    },
    {
      id: "Duration.decodeUnknown",
      name: "decodeUnknown",
      module: "Duration",
      package: "effect",
      signature: "(u: unknown) => Option<Duration>",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "2.5.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 54,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L54"
    },
    {
      id: "Duration.isDuration",
      name: "isDuration",
      module: "Duration",
      package: "effect",
      signature: "(u: unknown) => u is Duration",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 59,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L59"
    },
    {
      id: "Duration.isFinite",
      name: "isFinite",
      module: "Duration",
      package: "effect",
      signature: "(self: Duration) => boolean",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "guards"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 64,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L64"
    },
    {
      id: "Duration.isZero",
      name: "isZero",
      module: "Duration",
      package: "effect",
      signature: "(self: Duration) => boolean",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "guards"
      ],
      since: "3.5.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 69,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L69"
    },
    {
      id: "Duration.zero",
      name: "zero",
      module: "Duration",
      package: "effect",
      signature: "Duration",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 74,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L74"
    },
    {
      id: "Duration.infinity",
      name: "infinity",
      module: "Duration",
      package: "effect",
      signature: "Duration",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 79,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L79"
    },
    {
      id: "Duration.nanos",
      name: "nanos",
      module: "Duration",
      package: "effect",
      signature: "(nanos: bigint) => Duration",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 84,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L84"
    },
    {
      id: "Duration.micros",
      name: "micros",
      module: "Duration",
      package: "effect",
      signature: "(micros: bigint) => Duration",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 89,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L89"
    },
    {
      id: "Duration.millis",
      name: "millis",
      module: "Duration",
      package: "effect",
      signature: "(millis: number) => Duration",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 94,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L94"
    },
    {
      id: "Duration.seconds",
      name: "seconds",
      module: "Duration",
      package: "effect",
      signature: "(seconds: number) => Duration",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 99,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L99"
    },
    {
      id: "Duration.minutes",
      name: "minutes",
      module: "Duration",
      package: "effect",
      signature: "(minutes: number) => Duration",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 104,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L104"
    },
    {
      id: "Duration.hours",
      name: "hours",
      module: "Duration",
      package: "effect",
      signature: "(hours: number) => Duration",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 109,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L109"
    },
    {
      id: "Duration.days",
      name: "days",
      module: "Duration",
      package: "effect",
      signature: "(days: number) => Duration",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 114,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L114"
    },
    {
      id: "Duration.weeks",
      name: "weeks",
      module: "Duration",
      package: "effect",
      signature: "(weeks: number) => Duration",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 119,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L119"
    },
    {
      id: "Duration.toMillis",
      name: "toMillis",
      module: "Duration",
      package: "effect",
      signature: "(self: DurationInput) => number",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 124,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L124"
    },
    {
      id: "Duration.toSeconds",
      name: "toSeconds",
      module: "Duration",
      package: "effect",
      signature: "(self: DurationInput) => number",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 129,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L129"
    },
    {
      id: "Duration.toMinutes",
      name: "toMinutes",
      module: "Duration",
      package: "effect",
      signature: "(self: DurationInput) => number",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "getters"
      ],
      since: "3.8.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 134,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L134"
    },
    {
      id: "Duration.toHours",
      name: "toHours",
      module: "Duration",
      package: "effect",
      signature: "(self: DurationInput) => number",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "getters"
      ],
      since: "3.8.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 139,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L139"
    },
    {
      id: "Duration.toDays",
      name: "toDays",
      module: "Duration",
      package: "effect",
      signature: "(self: DurationInput) => number",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "getters"
      ],
      since: "3.8.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 144,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L144"
    },
    {
      id: "Duration.toWeeks",
      name: "toWeeks",
      module: "Duration",
      package: "effect",
      signature: "(self: DurationInput) => number",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "getters"
      ],
      since: "3.8.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 149,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L149"
    },
    {
      id: "Duration.toNanos",
      name: "toNanos",
      module: "Duration",
      package: "effect",
      signature: "(self: DurationInput) => Option<bigint>",
      description: "Get the duration in nanoseconds as a bigint. If the duration is infinite, returns `Option.none()`",
      documentation: "Get the duration in nanoseconds as a bigint.\n\nIf the duration is infinite, returns `Option.none()`",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 158,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L158"
    },
    {
      id: "Duration.unsafeToNanos",
      name: "unsafeToNanos",
      module: "Duration",
      package: "effect",
      signature: "(self: DurationInput) => bigint",
      description: "Get the duration in nanoseconds as a bigint. If the duration is infinite, it throws an error.",
      documentation: "Get the duration in nanoseconds as a bigint.\n\nIf the duration is infinite, it throws an error.",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 167,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L167"
    },
    {
      id: "Duration.toHrTime",
      name: "toHrTime",
      module: "Duration",
      package: "effect",
      signature: "(self: DurationInput) => [seconds: number, nanos: number]",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "getters"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 172,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L172"
    },
    {
      id: "Duration.match",
      name: "match",
      module: "Duration",
      package: "effect",
      signature: "{ <A, B>(options: { readonly onMillis: (millis: number) => A; readonly onNanos: (nanos: bigint) => B; }): (self: DurationInput) => A | B; <A, B>(self: DurationInput, options: { readonly onMillis: (millis: number) => A; readonly onNanos: (nanos: bigint) => B; }): A | B; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "pattern matching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 177,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L177"
    },
    {
      id: "Duration.matchWith",
      name: "matchWith",
      module: "Duration",
      package: "effect",
      signature: "{ <A, B>(that: DurationInput, options: { readonly onMillis: (self: number, that: number) => A; readonly onNanos: (self: bigint, that: bigint) => B; }): (self: DurationInput) => A | B; <A, B>(self: DurationInput, that: DurationInput, options: { readonly onMillis: (self: number, that: number) => A; readonly onNanos: (self: bigint, that: bigint) => B; }): A | B; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "pattern matching"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 199,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L199"
    },
    {
      id: "Duration.Order",
      name: "Order",
      module: "Duration",
      package: "effect",
      signature: "Order<Duration>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "instances"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 221,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L221"
    },
    {
      id: "Duration.between",
      name: "between",
      module: "Duration",
      package: "effect",
      signature: "{ (options: { minimum: DurationInput; maximum: DurationInput; }): (self: DurationInput) => boolean; (self: DurationInput, options: { minimum: DurationInput; maximum: DurationInput; }): boolean; }",
      description: "Checks if a `Duration` is between a `minimum` and `maximum` value.",
      documentation: "Checks if a `Duration` is between a `minimum` and `maximum` value.",
      examples: [],
      tags: [
        "predicates"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 228,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L228"
    },
    {
      id: "Duration.Equivalence",
      name: "Equivalence",
      module: "Duration",
      package: "effect",
      signature: "Equivalence<Duration>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "instances"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 254,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L254"
    },
    {
      id: "Duration.min",
      name: "min",
      module: "Duration",
      package: "effect",
      signature: "{ (that: DurationInput): (self: DurationInput) => Duration; (self: DurationInput, that: DurationInput): Duration; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 258,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L258"
    },
    {
      id: "Duration.max",
      name: "max",
      module: "Duration",
      package: "effect",
      signature: "{ (that: DurationInput): (self: DurationInput) => Duration; (self: DurationInput, that: DurationInput): Duration; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "order"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 272,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L272"
    },
    {
      id: "Duration.clamp",
      name: "clamp",
      module: "Duration",
      package: "effect",
      signature: "{ (options: { minimum: DurationInput; maximum: DurationInput; }): (self: DurationInput) => Duration; (self: DurationInput, options: { minimum: DurationInput; maximum: DurationInput; }): Duration; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "order"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 288,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L288"
    },
    {
      id: "Duration.divide",
      name: "divide",
      module: "Duration",
      package: "effect",
      signature: "{ (by: number): (self: DurationInput) => Option<Duration>; (self: DurationInput, by: number): Option<Duration>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "math"
      ],
      since: "2.4.19",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 310,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L310"
    },
    {
      id: "Duration.unsafeDivide",
      name: "unsafeDivide",
      module: "Duration",
      package: "effect",
      signature: "{ (by: number): (self: DurationInput) => Duration; (self: DurationInput, by: number): Duration; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "math"
      ],
      since: "2.4.19",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 326,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L326"
    },
    {
      id: "Duration.times",
      name: "times",
      module: "Duration",
      package: "effect",
      signature: "{ (times: number): (self: DurationInput) => Duration; (self: DurationInput, times: number): Duration; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "math"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 342,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L342"
    },
    {
      id: "Duration.subtract",
      name: "subtract",
      module: "Duration",
      package: "effect",
      signature: "{ (that: DurationInput): (self: DurationInput) => Duration; (self: DurationInput, that: DurationInput): Duration; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "math"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 358,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L358"
    },
    {
      id: "Duration.sum",
      name: "sum",
      module: "Duration",
      package: "effect",
      signature: "{ (that: DurationInput): (self: DurationInput) => Duration; (self: DurationInput, that: DurationInput): Duration; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "math"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 374,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L374"
    },
    {
      id: "Duration.lessThan",
      name: "lessThan",
      module: "Duration",
      package: "effect",
      signature: "{ (that: DurationInput): (self: DurationInput) => boolean; (self: DurationInput, that: DurationInput): boolean; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "predicates"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 390,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L390"
    },
    {
      id: "Duration.lessThanOrEqualTo",
      name: "lessThanOrEqualTo",
      module: "Duration",
      package: "effect",
      signature: "{ (that: DurationInput): (self: DurationInput) => boolean; (self: DurationInput, that: DurationInput): boolean; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "predicates"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 406,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L406"
    },
    {
      id: "Duration.greaterThan",
      name: "greaterThan",
      module: "Duration",
      package: "effect",
      signature: "{ (that: DurationInput): (self: DurationInput) => boolean; (self: DurationInput, that: DurationInput): boolean; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "predicates"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 422,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L422"
    },
    {
      id: "Duration.greaterThanOrEqualTo",
      name: "greaterThanOrEqualTo",
      module: "Duration",
      package: "effect",
      signature: "{ (that: DurationInput): (self: DurationInput) => boolean; (self: DurationInput, that: DurationInput): boolean; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "predicates"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 438,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L438"
    },
    {
      id: "Duration.equals",
      name: "equals",
      module: "Duration",
      package: "effect",
      signature: "{ (that: DurationInput): (self: DurationInput) => boolean; (self: DurationInput, that: DurationInput): boolean; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "predicates"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 454,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L454"
    },
    {
      id: "Duration.parts",
      name: "parts",
      module: "Duration",
      package: "effect",
      signature: "(self: DurationInput) => { days: number; hours: number; minutes: number; seconds: number; millis: number; nanos: number; }",
      description: "Converts a `Duration` to its parts.",
      documentation: "Converts a `Duration` to its parts.",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "3.8.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 472,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L472"
    },
    {
      id: "Duration.format",
      name: "format",
      module: "Duration",
      package: "effect",
      signature: "(self: DurationInput) => string",
      description: "Converts a `Duration` to a human readable string.",
      documentation: "Converts a `Duration` to a human readable string.",
      examples: [
        {
          code: 'import { Duration } from "effect"\n\nDuration.format(Duration.millis(1000)) // "1s"\nDuration.format(Duration.millis(1001)) // "1s 1ms"'
        }
      ],
      tags: [
        "conversions"
      ],
      since: "2.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 493,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L493"
    },
    {
      id: "Duration.unsafeFormatIso",
      name: "unsafeFormatIso",
      module: "Duration",
      package: "effect",
      signature: "(self: DurationInput) => string",
      description: "Formats a Duration into an ISO8601 duration string. Months are assumed to be 30 days and years are assumed to be 365 days. Milliseconds and nanoseconds are expressed as fractional seconds.",
      documentation: "Formats a Duration into an ISO8601 duration string.\n\nMonths are assumed to be 30 days and years are assumed to be 365 days.\n\nMilliseconds and nanoseconds are expressed as fractional seconds.",
      examples: [
        {
          code: 'import { Duration } from "effect"\n\nDuration.unsafeFormatIso(Duration.days(1)) // => "P1D"\nDuration.unsafeFormatIso(Duration.minutes(90)) // => "PT1H30M"\nDuration.unsafeFormatIso(Duration.millis(1500)) // => "PT1.5S"'
        }
      ],
      tags: [
        "conversions"
      ],
      since: "3.13.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 515,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L515"
    },
    {
      id: "Duration.formatIso",
      name: "formatIso",
      module: "Duration",
      package: "effect",
      signature: "(self: DurationInput) => Option<string>",
      description: "Formats a Duration into an ISO8601 duration string. Months are assumed to be 30 days and years are assumed to be 365 days. Returns `Option.none()` if the duration is infinite.",
      documentation: "Formats a Duration into an ISO8601 duration string.\n\nMonths are assumed to be 30 days and years are assumed to be 365 days.\n\nReturns `Option.none()` if the duration is infinite.",
      examples: [
        {
          code: 'import { Duration, Option } from "effect"\n\nDuration.formatIso(Duration.days(1)) // => Option.some("P1D")\nDuration.formatIso(Duration.minutes(90)) // => Option.some("PT1H30M")\nDuration.formatIso(Duration.millis(1500)) // => Option.some("PT1.5S")\nDuration.formatIso(Duration.infinity) // => Option.none()'
        }
      ],
      tags: [
        "conversions"
      ],
      since: "3.13.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 536,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L536"
    },
    {
      id: "Duration.fromIso",
      name: "fromIso",
      module: "Duration",
      package: "effect",
      signature: "(iso: string) => Option<Duration>",
      description: "Parses an ISO8601 duration string into a `Duration`. Months are assumed to be 30 days and years are assumed to be 365 days.",
      documentation: "Parses an ISO8601 duration string into a `Duration`.\n\nMonths are assumed to be 30 days and years are assumed to be 365 days.",
      examples: [
        {
          code: 'import { Duration, Option } from "effect"\n\nDuration.fromIso("P1D") // => Option.some(Duration.days(1))\nDuration.fromIso("PT1H") // => Option.some(Duration.hours(1))\nDuration.fromIso("PT1M") // => Option.some(Duration.minutes(1))\nDuration.fromIso("PT1.5S") // => Option.some(Duration.seconds(1.5))'
        }
      ],
      tags: [
        "conversions"
      ],
      since: "3.13.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/Duration.d.ts",
      sourceLine: 555,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Duration.ts#L555"
    },
    {
      id: "DateTime.TypeId",
      name: "TypeId",
      module: "DateTime",
      package: "effect",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 20,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L20"
    },
    {
      id: "DateTime.TimeZoneTypeId",
      name: "TimeZoneTypeId",
      module: "DateTime",
      package: "effect",
      signature: "typeof TimeZoneTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 138,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L138"
    },
    {
      id: "DateTime.isDateTime",
      name: "isDateTime",
      module: "DateTime",
      package: "effect",
      signature: "(u: unknown) => u is DateTime",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "guards"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 227,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L227"
    },
    {
      id: "DateTime.isTimeZone",
      name: "isTimeZone",
      module: "DateTime",
      package: "effect",
      signature: "(u: unknown) => u is TimeZone",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "guards"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 232,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L232"
    },
    {
      id: "DateTime.isTimeZoneOffset",
      name: "isTimeZoneOffset",
      module: "DateTime",
      package: "effect",
      signature: "(u: unknown) => u is TimeZone.Offset",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "guards"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 237,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L237"
    },
    {
      id: "DateTime.isTimeZoneNamed",
      name: "isTimeZoneNamed",
      module: "DateTime",
      package: "effect",
      signature: "(u: unknown) => u is TimeZone.Named",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "guards"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 242,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L242"
    },
    {
      id: "DateTime.isUtc",
      name: "isUtc",
      module: "DateTime",
      package: "effect",
      signature: "(self: DateTime) => self is Utc",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "guards"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 247,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L247"
    },
    {
      id: "DateTime.isZoned",
      name: "isZoned",
      module: "DateTime",
      package: "effect",
      signature: "(self: DateTime) => self is Zoned",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "guards"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 252,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L252"
    },
    {
      id: "DateTime.Equivalence",
      name: "Equivalence",
      module: "DateTime",
      package: "effect",
      signature: "Equivalence<DateTime>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "instances"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 257,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L257"
    },
    {
      id: "DateTime.Order",
      name: "Order",
      module: "DateTime",
      package: "effect",
      signature: "Order<DateTime>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "instances"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 262,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L262"
    },
    {
      id: "DateTime.clamp",
      name: "clamp",
      module: "DateTime",
      package: "effect",
      signature: "{ <Min extends DateTime, Max extends DateTime>(options: { readonly minimum: Min; readonly maximum: Max; }): <A extends DateTime>(self: A) => Min | Max | A; <A extends DateTime, Min extends DateTime, Max extends DateTime>(self: A, options: { readonly minimum: Min; readonly maximum: Max; }): A | Min | Max; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 266,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L266"
    },
    {
      id: "DateTime.unsafeFromDate",
      name: "unsafeFromDate",
      module: "DateTime",
      package: "effect",
      signature: "(date: Date) => Utc",
      description: "Create a `DateTime` from a `Date`. If the `Date` is invalid, an `IllegalArgumentException` will be thrown.",
      documentation: "Create a `DateTime` from a `Date`.\n\nIf the `Date` is invalid, an `IllegalArgumentException` will be thrown.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 290,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L290"
    },
    {
      id: "DateTime.unsafeMake",
      name: "unsafeMake",
      module: "DateTime",
      package: "effect",
      signature: "<A extends DateTime.Input>(input: A) => DateTime.PreserveZone<A>",
      description: "Create a `DateTime` from one of the following: - A `DateTime`\n- A `Date` instance (invalid dates will throw an `IllegalArgumentException`)\n- The `number` of milliseconds since the Unix epoch\n- An object with the parts of a date\n- A `string` that can be parsed by `Date.parse`",
      documentation: "Create a `DateTime` from one of the following:\n\n- A `DateTime`\n- A `Date` instance (invalid dates will throw an `IllegalArgumentException`)\n- The `number` of milliseconds since the Unix epoch\n- An object with the parts of a date\n- A `string` that can be parsed by `Date.parse`",
      examples: [
        {
          code: 'import { DateTime } from "effect"\n\n// from Date\nDateTime.unsafeMake(new Date())\n\n// from parts\nDateTime.unsafeMake({ year: 2024 })\n\n// from string\nDateTime.unsafeMake("2024-01-01")'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 316,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L316"
    },
    {
      id: "DateTime.unsafeMakeZoned",
      name: "unsafeMakeZoned",
      module: "DateTime",
      package: "effect",
      signature: "(input: DateTime.Input, options?: { readonly timeZone?: string | number | TimeZone; readonly adjustForTimeZone?: boolean; readonly disambiguation?: Disambiguation; }) => Zoned",
      description: "Create a `DateTime.Zoned` using `DateTime.unsafeMake` and a time zone. The input is treated as UTC and then the time zone is attached, unless\n`adjustForTimeZone` is set to `true`. In that case, the input is treated as\nalready in the time zone. When `adjustForTimeZone` is true and ambiguous times occur during DST transitions,\nthe `disambiguation` option controls how to resolve the ambiguity:\n- `compatible` (default): Choose earlier time for repeated times, later for gaps\n- `earlier`: Always choose the earlier of two possible times\n- `later`: Always choose the later of two possible times\n- `reject`: Throw an error when ambiguous times are encountered",
      documentation: "Create a `DateTime.Zoned` using `DateTime.unsafeMake` and a time zone.\n\nThe input is treated as UTC and then the time zone is attached, unless\n`adjustForTimeZone` is set to `true`. In that case, the input is treated as\nalready in the time zone.\n\nWhen `adjustForTimeZone` is true and ambiguous times occur during DST transitions,\nthe `disambiguation` option controls how to resolve the ambiguity:\n- `compatible` (default): Choose earlier time for repeated times, later for gaps\n- `earlier`: Always choose the earlier of two possible times\n- `later`: Always choose the later of two possible times\n- `reject`: Throw an error when ambiguous times are encountered",
      examples: [
        {
          code: 'import { DateTime } from "effect"\n\nDateTime.unsafeMakeZoned(new Date(), { timeZone: "Europe/London" })'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 340,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L340"
    },
    {
      id: "DateTime.makeZoned",
      name: "makeZoned",
      module: "DateTime",
      package: "effect",
      signature: "(input: DateTime.Input, options?: { readonly timeZone?: string | number | TimeZone; readonly adjustForTimeZone?: boolean; readonly disambiguation?: Disambiguation; }) => Option<Zoned>",
      description: "Create a `DateTime.Zoned` using `DateTime.make` and a time zone. The input is treated as UTC and then the time zone is attached, unless\n`adjustForTimeZone` is set to `true`. In that case, the input is treated as\nalready in the time zone. When `adjustForTimeZone` is true and ambiguous times occur during DST transitions,\nthe `disambiguation` option controls how to resolve the ambiguity:\n- `compatible` (default): Choose earlier time for repeated times, later for gaps\n- `earlier`: Always choose the earlier of two possible times\n- `later`: Always choose the later of two possible times\n- `reject`: Throw an error when ambiguous times are encountered If the date time input or time zone is invalid, `None` will be returned.",
      documentation: "Create a `DateTime.Zoned` using `DateTime.make` and a time zone.\n\nThe input is treated as UTC and then the time zone is attached, unless\n`adjustForTimeZone` is set to `true`. In that case, the input is treated as\nalready in the time zone.\n\nWhen `adjustForTimeZone` is true and ambiguous times occur during DST transitions,\nthe `disambiguation` option controls how to resolve the ambiguity:\n- `compatible` (default): Choose earlier time for repeated times, later for gaps\n- `earlier`: Always choose the earlier of two possible times\n- `later`: Always choose the later of two possible times\n- `reject`: Throw an error when ambiguous times are encountered\n\nIf the date time input or time zone is invalid, `None` will be returned.",
      examples: [
        {
          code: 'import { DateTime } from "effect"\n\nDateTime.makeZoned(new Date(), { timeZone: "Europe/London" })'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 370,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L370"
    },
    {
      id: "DateTime.make",
      name: "make",
      module: "DateTime",
      package: "effect",
      signature: "<A extends DateTime.Input>(input: A) => Option<DateTime.PreserveZone<A>>",
      description: "Create a `DateTime` from one of the following: - A `DateTime`\n- A `Date` instance (invalid dates will throw an `IllegalArgumentException`)\n- The `number` of milliseconds since the Unix epoch\n- An object with the parts of a date\n- A `string` that can be parsed by `Date.parse` If the input is invalid, `None` will be returned.",
      documentation: "Create a `DateTime` from one of the following:\n\n- A `DateTime`\n- A `Date` instance (invalid dates will throw an `IllegalArgumentException`)\n- The `number` of milliseconds since the Unix epoch\n- An object with the parts of a date\n- A `string` that can be parsed by `Date.parse`\n\nIf the input is invalid, `None` will be returned.",
      examples: [
        {
          code: 'import { DateTime } from "effect"\n\n// from Date\nDateTime.make(new Date())\n\n// from parts\nDateTime.make({ year: 2024 })\n\n// from string\nDateTime.make("2024-01-01")'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 402,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L402"
    },
    {
      id: "DateTime.makeZonedFromString",
      name: "makeZonedFromString",
      module: "DateTime",
      package: "effect",
      signature: "(input: string) => Option<Zoned>",
      description: "Create a `DateTime.Zoned` from a string. It uses the format: `YYYY-MM-DDTHH:mm:ss.sss+HH:MM[Time/Zone]`.",
      documentation: "Create a `DateTime.Zoned` from a string.\n\nIt uses the format: `YYYY-MM-DDTHH:mm:ss.sss+HH:MM[Time/Zone]`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 411,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L411"
    },
    {
      id: "DateTime.now",
      name: "now",
      module: "DateTime",
      package: "effect",
      signature: "Effect<Utc, never, never>",
      description: "Get the current time using the `Clock` service and convert it to a `DateTime`.",
      documentation: "Get the current time using the `Clock` service and convert it to a `DateTime`.",
      examples: [
        {
          code: 'import { DateTime, Effect } from "effect"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n})'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 426,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L426"
    },
    {
      id: "DateTime.nowAsDate",
      name: "nowAsDate",
      module: "DateTime",
      package: "effect",
      signature: "Effect<Date, never, never>",
      description: "Get the current time using the `Clock` service.",
      documentation: "Get the current time using the `Clock` service.",
      examples: [
        {
          code: 'import { DateTime, Effect } from "effect"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.nowAsDate\n})'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "3.14.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 441,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L441"
    },
    {
      id: "DateTime.unsafeNow",
      name: "unsafeNow",
      module: "DateTime",
      package: "effect",
      signature: "LazyArg<Utc>",
      description: "Get the current time using `Date.now`.",
      documentation: "Get the current time using `Date.now`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 448,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L448"
    },
    {
      id: "DateTime.toUtc",
      name: "toUtc",
      module: "DateTime",
      package: "effect",
      signature: "(self: DateTime) => Utc",
      description: "For a `DateTime` returns a new `DateTime.Utc`.",
      documentation: "For a `DateTime` returns a new `DateTime.Utc`.",
      examples: [
        {
          code: 'import { DateTime } from "effect"\n\nconst now = DateTime.unsafeMakeZoned({ year: 2024 }, { timeZone: "Europe/London" })\n\n// set as UTC\nconst utc: DateTime.Utc = DateTime.toUtc(now)'
        }
      ],
      tags: [
        "time zones"
      ],
      since: "3.13.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 464,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L464"
    },
    {
      id: "DateTime.setZone",
      name: "setZone",
      module: "DateTime",
      package: "effect",
      signature: "{ (zone: TimeZone, options?: { readonly adjustForTimeZone?: boolean; readonly disambiguation?: Disambiguation; }): (self: DateTime) => Zoned; (self: DateTime, zone: TimeZone, options?: { readonly adjustForTimeZone?: boolean; readonly disambiguation?: Disambiguation; }): Zoned; }",
      description: "Set the time zone of a `DateTime`, returning a new `DateTime.Zoned`.",
      documentation: "Set the time zone of a `DateTime`, returning a new `DateTime.Zoned`.",
      examples: [
        {
          code: 'import { DateTime, Effect } from "effect"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n  const zone = DateTime.zoneUnsafeMakeNamed("Europe/London")\n\n  // set the time zone\n  const zoned: DateTime.Zoned = DateTime.setZone(now, zone)\n})'
        }
      ],
      tags: [
        "time zones"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 483,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L483"
    },
    {
      id: "DateTime.setZoneOffset",
      name: "setZoneOffset",
      module: "DateTime",
      package: "effect",
      signature: "{ (offset: number, options?: { readonly adjustForTimeZone?: boolean; readonly disambiguation?: Disambiguation; }): (self: DateTime) => Zoned; (self: DateTime, offset: number, options?: { readonly adjustForTimeZone?: boolean; readonly disambiguation?: Disambiguation; }): Zoned; }",
      description: "Add a fixed offset time zone to a `DateTime`. The offset is in milliseconds.",
      documentation: "Add a fixed offset time zone to a `DateTime`.\n\nThe offset is in milliseconds.",
      examples: [
        {
          code: 'import { DateTime, Effect } from "effect"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n\n  // set the offset time zone in milliseconds\n  const zoned: DateTime.Zoned = DateTime.setZoneOffset(now, 3 * 60 * 60 * 1000)\n})'
        }
      ],
      tags: [
        "time zones"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 548,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L548"
    },
    {
      id: "DateTime.zoneUnsafeMakeNamed",
      name: "zoneUnsafeMakeNamed",
      module: "DateTime",
      package: "effect",
      signature: "(zoneId: string) => TimeZone.Named",
      description: "Attempt to create a named time zone from a IANA time zone identifier. If the time zone is invalid, an `IllegalArgumentException` will be thrown.",
      documentation: "Attempt to create a named time zone from a IANA time zone identifier.\n\nIf the time zone is invalid, an `IllegalArgumentException` will be thrown.",
      examples: [],
      tags: [
        "time zones"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 604,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L604"
    },
    {
      id: "DateTime.zoneMakeOffset",
      name: "zoneMakeOffset",
      module: "DateTime",
      package: "effect",
      signature: "(offset: number) => TimeZone.Offset",
      description: "Create a fixed offset time zone.",
      documentation: "Create a fixed offset time zone.",
      examples: [],
      tags: [
        "time zones"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 611,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L611"
    },
    {
      id: "DateTime.zoneMakeNamed",
      name: "zoneMakeNamed",
      module: "DateTime",
      package: "effect",
      signature: "(zoneId: string) => Option<TimeZone.Named>",
      description: "Create a named time zone from a IANA time zone identifier. If the time zone\nis invalid, `None` will be returned.",
      documentation: "Create a named time zone from a IANA time zone identifier. If the time zone\nis invalid, `None` will be returned.",
      examples: [],
      tags: [
        "time zones"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 619,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L619"
    },
    {
      id: "DateTime.zoneMakeNamedEffect",
      name: "zoneMakeNamedEffect",
      module: "DateTime",
      package: "effect",
      signature: "(zoneId: string) => Effect<TimeZone.Named, IllegalArgumentException, never>",
      description: "Create a named time zone from a IANA time zone identifier. If the time zone\nis invalid, it will fail with an `IllegalArgumentException`.",
      documentation: "Create a named time zone from a IANA time zone identifier. If the time zone\nis invalid, it will fail with an `IllegalArgumentException`.",
      examples: [],
      tags: [
        "time zones"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 627,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L627"
    },
    {
      id: "DateTime.zoneMakeLocal",
      name: "zoneMakeLocal",
      module: "DateTime",
      package: "effect",
      signature: "() => TimeZone.Named",
      description: "Create a named time zone from the system's local time zone.",
      documentation: "Create a named time zone from the system's local time zone.",
      examples: [],
      tags: [
        "time zones"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 634,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L634"
    },
    {
      id: "DateTime.zoneFromString",
      name: "zoneFromString",
      module: "DateTime",
      package: "effect",
      signature: "(zone: string) => Option<TimeZone>",
      description: "Try parse a TimeZone from a string",
      documentation: "Try parse a TimeZone from a string",
      examples: [],
      tags: [
        "time zones"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 641,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L641"
    },
    {
      id: "DateTime.zoneToString",
      name: "zoneToString",
      module: "DateTime",
      package: "effect",
      signature: "(self: TimeZone) => string",
      description: "Format a `TimeZone` as a string.",
      documentation: "Format a `TimeZone` as a string.",
      examples: [
        {
          code: 'import { DateTime, Effect } from "effect"\n\n// Outputs "+03:00"\nDateTime.zoneToString(DateTime.zoneMakeOffset(3 * 60 * 60 * 1000))\n\n// Outputs "Europe/London"\nDateTime.zoneToString(DateTime.zoneUnsafeMakeNamed("Europe/London"))'
        }
      ],
      tags: [
        "time zones"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 658,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L658"
    },
    {
      id: "DateTime.setZoneNamed",
      name: "setZoneNamed",
      module: "DateTime",
      package: "effect",
      signature: "{ (zoneId: string, options?: { readonly adjustForTimeZone?: boolean; readonly disambiguation?: Disambiguation; }): (self: DateTime) => Option<Zoned>; (self: DateTime, zoneId: string, options?: { readonly adjustForTimeZone?: boolean; readonly disambiguation?: Disambiguation; }): Option<Zoned>; }",
      description: "Set the time zone of a `DateTime` from an IANA time zone identifier. If the\ntime zone is invalid, `None` will be returned.",
      documentation: "Set the time zone of a `DateTime` from an IANA time zone identifier. If the\ntime zone is invalid, `None` will be returned.",
      examples: [
        {
          code: 'import { DateTime, Effect } from "effect"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n  // set the time zone, returns an Option\n  DateTime.setZoneNamed(now, "Europe/London")\n})'
        }
      ],
      tags: [
        "time zones"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 676,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L676"
    },
    {
      id: "DateTime.unsafeSetZoneNamed",
      name: "unsafeSetZoneNamed",
      module: "DateTime",
      package: "effect",
      signature: "{ (zoneId: string, options?: { readonly adjustForTimeZone?: boolean; readonly disambiguation?: Disambiguation; }): (self: DateTime) => Zoned; (self: DateTime, zoneId: string, options?: { readonly adjustForTimeZone?: boolean; readonly disambiguation?: Disambiguation; }): Zoned; }",
      description: "Set the time zone of a `DateTime` from an IANA time zone identifier. If the\ntime zone is invalid, an `IllegalArgumentException` will be thrown.",
      documentation: "Set the time zone of a `DateTime` from an IANA time zone identifier. If the\ntime zone is invalid, an `IllegalArgumentException` will be thrown.",
      examples: [
        {
          code: 'import { DateTime, Effect } from "effect"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n  // set the time zone\n  DateTime.unsafeSetZoneNamed(now, "Europe/London")\n})'
        }
      ],
      tags: [
        "time zones"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 737,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L737"
    },
    {
      id: "DateTime.distance",
      name: "distance",
      module: "DateTime",
      package: "effect",
      signature: "{ (other: DateTime): (self: DateTime) => number; (self: DateTime, other: DateTime): number; }",
      description: "Calulate the difference between two `DateTime` values, returning the number\nof milliseconds the `other` DateTime is from `self`. If `other` is *after* `self`, the result will be a positive number.",
      documentation: "Calulate the difference between two `DateTime` values, returning the number\nof milliseconds the `other` DateTime is from `self`.\n\nIf `other` is *after* `self`, the result will be a positive number.",
      examples: [
        {
          code: 'import { DateTime, Effect } from "effect"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n  const other = DateTime.add(now, { minutes: 1 })\n\n  // returns 60000\n  DateTime.distance(now, other)\n})'
        }
      ],
      tags: [
        "comparisons"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 802,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L802"
    },
    {
      id: "DateTime.distanceDurationEither",
      name: "distanceDurationEither",
      module: "DateTime",
      package: "effect",
      signature: "{ (other: DateTime): (self: DateTime) => Either<Duration, Duration>; (self: DateTime, other: DateTime): Either<Duration, Duration>; }",
      description: "Calulate the difference between two `DateTime` values. If the `other` DateTime is before `self`, the result will be a negative\n`Duration`, returned as a `Left`. If the `other` DateTime is after `self`, the result will be a positive\n`Duration`, returned as a `Right`.",
      documentation: "Calulate the difference between two `DateTime` values.\n\nIf the `other` DateTime is before `self`, the result will be a negative\n`Duration`, returned as a `Left`.\n\nIf the `other` DateTime is after `self`, the result will be a positive\n`Duration`, returned as a `Right`.",
      examples: [
        {
          code: 'import { DateTime, Effect } from "effect"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n  const other = DateTime.add(now, { minutes: 1 })\n\n  // returns Either.right(Duration.minutes(1))\n  DateTime.distanceDurationEither(now, other)\n\n  // returns Either.left(Duration.minutes(1))\n  DateTime.distanceDurationEither(other, now)\n})'
        }
      ],
      tags: [
        "comparisons"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 875,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L875"
    },
    {
      id: "DateTime.distanceDuration",
      name: "distanceDuration",
      module: "DateTime",
      package: "effect",
      signature: "{ (other: DateTime): (self: DateTime) => Duration; (self: DateTime, other: DateTime): Duration; }",
      description: "Calulate the distance between two `DateTime` values.",
      documentation: "Calulate the distance between two `DateTime` values.",
      examples: [
        {
          code: 'import { DateTime, Effect } from "effect"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n  const other = DateTime.add(now, { minutes: 1 })\n\n  // returns Duration.minutes(1)\n  DateTime.distanceDuration(now, other)\n})'
        }
      ],
      tags: [
        "comparisons"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 951,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L951"
    },
    {
      id: "DateTime.min",
      name: "min",
      module: "DateTime",
      package: "effect",
      signature: "{ <That extends DateTime>(that: That): <Self extends DateTime>(self: Self) => That | Self; <Self extends DateTime, That extends DateTime>(self: Self, that: That): Self | That; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "comparisons"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 995,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L995"
    },
    {
      id: "DateTime.max",
      name: "max",
      module: "DateTime",
      package: "effect",
      signature: "{ <That extends DateTime>(that: That): <Self extends DateTime>(self: Self) => That | Self; <Self extends DateTime, That extends DateTime>(self: Self, that: That): Self | That; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "comparisons"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1011,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1011"
    },
    {
      id: "DateTime.greaterThan",
      name: "greaterThan",
      module: "DateTime",
      package: "effect",
      signature: "{ (that: DateTime): (self: DateTime) => boolean; (self: DateTime, that: DateTime): boolean; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "comparisons"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1027,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1027"
    },
    {
      id: "DateTime.greaterThanOrEqualTo",
      name: "greaterThanOrEqualTo",
      module: "DateTime",
      package: "effect",
      signature: "{ (that: DateTime): (self: DateTime) => boolean; (self: DateTime, that: DateTime): boolean; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "comparisons"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1043,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1043"
    },
    {
      id: "DateTime.lessThan",
      name: "lessThan",
      module: "DateTime",
      package: "effect",
      signature: "{ (that: DateTime): (self: DateTime) => boolean; (self: DateTime, that: DateTime): boolean; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "comparisons"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1059,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1059"
    },
    {
      id: "DateTime.lessThanOrEqualTo",
      name: "lessThanOrEqualTo",
      module: "DateTime",
      package: "effect",
      signature: "{ (that: DateTime): (self: DateTime) => boolean; (self: DateTime, that: DateTime): boolean; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "comparisons"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1075,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1075"
    },
    {
      id: "DateTime.between",
      name: "between",
      module: "DateTime",
      package: "effect",
      signature: "{ (options: { minimum: DateTime; maximum: DateTime; }): (self: DateTime) => boolean; (self: DateTime, options: { minimum: DateTime; maximum: DateTime; }): boolean; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "comparisons"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1091,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1091"
    },
    {
      id: "DateTime.isFuture",
      name: "isFuture",
      module: "DateTime",
      package: "effect",
      signature: "(self: DateTime) => Effect<boolean, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "comparisons"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1113,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1113"
    },
    {
      id: "DateTime.unsafeIsFuture",
      name: "unsafeIsFuture",
      module: "DateTime",
      package: "effect",
      signature: "(self: DateTime) => boolean",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "comparisons"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1118,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1118"
    },
    {
      id: "DateTime.isPast",
      name: "isPast",
      module: "DateTime",
      package: "effect",
      signature: "(self: DateTime) => Effect<boolean, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "comparisons"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1123,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1123"
    },
    {
      id: "DateTime.unsafeIsPast",
      name: "unsafeIsPast",
      module: "DateTime",
      package: "effect",
      signature: "(self: DateTime) => boolean",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "comparisons"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1128,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1128"
    },
    {
      id: "DateTime.toDateUtc",
      name: "toDateUtc",
      module: "DateTime",
      package: "effect",
      signature: "(self: DateTime) => Date",
      description: "Get the UTC `Date` of a `DateTime`.",
      documentation: "Get the UTC `Date` of a `DateTime`.",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1135,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1135"
    },
    {
      id: "DateTime.toDate",
      name: "toDate",
      module: "DateTime",
      package: "effect",
      signature: "(self: DateTime) => Date",
      description: "Convert a `DateTime` to a `Date`, applying the time zone first.",
      documentation: "Convert a `DateTime` to a `Date`, applying the time zone first.",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1142,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1142"
    },
    {
      id: "DateTime.zonedOffset",
      name: "zonedOffset",
      module: "DateTime",
      package: "effect",
      signature: "(self: Zoned) => number",
      description: "Calculate the time zone offset of a `DateTime.Zoned` in milliseconds.",
      documentation: "Calculate the time zone offset of a `DateTime.Zoned` in milliseconds.",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1149,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1149"
    },
    {
      id: "DateTime.zonedOffsetIso",
      name: "zonedOffsetIso",
      module: "DateTime",
      package: "effect",
      signature: "(self: Zoned) => string",
      description: 'Calculate the time zone offset of a `DateTime` in milliseconds. The offset is formatted as "\xB1HH:MM".',
      documentation: 'Calculate the time zone offset of a `DateTime` in milliseconds.\n\nThe offset is formatted as "\xB1HH:MM".',
      examples: [],
      tags: [
        "conversions"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1158,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1158"
    },
    {
      id: "DateTime.toEpochMillis",
      name: "toEpochMillis",
      module: "DateTime",
      package: "effect",
      signature: "(self: DateTime) => number",
      description: "Get the milliseconds since the Unix epoch of a `DateTime`.",
      documentation: "Get the milliseconds since the Unix epoch of a `DateTime`.",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1165,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1165"
    },
    {
      id: "DateTime.removeTime",
      name: "removeTime",
      module: "DateTime",
      package: "effect",
      signature: "(self: DateTime) => Utc",
      description: "Remove the time aspect of a `DateTime`, first adjusting for the time\nzone. It will return a `DateTime.Utc` only containing the date.",
      documentation: "Remove the time aspect of a `DateTime`, first adjusting for the time\nzone. It will return a `DateTime.Utc` only containing the date.",
      examples: [
        {
          code: 'import { DateTime } from "effect"\n\n// returns "2024-01-01T00:00:00Z"\nDateTime.unsafeMakeZoned("2024-01-01T05:00:00Z", {\n  timeZone: "Pacific/Auckland",\n  adjustForTimeZone: true\n}).pipe(\n  DateTime.removeTime,\n  DateTime.formatIso\n)'
        }
      ],
      tags: [
        "conversions"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1186,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1186"
    },
    {
      id: "DateTime.toParts",
      name: "toParts",
      module: "DateTime",
      package: "effect",
      signature: "(self: DateTime) => DateTime.PartsWithWeekday",
      description: "Get the different parts of a `DateTime` as an object. The parts will be time zone adjusted.",
      documentation: "Get the different parts of a `DateTime` as an object.\n\nThe parts will be time zone adjusted.",
      examples: [],
      tags: [
        "parts"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1195,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1195"
    },
    {
      id: "DateTime.toPartsUtc",
      name: "toPartsUtc",
      module: "DateTime",
      package: "effect",
      signature: "(self: DateTime) => DateTime.PartsWithWeekday",
      description: "Get the different parts of a `DateTime` as an object. The parts will be in UTC.",
      documentation: "Get the different parts of a `DateTime` as an object.\n\nThe parts will be in UTC.",
      examples: [],
      tags: [
        "parts"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1204,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1204"
    },
    {
      id: "DateTime.getPartUtc",
      name: "getPartUtc",
      module: "DateTime",
      package: "effect",
      signature: "{ (part: keyof DateTime.PartsWithWeekday): (self: DateTime) => number; (self: DateTime, part: keyof DateTime.PartsWithWeekday): number; }",
      description: "Get a part of a `DateTime` as a number. The part will be in the UTC time zone.",
      documentation: "Get a part of a `DateTime` as a number.\n\nThe part will be in the UTC time zone.",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { DateTime } from "effect"\n\nconst now = DateTime.unsafeMake({ year: 2024 })\nconst year = DateTime.getPartUtc(now, "year")\nassert.strictEqual(year, 2024)'
        }
      ],
      tags: [
        "parts"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1222,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1222"
    },
    {
      id: "DateTime.getPart",
      name: "getPart",
      module: "DateTime",
      package: "effect",
      signature: "{ (part: keyof DateTime.PartsWithWeekday): (self: DateTime) => number; (self: DateTime, part: keyof DateTime.PartsWithWeekday): number; }",
      description: "Get a part of a `DateTime` as a number. The part will be time zone adjusted.",
      documentation: "Get a part of a `DateTime` as a number.\n\nThe part will be time zone adjusted.",
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { DateTime } from "effect"\n\nconst now = DateTime.unsafeMakeZoned({ year: 2024 }, { timeZone: "Europe/London" })\nconst year = DateTime.getPart(now, "year")\nassert.strictEqual(year, 2024)'
        }
      ],
      tags: [
        "parts"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1277,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1277"
    },
    {
      id: "DateTime.setParts",
      name: "setParts",
      module: "DateTime",
      package: "effect",
      signature: "{ (parts: Partial<DateTime.PartsWithWeekday>): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, parts: Partial<DateTime.PartsWithWeekday>): A; }",
      description: "Set the different parts of a `DateTime` as an object. The Date will be time zone adjusted.",
      documentation: "Set the different parts of a `DateTime` as an object.\n\nThe Date will be time zone adjusted.",
      examples: [],
      tags: [
        "parts"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1323,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1323"
    },
    {
      id: "DateTime.setPartsUtc",
      name: "setPartsUtc",
      module: "DateTime",
      package: "effect",
      signature: "{ (parts: Partial<DateTime.PartsWithWeekday>): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, parts: Partial<DateTime.PartsWithWeekday>): A; }",
      description: "Set the different parts of a `DateTime` as an object.",
      documentation: "Set the different parts of a `DateTime` as an object.",
      examples: [],
      tags: [
        "parts"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1349,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1349"
    },
    {
      id: "DateTime.setZoneCurrent",
      name: "setZoneCurrent",
      module: "DateTime",
      package: "effect",
      signature: "(self: DateTime) => Effect<Zoned, never, CurrentTimeZone>",
      description: "Set the time zone of a `DateTime` to the current time zone, which is\ndetermined by the `CurrentTimeZone` service.",
      documentation: "Set the time zone of a `DateTime` to the current time zone, which is\ndetermined by the `CurrentTimeZone` service.",
      examples: [
        {
          code: 'import { DateTime, Effect } from "effect"\n\nEffect.gen(function* () {\n  const now = yield* DateTime.now\n\n  // set the time zone to "Europe/London"\n  const zoned = yield* DateTime.setZoneCurrent(now)\n}).pipe(DateTime.withCurrentZoneNamed("Europe/London"))'
        }
      ],
      tags: [
        "current time zone"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1390,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1390"
    },
    {
      id: "DateTime.withCurrentZone",
      name: "withCurrentZone",
      module: "DateTime",
      package: "effect",
      signature: "{ (zone: TimeZone): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, Exclude<R, CurrentTimeZone>>; <A, E, R>(effect: Effect<A, E, R>, zone: TimeZone): Effect<A, E, Exclude<R, CurrentTimeZone>>; }",
      description: "Provide the `CurrentTimeZone` to an effect.",
      documentation: "Provide the `CurrentTimeZone` to an effect.",
      examples: [
        {
          code: 'import { DateTime, Effect } from "effect"\n\nconst zone = DateTime.zoneUnsafeMakeNamed("Europe/London")\n\nEffect.gen(function* () {\n  const now = yield* DateTime.nowInCurrentZone\n}).pipe(DateTime.withCurrentZone(zone))'
        }
      ],
      tags: [
        "current time zone"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1407,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1407"
    },
    {
      id: "DateTime.withCurrentZoneLocal",
      name: "withCurrentZoneLocal",
      module: "DateTime",
      package: "effect",
      signature: "<A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, Exclude<R, CurrentTimeZone>>",
      description: "Provide the `CurrentTimeZone` to an effect, using the system's local time\nzone.",
      documentation: "Provide the `CurrentTimeZone` to an effect, using the system's local time\nzone.",
      examples: [
        {
          code: `import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  // will use the system's local time zone
  const now = yield* DateTime.nowInCurrentZone
}).pipe(DateTime.withCurrentZoneLocal)`
        }
      ],
      tags: [
        "current time zone"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1459,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1459"
    },
    {
      id: "DateTime.withCurrentZoneOffset",
      name: "withCurrentZoneOffset",
      module: "DateTime",
      package: "effect",
      signature: "{ (offset: number): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, Exclude<R, CurrentTimeZone>>; <A, E, R>(effect: Effect<A, E, R>, offset: number): Effect<A, E, Exclude<R, CurrentTimeZone>>; }",
      description: "Provide the `CurrentTimeZone` to an effect, using a offset.",
      documentation: "Provide the `CurrentTimeZone` to an effect, using a offset.",
      examples: [
        {
          code: `import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  // will use the system's local time zone
  const now = yield* DateTime.nowInCurrentZone
}).pipe(DateTime.withCurrentZoneOffset(3 * 60 * 60 * 1000))`
        }
      ],
      tags: [
        "current time zone"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1475,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1475"
    },
    {
      id: "DateTime.withCurrentZoneNamed",
      name: "withCurrentZoneNamed",
      module: "DateTime",
      package: "effect",
      signature: "{ (zone: string): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, IllegalArgumentException | E, Exclude<R, CurrentTimeZone>>; <A, E, R>(effect: Effect<A, E, R>, zone: string): Effect<A, IllegalArgumentException | E, Exclude<R, CurrentTimeZone>>; }",
      description: "Provide the `CurrentTimeZone` to an effect using an IANA time zone\nidentifier. If the time zone is invalid, it will fail with an `IllegalArgumentException`.",
      documentation: "Provide the `CurrentTimeZone` to an effect using an IANA time zone\nidentifier.\n\nIf the time zone is invalid, it will fail with an `IllegalArgumentException`.",
      examples: [
        {
          code: 'import { DateTime, Effect } from "effect"\n\nEffect.gen(function* () {\n  // will use the "Europe/London" time zone\n  const now = yield* DateTime.nowInCurrentZone\n}).pipe(DateTime.withCurrentZoneNamed("Europe/London"))'
        }
      ],
      tags: [
        "current time zone"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1527,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1527"
    },
    {
      id: "DateTime.nowInCurrentZone",
      name: "nowInCurrentZone",
      module: "DateTime",
      package: "effect",
      signature: "Effect<Zoned, never, CurrentTimeZone>",
      description: "Get the current time as a `DateTime.Zoned`, using the `CurrentTimeZone`.",
      documentation: "Get the current time as a `DateTime.Zoned`, using the `CurrentTimeZone`.",
      examples: [
        {
          code: 'import { DateTime, Effect } from "effect"\n\nEffect.gen(function* () {\n  // will use the "Europe/London" time zone\n  const now = yield* DateTime.nowInCurrentZone\n}).pipe(DateTime.withCurrentZoneNamed("Europe/London"))'
        }
      ],
      tags: [
        "current time zone"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1582,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1582"
    },
    {
      id: "DateTime.mutate",
      name: "mutate",
      module: "DateTime",
      package: "effect",
      signature: "{ (f: (date: Date) => void, options?: { readonly disambiguation?: Disambiguation; }): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, f: (date: Date) => void, options?: { readonly disambiguation?: Disambiguation; }): A; }",
      description: "Modify a `DateTime` by applying a function to a cloned `Date` instance. The `Date` will first have the time zone applied if possible, and then be\nconverted back to a `DateTime` within the same time zone. Supports `disambiguation` when the new wall clock time is ambiguous.",
      documentation: "Modify a `DateTime` by applying a function to a cloned `Date` instance.\n\nThe `Date` will first have the time zone applied if possible, and then be\nconverted back to a `DateTime` within the same time zone.\n\nSupports `disambiguation` when the new wall clock time is ambiguous.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1594,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1594"
    },
    {
      id: "DateTime.mutateUtc",
      name: "mutateUtc",
      module: "DateTime",
      package: "effect",
      signature: "{ (f: (date: Date) => void): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, f: (date: Date) => void): A; }",
      description: "Modify a `DateTime` by applying a function to a cloned UTC `Date` instance.",
      documentation: "Modify a `DateTime` by applying a function to a cloned UTC `Date` instance.",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1630,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1630"
    },
    {
      id: "DateTime.mapEpochMillis",
      name: "mapEpochMillis",
      module: "DateTime",
      package: "effect",
      signature: "{ (f: (millis: number) => number): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, f: (millis: number) => number): A; }",
      description: "Transform a `DateTime` by applying a function to the number of milliseconds\nsince the Unix epoch.",
      documentation: "Transform a `DateTime` by applying a function to the number of milliseconds\nsince the Unix epoch.",
      examples: [
        {
          code: 'import { DateTime } from "effect"\n\n// add 10 milliseconds\nDateTime.unsafeMake(0).pipe(\n  DateTime.mapEpochMillis((millis) => millis + 10)\n)'
        }
      ],
      tags: [
        "mapping"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1662,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1662"
    },
    {
      id: "DateTime.withDate",
      name: "withDate",
      module: "DateTime",
      package: "effect",
      signature: "{ <A>(f: (date: Date) => A): (self: DateTime) => A; <A>(self: DateTime, f: (date: Date) => A): A; }",
      description: "Using the time zone adjusted `Date`, apply a function to the `Date` and\nreturn the result.",
      documentation: "Using the time zone adjusted `Date`, apply a function to the `Date` and\nreturn the result.",
      examples: [
        {
          code: 'import { DateTime } from "effect"\n\n// get the time zone adjusted date in milliseconds\nDateTime.unsafeMakeZoned(0, { timeZone: "Europe/London" }).pipe(\n  DateTime.withDate((date) => date.getTime())\n)'
        }
      ],
      tags: [
        "mapping"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1714,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1714"
    },
    {
      id: "DateTime.withDateUtc",
      name: "withDateUtc",
      module: "DateTime",
      package: "effect",
      signature: "{ <A>(f: (date: Date) => A): (self: DateTime) => A; <A>(self: DateTime, f: (date: Date) => A): A; }",
      description: "Using the time zone adjusted `Date`, apply a function to the `Date` and\nreturn the result.",
      documentation: "Using the time zone adjusted `Date`, apply a function to the `Date` and\nreturn the result.",
      examples: [
        {
          code: 'import { DateTime } from "effect"\n\n// get the date in milliseconds\nDateTime.unsafeMake(0).pipe(\n  DateTime.withDateUtc((date) => date.getTime())\n)'
        }
      ],
      tags: [
        "mapping"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1766,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1766"
    },
    {
      id: "DateTime.match",
      name: "match",
      module: "DateTime",
      package: "effect",
      signature: "{ <A, B>(options: { readonly onUtc: (_: Utc) => A; readonly onZoned: (_: Zoned) => B; }): (self: DateTime) => A | B; <A, B>(self: DateTime, options: { readonly onUtc: (_: Utc) => A; readonly onZoned: (_: Zoned) => B; }): A | B; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "mapping"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1806,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1806"
    },
    {
      id: "DateTime.addDuration",
      name: "addDuration",
      module: "DateTime",
      package: "effect",
      signature: "{ (duration: DurationInput): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, duration: DurationInput): A; }",
      description: "Add the given `Duration` to a `DateTime`.",
      documentation: "Add the given `Duration` to a `DateTime`.",
      examples: [
        {
          code: 'import { DateTime } from "effect"\n\n// add 5 minutes\nDateTime.unsafeMake(0).pipe(\n  DateTime.addDuration("5 minutes")\n)'
        }
      ],
      tags: [
        "math"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1839,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1839"
    },
    {
      id: "DateTime.subtractDuration",
      name: "subtractDuration",
      module: "DateTime",
      package: "effect",
      signature: "{ (duration: DurationInput): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, duration: DurationInput): A; }",
      description: "Subtract the given `Duration` from a `DateTime`.",
      documentation: "Subtract the given `Duration` from a `DateTime`.",
      examples: [
        {
          code: 'import { DateTime } from "effect"\n\n// subtract 5 minutes\nDateTime.unsafeMake(0).pipe(\n  DateTime.subtractDuration("5 minutes")\n)'
        }
      ],
      tags: [
        "math"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1888,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1888"
    },
    {
      id: "DateTime.add",
      name: "add",
      module: "DateTime",
      package: "effect",
      signature: "{ (parts: Partial<DateTime.PartsForMath>): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, parts: Partial<DateTime.PartsForMath>): A; }",
      description: "Add the given `amount` of `unit`'s to a `DateTime`. The time zone is taken into account when adding days, weeks, months, and\nyears.",
      documentation: "Add the given `amount` of `unit`'s to a `DateTime`.\n\nThe time zone is taken into account when adding days, weeks, months, and\nyears.",
      examples: [
        {
          code: 'import { DateTime } from "effect"\n\n// add 5 minutes\nDateTime.unsafeMake(0).pipe(\n  DateTime.add({ minutes: 5 })\n)'
        }
      ],
      tags: [
        "math"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1940,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1940"
    },
    {
      id: "DateTime.subtract",
      name: "subtract",
      module: "DateTime",
      package: "effect",
      signature: "{ (parts: Partial<DateTime.PartsForMath>): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, parts: Partial<DateTime.PartsForMath>): A; }",
      description: "Subtract the given `amount` of `unit`'s from a `DateTime`.",
      documentation: "Subtract the given `amount` of `unit`'s from a `DateTime`.",
      examples: [
        {
          code: 'import { DateTime } from "effect"\n\n// subtract 5 minutes\nDateTime.unsafeMake(0).pipe(\n  DateTime.subtract({ minutes: 5 })\n)'
        }
      ],
      tags: [
        "math"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 1995,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L1995"
    },
    {
      id: "DateTime.startOf",
      name: "startOf",
      module: "DateTime",
      package: "effect",
      signature: "{ (part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 2 | 1 | 3 | 4 | 5 | 6; }): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 2 | 1 | 3 | 4 | 5 | 6; }): A; }",
      description: "Converts a `DateTime` to the start of the given `part`. If the part is `week`, the `weekStartsOn` option can be used to specify the\nday of the week that the week starts on. The default is 0 (Sunday).",
      documentation: "Converts a `DateTime` to the start of the given `part`.\n\nIf the part is `week`, the `weekStartsOn` option can be used to specify the\nday of the week that the week starts on. The default is 0 (Sunday).",
      examples: [
        {
          code: 'import { DateTime } from "effect"\n\n// returns "2024-01-01T00:00:00Z"\nDateTime.unsafeMake("2024-01-01T12:00:00Z").pipe(\n  DateTime.startOf("day"),\n  DateTime.formatIso\n)'
        }
      ],
      tags: [
        "math"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 2048,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L2048"
    },
    {
      id: "DateTime.endOf",
      name: "endOf",
      module: "DateTime",
      package: "effect",
      signature: "{ (part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 2 | 1 | 3 | 4 | 5 | 6; }): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 2 | 1 | 3 | 4 | 5 | 6; }): A; }",
      description: "Converts a `DateTime` to the end of the given `part`. If the part is `week`, the `weekStartsOn` option can be used to specify the\nday of the week that the week starts on. The default is 0 (Sunday).",
      documentation: "Converts a `DateTime` to the end of the given `part`.\n\nIf the part is `week`, the `weekStartsOn` option can be used to specify the\nday of the week that the week starts on. The default is 0 (Sunday).",
      examples: [
        {
          code: 'import { DateTime } from "effect"\n\n// returns "2024-01-01T23:59:59.999Z"\nDateTime.unsafeMake("2024-01-01T12:00:00Z").pipe(\n  DateTime.endOf("day"),\n  DateTime.formatIso\n)'
        }
      ],
      tags: [
        "math"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 2113,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L2113"
    },
    {
      id: "DateTime.nearest",
      name: "nearest",
      module: "DateTime",
      package: "effect",
      signature: "{ (part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 2 | 1 | 3 | 4 | 5 | 6; }): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 2 | 1 | 3 | 4 | 5 | 6; }): A; }",
      description: "Converts a `DateTime` to the nearest given `part`. If the part is `week`, the `weekStartsOn` option can be used to specify the\nday of the week that the week starts on. The default is 0 (Sunday).",
      documentation: "Converts a `DateTime` to the nearest given `part`.\n\nIf the part is `week`, the `weekStartsOn` option can be used to specify the\nday of the week that the week starts on. The default is 0 (Sunday).",
      examples: [
        {
          code: 'import { DateTime } from "effect"\n\n// returns "2024-01-02T00:00:00Z"\nDateTime.unsafeMake("2024-01-01T12:01:00Z").pipe(\n  DateTime.nearest("day"),\n  DateTime.formatIso\n)'
        }
      ],
      tags: [
        "math"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 2178,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L2178"
    },
    {
      id: "DateTime.format",
      name: "format",
      module: "DateTime",
      package: "effect",
      signature: "{ (options?: Intl.DateTimeFormatOptions & { readonly locale?: Intl.LocalesArgument; }): (self: DateTime) => string; (self: DateTime, options?: Intl.DateTimeFormatOptions & { readonly locale?: Intl.LocalesArgument; }): string; }",
      description: 'Format a `DateTime` as a string using the `DateTimeFormat` API. The `timeZone` option is set to the offset of the time zone. Note: On Node versions < 22, fixed "Offset" zones will set the time zone to\n"UTC" and use the adjusted `Date`.',
      documentation: 'Format a `DateTime` as a string using the `DateTimeFormat` API.\n\nThe `timeZone` option is set to the offset of the time zone.\n\nNote: On Node versions < 22, fixed "Offset" zones will set the time zone to\n"UTC" and use the adjusted `Date`.',
      examples: [],
      tags: [
        "formatting"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 2235,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L2235"
    },
    {
      id: "DateTime.formatLocal",
      name: "formatLocal",
      module: "DateTime",
      package: "effect",
      signature: "{ (options?: Intl.DateTimeFormatOptions & { readonly locale?: Intl.LocalesArgument; }): (self: DateTime) => string; (self: DateTime, options?: Intl.DateTimeFormatOptions & { readonly locale?: Intl.LocalesArgument; }): string; }",
      description: "Format a `DateTime` as a string using the `DateTimeFormat` API. It will use the system's local time zone & locale.",
      documentation: "Format a `DateTime` as a string using the `DateTimeFormat` API.\n\nIt will use the system's local time zone & locale.",
      examples: [],
      tags: [
        "formatting"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 2273,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L2273"
    },
    {
      id: "DateTime.formatUtc",
      name: "formatUtc",
      module: "DateTime",
      package: "effect",
      signature: "{ (options?: Intl.DateTimeFormatOptions & { readonly locale?: Intl.LocalesArgument; }): (self: DateTime) => string; (self: DateTime, options?: Intl.DateTimeFormatOptions & { readonly locale?: Intl.LocalesArgument; }): string; }",
      description: "Format a `DateTime` as a string using the `DateTimeFormat` API. This forces the time zone to be UTC.",
      documentation: "Format a `DateTime` as a string using the `DateTimeFormat` API.\n\nThis forces the time zone to be UTC.",
      examples: [],
      tags: [
        "formatting"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 2305,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L2305"
    },
    {
      id: "DateTime.formatIntl",
      name: "formatIntl",
      module: "DateTime",
      package: "effect",
      signature: "{ (format: Intl.DateTimeFormat): (self: DateTime) => string; (self: DateTime, format: Intl.DateTimeFormat): string; }",
      description: "Format a `DateTime` as a string using the `DateTimeFormat` API.",
      documentation: "Format a `DateTime` as a string using the `DateTimeFormat` API.",
      examples: [],
      tags: [
        "formatting"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 2335,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L2335"
    },
    {
      id: "DateTime.formatIso",
      name: "formatIso",
      module: "DateTime",
      package: "effect",
      signature: "(self: DateTime) => string",
      description: "Format a `DateTime` as a UTC ISO string.",
      documentation: "Format a `DateTime` as a UTC ISO string.",
      examples: [],
      tags: [
        "formatting"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 2357,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L2357"
    },
    {
      id: "DateTime.formatIsoDate",
      name: "formatIsoDate",
      module: "DateTime",
      package: "effect",
      signature: "(self: DateTime) => string",
      description: "Format a `DateTime` as a time zone adjusted ISO date string.",
      documentation: "Format a `DateTime` as a time zone adjusted ISO date string.",
      examples: [],
      tags: [
        "formatting"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 2364,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L2364"
    },
    {
      id: "DateTime.formatIsoDateUtc",
      name: "formatIsoDateUtc",
      module: "DateTime",
      package: "effect",
      signature: "(self: DateTime) => string",
      description: "Format a `DateTime` as a UTC ISO date string.",
      documentation: "Format a `DateTime` as a UTC ISO date string.",
      examples: [],
      tags: [
        "formatting"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 2371,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L2371"
    },
    {
      id: "DateTime.formatIsoOffset",
      name: "formatIsoOffset",
      module: "DateTime",
      package: "effect",
      signature: "(self: DateTime) => string",
      description: "Format a `DateTime.Zoned` as a ISO string with an offset.",
      documentation: "Format a `DateTime.Zoned` as a ISO string with an offset.",
      examples: [],
      tags: [
        "formatting"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 2378,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L2378"
    },
    {
      id: "DateTime.formatIsoZoned",
      name: "formatIsoZoned",
      module: "DateTime",
      package: "effect",
      signature: "(self: Zoned) => string",
      description: "Format a `DateTime.Zoned` as a string. It uses the format: `YYYY-MM-DDTHH:mm:ss.sss+HH:MM[Time/Zone]`.",
      documentation: "Format a `DateTime.Zoned` as a string.\n\nIt uses the format: `YYYY-MM-DDTHH:mm:ss.sss+HH:MM[Time/Zone]`.",
      examples: [],
      tags: [
        "formatting"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 2387,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L2387"
    },
    {
      id: "DateTime.layerCurrentZone",
      name: "layerCurrentZone",
      module: "DateTime",
      package: "effect",
      signature: "(zone: TimeZone) => Layer<CurrentTimeZone, never, never>",
      description: "Create a Layer from the given time zone.",
      documentation: "Create a Layer from the given time zone.",
      examples: [],
      tags: [
        "current time zone"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 2394,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L2394"
    },
    {
      id: "DateTime.layerCurrentZoneOffset",
      name: "layerCurrentZoneOffset",
      module: "DateTime",
      package: "effect",
      signature: "(offset: number) => Layer<CurrentTimeZone, never, never>",
      description: "Create a Layer from the given time zone offset.",
      documentation: "Create a Layer from the given time zone offset.",
      examples: [],
      tags: [
        "current time zone"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 2401,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L2401"
    },
    {
      id: "DateTime.layerCurrentZoneNamed",
      name: "layerCurrentZoneNamed",
      module: "DateTime",
      package: "effect",
      signature: "(zoneId: string) => Layer<CurrentTimeZone, IllegalArgumentException, never>",
      description: "Create a Layer from the given IANA time zone identifier.",
      documentation: "Create a Layer from the given IANA time zone identifier.",
      examples: [],
      tags: [
        "current time zone"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 2408,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L2408"
    },
    {
      id: "DateTime.layerCurrentZoneLocal",
      name: "layerCurrentZoneLocal",
      module: "DateTime",
      package: "effect",
      signature: "Layer<CurrentTimeZone, never, never>",
      description: "Create a Layer from the systems local time zone.",
      documentation: "Create a Layer from the systems local time zone.",
      examples: [],
      tags: [
        "current time zone"
      ],
      since: "3.6.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/effect/dist/dts/DateTime.d.ts",
      sourceLine: 2415,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/DateTime.ts#L2415"
    },
    {
      id: "FileSystem.Size",
      name: "Size",
      module: "FileSystem",
      package: "@effect/platform",
      signature: "(bytes: SizeInput) => Size",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "sizes"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/FileSystem.d.ts",
      sourceLine: 198,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FileSystem.ts#L198"
    },
    {
      id: "FileSystem.KiB",
      name: "KiB",
      module: "FileSystem",
      package: "@effect/platform",
      signature: "(n: number) => Size",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "sizes"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/FileSystem.d.ts",
      sourceLine: 203,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FileSystem.ts#L203"
    },
    {
      id: "FileSystem.MiB",
      name: "MiB",
      module: "FileSystem",
      package: "@effect/platform",
      signature: "(n: number) => Size",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "sizes"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/FileSystem.d.ts",
      sourceLine: 208,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FileSystem.ts#L208"
    },
    {
      id: "FileSystem.GiB",
      name: "GiB",
      module: "FileSystem",
      package: "@effect/platform",
      signature: "(n: number) => Size",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "sizes"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/FileSystem.d.ts",
      sourceLine: 213,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FileSystem.ts#L213"
    },
    {
      id: "FileSystem.TiB",
      name: "TiB",
      module: "FileSystem",
      package: "@effect/platform",
      signature: "(n: number) => Size",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "sizes"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/FileSystem.d.ts",
      sourceLine: 218,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FileSystem.ts#L218"
    },
    {
      id: "FileSystem.PiB",
      name: "PiB",
      module: "FileSystem",
      package: "@effect/platform",
      signature: "(n: number) => Size",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "sizes"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/FileSystem.d.ts",
      sourceLine: 223,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FileSystem.ts#L223"
    },
    {
      id: "FileSystem.FileSystem",
      name: "FileSystem",
      module: "FileSystem",
      package: "@effect/platform",
      signature: "Tag<FileSystem, FileSystem>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "tag"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/FileSystem.d.ts",
      sourceLine: 346,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FileSystem.ts#L346"
    },
    {
      id: "FileSystem.make",
      name: "make",
      module: "FileSystem",
      package: "@effect/platform",
      signature: '(impl: Omit<FileSystem, "exists" | "readFileString" | "stream" | "sink" | "writeFileString">) => FileSystem',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructor"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/FileSystem.d.ts",
      sourceLine: 351,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FileSystem.ts#L351"
    },
    {
      id: "FileSystem.makeNoop",
      name: "makeNoop",
      module: "FileSystem",
      package: "@effect/platform",
      signature: "(fileSystem: Partial<FileSystem>) => FileSystem",
      description: "Create a no-op file system that can be used for testing.",
      documentation: "Create a no-op file system that can be used for testing.",
      examples: [],
      tags: [
        "constructor"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/FileSystem.d.ts",
      sourceLine: 358,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FileSystem.ts#L358"
    },
    {
      id: "FileSystem.layerNoop",
      name: "layerNoop",
      module: "FileSystem",
      package: "@effect/platform",
      signature: "(fileSystem: Partial<FileSystem>) => Layer<FileSystem, never, never>",
      description: "Create a no-op file system that can be used for testing.",
      documentation: "Create a no-op file system that can be used for testing.",
      examples: [],
      tags: [
        "layers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/FileSystem.d.ts",
      sourceLine: 365,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FileSystem.ts#L365"
    },
    {
      id: "FileSystem.FileTypeId",
      name: "FileTypeId",
      module: "FileSystem",
      package: "@effect/platform",
      signature: "typeof FileTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type id"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/FileSystem.d.ts",
      sourceLine: 370,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FileSystem.ts#L370"
    },
    {
      id: "FileSystem.isFile",
      name: "isFile",
      module: "FileSystem",
      package: "@effect/platform",
      signature: "(u: unknown) => u is File",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "guard"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/FileSystem.d.ts",
      sourceLine: 380,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FileSystem.ts#L380"
    },
    {
      id: "FileSystem.FileDescriptor",
      name: "FileDescriptor",
      module: "FileSystem",
      package: "@effect/platform",
      signature: "Brand.Constructor<File.Descriptor>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructor"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/FileSystem.d.ts",
      sourceLine: 436,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FileSystem.ts#L436"
    },
    {
      id: "FileSystem.WatchEventCreate",
      name: "WatchEventCreate",
      module: "FileSystem",
      package: "@effect/platform",
      signature: 'Case.Constructor<WatchEvent.Create, "_tag">',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructor"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/FileSystem.d.ts",
      sourceLine: 481,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FileSystem.ts#L481"
    },
    {
      id: "FileSystem.WatchEventUpdate",
      name: "WatchEventUpdate",
      module: "FileSystem",
      package: "@effect/platform",
      signature: 'Case.Constructor<WatchEvent.Update, "_tag">',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructor"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/FileSystem.d.ts",
      sourceLine: 486,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FileSystem.ts#L486"
    },
    {
      id: "FileSystem.WatchEventRemove",
      name: "WatchEventRemove",
      module: "FileSystem",
      package: "@effect/platform",
      signature: 'Case.Constructor<WatchEvent.Remove, "_tag">',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructor"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/FileSystem.d.ts",
      sourceLine: 491,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FileSystem.ts#L491"
    },
    {
      id: "HttpApi.TypeId",
      name: "TypeId",
      module: "HttpApi",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApi.d.ts",
      sourceLine: 21,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApi.ts#L21"
    },
    {
      id: "HttpApi.isHttpApi",
      name: "isHttpApi",
      module: "HttpApi",
      package: "@effect/platform",
      signature: "(u: unknown) => u is HttpApi.Any",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "guards"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApi.d.ts",
      sourceLine: 31,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApi.ts#L31"
    },
    {
      id: "HttpApi.make",
      name: "make",
      module: "HttpApi",
      package: "@effect/platform",
      signature: "<const Id extends string>(identifier: Id) => HttpApi<Id, never, HttpApiDecodeError, never>",
      description: "An `HttpApi` is a collection of `HttpApiEndpoint`s. You can use an `HttpApi` to\nrepresent a portion of your domain. The endpoints can be implemented later using the `HttpApiBuilder.make` api.",
      documentation: "An `HttpApi` is a collection of `HttpApiEndpoint`s. You can use an `HttpApi` to\nrepresent a portion of your domain.\n\nThe endpoints can be implemented later using the `HttpApiBuilder.make` api.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApi.d.ts",
      sourceLine: 118,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApi.ts#L118"
    },
    {
      id: "HttpApi.reflect",
      name: "reflect",
      module: "HttpApi",
      package: "@effect/platform",
      signature: "<Id extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, Error, R>(self: HttpApi<Id, Groups, Error, R>, options: { readonly predicate?: Predicate<{ readonly endpoint: HttpApiEndpoint.AnyWithProps; readonly group: HttpApiGroup.AnyWithProps; }>; readonly onGroup: (options: { readonly group: HttpApiGroup.AnyWithProps; readonly mergedAnnotations: Context<never>; }) => void; readonly onEndpoint: (options: { readonly group: HttpApiGroup.AnyWithProps; readonly endpoint: HttpApiEndpoint<string, HttpMethod, never, never, never, never, void, never, never, never>; readonly mergedAnnotations: Context<never>; readonly middleware: ReadonlySet<TagClassAny>; readonly payloads: ReadonlyMap<string, { readonly encoding: Encoding; readonly ast: AST; }>; readonly successes: ReadonlyMap<number, { readonly ast: Option<AST>; readonly description: Option<string>; }>; readonly errors: ReadonlyMap<number, { readonly ast: Option<AST>; readonly description: Option<string>; }>; }) => void; }) => void",
      description: "Extract metadata from an `HttpApi`, which can be used to generate documentation\nor other tooling. See the `OpenApi` & `HttpApiClient` modules for examples of how to use this function.",
      documentation: "Extract metadata from an `HttpApi`, which can be used to generate documentation\nor other tooling.\n\nSee the `OpenApi` & `HttpApiClient` modules for examples of how to use this function.",
      examples: [],
      tags: [
        "reflection"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApi.d.ts",
      sourceLine: 128,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApi.ts#L128"
    },
    {
      id: "HttpApiBuilder.api",
      name: "api",
      module: "HttpApiBuilder",
      package: "@effect/platform",
      signature: "<Id extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, E, R>(api: HttpApi<Id, Groups, E, R>) => Layer<Api, never, R | HttpApiGroup.ToService<Id, Groups> | HttpApiGroup.ErrorContext<Groups>>",
      description: "Create a top-level `HttpApi` layer.",
      documentation: "Create a top-level `HttpApi` layer.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiBuilder.d.ts",
      sourceLine: 38,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiBuilder.ts#L38"
    },
    {
      id: "HttpApiBuilder.serve",
      name: "serve",
      module: "HttpApiBuilder",
      package: "@effect/platform",
      signature: "<R = never>(middleware?: (httpApp: Default<never, never>) => Default<never, R>) => Layer<never, never, Api | HttpServer | HttpRouter.DefaultServices | Exclude<R, Scope | HttpServerRequest>>",
      description: "Build an `HttpApp` from an `HttpApi` instance, and serve it using an\n`HttpServer`. Optionally, you can provide a middleware function that will be applied to\nthe `HttpApp` before serving.",
      documentation: "Build an `HttpApp` from an `HttpApi` instance, and serve it using an\n`HttpServer`.\n\nOptionally, you can provide a middleware function that will be applied to\nthe `HttpApp` before serving.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiBuilder.d.ts",
      sourceLine: 49,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiBuilder.ts#L49"
    },
    {
      id: "HttpApiBuilder.httpApp",
      name: "httpApp",
      module: "HttpApiBuilder",
      package: "@effect/platform",
      signature: "Effect<Default<never, HttpRouter.DefaultServices>, never, Api | Router | Middleware>",
      description: "Construct an `HttpApp` from an `HttpApi` instance.",
      documentation: "Construct an `HttpApp` from an `HttpApi` instance.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiBuilder.d.ts",
      sourceLine: 56,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiBuilder.ts#L56"
    },
    {
      id: "HttpApiBuilder.buildMiddleware",
      name: "buildMiddleware",
      module: "HttpApiBuilder",
      package: "@effect/platform",
      signature: "<Id extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, E, R>(api: HttpApi<Id, Groups, E, R>) => Effect<(effect: Effect<HttpServerResponse, unknown, never>) => Effect<HttpServerResponse, unknown, never>, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiBuilder.d.ts",
      sourceLine: 61,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiBuilder.ts#L61"
    },
    {
      id: "HttpApiBuilder.toWebHandler",
      name: "toWebHandler",
      module: "HttpApiBuilder",
      package: "@effect/platform",
      signature: "<LA, LE>(layer: Layer<Api | HttpRouter.DefaultServices | LA, LE, never>, options?: { readonly middleware?: (httpApp: Default<never, never>) => Default<never, Api | HttpRouter.DefaultServices | Router>; readonly memoMap?: MemoMap; }) => { readonly handler: (request: Request, context?: Context<never>) => Promise<Response>; readonly dispose: () => Promise<void>; }",
      description: "Construct an http web handler from an `HttpApi` instance.",
      documentation: 'Construct an http web handler from an `HttpApi` instance.\n\n**Example**\n\n```ts\nimport { HttpApi, HttpApiBuilder, HttpServer } from "@effect/platform"\nimport { Layer } from "effect"\n\nclass MyApi extends HttpApi.make("api") {}\n\nconst MyApiLive = HttpApiBuilder.api(MyApi)\n\nconst { dispose, handler } = HttpApiBuilder.toWebHandler(\n  Layer.mergeAll(\n    MyApiLive,\n    // you could also use NodeHttpServer.layerContext, depending on your\n    // server\'s platform\n    HttpServer.layerContext\n  )\n)\n```',
      examples: [
        {
          code: `import { HttpApi, HttpApiBuilder, HttpServer } from "@effect/platform"
import { Layer } from "effect"

class MyApi extends HttpApi.make("api") {}

const MyApiLive = HttpApiBuilder.api(MyApi)

const { dispose, handler } = HttpApiBuilder.toWebHandler(
  Layer.mergeAll(
    MyApiLive,
    // you could also use NodeHttpServer.layerContext, depending on your
    // server's platform
    HttpServer.layerContext
  )
)`
        }
      ],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiBuilder.d.ts",
      sourceLine: 88,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiBuilder.ts#L88"
    },
    {
      id: "HttpApiBuilder.HandlersTypeId",
      name: "HandlersTypeId",
      module: "HttpApiBuilder",
      package: "@effect/platform",
      signature: "typeof HandlersTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "handlers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiBuilder.d.ts",
      sourceLine: 99,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiBuilder.ts#L99"
    },
    {
      id: "HttpApiBuilder.group",
      name: "group",
      module: "HttpApiBuilder",
      package: "@effect/platform",
      signature: "<ApiId extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, ApiError, ApiR, const Name extends HttpApiGroup.HttpApiGroup.Name<Groups>, Return>(api: HttpApi<ApiId, Groups, ApiError, ApiR>, groupName: Name, build: (handlers: Handlers.FromGroup<ApiError, ApiR, Extract<Groups, { readonly identifier: Name; }>>) => Handlers.ValidateReturn<Return>) => Layer<ApiGroup<ApiId, Name>, Handlers.Error<Return>, Exclude<Handlers.Context<Return>, Scope> | Exclude<HttpApiGroup.Middleware<Extract<Groups, { readonly identifier: Name; }>>, Scope>>",
      description: "Create a `Layer` that will implement all the endpoints in an `HttpApi`. An unimplemented `Handlers` instance is passed to the `build` function, which\nyou can use to add handlers to the group. You can implement endpoints using the `handlers.handle` api.",
      documentation: "Create a `Layer` that will implement all the endpoints in an `HttpApi`.\n\nAn unimplemented `Handlers` instance is passed to the `build` function, which\nyou can use to add handlers to the group.\n\nYou can implement endpoints using the `handlers.handle` api.",
      examples: [],
      tags: [
        "handlers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiBuilder.d.ts",
      sourceLine: 190,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiBuilder.ts#L190"
    },
    {
      id: "HttpApiBuilder.handler",
      name: "handler",
      module: "HttpApiBuilder",
      package: "@effect/platform",
      signature: '<ApiId extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, ApiError, ApiR, const GroupName extends Groups["identifier"], const Name extends HttpApiGroup.HttpApiGroup.EndpointsWithName<Groups, GroupName>["name"], R>(_api: HttpApi<ApiId, Groups, ApiError, ApiR>, _groupName: GroupName, _name: Name, f: HttpApiEndpoint.HandlerWithName<HttpApiGroup.Endpoints<Extract<Groups, { readonly identifier: GroupName; }>>, Name, ApiError | HttpApiGroup.Error<Extract<Groups, { readonly identifier: GroupName; }>>, R>) => HttpApiEndpoint.HandlerWithName<HttpApiGroup.Endpoints<Extract<Groups, { readonly identifier: GroupName; }>>, Name, ApiError | HttpApiGroup.Error<Extract<Groups, { readonly identifier: GroupName; }>>, R>',
      description: "Create a `Handler` for a single endpoint.",
      documentation: "Create a `Handler` for a single endpoint.",
      examples: [],
      tags: [
        "handlers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiBuilder.d.ts",
      sourceLine: 197,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiBuilder.ts#L197"
    },
    {
      id: "HttpApiBuilder.middleware",
      name: "middleware",
      module: "HttpApiBuilder",
      package: "@effect/platform",
      signature: "{ <EX = never, RX = never>(middleware: MiddlewareFn<never, HttpRouter.Provided> | Effect<MiddlewareFn<never, HttpRouter.Provided>, EX, RX>, options?: { readonly withContext?: false; }): Layer<never, EX, Exclude<RX, Scope>>; <R, EX = never, RX = never>(middleware: MiddlewareFn<never, R> | Effect<MiddlewareFn<never, R>, EX, RX>, options: { readonly withContext: true; }): Layer<never, EX, Exclude<RX, Scope> | Exclude<Exclude<R, HttpRouter.Provided>, Scope>>; <ApiId extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, Error, ErrorR, EX = never, RX = never>(api: HttpApi<ApiId, Groups, Error, ErrorR>, middleware: MiddlewareFn<NoInfer<Error>, HttpRouter.Provided> | Effect<MiddlewareFn<NoInfer<Error>, HttpRouter.Provided>, EX, RX>, options?: { readonly withContext?: false; }): Layer<never, EX, Exclude<RX, Scope>>; <ApiId extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, Error, ErrorR, R, EX = never, RX = never>(api: HttpApi<ApiId, Groups, Error, ErrorR>, middleware: MiddlewareFn<NoInfer<Error>, R> | Effect<MiddlewareFn<NoInfer<Error>, R>, EX, RX>, options: { readonly withContext: true; }): Layer<never, EX, Exclude<RX, Scope> | Exclude<Exclude<R, HttpRouter.Provided>, Scope>>; }",
      description: "Create an `HttpApi` level middleware `Layer`.",
      documentation: "Create an `HttpApi` level middleware `Layer`.",
      examples: [],
      tags: [
        "middleware"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiBuilder.d.ts",
      sourceLine: 223,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiBuilder.ts#L223"
    },
    {
      id: "HttpApiBuilder.middlewareCors",
      name: "middlewareCors",
      module: "HttpApiBuilder",
      package: "@effect/platform",
      signature: "(options?: { readonly allowedOrigins?: readonly string[] | Predicate<string>; readonly allowedMethods?: readonly string[]; readonly allowedHeaders?: readonly string[]; readonly exposedHeaders?: readonly string[]; readonly maxAge?: number; readonly credentials?: boolean; }) => Layer<never, never, never>",
      description: "A CORS middleware layer that can be provided to the `HttpApiBuilder.serve` layer.",
      documentation: "A CORS middleware layer that can be provided to the `HttpApiBuilder.serve` layer.",
      examples: [],
      tags: [
        "middleware"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiBuilder.d.ts",
      sourceLine: 267,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiBuilder.ts#L267"
    },
    {
      id: "HttpApiBuilder.middlewareOpenApi",
      name: "middlewareOpenApi",
      module: "HttpApiBuilder",
      package: "@effect/platform",
      signature: "(options?: { readonly path?: `/${string}`; readonly additionalPropertiesStrategy?: AdditionalPropertiesStrategy; }) => Layer<never, never, Api>",
      description: "A middleware that adds an openapi.json endpoint to the API.",
      documentation: "A middleware that adds an openapi.json endpoint to the API.",
      examples: [],
      tags: [
        "middleware"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiBuilder.d.ts",
      sourceLine: 281,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiBuilder.ts#L281"
    },
    {
      id: "HttpApiBuilder.securityDecode",
      name: "securityDecode",
      module: "HttpApiBuilder",
      package: "@effect/platform",
      signature: "<Security extends HttpApiSecurity.HttpApiSecurity>(self: Security) => Effect<HttpApiSecurity.Type<Security>, never, HttpServerRequest | ParsedSearchParams>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "security"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiBuilder.d.ts",
      sourceLine: 289,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiBuilder.ts#L289"
    },
    {
      id: "HttpApiBuilder.securitySetCookie",
      name: "securitySetCookie",
      module: "HttpApiBuilder",
      package: "@effect/platform",
      signature: '(self: ApiKey, value: string | Redacted<string>, options?: { readonly domain?: string; readonly expires?: Date; readonly maxAge?: DurationInput; readonly path?: string; readonly priority?: "low" | "medium" | "high"; readonly httpOnly?: boolean; readonly secure?: boolean; readonly partitioned?: boolean; readonly sameSite?: "strict" | "lax" | "none"; }) => Effect<void, never, never>',
      description: "Set a cookie from an `HttpApiSecurity.HttpApiKey` instance. You can use this api before returning a response from an endpoint handler.",
      documentation: 'Set a cookie from an `HttpApiSecurity.HttpApiKey` instance.\n\nYou can use this api before returning a response from an endpoint handler.\n\n```ts skip-type-checking\nhandlers.handle(\n  "authenticate",\n  (_) => HttpApiBuilder.securitySetCookie(security, "secret123")\n)\n```',
      examples: [],
      tags: [
        "middleware"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiBuilder.d.ts",
      sourceLine: 305,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiBuilder.ts#L305"
    },
    {
      id: "HttpApiClient.make",
      name: "make",
      module: "HttpApiClient",
      package: "@effect/platform",
      signature: '<ApiId extends string, Groups extends HttpApiGroup.Any, ApiError, ApiR>(api: HttpApi<ApiId, Groups, ApiError, ApiR>, options?: { readonly transformClient?: (client: HttpClient) => HttpClient; readonly transformResponse?: (effect: Effect<unknown, unknown, never>) => Effect<unknown, unknown, never>; readonly baseUrl?: string | URL; }) => Effect<Simplify<Simplify<{ readonly [Group in Extract<Groups, { readonly topLevel: false; }> as HttpApiGroup.Name<Group>]: Client.Group<Group, Group["identifier"], ApiError, never>; } & { readonly [Method in Client.TopLevelMethods<Groups, ApiError, never> as Method[0]]: Method[1]; }>>, never, HttpClient | Exclude<ApiR, HttpApiMiddleware.AnyId> | Exclude<HttpApiGroup.ClientContext<Groups>, HttpApiMiddleware.AnyId>>',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiClient.d.ts",
      sourceLine: 57,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiClient.ts#L57"
    },
    {
      id: "HttpApiClient.makeWith",
      name: "makeWith",
      module: "HttpApiClient",
      package: "@effect/platform",
      signature: '<ApiId extends string, Groups extends HttpApiGroup.Any, ApiError, ApiR, E, R>(api: HttpApi<ApiId, Groups, ApiError, ApiR>, options: { readonly httpClient: HttpClient.With<E, R>; readonly transformResponse?: (effect: Effect<unknown, unknown, never>) => Effect<unknown, unknown, never>; readonly baseUrl?: string | URL; }) => Effect<Simplify<Simplify<{ readonly [Group in Extract<Groups, { readonly topLevel: false; }> as HttpApiGroup.Name<Group>]: Client.Group<Group, Group["identifier"], ApiError | E, R>; } & { readonly [Method in Client.TopLevelMethods<Groups, ApiError | E, R> as Method[0]]: Method[1]; }>>, never, Exclude<ApiR, HttpApiMiddleware.AnyId> | Exclude<HttpApiGroup.ClientContext<Groups>, HttpApiMiddleware.AnyId>>',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiClient.d.ts",
      sourceLine: 66,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiClient.ts#L66"
    },
    {
      id: "HttpApiClient.group",
      name: "group",
      module: "HttpApiClient",
      package: "@effect/platform",
      signature: "<ApiId extends string, Groups extends HttpApiGroup.Any, ApiError, ApiR, const GroupName extends HttpApiGroup.Name<Groups>, E, R>(api: HttpApi<ApiId, Groups, ApiError, ApiR>, options: { readonly group: GroupName; readonly httpClient: HttpClient.With<E, R>; readonly transformResponse?: (effect: Effect<unknown, unknown, never>) => Effect<unknown, unknown, never>; readonly baseUrl?: string | URL; }) => Effect<Client.Group<Groups, GroupName, ApiError | E, R>, never, Exclude<ApiR, HttpApiMiddleware.AnyId> | Exclude<HttpApiGroup.ClientContext<Extract<Groups, { readonly identifier: GroupName; }>>, HttpApiMiddleware.AnyId>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiClient.d.ts",
      sourceLine: 75,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiClient.ts#L75"
    },
    {
      id: "HttpApiClient.endpoint",
      name: "endpoint",
      module: "HttpApiClient",
      package: "@effect/platform",
      signature: "<ApiId extends string, Groups extends HttpApiGroup.Any, ApiError, ApiR, const GroupName extends HttpApiGroup.Name<Groups>, const EndpointName extends HttpApiEndpoint.Name<HttpApiGroup.EndpointsWithName<Groups, GroupName>>, E, R>(api: HttpApi<ApiId, Groups, ApiError, ApiR>, options: { readonly group: GroupName; readonly endpoint: EndpointName; readonly httpClient: HttpClient.With<E, R>; readonly transformClient?: (client: HttpClient) => HttpClient; readonly transformResponse?: (effect: Effect<unknown, unknown, never>) => Effect<unknown, unknown, never>; readonly baseUrl?: string | URL; }) => Effect<Client.Method<Extract<HttpApiGroup.Endpoints<Extract<Groups, { readonly identifier: GroupName; }>>, { readonly name: EndpointName; }>, HttpApiGroup.Error<Extract<Groups, { readonly identifier: GroupName; }>>, ApiError | E, R>, never, Exclude<ApiR, HttpApiMiddleware.AnyId> | Exclude<HttpApiGroup.Context<Extract<Groups, { readonly identifier: GroupName; }>>, HttpApiMiddleware.AnyId> | Exclude<HttpApiEndpoint.Context<Extract<HttpApiGroup.Endpoints<Extract<Groups, { readonly identifier: GroupName; }>>, { readonly name: EndpointName; }>>, HttpApiMiddleware.AnyId> | Exclude<HttpApiEndpoint.ErrorContext<Extract<HttpApiGroup.Endpoints<Extract<Groups, { readonly identifier: GroupName; }>>, { readonly name: EndpointName; }>>, HttpApiMiddleware.AnyId>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiClient.d.ts",
      sourceLine: 85,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiClient.ts#L85"
    },
    {
      id: "HttpApiEndpoint.TypeId",
      name: "TypeId",
      module: "HttpApiEndpoint",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiEndpoint.d.ts",
      sourceLine: 23,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiEndpoint.ts#L23"
    },
    {
      id: "HttpApiEndpoint.isHttpApiEndpoint",
      name: "isHttpApiEndpoint",
      module: "HttpApiEndpoint",
      package: "@effect/platform",
      signature: "(u: unknown) => u is HttpApiEndpoint<any, any, any, never, never, never, void, never, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "guards"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiEndpoint.d.ts",
      sourceLine: 33,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiEndpoint.ts#L33"
    },
    {
      id: "HttpApiEndpoint.make",
      name: "make",
      module: "HttpApiEndpoint",
      package: "@effect/platform",
      signature: "<Method extends HttpMethod>(method: Method) => { <const Name extends string>(name: Name): HttpApiEndpoint.Constructor<Name, Method>; <const Name extends string>(name: Name, path: `/${string}`): HttpApiEndpoint<Name, Method, never, never, never, never, void, never, never, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiEndpoint.d.ts",
      sourceLine: 358,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiEndpoint.ts#L358"
    },
    {
      id: "HttpApiEndpoint.get",
      name: "get",
      module: "HttpApiEndpoint",
      package: "@effect/platform",
      signature: '{ <const Name extends string>(name: Name): HttpApiEndpoint.Constructor<Name, "GET">; <const Name extends string>(name: Name, path: `/${string}`): HttpApiEndpoint<Name, "GET", never, never, never, never, void, never, never, never>; }',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiEndpoint.d.ts",
      sourceLine: 366,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiEndpoint.ts#L366"
    },
    {
      id: "HttpApiEndpoint.post",
      name: "post",
      module: "HttpApiEndpoint",
      package: "@effect/platform",
      signature: '{ <const Name extends string>(name: Name): HttpApiEndpoint.Constructor<Name, "POST">; <const Name extends string>(name: Name, path: `/${string}`): HttpApiEndpoint<Name, "POST", never, never, never, never, void, never, never, never>; }',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiEndpoint.d.ts",
      sourceLine: 382,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiEndpoint.ts#L382"
    },
    {
      id: "HttpApiEndpoint.put",
      name: "put",
      module: "HttpApiEndpoint",
      package: "@effect/platform",
      signature: '{ <const Name extends string>(name: Name): HttpApiEndpoint.Constructor<Name, "PUT">; <const Name extends string>(name: Name, path: `/${string}`): HttpApiEndpoint<Name, "PUT", never, never, never, never, void, never, never, never>; }',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiEndpoint.d.ts",
      sourceLine: 398,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiEndpoint.ts#L398"
    },
    {
      id: "HttpApiEndpoint.patch",
      name: "patch",
      module: "HttpApiEndpoint",
      package: "@effect/platform",
      signature: '{ <const Name extends string>(name: Name): HttpApiEndpoint.Constructor<Name, "PATCH">; <const Name extends string>(name: Name, path: `/${string}`): HttpApiEndpoint<Name, "PATCH", never, never, never, never, void, never, never, never>; }',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiEndpoint.d.ts",
      sourceLine: 414,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiEndpoint.ts#L414"
    },
    {
      id: "HttpApiEndpoint.del",
      name: "del",
      module: "HttpApiEndpoint",
      package: "@effect/platform",
      signature: '{ <const Name extends string>(name: Name): HttpApiEndpoint.Constructor<Name, "DELETE">; <const Name extends string>(name: Name, path: `/${string}`): HttpApiEndpoint<Name, "DELETE", never, never, never, never, void, never, never, never>; }',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiEndpoint.d.ts",
      sourceLine: 430,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiEndpoint.ts#L430"
    },
    {
      id: "HttpApiEndpoint.head",
      name: "head",
      module: "HttpApiEndpoint",
      package: "@effect/platform",
      signature: '{ <const Name extends string>(name: Name): HttpApiEndpoint.Constructor<Name, "HEAD">; <const Name extends string>(name: Name, path: `/${string}`): HttpApiEndpoint<Name, "HEAD", never, never, never, never, void, never, never, never>; }',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiEndpoint.d.ts",
      sourceLine: 446,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiEndpoint.ts#L446"
    },
    {
      id: "HttpApiEndpoint.options",
      name: "options",
      module: "HttpApiEndpoint",
      package: "@effect/platform",
      signature: '{ <const Name extends string>(name: Name): HttpApiEndpoint.Constructor<Name, "OPTIONS">; <const Name extends string>(name: Name, path: `/${string}`): HttpApiEndpoint<Name, "OPTIONS", never, never, never, never, void, never, never, never>; }',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiEndpoint.d.ts",
      sourceLine: 462,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiEndpoint.ts#L462"
    },
    {
      id: "HttpApiError.TypeId",
      name: "TypeId",
      module: "HttpApiError",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiError.d.ts",
      sourceLine: 12,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiError.ts#L12"
    },
    {
      id: "HttpApiGroup.TypeId",
      name: "TypeId",
      module: "HttpApiGroup",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiGroup.d.ts",
      sourceLine: 15,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiGroup.ts#L15"
    },
    {
      id: "HttpApiGroup.isHttpApiGroup",
      name: "isHttpApiGroup",
      module: "HttpApiGroup",
      package: "@effect/platform",
      signature: "(u: unknown) => u is HttpApiGroup.Any",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "guards"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiGroup.d.ts",
      sourceLine: 25,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiGroup.ts#L25"
    },
    {
      id: "HttpApiGroup.make",
      name: "make",
      module: "HttpApiGroup",
      package: "@effect/platform",
      signature: "<const Id extends string, const TopLevel extends (true | false) = false>(identifier: Id, options?: { readonly topLevel?: TopLevel; }) => HttpApiGroup<Id, never, never, never, TopLevel>",
      description: "An `HttpApiGroup` is a collection of `HttpApiEndpoint`s. You can use an `HttpApiGroup` to\nrepresent a portion of your domain. The endpoints can be implemented later using the `HttpApiBuilder.group` api.",
      documentation: "An `HttpApiGroup` is a collection of `HttpApiEndpoint`s. You can use an `HttpApiGroup` to\nrepresent a portion of your domain.\n\nThe endpoints can be implemented later using the `HttpApiBuilder.group` api.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiGroup.d.ts",
      sourceLine: 210,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiGroup.ts#L210"
    },
    {
      id: "HttpApiMiddleware.TypeId",
      name: "TypeId",
      module: "HttpApiMiddleware",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiMiddleware.d.ts",
      sourceLine: 14,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiMiddleware.ts#L14"
    },
    {
      id: "HttpApiMiddleware.SecurityTypeId",
      name: "SecurityTypeId",
      module: "HttpApiMiddleware",
      package: "@effect/platform",
      signature: "typeof SecurityTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiMiddleware.d.ts",
      sourceLine: 24,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiMiddleware.ts#L24"
    },
    {
      id: "HttpApiMiddleware.isSecurity",
      name: "isSecurity",
      module: "HttpApiMiddleware",
      package: "@effect/platform",
      signature: "(u: TagClassAny) => u is TagClassSecurityAny",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "guards"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiMiddleware.d.ts",
      sourceLine: 34,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiMiddleware.ts#L34"
    },
    {
      id: "HttpApiMiddleware.Tag",
      name: "Tag",
      module: "HttpApiMiddleware",
      package: "@effect/platform",
      signature: "<Self>() => <const Name extends string, const Options extends { readonly optional?: boolean; readonly failure?: Schema.Schema.All; readonly provides?: Context.Tag<any, any>; readonly security?: Record<string, HttpApiSecurity.HttpApiSecurity>; }>(id: Name, options?: Options) => TagClass<Self, Name, Options>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "tags"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiMiddleware.d.ts",
      sourceLine: 222,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiMiddleware.ts#L222"
    },
    {
      id: "HttpApiSchema.AnnotationMultipart",
      name: "AnnotationMultipart",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "typeof AnnotationMultipart",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "annotations"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 17,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L17"
    },
    {
      id: "HttpApiSchema.AnnotationMultipartStream",
      name: "AnnotationMultipartStream",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "typeof AnnotationMultipartStream",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "annotations"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 22,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L22"
    },
    {
      id: "HttpApiSchema.AnnotationStatus",
      name: "AnnotationStatus",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "typeof AnnotationStatus",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "annotations"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 27,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L27"
    },
    {
      id: "HttpApiSchema.AnnotationEmptyDecodeable",
      name: "AnnotationEmptyDecodeable",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "typeof AnnotationEmptyDecodeable",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "annotations"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 32,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L32"
    },
    {
      id: "HttpApiSchema.AnnotationEncoding",
      name: "AnnotationEncoding",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "typeof AnnotationEncoding",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "annotations"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 37,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L37"
    },
    {
      id: "HttpApiSchema.AnnotationParam",
      name: "AnnotationParam",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "typeof AnnotationParam",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "annotations"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 42,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L42"
    },
    {
      id: "HttpApiSchema.extractAnnotations",
      name: "extractAnnotations",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "(ast: Annotations) => Annotations",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "annotations"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 47,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L47"
    },
    {
      id: "HttpApiSchema.getStatus",
      name: "getStatus",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "(ast: AST, defaultStatus: number) => number",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "annotations"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 52,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L52"
    },
    {
      id: "HttpApiSchema.getEmptyDecodeable",
      name: "getEmptyDecodeable",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "(ast: AST) => boolean",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "annotations"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 57,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L57"
    },
    {
      id: "HttpApiSchema.getMultipart",
      name: "getMultipart",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "(ast: AST) => withLimits.Options",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "annotations"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 62,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L62"
    },
    {
      id: "HttpApiSchema.getMultipartStream",
      name: "getMultipartStream",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "(ast: AST) => withLimits.Options",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "annotations"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 67,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L67"
    },
    {
      id: "HttpApiSchema.getEncoding",
      name: "getEncoding",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "(ast: AST, fallback?: Encoding) => Encoding",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "annotations"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 72,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L72"
    },
    {
      id: "HttpApiSchema.getParam",
      name: "getParam",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "(ast: AST | PropertySignature.AST) => string",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "annotations"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 77,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L77"
    },
    {
      id: "HttpApiSchema.annotations",
      name: "annotations",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "<A>(annotations: Annotations.Schema<NoInfer<A>, readonly []> & { readonly status?: number; }) => Annotations.Schema<A, readonly []>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "annotations"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 82,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L82"
    },
    {
      id: "HttpApiSchema.isVoid",
      name: "isVoid",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "(ast: AST) => boolean",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "reflection"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 89,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L89"
    },
    {
      id: "HttpApiSchema.getStatusSuccessAST",
      name: "getStatusSuccessAST",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "(ast: AST) => number",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "reflection"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 94,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L94"
    },
    {
      id: "HttpApiSchema.getStatusSuccess",
      name: "getStatusSuccess",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "<A extends Schema.Schema.Any>(self: A) => number",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "reflection"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 99,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L99"
    },
    {
      id: "HttpApiSchema.getStatusErrorAST",
      name: "getStatusErrorAST",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "(ast: AST) => number",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "reflection"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 104,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L104"
    },
    {
      id: "HttpApiSchema.getStatusError",
      name: "getStatusError",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "<A extends Schema.Schema.All>(self: A) => number",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "reflection"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 109,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L109"
    },
    {
      id: "HttpApiSchema.UnionUnify",
      name: "UnionUnify",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: '<A extends Schema.Schema.All, B extends Schema.Schema.All>(self: A, that: B) => Schema<A["Type"] | B["Type"], A["Encoded"] | B["Encoded"], A["Context"] | B["Context"]>',
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 113,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L113"
    },
    {
      id: "HttpApiSchema.param",
      name: "param",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: '{ <Name extends string>(name: Name): <S extends Schema.Schema.Any | Schema.PropertySignature.Any>(schema: S & ([Schema.Encoded<S> & {}] extends [string] ? unknown : "Schema must be encodable to a string")) => Param<Name, S>; <Name extends string, S extends Schema.Schema.Any | Schema.PropertySignature.Any>(name: Name, schema: S & ([Schema.Encoded<S> & {}] extends [string] ? unknown : "Schema must be encodable to a string")): Param<Name, S>; }',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "path params"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 129,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L129"
    },
    {
      id: "HttpApiSchema.Empty",
      name: "Empty",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "(status: number) => typeof Void",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "empty response"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 145,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L145"
    },
    {
      id: "HttpApiSchema.asEmpty",
      name: "asEmpty",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "{ <S extends Schema.Schema.Any>(options: { readonly status: number; readonly decode: LazyArg<Schema.Type<S>>; }): (self: S) => asEmpty<S>; <S extends Schema.Schema.Any>(self: S, options: { readonly status: number; readonly decode: LazyArg<Schema.Type<S>>; }): asEmpty<S>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "empty response"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 156,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L156"
    },
    {
      id: "HttpApiSchema.Created",
      name: "Created",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "Created",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "empty response"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 185,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L185"
    },
    {
      id: "HttpApiSchema.Accepted",
      name: "Accepted",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "Accepted",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "empty response"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 197,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L197"
    },
    {
      id: "HttpApiSchema.NoContent",
      name: "NoContent",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "NoContent",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "empty response"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 209,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L209"
    },
    {
      id: "HttpApiSchema.MultipartTypeId",
      name: "MultipartTypeId",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "typeof MultipartTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "multipart"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 214,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L214"
    },
    {
      id: "HttpApiSchema.Multipart",
      name: "Multipart",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "<S extends Schema.Schema.Any>(self: S, options?: { readonly maxParts?: Option<number>; readonly maxFieldSize?: SizeInput; readonly maxFileSize?: Option<SizeInput>; readonly maxTotalSize?: Option<SizeInput>; readonly fieldMimeTypes?: readonly string[]; }) => Multipart<S>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "multipart"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 230,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L230"
    },
    {
      id: "HttpApiSchema.MultipartStreamTypeId",
      name: "MultipartStreamTypeId",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "typeof MultipartStreamTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "multipart"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 241,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L241"
    },
    {
      id: "HttpApiSchema.MultipartStream",
      name: "MultipartStream",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "<S extends Schema.Schema.Any>(self: S, options?: { readonly maxParts?: Option<number>; readonly maxFieldSize?: SizeInput; readonly maxFileSize?: Option<SizeInput>; readonly maxTotalSize?: Option<SizeInput>; readonly fieldMimeTypes?: readonly string[]; }) => MultipartStream<S>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "multipart"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 257,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L257"
    },
    {
      id: "HttpApiSchema.withEncoding",
      name: "withEncoding",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: '{ <A extends Schema.Schema.Any, Kind extends Encoding["kind"]>(options: { readonly kind: Kind; readonly contentType?: string; } & Encoding.Validate<A, Kind>): (self: A) => A; <A extends Schema.Schema.Any, Kind extends Encoding["kind"]>(self: A, options: { readonly kind: Kind; readonly contentType?: string; } & Encoding.Validate<A, Kind>): A; }',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "encoding"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 289,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L289"
    },
    {
      id: "HttpApiSchema.Text",
      name: "Text",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "(options?: { readonly contentType?: string; }) => typeof String",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "encoding"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 311,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L311"
    },
    {
      id: "HttpApiSchema.Uint8Array",
      name: "Uint8Array",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "(options?: { readonly contentType?: string; }) => typeof Uint8ArrayFromSelf",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "encoding"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 318,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L318"
    },
    {
      id: "HttpApiSchema.deunionize",
      name: "deunionize",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "(schemas: Set<Schema.Any>, schema: Schema.Any) => void",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 324,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L324"
    },
    {
      id: "HttpApiSchema.EmptyError",
      name: "EmptyError",
      module: "HttpApiSchema",
      package: "@effect/platform",
      signature: "<Self>() => <const Tag extends string>(options: { readonly tag: Tag; readonly status: number; }) => EmptyErrorClass<Self, Tag>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "empty errors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSchema.d.ts",
      sourceLine: 362,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSchema.ts#L362"
    },
    {
      id: "HttpApiSecurity.TypeId",
      name: "TypeId",
      module: "HttpApiSecurity",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSecurity.d.ts",
      sourceLine: 12,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSecurity.ts#L12"
    },
    {
      id: "HttpApiSecurity.bearer",
      name: "bearer",
      module: "HttpApiSecurity",
      package: "@effect/platform",
      signature: "Bearer",
      description: "Create an Bearer token security scheme. You can implement some api middleware for this security scheme using\n`HttpApiBuilder.middlewareSecurity`.",
      documentation: "Create an Bearer token security scheme.\n\nYou can implement some api middleware for this security scheme using\n`HttpApiBuilder.middlewareSecurity`.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSecurity.d.ts",
      sourceLine: 84,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSecurity.ts#L84"
    },
    {
      id: "HttpApiSecurity.apiKey",
      name: "apiKey",
      module: "HttpApiSecurity",
      package: "@effect/platform",
      signature: '(options: { readonly key: string; readonly in?: "header" | "query" | "cookie"; }) => ApiKey',
      description: 'Create an API key security scheme. You can implement some api middleware for this security scheme using\n`HttpApiBuilder.middlewareSecurity`. To set the correct cookie in a handler, you can use\n`HttpApiBuilder.securitySetCookie`. The default value for `in` is "header".',
      documentation: 'Create an API key security scheme.\n\nYou can implement some api middleware for this security scheme using\n`HttpApiBuilder.middlewareSecurity`.\n\nTo set the correct cookie in a handler, you can use\n`HttpApiBuilder.securitySetCookie`.\n\nThe default value for `in` is "header".',
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSecurity.d.ts",
      sourceLine: 99,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSecurity.ts#L99"
    },
    {
      id: "HttpApiSecurity.basic",
      name: "basic",
      module: "HttpApiSecurity",
      package: "@effect/platform",
      signature: "Basic",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSecurity.d.ts",
      sourceLine: 107,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSecurity.ts#L107"
    },
    {
      id: "HttpApiSecurity.annotateContext",
      name: "annotateContext",
      module: "HttpApiSecurity",
      package: "@effect/platform",
      signature: "{ <I>(context: Context<I>): <A extends HttpApiSecurity>(self: A) => A; <A extends HttpApiSecurity, I>(self: A, context: Context<I>): A; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "annotations"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSecurity.d.ts",
      sourceLine: 112,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSecurity.ts#L112"
    },
    {
      id: "HttpApiSecurity.annotate",
      name: "annotate",
      module: "HttpApiSecurity",
      package: "@effect/platform",
      signature: "{ <I, S>(tag: Tag<I, S>, value: S): <A extends HttpApiSecurity>(self: A) => A; <A extends HttpApiSecurity, I, S>(self: A, tag: Tag<I, S>, value: S): A; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "annotations"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSecurity.d.ts",
      sourceLine: 128,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSecurity.ts#L128"
    },
    {
      id: "HttpApiSwagger.layer",
      name: "layer",
      module: "HttpApiSwagger",
      package: "@effect/platform",
      signature: "(options?: { readonly path?: `/${string}`; }) => Layer<never, never, Api>",
      description: "Exported layer mounting Swagger/OpenAPI documentation UI.",
      documentation: "Exported layer mounting Swagger/OpenAPI documentation UI.",
      examples: [],
      tags: [
        "layers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSwagger.d.ts",
      sourceLine: 13,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSwagger.ts#L13"
    },
    {
      id: "HttpApiSwagger.layerHttpLayerRouter",
      name: "layerHttpLayerRouter",
      module: "HttpApiSwagger",
      package: "@effect/platform",
      signature: "(options: { readonly api: HttpApi.Any; readonly path: `/${string}`; }) => Layer<never, never, HttpRouter>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "layers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApiSwagger.d.ts",
      sourceLine: 20,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApiSwagger.ts#L20"
    },
    {
      id: "HttpApp.toHandled",
      name: "toHandled",
      module: "HttpApp",
      package: "@effect/platform",
      signature: "<E, R, _, EH, RH>(self: Default<E, R>, handleResponse: (request: HttpServerRequest, response: HttpServerResponse) => Effect<_, EH, RH>, middleware?: HttpMiddleware) => Effect<void, never, HttpServerRequest | Exclude<R, Scope> | Exclude<RH, Scope>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApp.d.ts",
      sourceLine: 26,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApp.ts#L26"
    },
    {
      id: "HttpApp.ejectDefaultScopeClose",
      name: "ejectDefaultScopeClose",
      module: "HttpApp",
      package: "@effect/platform",
      signature: "(scope: Scope) => void",
      description: "If you want to finalize the http request scope elsewhere, you can use this\nfunction to eject from the default scope closure.",
      documentation: "If you want to finalize the http request scope elsewhere, you can use this\nfunction to eject from the default scope closure.",
      examples: [],
      tags: [
        "Scope"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApp.d.ts",
      sourceLine: 34,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApp.ts#L34"
    },
    {
      id: "HttpApp.unsafeEjectStreamScope",
      name: "unsafeEjectStreamScope",
      module: "HttpApp",
      package: "@effect/platform",
      signature: "(response: HttpServerResponse) => HttpServerResponse",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Scope"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApp.d.ts",
      sourceLine: 39,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApp.ts#L39"
    },
    {
      id: "HttpApp.currentPreResponseHandlers",
      name: "currentPreResponseHandlers",
      module: "HttpApp",
      package: "@effect/platform",
      signature: "FiberRef<Option<PreResponseHandler>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiber refs"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApp.d.ts",
      sourceLine: 49,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApp.ts#L49"
    },
    {
      id: "HttpApp.appendPreResponseHandler",
      name: "appendPreResponseHandler",
      module: "HttpApp",
      package: "@effect/platform",
      signature: "(handler: PreResponseHandler) => Effect<void, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiber refs"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApp.d.ts",
      sourceLine: 54,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApp.ts#L54"
    },
    {
      id: "HttpApp.withPreResponseHandler",
      name: "withPreResponseHandler",
      module: "HttpApp",
      package: "@effect/platform",
      signature: "((handler: PreResponseHandler) => <A, E, R>(self: HttpApp<A, E, R>) => HttpApp<A, E, R>) & (<A, E, R>(self: HttpApp<A, E, R>, handler: PreResponseHandler) => HttpApp<A, E, R>)",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiber refs"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApp.d.ts",
      sourceLine: 59,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApp.ts#L59"
    },
    {
      id: "HttpApp.toWebHandlerRuntime",
      name: "toWebHandlerRuntime",
      module: "HttpApp",
      package: "@effect/platform",
      signature: "<R>(runtime: Runtime<R>) => <E>(self: Default<E, Scope | R>, middleware?: HttpMiddleware) => (request: Request, context?: Context<never>) => Promise<Response>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApp.d.ts",
      sourceLine: 64,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApp.ts#L64"
    },
    {
      id: "HttpApp.toWebHandler",
      name: "toWebHandler",
      module: "HttpApp",
      package: "@effect/platform",
      signature: "<E>(self: Default<E, Scope>, middleware?: HttpMiddleware) => (request: Request, context?: Context<never>) => Promise<Response>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApp.d.ts",
      sourceLine: 69,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApp.ts#L69"
    },
    {
      id: "HttpApp.toWebHandlerLayerWith",
      name: "toWebHandlerLayerWith",
      module: "HttpApp",
      package: "@effect/platform",
      signature: "<E, R, RE, EX>(layer: Layer<R, RE, never>, options: { readonly toHandler: (runtime: Runtime<R>) => Effect<Effect<HttpServerResponse, E, HttpServerRequest | Scope | R>, EX, never>; readonly middleware?: HttpMiddleware; readonly memoMap?: MemoMap; }) => { readonly dispose: () => Promise<void>; readonly handler: (request: Request, context?: Context<never>) => Promise<Response>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApp.d.ts",
      sourceLine: 74,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApp.ts#L74"
    },
    {
      id: "HttpApp.toWebHandlerLayer",
      name: "toWebHandlerLayer",
      module: "HttpApp",
      package: "@effect/platform",
      signature: "<E, R, RE>(self: Default<E, Scope | R>, layer: Layer<R, RE, never>, options?: { readonly memoMap?: MemoMap; readonly middleware?: HttpMiddleware; }) => { readonly dispose: () => Promise<void>; readonly handler: (request: Request, context?: Context<never>) => Promise<Response>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApp.d.ts",
      sourceLine: 86,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApp.ts#L86"
    },
    {
      id: "HttpApp.fromWebHandler",
      name: "fromWebHandler",
      module: "HttpApp",
      package: "@effect/platform",
      signature: "(handler: (request: Request) => Promise<Response>) => Default<HttpServerError, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpApp.d.ts",
      sourceLine: 97,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpApp.ts#L97"
    },
    {
      id: "HttpBody.TypeId",
      name: "TypeId",
      module: "HttpBody",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpBody.d.ts",
      sourceLine: 16,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpBody.ts#L16"
    },
    {
      id: "HttpBody.isHttpBody",
      name: "isHttpBody",
      module: "HttpBody",
      package: "@effect/platform",
      signature: "(u: unknown) => u is HttpBody",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpBody.d.ts",
      sourceLine: 26,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpBody.ts#L26"
    },
    {
      id: "HttpBody.ErrorTypeId",
      name: "ErrorTypeId",
      module: "HttpBody",
      package: "@effect/platform",
      signature: "typeof ErrorTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpBody.d.ts",
      sourceLine: 62,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpBody.ts#L62"
    },
    {
      id: "HttpBody.HttpBodyError",
      name: "HttpBodyError",
      module: "HttpBody",
      package: "@effect/platform",
      signature: "(reason: ErrorReason) => HttpBodyError",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "errors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpBody.d.ts",
      sourceLine: 81,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpBody.ts#L81"
    },
    {
      id: "HttpBody.empty",
      name: "empty",
      module: "HttpBody",
      package: "@effect/platform",
      signature: "Empty",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpBody.d.ts",
      sourceLine: 104,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpBody.ts#L104"
    },
    {
      id: "HttpBody.raw",
      name: "raw",
      module: "HttpBody",
      package: "@effect/platform",
      signature: "(body: unknown, options?: { readonly contentType?: string; readonly contentLength?: number; }) => Raw",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpBody.d.ts",
      sourceLine: 117,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpBody.ts#L117"
    },
    {
      id: "HttpBody.uint8Array",
      name: "uint8Array",
      module: "HttpBody",
      package: "@effect/platform",
      signature: "(body: Uint8Array, contentType?: string) => Uint8Array",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpBody.d.ts",
      sourceLine: 135,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpBody.ts#L135"
    },
    {
      id: "HttpBody.text",
      name: "text",
      module: "HttpBody",
      package: "@effect/platform",
      signature: "(body: string, contentType?: string) => Uint8Array",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpBody.d.ts",
      sourceLine: 140,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpBody.ts#L140"
    },
    {
      id: "HttpBody.unsafeJson",
      name: "unsafeJson",
      module: "HttpBody",
      package: "@effect/platform",
      signature: "(body: unknown) => Uint8Array",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpBody.d.ts",
      sourceLine: 145,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpBody.ts#L145"
    },
    {
      id: "HttpBody.json",
      name: "json",
      module: "HttpBody",
      package: "@effect/platform",
      signature: "(body: unknown) => Effect<Uint8Array, HttpBodyError, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpBody.d.ts",
      sourceLine: 150,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpBody.ts#L150"
    },
    {
      id: "HttpBody.jsonSchema",
      name: "jsonSchema",
      module: "HttpBody",
      package: "@effect/platform",
      signature: "<A, I, R>(schema: Schema<A, I, R>) => (body: A) => Effect<Uint8Array, HttpBodyError, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpBody.d.ts",
      sourceLine: 155,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpBody.ts#L155"
    },
    {
      id: "HttpBody.urlParams",
      name: "urlParams",
      module: "HttpBody",
      package: "@effect/platform",
      signature: "(urlParams: UrlParams) => Uint8Array",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpBody.d.ts",
      sourceLine: 160,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpBody.ts#L160"
    },
    {
      id: "HttpBody.formData",
      name: "formData",
      module: "HttpBody",
      package: "@effect/platform",
      signature: "(body: FormData) => FormData",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "FormData"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpBody.d.ts",
      sourceLine: 173,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpBody.ts#L173"
    },
    {
      id: "HttpBody.formDataRecord",
      name: "formDataRecord",
      module: "HttpBody",
      package: "@effect/platform",
      signature: "(entries: FormDataInput) => FormData",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "FormData"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpBody.d.ts",
      sourceLine: 188,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpBody.ts#L188"
    },
    {
      id: "HttpBody.stream",
      name: "stream",
      module: "HttpBody",
      package: "@effect/platform",
      signature: "(body: Stream<Uint8Array, unknown, never>, contentType?: string, contentLength?: number) => Stream",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpBody.d.ts",
      sourceLine: 203,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpBody.ts#L203"
    },
    {
      id: "HttpBody.file",
      name: "file",
      module: "HttpBody",
      package: "@effect/platform",
      signature: "(path: string, options?: StreamOptions & { readonly contentType?: string; }) => Effect<Stream, PlatformError, FileSystem>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpBody.d.ts",
      sourceLine: 208,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpBody.ts#L208"
    },
    {
      id: "HttpBody.fileInfo",
      name: "fileInfo",
      module: "HttpBody",
      package: "@effect/platform",
      signature: "(path: string, info: File.Info, options?: StreamOptions & { readonly contentType?: string; }) => Effect<Stream, PlatformError, FileSystem>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpBody.d.ts",
      sourceLine: 215,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpBody.ts#L215"
    },
    {
      id: "HttpBody.fileWeb",
      name: "fileWeb",
      module: "HttpBody",
      package: "@effect/platform",
      signature: "(file: HttpBody.FileLike) => Stream",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpBody.d.ts",
      sourceLine: 222,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpBody.ts#L222"
    },
    {
      id: "HttpClient.TypeId",
      name: "TypeId",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 24,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L24"
    },
    {
      id: "HttpClient.HttpClient",
      name: "HttpClient",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "Tag<HttpClient, HttpClient>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "tags"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 70,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L70"
    },
    {
      id: "HttpClient.execute",
      name: "execute",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "(request: HttpClientRequest) => Effect<HttpClientResponse, HttpClientError, HttpClient>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "accessors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 75,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L75"
    },
    {
      id: "HttpClient.get",
      name: "get",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "(url: string | URL, options?: Options.NoBody) => Effect<HttpClientResponse, HttpClientError, HttpClient>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "accessors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 80,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L80"
    },
    {
      id: "HttpClient.head",
      name: "head",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "(url: string | URL, options?: Options.NoBody) => Effect<HttpClientResponse, HttpClientError, HttpClient>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "accessors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 85,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L85"
    },
    {
      id: "HttpClient.post",
      name: "post",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "(url: string | URL, options?: Options.NoUrl) => Effect<HttpClientResponse, HttpClientError, HttpClient>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "accessors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 90,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L90"
    },
    {
      id: "HttpClient.patch",
      name: "patch",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "(url: string | URL, options?: Options.NoUrl) => Effect<HttpClientResponse, HttpClientError, HttpClient>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "accessors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 95,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L95"
    },
    {
      id: "HttpClient.put",
      name: "put",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "(url: string | URL, options?: Options.NoUrl) => Effect<HttpClientResponse, HttpClientError, HttpClient>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "accessors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 100,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L100"
    },
    {
      id: "HttpClient.del",
      name: "del",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "(url: string | URL, options?: Options.NoUrl) => Effect<HttpClientResponse, HttpClientError, HttpClient>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "accessors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 105,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L105"
    },
    {
      id: "HttpClient.options",
      name: "options",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "(url: string | URL, options?: Options.NoUrl) => Effect<HttpClientResponse, HttpClientError, HttpClient>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "accessors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 110,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L110"
    },
    {
      id: "HttpClient.catchAll",
      name: "catchAll",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "{ <E, E2, R2>(f: (e: E) => Effect<HttpClientResponse, E2, R2>): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E2, R2 | R>; <E, R, A2, E2, R2>(self: HttpClient.With<E, R>, f: (e: E) => Effect<A2, E2, R2>): HttpClient.With<E2, R | R2>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 115,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L115"
    },
    {
      id: "HttpClient.catchTag",
      name: "catchTag",
      module: "HttpClient",
      package: "@effect/platform",
      signature: '{ <K extends E extends { _tag: string; } ? E["_tag"] : never, E, E1, R1>(tag: K, f: (e: Extract<E, { _tag: K; }>) => Effect<HttpClientResponse, E1, R1>): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E1 | Exclude<E, { _tag: K; }>, R1 | R>; <R, E, K extends E extends { _tag: string; } ? E["_tag"] : never, R1, E1>(self: HttpClient.With<E, R>, tag: K, f: (e: Extract<E, { _tag: K; }>) => Effect<HttpClientResponse, E1, R1>): HttpClient.With<E1 | Exclude<E, { _tag: K; }>, R | R1>; }',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 131,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L131"
    },
    {
      id: "HttpClient.catchTags",
      name: "catchTags",
      module: "HttpClient",
      package: "@effect/platform",
      signature: '{ <E, Cases extends { [K in Extract<E, { _tag: string; }>["_tag"]]+?: (error: Extract<E, { _tag: K; }>) => Effect.Effect<ClientResponse.HttpClientResponse, any, any>; } & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string; }>["_tag"]>]: never; })>(cases: Cases): <R>(self: HttpClient.With<E, R>) => HttpClient.With<Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: any[]) => Effect<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: any[]) => Effect<any, any, infer R> ? R : never; }[keyof Cases]>; <E extends { _tag: string; }, R, Cases extends { [K in Extract<E, { _tag: string; }>["_tag"]]+?: (error: Extract<E, { _tag: K; }>) => Effect.Effect<ClientResponse.HttpClientResponse, any, any>; } & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string; }>["_tag"]>]: never; })>(self: HttpClient.With<E, R>, cases: Cases): HttpClient.With<Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: any[]) => Effect<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: any[]) => Effect<any, any, infer R> ? R : never; }[keyof Cases]>; }',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 159,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L159"
    },
    {
      id: "HttpClient.filterOrElse",
      name: "filterOrElse",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "{ <E2, R2>(predicate: Predicate<HttpClientResponse>, orElse: (response: HttpClientResponse) => Effect<HttpClientResponse, E2, R2>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E2 | E, R2 | R>; <E, R, E2, R2>(self: HttpClient.With<E, R>, predicate: Predicate<HttpClientResponse>, orElse: (response: HttpClientResponse) => Effect<HttpClientResponse, E2, R2>): HttpClient.With<E | E2, R | R2>; }",
      description: "Filters the result of a response, or runs an alternative effect if the predicate fails.",
      documentation: "Filters the result of a response, or runs an alternative effect if the predicate fails.",
      examples: [],
      tags: [
        "filters"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 211,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L211"
    },
    {
      id: "HttpClient.filterOrFail",
      name: "filterOrFail",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "{ <E2>(predicate: Predicate<HttpClientResponse>, orFailWith: (response: HttpClientResponse) => E2): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E2 | E, R>; <E, R, E2>(self: HttpClient.With<E, R>, predicate: Predicate<HttpClientResponse>, orFailWith: (response: HttpClientResponse) => E2): HttpClient.With<E | E2, R>; }",
      description: "Filters the result of a response, or throws an error if the predicate fails.",
      documentation: "Filters the result of a response, or throws an error if the predicate fails.",
      examples: [],
      tags: [
        "filters"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 233,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L233"
    },
    {
      id: "HttpClient.filterStatus",
      name: "filterStatus",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "{ (f: (status: number) => boolean): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<ResponseError | E, R>; <E, R>(self: HttpClient.With<E, R>, f: (status: number) => boolean): HttpClient.With<ResponseError | E, R>; }",
      description: "Filters responses by HTTP status code.",
      documentation: "Filters responses by HTTP status code.",
      examples: [],
      tags: [
        "filters"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 255,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L255"
    },
    {
      id: "HttpClient.filterStatusOk",
      name: "filterStatusOk",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "<E, R>(self: HttpClient.With<E, R>) => HttpClient.With<ResponseError | E, R>",
      description: "Filters responses that return a 2xx status code.",
      documentation: "Filters responses that return a 2xx status code.",
      examples: [],
      tags: [
        "filters"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 277,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L277"
    },
    {
      id: "HttpClient.makeWith",
      name: "makeWith",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "<E2, R2, E, R>(postprocess: (request: Effect<HttpClientRequest, E2, R2>) => Effect<HttpClientResponse, E, R>, preprocess: HttpClient.Preprocess<E2, R2>) => HttpClient.With<E, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 282,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L282"
    },
    {
      id: "HttpClient.make",
      name: "make",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "(f: (request: HttpClientRequest, url: URL, signal: AbortSignal, fiber: RuntimeFiber<HttpClientResponse, HttpClientError>) => Effect<HttpClientResponse, HttpClientError, never>) => HttpClient",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 287,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L287"
    },
    {
      id: "HttpClient.transform",
      name: "transform",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "{ <E, R, E1, R1>(f: (effect: Effect<HttpClientResponse, E, R>, request: HttpClientRequest) => Effect<HttpClientResponse, E1, R1>): (self: HttpClient.With<E, R>) => HttpClient.With<E | E1, R | R1>; <E, R, E1, R1>(self: HttpClient.With<E, R>, f: (effect: Effect<HttpClientResponse, E, R>, request: HttpClientRequest) => Effect<HttpClientResponse, E1, R1>): HttpClient.With<E | E1, R | R1>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "mapping & sequencing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 292,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L292"
    },
    {
      id: "HttpClient.transformResponse",
      name: "transformResponse",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "{ <E, R, E1, R1>(f: (effect: Effect<HttpClientResponse, E, R>) => Effect<HttpClientResponse, E1, R1>): (self: HttpClient.With<E, R>) => HttpClient.With<E1, R1>; <E, R, E1, R1>(self: HttpClient.With<E, R>, f: (effect: Effect<HttpClientResponse, E, R>) => Effect<HttpClientResponse, E1, R1>): HttpClient.With<E1, R1>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "mapping & sequencing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 308,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L308"
    },
    {
      id: "HttpClient.mapRequest",
      name: "mapRequest",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "{ (f: (a: HttpClientRequest) => HttpClientRequest): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>; <E, R>(self: HttpClient.With<E, R>, f: (a: HttpClientRequest) => HttpClientRequest): HttpClient.With<E, R>; }",
      description: "Appends a transformation of the request object before sending it.",
      documentation: "Appends a transformation of the request object before sending it.",
      examples: [],
      tags: [
        "mapping & sequencing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 326,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L326"
    },
    {
      id: "HttpClient.mapRequestEffect",
      name: "mapRequestEffect",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "{ <E2, R2>(f: (a: HttpClientRequest) => Effect<HttpClientRequest, E2, R2>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E2 | E, R2 | R>; <E, R, E2, R2>(self: HttpClient.With<E, R>, f: (a: HttpClientRequest) => Effect<HttpClientRequest, E2, R2>): HttpClient.With<E | E2, R | R2>; }",
      description: "Appends an effectful transformation of the request object before sending it.",
      documentation: "Appends an effectful transformation of the request object before sending it.",
      examples: [],
      tags: [
        "mapping & sequencing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 348,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L348"
    },
    {
      id: "HttpClient.mapRequestInput",
      name: "mapRequestInput",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "{ (f: (a: HttpClientRequest) => HttpClientRequest): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>; <E, R>(self: HttpClient.With<E, R>, f: (a: HttpClientRequest) => HttpClientRequest): HttpClient.With<E, R>; }",
      description: "Prepends a transformation of the request object before sending it.",
      documentation: "Prepends a transformation of the request object before sending it.",
      examples: [],
      tags: [
        "mapping & sequencing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 370,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L370"
    },
    {
      id: "HttpClient.mapRequestInputEffect",
      name: "mapRequestInputEffect",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "{ <E2, R2>(f: (a: HttpClientRequest) => Effect<HttpClientRequest, E2, R2>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E2 | E, R2 | R>; <E, R, E2, R2>(self: HttpClient.With<E, R>, f: (a: HttpClientRequest) => Effect<HttpClientRequest, E2, R2>): HttpClient.With<E | E2, R | R2>; }",
      description: "Prepends an effectful transformation of the request object before sending it.",
      documentation: "Prepends an effectful transformation of the request object before sending it.",
      examples: [],
      tags: [
        "mapping & sequencing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 392,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L392"
    },
    {
      id: "HttpClient.retry",
      name: "retry",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "{ <E, O extends NoExcessProperties<Effect.Retry.Options<E>, O>>(options: O): <R>(self: HttpClient.With<E, R>) => HttpClient.With<(O extends { schedule: Schedule<infer _O, infer _I, infer _R>; } ? E : O extends { until: Refinement<E, infer E2 extends E>; } ? E2 : E) | (O extends { while: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never), R | (O extends { schedule: Schedule<infer _O, infer _I, infer R>; } ? R : never) | (O extends { while: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never)>; <B, E, R1>(policy: Schedule<B, NoInfer<E>, R1>): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R1 | R>; <E, R, O extends NoExcessProperties<Effect.Retry.Options<E>, O>>(self: HttpClient.With<E, R>, options: O): HttpClient.With<(O extends { schedule: Schedule<infer _O, infer _I, infer _R>; } ? E : O extends { until: Refinement<E, infer E2 extends E>; } ? E2 : E) | (O extends { while: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never), R | (O extends { schedule: Schedule<infer _O, infer _I, infer R>; } ? R : never) | (O extends { while: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never)>; <E, R, B, R1>(self: HttpClient.With<E, R>, policy: Schedule<B, E, R1>): HttpClient.With<E, R | R1>; }",
      description: "Retries the request based on a provided schedule or policy.",
      documentation: "Retries the request based on a provided schedule or policy.",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 439,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L439"
    },
    {
      id: "HttpClient.retryTransient",
      name: "retryTransient",
      module: "HttpClient",
      package: "@effect/platform",
      signature: '{ <B, E, R1 = never, const Mode extends "errors-only" | "response-only" | "both" = never, Input = "errors-only" extends Mode ? E : "response-only" extends Mode ? HttpClientResponse : HttpClientResponse | E>(options: { readonly mode?: Mode; readonly while?: Predicate<NoInfer<Input>>; readonly schedule?: Schedule<B, NoInfer<Input>, R1>; readonly times?: number; } | Schedule<B, NoInfer<Input>, R1>): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R1 | R>; <E, R, B, R1 = never, const Mode extends "errors-only" | "response-only" | "both" = never, Input = "errors-only" extends Mode ? E : "response-only" extends Mode ? HttpClientResponse : HttpClientResponse | E>(self: HttpClient.With<E, R>, options: { readonly mode?: Mode; readonly while?: Predicate<NoInfer<Input>>; readonly schedule?: Schedule<B, NoInfer<Input>, R1>; readonly times?: number; } | Schedule<B, NoInfer<Input>, R1>): HttpClient.With<E, R | R1>; }',
      description: "Retries common transient errors, such as rate limiting, timeouts or network issues. Specifying a `while` predicate allows you to consider other errors as\ntransient.",
      documentation: "Retries common transient errors, such as rate limiting, timeouts or network issues.\n\nSpecifying a `while` predicate allows you to consider other errors as\ntransient.",
      examples: [],
      tags: [
        "error handling"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 478,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L478"
    },
    {
      id: "HttpClient.tap",
      name: "tap",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "{ <_, E2, R2>(f: (response: HttpClientResponse) => Effect<_, E2, R2>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E2 | E, R2 | R>; <E, R, _, E2, R2>(self: HttpClient.With<E, R>, f: (response: HttpClientResponse) => Effect<_, E2, R2>): HttpClient.With<E | E2, R | R2>; }",
      description: "Performs an additional effect after a successful request.",
      documentation: "Performs an additional effect after a successful request.",
      examples: [],
      tags: [
        "mapping & sequencing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 516,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L516"
    },
    {
      id: "HttpClient.tapError",
      name: "tapError",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "{ <_, E, E2, R2>(f: (e: NoInfer<E>) => Effect<_, E2, R2>): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R2 | R>; <E, R, _, E2, R2>(self: HttpClient.With<E, R>, f: (e: NoInfer<E>) => Effect<_, E2, R2>): HttpClient.With<E | E2, R | R2>; }",
      description: "Performs an additional effect after an unsuccessful request.",
      documentation: "Performs an additional effect after an unsuccessful request.",
      examples: [],
      tags: [
        "mapping & sequencing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 538,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L538"
    },
    {
      id: "HttpClient.tapRequest",
      name: "tapRequest",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "{ <_, E2, R2>(f: (a: HttpClientRequest) => Effect<_, E2, R2>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E2 | E, R2 | R>; <E, R, _, E2, R2>(self: HttpClient.With<E, R>, f: (a: HttpClientRequest) => Effect<_, E2, R2>): HttpClient.With<E | E2, R | R2>; }",
      description: "Performs an additional effect on the request before sending it.",
      documentation: "Performs an additional effect on the request before sending it.",
      examples: [],
      tags: [
        "mapping & sequencing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 560,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L560"
    },
    {
      id: "HttpClient.withCookiesRef",
      name: "withCookiesRef",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "{ (ref: Ref<Cookies>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>; <E, R>(self: HttpClient.With<E, R>, ref: Ref<Cookies>): HttpClient.With<E, R>; }",
      description: "Associates a `Ref` of cookies with the client for handling cookies across requests.",
      documentation: "Associates a `Ref` of cookies with the client for handling cookies across requests.",
      examples: [],
      tags: [
        "cookies"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 582,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L582"
    },
    {
      id: "HttpClient.followRedirects",
      name: "followRedirects",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "{ (maxRedirects?: number): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>; <E, R>(self: HttpClient.With<E, R>, maxRedirects?: number): HttpClient.With<E, R>; }",
      description: "Follows HTTP redirects up to a specified number of times.",
      documentation: "Follows HTTP redirects up to a specified number of times.",
      examples: [],
      tags: [
        "redirects"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 604,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L604"
    },
    {
      id: "HttpClient.currentTracerDisabledWhen",
      name: "currentTracerDisabledWhen",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "FiberRef<Predicate<HttpClientRequest>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 624,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L624"
    },
    {
      id: "HttpClient.withTracerDisabledWhen",
      name: "withTracerDisabledWhen",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "{ (predicate: Predicate<HttpClientRequest>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>; <E, R>(self: HttpClient.With<E, R>, predicate: Predicate<HttpClientRequest>): HttpClient.With<E, R>; }",
      description: "Disables tracing for specific requests based on a provided predicate.",
      documentation: "Disables tracing for specific requests based on a provided predicate.",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 631,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L631"
    },
    {
      id: "HttpClient.currentTracerPropagation",
      name: "currentTracerPropagation",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "FiberRef<boolean>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 651,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L651"
    },
    {
      id: "HttpClient.withTracerPropagation",
      name: "withTracerPropagation",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "{ (enabled: boolean): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>; <E, R>(self: HttpClient.With<E, R>, enabled: boolean): HttpClient.With<E, R>; }",
      description: "Enables or disables tracing propagation for the request.",
      documentation: "Enables or disables tracing propagation for the request.",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 658,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L658"
    },
    {
      id: "HttpClient.layerMergedContext",
      name: "layerMergedContext",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "<E, R>(effect: Effect<HttpClient, E, R>) => Layer<HttpClient, E, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 677,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L677"
    },
    {
      id: "HttpClient.SpanNameGenerator",
      name: "SpanNameGenerator",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "Reference<SpanNameGenerator, (request: HttpClientRequest) => string>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 689,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L689"
    },
    {
      id: "HttpClient.withSpanNameGenerator",
      name: "withSpanNameGenerator",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "{ (f: (request: HttpClientRequest) => string): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>; <E, R>(self: HttpClient.With<E, R>, f: (request: HttpClientRequest) => string): HttpClient.With<E, R>; }",
      description: "Customizes the span names for tracing.",
      documentation: 'Customizes the span names for tracing.\n\n```ts\nimport { FetchHttpClient, HttpClient } from "@effect/platform"\nimport { NodeRuntime } from "@effect/platform-node"\nimport { Effect } from "effect"\n\nEffect.gen(function* () {\n  const client = (yield* HttpClient.HttpClient).pipe(\n    // Customize the span names for this HttpClient\n    HttpClient.withSpanNameGenerator(\n      (request) => `http.client ${request.method} ${request.url}`\n    )\n  )\n\n  yield* client.get("https://jsonplaceholder.typicode.com/posts/1")\n}).pipe(Effect.provide(FetchHttpClient.layer), NodeRuntime.runMain)\n```',
      examples: [
        {
          code: 'import { FetchHttpClient, HttpClient } from "@effect/platform"\nimport { NodeRuntime } from "@effect/platform-node"\nimport { Effect } from "effect"\n\nEffect.gen(function* () {\n  const client = (yield* HttpClient.HttpClient).pipe(\n    // Customize the span names for this HttpClient\n    HttpClient.withSpanNameGenerator(\n      (request) => `http.client ${request.method} ${request.url}`\n    )\n  )\n\n  yield* client.get("https://jsonplaceholder.typicode.com/posts/1")\n}).pipe(Effect.provide(FetchHttpClient.layer), NodeRuntime.runMain)'
        }
      ],
      tags: [
        "Tracing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 713,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L713"
    },
    {
      id: "HttpClient.withScope",
      name: "withScope",
      module: "HttpClient",
      package: "@effect/platform",
      signature: "<E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, Scope | R>",
      description: "Ties the lifetime of the `HttpClientRequest` to a `Scope`.",
      documentation: "Ties the lifetime of the `HttpClientRequest` to a `Scope`.",
      examples: [],
      tags: [
        "Scope"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClient.d.ts",
      sourceLine: 769,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClient.ts#L769"
    },
    {
      id: "HttpClientError.TypeId",
      name: "TypeId",
      module: "HttpClientError",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type id"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientError.d.ts",
      sourceLine: 7,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientError.ts#L7"
    },
    {
      id: "HttpClientError.isHttpClientError",
      name: "isHttpClientError",
      module: "HttpClientError",
      package: "@effect/platform",
      signature: "(u: unknown) => u is HttpClientError",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "guards"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientError.d.ts",
      sourceLine: 17,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientError.ts#L17"
    },
    {
      id: "HttpClientRequest.TypeId",
      name: "TypeId",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 22,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L22"
    },
    {
      id: "HttpClientRequest.make",
      name: "make",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: '<M extends HttpMethod>(method: M) => (url: string | URL, options?: M extends "GET" | "HEAD" ? Options.NoBody : Options.NoUrl) => HttpClientRequest',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 76,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L76"
    },
    {
      id: "HttpClientRequest.get",
      name: "get",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "(url: string | URL, options?: Options.NoBody) => HttpClientRequest",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 81,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L81"
    },
    {
      id: "HttpClientRequest.post",
      name: "post",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "(url: string | URL, options?: Options.NoUrl) => HttpClientRequest",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 86,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L86"
    },
    {
      id: "HttpClientRequest.patch",
      name: "patch",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "(url: string | URL, options?: Options.NoUrl) => HttpClientRequest",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 91,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L91"
    },
    {
      id: "HttpClientRequest.put",
      name: "put",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "(url: string | URL, options?: Options.NoUrl) => HttpClientRequest",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 96,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L96"
    },
    {
      id: "HttpClientRequest.del",
      name: "del",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "(url: string | URL, options?: Options.NoUrl) => HttpClientRequest",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 101,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L101"
    },
    {
      id: "HttpClientRequest.head",
      name: "head",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "(url: string | URL, options?: Options.NoBody) => HttpClientRequest",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 106,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L106"
    },
    {
      id: "HttpClientRequest.options",
      name: "options",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "(url: string | URL, options?: Options.NoUrl) => HttpClientRequest",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 111,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L111"
    },
    {
      id: "HttpClientRequest.modify",
      name: "modify",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (options: Options): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, options: Options): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 116,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L116"
    },
    {
      id: "HttpClientRequest.setMethod",
      name: "setMethod",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (method: HttpMethod): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, method: HttpMethod): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 132,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L132"
    },
    {
      id: "HttpClientRequest.setHeader",
      name: "setHeader",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (key: string, value: string): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, key: string, value: string): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 148,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L148"
    },
    {
      id: "HttpClientRequest.setHeaders",
      name: "setHeaders",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (input: Input): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, input: Input): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 164,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L164"
    },
    {
      id: "HttpClientRequest.basicAuth",
      name: "basicAuth",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (username: string | Redacted<string>, password: string | Redacted<string>): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, username: string | Redacted<string>, password: string | Redacted<string>): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 180,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L180"
    },
    {
      id: "HttpClientRequest.bearerToken",
      name: "bearerToken",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (token: string | Redacted<string>): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, token: string | Redacted<string>): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 196,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L196"
    },
    {
      id: "HttpClientRequest.accept",
      name: "accept",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (mediaType: string): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, mediaType: string): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 212,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L212"
    },
    {
      id: "HttpClientRequest.acceptJson",
      name: "acceptJson",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "(self: HttpClientRequest) => HttpClientRequest",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 228,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L228"
    },
    {
      id: "HttpClientRequest.setUrl",
      name: "setUrl",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (url: string | URL): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, url: string | URL): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 233,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L233"
    },
    {
      id: "HttpClientRequest.prependUrl",
      name: "prependUrl",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (path: string): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, path: string): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 249,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L249"
    },
    {
      id: "HttpClientRequest.appendUrl",
      name: "appendUrl",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (path: string): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, path: string): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 265,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L265"
    },
    {
      id: "HttpClientRequest.updateUrl",
      name: "updateUrl",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (f: (url: string) => string): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, f: (url: string) => string): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 281,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L281"
    },
    {
      id: "HttpClientRequest.setUrlParam",
      name: "setUrlParam",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (key: string, value: string): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, key: string, value: string): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 297,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L297"
    },
    {
      id: "HttpClientRequest.setUrlParams",
      name: "setUrlParams",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (input: Input): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, input: Input): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 313,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L313"
    },
    {
      id: "HttpClientRequest.appendUrlParam",
      name: "appendUrlParam",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (key: string, value: string): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, key: string, value: string): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 329,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L329"
    },
    {
      id: "HttpClientRequest.appendUrlParams",
      name: "appendUrlParams",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (input: Input): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, input: Input): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 345,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L345"
    },
    {
      id: "HttpClientRequest.setHash",
      name: "setHash",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (hash: string): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, hash: string): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 361,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L361"
    },
    {
      id: "HttpClientRequest.removeHash",
      name: "removeHash",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "(self: HttpClientRequest) => HttpClientRequest",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 377,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L377"
    },
    {
      id: "HttpClientRequest.toUrl",
      name: "toUrl",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "(self: HttpClientRequest) => Option<URL>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 382,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L382"
    },
    {
      id: "HttpClientRequest.setBody",
      name: "setBody",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (body: HttpBody): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, body: HttpBody): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 387,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L387"
    },
    {
      id: "HttpClientRequest.bodyUint8Array",
      name: "bodyUint8Array",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (body: Uint8Array, contentType?: string): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, body: Uint8Array, contentType?: string): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 403,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L403"
    },
    {
      id: "HttpClientRequest.bodyText",
      name: "bodyText",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (body: string, contentType?: string): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, body: string, contentType?: string): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 419,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L419"
    },
    {
      id: "HttpClientRequest.bodyJson",
      name: "bodyJson",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (body: unknown): (self: HttpClientRequest) => Effect<HttpClientRequest, HttpBodyError, never>; (self: HttpClientRequest, body: unknown): Effect<HttpClientRequest, HttpBodyError, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 435,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L435"
    },
    {
      id: "HttpClientRequest.bodyUnsafeJson",
      name: "bodyUnsafeJson",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (body: unknown): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, body: unknown): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 451,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L451"
    },
    {
      id: "HttpClientRequest.schemaBodyJson",
      name: "schemaBodyJson",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "<A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => { (body: A): (self: HttpClientRequest) => Effect<HttpClientRequest, HttpBodyError, R>; (self: HttpClientRequest, body: A): Effect<HttpClientRequest, HttpBodyError, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 467,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L467"
    },
    {
      id: "HttpClientRequest.bodyUrlParams",
      name: "bodyUrlParams",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (input: Input): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, input: Input): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 475,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L475"
    },
    {
      id: "HttpClientRequest.bodyFormData",
      name: "bodyFormData",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (body: FormData): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, body: FormData): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 491,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L491"
    },
    {
      id: "HttpClientRequest.bodyFormDataRecord",
      name: "bodyFormDataRecord",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (entries: FormDataInput): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, entries: FormDataInput): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 507,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L507"
    },
    {
      id: "HttpClientRequest.bodyStream",
      name: "bodyStream",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (body: Stream<Uint8Array, unknown, never>, options?: { readonly contentType?: string; readonly contentLength?: number; }): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, body: Stream<Uint8Array, unknown, never>, options?: { readonly contentType?: string; readonly contentLength?: number; }): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 523,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L523"
    },
    {
      id: "HttpClientRequest.bodyFile",
      name: "bodyFile",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (path: string, options?: StreamOptions & { readonly contentType?: string; }): (self: HttpClientRequest) => Effect<HttpClientRequest, PlatformError, FileSystem>; (self: HttpClientRequest, path: string, options?: StreamOptions & { readonly contentType?: string; }): Effect<HttpClientRequest, PlatformError, FileSystem>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 545,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L545"
    },
    {
      id: "HttpClientRequest.bodyFileWeb",
      name: "bodyFileWeb",
      module: "HttpClientRequest",
      package: "@effect/platform",
      signature: "{ (file: HttpBody.FileLike): (self: HttpClientRequest) => HttpClientRequest; (self: HttpClientRequest, file: HttpBody.FileLike): HttpClientRequest; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientRequest.d.ts",
      sourceLine: 565,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientRequest.ts#L565"
    },
    {
      id: "HttpClientResponse.TypeId",
      name: "TypeId",
      module: "HttpClientResponse",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientResponse.d.ts",
      sourceLine: 34,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientResponse.ts#L34"
    },
    {
      id: "HttpClientResponse.fromWeb",
      name: "fromWeb",
      module: "HttpClientResponse",
      package: "@effect/platform",
      signature: "(request: HttpClientRequest, source: Response) => HttpClientResponse",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientResponse.d.ts",
      sourceLine: 55,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientResponse.ts#L55"
    },
    {
      id: "HttpClientResponse.schemaJson",
      name: "schemaJson",
      module: "HttpClientResponse",
      package: "@effect/platform",
      signature: "<R, I extends { readonly status?: number | undefined; readonly headers?: Readonly<Record<string, string>> | undefined; readonly body?: unknown; }, A>(schema: Schema<A, I, R>, options?: ParseOptions) => (self: HttpClientResponse) => Effect<A, ResponseError | ParseError, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schema"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientResponse.d.ts",
      sourceLine: 60,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientResponse.ts#L60"
    },
    {
      id: "HttpClientResponse.schemaNoBody",
      name: "schemaNoBody",
      module: "HttpClientResponse",
      package: "@effect/platform",
      signature: "<R, I extends { readonly status?: number | undefined; readonly headers?: Readonly<Record<string, string>> | undefined; }, A>(schema: Schema<A, I, R>, options?: ParseOptions) => (self: HttpClientResponse) => Effect<A, ParseError, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schema"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientResponse.d.ts",
      sourceLine: 69,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientResponse.ts#L69"
    },
    {
      id: "HttpClientResponse.stream",
      name: "stream",
      module: "HttpClientResponse",
      package: "@effect/platform",
      signature: "<E, R>(effect: Effect<HttpClientResponse, E, R>) => Stream<Uint8Array, ResponseError | E, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "accessors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientResponse.d.ts",
      sourceLine: 77,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientResponse.ts#L77"
    },
    {
      id: "HttpClientResponse.matchStatus",
      name: "matchStatus",
      module: "HttpClientResponse",
      package: "@effect/platform",
      signature: '{ <const Cases extends { readonly [status: number]: (_: HttpClientResponse) => any; readonly "2xx"?: (_: HttpClientResponse) => any; readonly "3xx"?: (_: HttpClientResponse) => any; readonly "4xx"?: (_: HttpClientResponse) => any; readonly "5xx"?: (_: HttpClientResponse) => any; readonly orElse: (_: HttpClientResponse) => any; }>(cases: Cases): (self: HttpClientResponse) => Cases[keyof Cases] extends (_: any) => infer R ? Unify<R> : never; <const Cases extends { readonly [status: number]: (_: HttpClientResponse) => any; readonly "2xx"?: (_: HttpClientResponse) => any; readonly "3xx"?: (_: HttpClientResponse) => any; readonly "4xx"?: (_: HttpClientResponse) => any; readonly "5xx"?: (_: HttpClientResponse) => any; readonly orElse: (_: HttpClientResponse) => any; }>(self: HttpClientResponse, cases: Cases): Cases[keyof Cases] extends (_: any) => infer R ? Unify<R> : never; }',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "pattern matching"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientResponse.d.ts",
      sourceLine: 82,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientResponse.ts#L82"
    },
    {
      id: "HttpClientResponse.filterStatus",
      name: "filterStatus",
      module: "HttpClientResponse",
      package: "@effect/platform",
      signature: "{ (f: (status: number) => boolean): (self: HttpClientResponse) => Effect<HttpClientResponse, ResponseError, never>; (self: HttpClientResponse, f: (status: number) => boolean): Effect<HttpClientResponse, ResponseError, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "filters"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientResponse.d.ts",
      sourceLine: 112,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientResponse.ts#L112"
    },
    {
      id: "HttpClientResponse.filterStatusOk",
      name: "filterStatusOk",
      module: "HttpClientResponse",
      package: "@effect/platform",
      signature: "(self: HttpClientResponse) => Effect<HttpClientResponse, ResponseError, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "filters"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpClientResponse.d.ts",
      sourceLine: 128,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpClientResponse.ts#L128"
    },
    {
      id: "HttpIncomingMessage.TypeId",
      name: "TypeId",
      module: "HttpIncomingMessage",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpIncomingMessage.d.ts",
      sourceLine: 19,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpIncomingMessage.ts#L19"
    },
    {
      id: "HttpIncomingMessage.schemaBodyJson",
      name: "schemaBodyJson",
      module: "HttpIncomingMessage",
      package: "@effect/platform",
      signature: "<A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => <E>(self: HttpIncomingMessage<E>) => Effect<A, ParseError | E, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schema"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpIncomingMessage.d.ts",
      sourceLine: 43,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpIncomingMessage.ts#L43"
    },
    {
      id: "HttpIncomingMessage.schemaBodyUrlParams",
      name: "schemaBodyUrlParams",
      module: "HttpIncomingMessage",
      package: "@effect/platform",
      signature: "<A, I extends Readonly<Record<string, string | ReadonlyArray<string> | undefined>>, R>(schema: Schema<A, I, R>, options?: ParseOptions) => <E>(self: HttpIncomingMessage<E>) => Effect<A, ParseError | E, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schema"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpIncomingMessage.d.ts",
      sourceLine: 48,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpIncomingMessage.ts#L48"
    },
    {
      id: "HttpIncomingMessage.schemaHeaders",
      name: "schemaHeaders",
      module: "HttpIncomingMessage",
      package: "@effect/platform",
      signature: "<A, I extends Readonly<Record<string, string | undefined>>, R>(schema: Schema<A, I, R>, options?: ParseOptions) => <E>(self: HttpIncomingMessage<E>) => Effect<A, ParseError, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schema"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpIncomingMessage.d.ts",
      sourceLine: 53,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpIncomingMessage.ts#L53"
    },
    {
      id: "HttpIncomingMessage.withMaxBodySize",
      name: "withMaxBodySize",
      module: "HttpIncomingMessage",
      package: "@effect/platform",
      signature: "((size: Option<SizeInput>) => <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>) & (<A, E, R>(effect: Effect<A, E, R>, size: Option<SizeInput>) => Effect<A, E, R>)",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiber refs"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpIncomingMessage.d.ts",
      sourceLine: 65,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpIncomingMessage.ts#L65"
    },
    {
      id: "HttpIncomingMessage.inspect",
      name: "inspect",
      module: "HttpIncomingMessage",
      package: "@effect/platform",
      signature: "<E>(self: HttpIncomingMessage<E>, that: object) => object",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpIncomingMessage.d.ts",
      sourceLine: 69,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpIncomingMessage.ts#L69"
    },
    {
      id: "HttpMethod.hasBody",
      name: "hasBody",
      module: "HttpMethod",
      package: "@effect/platform",
      signature: "(method: HttpMethod) => boolean",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMethod.d.ts",
      sourceLine: 25,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMethod.ts#L25"
    },
    {
      id: "HttpMethod.all",
      name: "all",
      module: "HttpMethod",
      package: "@effect/platform",
      signature: "ReadonlySet<HttpMethod>",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMethod.d.ts",
      sourceLine: 29,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMethod.ts#L29"
    },
    {
      id: "HttpMethod.isHttpMethod",
      name: "isHttpMethod",
      module: "HttpMethod",
      package: "@effect/platform",
      signature: "(u: unknown) => u is HttpMethod",
      description: "Tests if a value is a `HttpMethod`.",
      documentation: 'Tests if a value is a `HttpMethod`.\n\n**Example**\n\n```ts\nimport { HttpMethod } from "@effect/platform"\n\nconsole.log(HttpMethod.isHttpMethod("GET"))\n// true\nconsole.log(HttpMethod.isHttpMethod("get"))\n// false\nconsole.log(HttpMethod.isHttpMethod(1))\n// false\n```',
      examples: [
        {
          code: 'import { HttpMethod } from "@effect/platform"\n\nconsole.log(HttpMethod.isHttpMethod("GET"))\n// true\nconsole.log(HttpMethod.isHttpMethod("get"))\n// false\nconsole.log(HttpMethod.isHttpMethod(1))\n// false'
        }
      ],
      tags: [
        "refinements"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMethod.d.ts",
      sourceLine: 49,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMethod.ts#L49"
    },
    {
      id: "HttpMiddleware.make",
      name: "make",
      module: "HttpMiddleware",
      package: "@effect/platform",
      signature: "<M extends HttpMiddleware>(middleware: M) => M",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMiddleware.d.ts",
      sourceLine: 33,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMiddleware.ts#L33"
    },
    {
      id: "HttpMiddleware.logger",
      name: "logger",
      module: "HttpMiddleware",
      package: "@effect/platform",
      signature: "<E, R>(httpApp: Default<E, R>) => Default<E, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMiddleware.d.ts",
      sourceLine: 38,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMiddleware.ts#L38"
    },
    {
      id: "HttpMiddleware.loggerDisabled",
      name: "loggerDisabled",
      module: "HttpMiddleware",
      package: "@effect/platform",
      signature: "FiberRef<boolean>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiber refs"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMiddleware.d.ts",
      sourceLine: 43,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMiddleware.ts#L43"
    },
    {
      id: "HttpMiddleware.withLoggerDisabled",
      name: "withLoggerDisabled",
      module: "HttpMiddleware",
      package: "@effect/platform",
      signature: "<A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiber refs"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMiddleware.d.ts",
      sourceLine: 48,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMiddleware.ts#L48"
    },
    {
      id: "HttpMiddleware.currentTracerDisabledWhen",
      name: "currentTracerDisabledWhen",
      module: "HttpMiddleware",
      package: "@effect/platform",
      signature: "FiberRef<Predicate<HttpServerRequest>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiber refs"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMiddleware.d.ts",
      sourceLine: 53,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMiddleware.ts#L53"
    },
    {
      id: "HttpMiddleware.withTracerDisabledWhen",
      name: "withTracerDisabledWhen",
      module: "HttpMiddleware",
      package: "@effect/platform",
      signature: "{ (predicate: Predicate<HttpServerRequest>): <A, E, R>(layer: Layer<A, E, R>) => Layer<A, E, R>; <A, E, R>(layer: Layer<A, E, R>, predicate: Predicate<HttpServerRequest>): Layer<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiber refs"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMiddleware.d.ts",
      sourceLine: 58,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMiddleware.ts#L58"
    },
    {
      id: "HttpMiddleware.withTracerDisabledWhenEffect",
      name: "withTracerDisabledWhenEffect",
      module: "HttpMiddleware",
      package: "@effect/platform",
      signature: "{ (predicate: Predicate<HttpServerRequest>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, predicate: Predicate<HttpServerRequest>): Effect<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiber refs"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMiddleware.d.ts",
      sourceLine: 74,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMiddleware.ts#L74"
    },
    {
      id: "HttpMiddleware.withTracerDisabledForUrls",
      name: "withTracerDisabledForUrls",
      module: "HttpMiddleware",
      package: "@effect/platform",
      signature: "{ (urls: readonly string[]): <A, E, R>(layer: Layer<A, E, R>) => Layer<A, E, R>; <A, E, R>(layer: Layer<A, E, R>, urls: readonly string[]): Layer<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiber refs"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMiddleware.d.ts",
      sourceLine: 90,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMiddleware.ts#L90"
    },
    {
      id: "HttpMiddleware.xForwardedHeaders",
      name: "xForwardedHeaders",
      module: "HttpMiddleware",
      package: "@effect/platform",
      signature: "<E, R>(httpApp: Default<E, R>) => Default<E, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMiddleware.d.ts",
      sourceLine: 106,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMiddleware.ts#L106"
    },
    {
      id: "HttpMiddleware.searchParamsParser",
      name: "searchParamsParser",
      module: "HttpMiddleware",
      package: "@effect/platform",
      signature: "<E, R>(httpApp: Default<E, R>) => Default<E, Exclude<R, ParsedSearchParams>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMiddleware.d.ts",
      sourceLine: 111,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMiddleware.ts#L111"
    },
    {
      id: "HttpMiddleware.cors",
      name: "cors",
      module: "HttpMiddleware",
      package: "@effect/platform",
      signature: "(options?: { readonly allowedOrigins?: readonly string[] | Predicate<string>; readonly allowedMethods?: readonly string[]; readonly allowedHeaders?: readonly string[]; readonly exposedHeaders?: readonly string[]; readonly maxAge?: number; readonly credentials?: boolean; }) => <E, R>(httpApp: Default<E, R>) => Default<E, R>",
      description: "Creates a CORS (Cross-Origin Resource Sharing) middleware for HTTP applications.",
      documentation: "Creates a CORS (Cross-Origin Resource Sharing) middleware for HTTP applications.",
      examples: [
        {
          code: 'import { HttpMiddleware, HttpRouter, HttpServerResponse } from "@effect/platform"\n\n// Allow all origins and reflect requested headers (default behavior)\nHttpRouter.empty.pipe(\n  HttpRouter.get("/", HttpServerResponse.empty()),\n  HttpMiddleware.cors()\n)\n\n// Restrict to specific origins and headers\nHttpRouter.empty.pipe(\n  HttpRouter.get("/", HttpServerResponse.empty()),\n  HttpMiddleware.cors({\n    allowedOrigins: ["https://example.com"],\n    allowedHeaders: ["Content-Type", "Authorization"],\n    credentials: true\n  })\n)\n\n// Dynamic origin checking with predicate\nHttpRouter.empty.pipe(\n  HttpRouter.get("/", HttpServerResponse.empty()),\n  HttpMiddleware.cors({\n    allowedOrigins: (origin) => origin.endsWith(".example.com")\n  })\n)'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMiddleware.d.ts",
      sourceLine: 166,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMiddleware.ts#L166"
    },
    {
      id: "HttpMiddleware.SpanNameGenerator",
      name: "SpanNameGenerator",
      module: "HttpMiddleware",
      package: "@effect/platform",
      signature: "Reference<SpanNameGenerator, (request: HttpServerRequest) => string>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMiddleware.d.ts",
      sourceLine: 185,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMiddleware.ts#L185"
    },
    {
      id: "HttpMiddleware.withSpanNameGenerator",
      name: "withSpanNameGenerator",
      module: "HttpMiddleware",
      package: "@effect/platform",
      signature: "{ (f: (request: HttpServerRequest) => string): <A, E, R>(layer: Layer<A, E, R>) => Layer<A, E, R>; <A, E, R>(layer: Layer<A, E, R>, f: (request: HttpServerRequest) => string): Layer<A, E, R>; }",
      description: "Customizes the span name for the http app.",
      documentation: 'Customizes the span name for the http app.\n\n```ts\nimport {\n  HttpMiddleware,\n  HttpRouter,\n  HttpServer,\n  HttpServerResponse\n} from "@effect/platform"\nimport { NodeHttpServer, NodeRuntime } from "@effect/platform-node"\nimport { Layer } from "effect"\nimport { createServer } from "http"\n\nHttpRouter.empty.pipe(\n  HttpRouter.get("/", HttpServerResponse.empty()),\n  HttpServer.serve(),\n  // Customize the span names for this HttpApp\n  HttpMiddleware.withSpanNameGenerator((request) => `GET ${request.url}`),\n  Layer.provide(NodeHttpServer.layer(createServer, { port: 3000 })),\n  Layer.launch,\n  NodeRuntime.runMain\n)\n```',
      examples: [],
      tags: [
        "Tracing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMiddleware.d.ts",
      sourceLine: 214,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMiddleware.ts#L214"
    },
    {
      id: "HttpMultiplex.TypeId",
      name: "TypeId",
      module: "HttpMultiplex",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMultiplex.d.ts",
      sourceLine: 13,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMultiplex.ts#L13"
    },
    {
      id: "HttpMultiplex.empty",
      name: "empty",
      module: "HttpMultiplex",
      package: "@effect/platform",
      signature: "HttpMultiplex<never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMultiplex.d.ts",
      sourceLine: 34,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMultiplex.ts#L34"
    },
    {
      id: "HttpMultiplex.make",
      name: "make",
      module: "HttpMultiplex",
      package: "@effect/platform",
      signature: "<E, R>(apps: Iterable<readonly [predicate: (request: HttpServerRequest) => Effect<boolean, E, R>, app: Default<E, R>]>) => HttpMultiplex<E, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMultiplex.d.ts",
      sourceLine: 39,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMultiplex.ts#L39"
    },
    {
      id: "HttpMultiplex.add",
      name: "add",
      module: "HttpMultiplex",
      package: "@effect/platform",
      signature: "{ <E2, R2, E3, R3>(predicate: (request: HttpServerRequest) => Effect<boolean, E2, R2>, app: Default<E3, R3>): <E, R>(self: HttpMultiplex<E, R>) => HttpMultiplex<E2 | E3 | E, R2 | R3 | R>; <E, R, E2, R2, E3, R3>(self: HttpMultiplex<E, R>, predicate: (request: HttpServerRequest) => Effect<boolean, E2, R2>, app: Default<E3, R3>): HttpMultiplex<E | E2 | E3, R | R2 | R3>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMultiplex.d.ts",
      sourceLine: 47,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMultiplex.ts#L47"
    },
    {
      id: "HttpMultiplex.headerExact",
      name: "headerExact",
      module: "HttpMultiplex",
      package: "@effect/platform",
      signature: "{ <E2, R2>(header: string, value: string, app: Default<E2, R2>): <E, R>(self: HttpMultiplex<E, R>) => HttpMultiplex<E2 | E, R2 | R>; <E, R, E2, R2>(self: HttpMultiplex<E, R>, header: string, value: string, app: Default<E2, R2>): HttpMultiplex<E | E2, R | R2>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMultiplex.d.ts",
      sourceLine: 63,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMultiplex.ts#L63"
    },
    {
      id: "HttpMultiplex.headerRegex",
      name: "headerRegex",
      module: "HttpMultiplex",
      package: "@effect/platform",
      signature: "{ <E2, R2>(header: string, regex: RegExp, app: Default<E2, R2>): <E, R>(self: HttpMultiplex<E, R>) => HttpMultiplex<E2 | E, R2 | R>; <E, R, E2, R2>(self: HttpMultiplex<E, R>, header: string, regex: RegExp, app: Default<E2, R2>): HttpMultiplex<E | E2, R | R2>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMultiplex.d.ts",
      sourceLine: 79,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMultiplex.ts#L79"
    },
    {
      id: "HttpMultiplex.headerStartsWith",
      name: "headerStartsWith",
      module: "HttpMultiplex",
      package: "@effect/platform",
      signature: "{ <E2, R2>(header: string, prefix: string, app: Default<E2, R2>): <E, R>(self: HttpMultiplex<E, R>) => HttpMultiplex<E2 | E, R2 | R>; <E, R, E2, R2>(self: HttpMultiplex<E, R>, header: string, prefix: string, app: Default<E2, R2>): HttpMultiplex<E | E2, R | R2>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMultiplex.d.ts",
      sourceLine: 95,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMultiplex.ts#L95"
    },
    {
      id: "HttpMultiplex.headerEndsWith",
      name: "headerEndsWith",
      module: "HttpMultiplex",
      package: "@effect/platform",
      signature: "{ <E2, R2>(header: string, suffix: string, app: Default<E2, R2>): <E, R>(self: HttpMultiplex<E, R>) => HttpMultiplex<E2 | E, R2 | R>; <E, R, E2, R2>(self: HttpMultiplex<E, R>, header: string, suffix: string, app: Default<E2, R2>): HttpMultiplex<E | E2, R | R2>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMultiplex.d.ts",
      sourceLine: 111,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMultiplex.ts#L111"
    },
    {
      id: "HttpMultiplex.hostExact",
      name: "hostExact",
      module: "HttpMultiplex",
      package: "@effect/platform",
      signature: "{ <E2, R2>(host: string, app: Default<E2, R2>): <E, R>(self: HttpMultiplex<E, R>) => HttpMultiplex<E2 | E, R2 | R>; <E, R, E2, R2>(self: HttpMultiplex<E, R>, host: string, app: Default<E2, R2>): HttpMultiplex<E | E2, R | R2>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMultiplex.d.ts",
      sourceLine: 127,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMultiplex.ts#L127"
    },
    {
      id: "HttpMultiplex.hostRegex",
      name: "hostRegex",
      module: "HttpMultiplex",
      package: "@effect/platform",
      signature: "{ <E2, R2>(regex: RegExp, app: Default<E2, R2>): <E, R>(self: HttpMultiplex<E, R>) => HttpMultiplex<E2 | E, R2 | R>; <E, R, E2, R2>(self: HttpMultiplex<E, R>, regex: RegExp, app: Default<E2, R2>): HttpMultiplex<E | E2, R | R2>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMultiplex.d.ts",
      sourceLine: 143,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMultiplex.ts#L143"
    },
    {
      id: "HttpMultiplex.hostStartsWith",
      name: "hostStartsWith",
      module: "HttpMultiplex",
      package: "@effect/platform",
      signature: "{ <E2, R2>(prefix: string, app: Default<E2, R2>): <E, R>(self: HttpMultiplex<E, R>) => HttpMultiplex<E2 | E, R2 | R>; <E, R, E2, R2>(self: HttpMultiplex<E, R>, prefix: string, app: Default<E2, R2>): HttpMultiplex<E | E2, R | R2>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMultiplex.d.ts",
      sourceLine: 159,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMultiplex.ts#L159"
    },
    {
      id: "HttpMultiplex.hostEndsWith",
      name: "hostEndsWith",
      module: "HttpMultiplex",
      package: "@effect/platform",
      signature: "{ <E2, R2>(suffix: string, app: Default<E2, R2>): <E, R>(self: HttpMultiplex<E, R>) => HttpMultiplex<E2 | E, R2 | R>; <E, R, E2, R2>(self: HttpMultiplex<E, R>, suffix: string, app: Default<E2, R2>): HttpMultiplex<E | E2, R | R2>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpMultiplex.d.ts",
      sourceLine: 175,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpMultiplex.ts#L175"
    },
    {
      id: "HttpPlatform.TypeId",
      name: "TypeId",
      module: "HttpPlatform",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpPlatform.d.ts",
      sourceLine: 17,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpPlatform.ts#L17"
    },
    {
      id: "HttpPlatform.HttpPlatform",
      name: "HttpPlatform",
      module: "HttpPlatform",
      package: "@effect/platform",
      signature: "Tag<HttpPlatform, HttpPlatform>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "tags"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpPlatform.d.ts",
      sourceLine: 27,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpPlatform.ts#L27"
    },
    {
      id: "HttpPlatform.make",
      name: "make",
      module: "HttpPlatform",
      package: "@effect/platform",
      signature: "(impl: { readonly fileResponse: (path: string, status: number, statusText: string, headers: Headers, start: number, end: number, contentLength: number) => HttpServerResponse; readonly fileWebResponse: (file: HttpBody.FileLike, status: number, statusText: string, headers: Headers, options?: StreamOptions) => HttpServerResponse; }) => Effect<HttpPlatform, never, FileSystem | Generator>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpPlatform.d.ts",
      sourceLine: 41,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpPlatform.ts#L41"
    },
    {
      id: "HttpPlatform.layer",
      name: "layer",
      module: "HttpPlatform",
      package: "@effect/platform",
      signature: "Layer<HttpPlatform, never, FileSystem>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "layers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpPlatform.d.ts",
      sourceLine: 49,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpPlatform.ts#L49"
    },
    {
      id: "HttpRouter.TypeId",
      name: "TypeId",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 33,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L33"
    },
    {
      id: "HttpRouter.RouteTypeId",
      name: "RouteTypeId",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "typeof RouteTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 122,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L122"
    },
    {
      id: "HttpRouter.RouteContextTypeId",
      name: "RouteContextTypeId",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "typeof RouteContextTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 162,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L162"
    },
    {
      id: "HttpRouter.RouteContext",
      name: "RouteContext",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "Tag<RouteContext, RouteContext>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "route context"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 181,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L181"
    },
    {
      id: "HttpRouter.params",
      name: "params",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "Effect<Readonly<Record<string, string>>, never, RouteContext>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "route context"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 186,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L186"
    },
    {
      id: "HttpRouter.schemaJson",
      name: "schemaJson",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "<R, I extends Partial<{ readonly method: Method.HttpMethod; readonly url: string; readonly cookies: Readonly<Record<string, string | undefined>>; readonly headers: Readonly<Record<string, string | undefined>>; readonly pathParams: Readonly<Record<string, string | undefined>>; readonly searchParams: Readonly<Record<string, string | ReadonlyArray<string> | undefined>>; readonly body: any; }>, A>(schema: Schema<A, I, R>, options?: ParseOptions) => Effect<A, RequestError | ParseError, HttpServerRequest | RouteContext | R | ParsedSearchParams>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "route context"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 191,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L191"
    },
    {
      id: "HttpRouter.schemaNoBody",
      name: "schemaNoBody",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "<R, I extends Partial<{ readonly method: Method.HttpMethod; readonly url: string; readonly cookies: Readonly<Record<string, string | undefined>>; readonly headers: Readonly<Record<string, string | undefined>>; readonly pathParams: Readonly<Record<string, string | undefined>>; readonly searchParams: Readonly<Record<string, string | ReadonlyArray<string> | undefined>>; }>, A>(schema: Schema<A, I, R>, options?: ParseOptions) => Effect<A, ParseError, HttpServerRequest | RouteContext | ParsedSearchParams | R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "route context"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 204,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L204"
    },
    {
      id: "HttpRouter.schemaParams",
      name: "schemaParams",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "<A, I extends Readonly<Record<string, string | ReadonlyArray<string> | undefined>>, R>(schema: Schema<A, I, R>, options?: ParseOptions) => Effect<A, ParseError, RouteContext | ParsedSearchParams | R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "route context"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 216,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L216"
    },
    {
      id: "HttpRouter.schemaPathParams",
      name: "schemaPathParams",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "<A, I extends Readonly<Record<string, string | undefined>>, R>(schema: Schema<A, I, R>, options?: ParseOptions) => Effect<A, ParseError, RouteContext | R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "route context"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 221,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L221"
    },
    {
      id: "HttpRouter.currentRouterConfig",
      name: "currentRouterConfig",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "FiberRef<RouterConfig>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "router config"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 226,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L226"
    },
    {
      id: "HttpRouter.withRouterConfig",
      name: "withRouterConfig",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "{ (config: RouterConfig): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, config: RouterConfig): Effect<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "router config"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 231,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L231"
    },
    {
      id: "HttpRouter.setRouterConfig",
      name: "setRouterConfig",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "(config: RouterConfig) => Layer<never, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "router config"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 247,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L247"
    },
    {
      id: "HttpRouter.empty",
      name: "empty",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "HttpRouter<never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 252,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L252"
    },
    {
      id: "HttpRouter.fromIterable",
      name: "fromIterable",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "<R extends Route<any, any>>(routes: Iterable<R>) => HttpRouter<R extends Route<infer E, infer _> ? E : never, R extends Route<infer _, infer Env> ? Env : never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 257,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L257"
    },
    {
      id: "HttpRouter.makeRoute",
      name: "makeRoute",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: '<E, R>(method: HttpMethod | "*", path: PathInput, handler: Route.Handler<E, R>, options?: { readonly prefix?: string; readonly uninterruptible?: boolean; }) => Route<E, Exclude<R, HttpRouter.Provided>>',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 262,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L262"
    },
    {
      id: "HttpRouter.prefixPath",
      name: "prefixPath",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "{ (prefix: string): (self: string) => string; (self: string, prefix: string): string; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 270,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L270"
    },
    {
      id: "HttpRouter.prefixAll",
      name: "prefixAll",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "{ (prefix: PathInput): <E, R>(self: HttpRouter<E, R>) => HttpRouter<E, R>; <E, R>(self: HttpRouter<E, R>, prefix: PathInput): HttpRouter<E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 286,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L286"
    },
    {
      id: "HttpRouter.append",
      name: "append",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "{ <R1, E1>(route: Route<E1, R1>): <E, R>(self: HttpRouter<E, R>) => HttpRouter<E1 | E, R | Exclude<R1, HttpRouter.Provided>>; <E, R, E1, R1>(self: HttpRouter<E, R>, route: Route<E1, R1>): HttpRouter<E | E1, R | Exclude<R1, HttpRouter.Provided>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 302,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L302"
    },
    {
      id: "HttpRouter.concat",
      name: "concat",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "{ <R1, E1>(that: HttpRouter<E1, R1>): <E, R>(self: HttpRouter<E, R>) => HttpRouter<E1 | E, R1 | R>; <E, R, R1, E1>(self: HttpRouter<E, R>, that: HttpRouter<E1, R1>): HttpRouter<E | E1, R | R1>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 318,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L318"
    },
    {
      id: "HttpRouter.concatAll",
      name: "concatAll",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "<Routers extends ReadonlyArray<HttpRouter<unknown, unknown>>>(...routers: Routers) => [Routers[number]] extends [HttpRouter<infer E, infer R>] ? HttpRouter<E, R> : never",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 334,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L334"
    },
    {
      id: "HttpRouter.mount",
      name: "mount",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "{ <R1, E1>(path: `/${string}`, that: HttpRouter<E1, R1>): <E, R>(self: HttpRouter<E, R>) => HttpRouter<E1 | E, R1 | R>; <E, R, E1, R1>(self: HttpRouter<E, R>, path: `/${string}`, that: HttpRouter<E1, R1>): HttpRouter<E | E1, R | R1>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "routing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 339,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L339"
    },
    {
      id: "HttpRouter.mountApp",
      name: "mountApp",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "{ <R1, E1>(path: `/${string}`, that: Default<E1, R1>, options?: { readonly includePrefix?: boolean; }): <E, R>(self: HttpRouter<E, R>) => HttpRouter<E1 | E, Exclude<R1, HttpRouter.Provided> | Exclude<R, HttpRouter.Provided>>; <E, R, E1, R1>(self: HttpRouter<E, R>, path: `/${string}`, that: Default<E1, R1>, options?: { readonly includePrefix?: boolean; }): HttpRouter<E | E1, Exclude<R, HttpRouter.Provided> | Exclude<R1, HttpRouter.Provided>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "routing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 355,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L355"
    },
    {
      id: "HttpRouter.route",
      name: "route",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: '(method: HttpMethod | "*") => { <R1, E1>(path: PathInput, handler: Route.Handler<E1, R1>, options?: { readonly uninterruptible?: boolean; }): <E, R>(self: HttpRouter<E, R>) => HttpRouter<E1 | E, R | Exclude<R1, HttpServerRequest | RouteContext | Scope>>; <E, R, E1, R1>(self: HttpRouter<E, R>, path: PathInput, handler: Route.Handler<E1, R1>, options?: { readonly uninterruptible?: boolean; }): HttpRouter<E | E1, R | Exclude<R1, HttpServerRequest | RouteContext | Scope>>; }',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "routing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 375,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L375"
    },
    {
      id: "HttpRouter.all",
      name: "all",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "{ <R1, E1>(path: PathInput, handler: Route.Handler<E1, R1>, options?: { readonly uninterruptible?: boolean; }): <E, R>(self: HttpRouter<E, R>) => HttpRouter<E1 | E, R | Exclude<R1, HttpRouter.Provided>>; <E, R, E1, R1>(self: HttpRouter<E, R>, path: PathInput, handler: Route.Handler<E1, R1>, options?: { readonly uninterruptible?: boolean; }): HttpRouter<E | E1, R | Exclude<R1, HttpRouter.Provided>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "routing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 387,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L387"
    },
    {
      id: "HttpRouter.get",
      name: "get",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "{ <R1, E1>(path: PathInput, handler: Route.Handler<E1, R1>, options?: { readonly uninterruptible?: boolean; }): <E, R>(self: HttpRouter<E, R>) => HttpRouter<E1 | E, R | Exclude<R1, HttpRouter.Provided>>; <E, R, E1, R1>(self: HttpRouter<E, R>, path: PathInput, handler: Route.Handler<E1, R1>, options?: { readonly uninterruptible?: boolean; }): HttpRouter<E | E1, R | Exclude<R1, HttpRouter.Provided>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "routing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 407,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L407"
    },
    {
      id: "HttpRouter.post",
      name: "post",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "{ <R1, E1>(path: PathInput, handler: Route.Handler<E1, R1>, options?: { readonly uninterruptible?: boolean; }): <E, R>(self: HttpRouter<E, R>) => HttpRouter<E1 | E, R | Exclude<R1, HttpRouter.Provided>>; <E, R, E1, R1>(self: HttpRouter<E, R>, path: PathInput, handler: Route.Handler<E1, R1>, options?: { readonly uninterruptible?: boolean; }): HttpRouter<E | E1, R | Exclude<R1, HttpRouter.Provided>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "routing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 427,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L427"
    },
    {
      id: "HttpRouter.patch",
      name: "patch",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "{ <R1, E1>(path: PathInput, handler: Route.Handler<E1, R1>, options?: { readonly uninterruptible?: boolean; }): <E, R>(self: HttpRouter<E, R>) => HttpRouter<E1 | E, R | Exclude<R1, HttpRouter.Provided>>; <E, R, E1, R1>(self: HttpRouter<E, R>, path: PathInput, handler: Route.Handler<E1, R1>, options?: { readonly uninterruptible?: boolean; }): HttpRouter<E | E1, R | Exclude<R1, HttpRouter.Provided>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "routing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 447,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L447"
    },
    {
      id: "HttpRouter.put",
      name: "put",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "{ <R1, E1>(path: PathInput, handler: Route.Handler<E1, R1>, options?: { readonly uninterruptible?: boolean; }): <E, R>(self: HttpRouter<E, R>) => HttpRouter<E1 | E, R | Exclude<R1, HttpRouter.Provided>>; <E, R, E1, R1>(self: HttpRouter<E, R>, path: PathInput, handler: Route.Handler<E1, R1>, options?: { readonly uninterruptible?: boolean; }): HttpRouter<E | E1, R | Exclude<R1, HttpRouter.Provided>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "routing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 467,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L467"
    },
    {
      id: "HttpRouter.del",
      name: "del",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "{ <R1, E1>(path: PathInput, handler: Route.Handler<E1, R1>, options?: { readonly uninterruptible?: boolean; }): <E, R>(self: HttpRouter<E, R>) => HttpRouter<E1 | E, R | Exclude<R1, HttpRouter.Provided>>; <E, R, E1, R1>(self: HttpRouter<E, R>, path: PathInput, handler: Route.Handler<E1, R1>, options?: { readonly uninterruptible?: boolean; }): HttpRouter<E | E1, R | Exclude<R1, HttpRouter.Provided>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "routing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 487,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L487"
    },
    {
      id: "HttpRouter.head",
      name: "head",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "{ <R1, E1>(path: PathInput, handler: Route.Handler<E1, R1>, options?: { readonly uninterruptible?: boolean; }): <E, R>(self: HttpRouter<E, R>) => HttpRouter<E1 | E, R | Exclude<R1, HttpRouter.Provided>>; <E, R, E1, R1>(self: HttpRouter<E, R>, path: PathInput, handler: Route.Handler<E1, R1>, options?: { readonly uninterruptible?: boolean; }): HttpRouter<E | E1, R | Exclude<R1, HttpRouter.Provided>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "routing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 507,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L507"
    },
    {
      id: "HttpRouter.options",
      name: "options",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "{ <R1, E1>(path: PathInput, handler: Route.Handler<E1, R1>, options?: { readonly uninterruptible?: boolean; }): <E, R>(self: HttpRouter<E, R>) => HttpRouter<E1 | E, R | Exclude<R1, HttpRouter.Provided>>; <E, R, E1, R1>(self: HttpRouter<E, R>, path: PathInput, handler: Route.Handler<E1, R1>, options?: { readonly uninterruptible?: boolean; }): HttpRouter<E | E1, R | Exclude<R1, HttpRouter.Provided>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "routing"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 527,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L527"
    },
    {
      id: "HttpRouter.use",
      name: "use",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "{ <E, R, R1, E1>(f: (self: Route.Middleware<E, R>) => Default<E1, R1>): (self: HttpRouter<E, R>) => HttpRouter<E1, Exclude<R1, HttpRouter.Provided>>; <E, R, R1, E1>(self: HttpRouter<E, R>, f: (self: Route.Middleware<E, R>) => Default<E1, R1>): HttpRouter<E1, Exclude<R1, HttpRouter.Provided>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 547,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L547"
    },
    {
      id: "HttpRouter.transform",
      name: "transform",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "{ <E, R, R1, E1>(f: (self: Route.Handler<E, R>) => HttpApp<Respondable, E1, R1>): (self: HttpRouter<E, R>) => HttpRouter<E1, Exclude<R1, HttpRouter.Provided>>; <E, R, R1, E1>(self: HttpRouter<E, R>, f: (self: Route.Handler<E, R>) => HttpApp<Respondable, E1, R1>): HttpRouter<E1, Exclude<R1, HttpRouter.Provided>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 563,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L563"
    },
    {
      id: "HttpRouter.catchAll",
      name: "catchAll",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "{ <E, E2, R2>(f: (e: E) => Route.Handler<E2, R2>): <R>(self: HttpRouter<E, R>) => HttpRouter<E2, R | Exclude<R2, HttpRouter.Provided>>; <E, R, E2, R2>(self: HttpRouter<E, R>, f: (e: E) => Route.Handler<E2, R2>): HttpRouter<E2, R | Exclude<R2, HttpRouter.Provided>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 579,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L579"
    },
    {
      id: "HttpRouter.catchAllCause",
      name: "catchAllCause",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "{ <E, E2, R2>(f: (e: Cause<E>) => Route.Handler<E2, R2>): <R>(self: HttpRouter<E, R>) => HttpRouter<E2, R | Exclude<R2, HttpRouter.Provided>>; <E, R, E2, R2>(self: HttpRouter<E, R>, f: (e: Cause<E>) => Route.Handler<E2, R2>): HttpRouter<E2, R | Exclude<R2, HttpRouter.Provided>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 595,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L595"
    },
    {
      id: "HttpRouter.catchTag",
      name: "catchTag",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: '{ <K extends E extends { _tag: string; } ? E["_tag"] : never, E, E1, R1>(k: K, f: (e: Extract<E, { _tag: K; }>) => Route.Handler<E1, R1>): <R>(self: HttpRouter<E, R>) => HttpRouter<E1 | Exclude<E, { _tag: K; }>, R | Exclude<R1, HttpRouter.Provided>>; <E, R, K extends E extends { _tag: string; } ? E["_tag"] : never, E1, R1>(self: HttpRouter<E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => Route.Handler<E1, R1>): HttpRouter<E1 | Exclude<E, { _tag: K; }>, R | Exclude<R1, HttpRouter.Provided>>; }',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 611,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L611"
    },
    {
      id: "HttpRouter.catchTags",
      name: "catchTags",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: '{ <E, Cases extends E extends { _tag: string; } ? { [K in E["_tag"]]+?: ((error: Extract<E, { _tag: K; }>) => Route.Handler<any, any>) | undefined; } : {}>(cases: Cases): <R>(self: HttpRouter<E, R>) => HttpRouter<Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: any[]) => Effect<any, infer E, any> ? E : never; }[keyof Cases], R | Exclude<{ [K in keyof Cases]: Cases[K] extends (...args: any[]) => Effect<any, any, infer R> ? R : never; }[keyof Cases], HttpRouter.Provided>>; <R, E, Cases extends E extends { _tag: string; } ? { [K in E["_tag"]]+?: ((error: Extract<E, { _tag: K; }>) => Route.Handler<any, any>) | undefined; } : {}>(self: HttpRouter<E, R>, cases: Cases): HttpRouter<Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: any[]) => Effect<any, infer E, any> ? E : never; }[keyof Cases], R | Exclude<{ [K in keyof Cases]: Cases[K] extends (...args: any[]) => Effect<any, any, infer R> ? R : never; }[keyof Cases], HttpRouter.Provided>>; }',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 639,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L639"
    },
    {
      id: "HttpRouter.provideService",
      name: "provideService",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "{ <T extends Context.Tag<any, any>>(tag: T, service: Tag.Service<T>): <E, R>(self: HttpRouter<E, R>) => HttpRouter<E, Exclude<R, Tag.Identifier<T>>>; <E, R, T extends Context.Tag<any, any>>(self: HttpRouter<E, R>, tag: T, service: Tag.Service<T>): HttpRouter<E, Exclude<R, Tag.Identifier<T>>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 679,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L679"
    },
    {
      id: "HttpRouter.provideServiceEffect",
      name: "provideServiceEffect",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "{ <T extends Context.Tag<any, any>, R1, E1>(tag: T, effect: Effect<Tag.Service<T>, E1, R1>): <E, R>(self: HttpRouter<E, R>) => HttpRouter<E1 | E, Exclude<R, Tag.Identifier<T>> | Exclude<Exclude<R1, HttpRouter.Provided>, Tag.Identifier<T>>>; <E, R, T extends Context.Tag<any, any>, R1, E1>(self: HttpRouter<E, R>, tag: T, effect: Effect<Tag.Service<T>, E1, R1>): HttpRouter<E | E1, Exclude<R, Tag.Identifier<T>> | Exclude<Exclude<R1, HttpRouter.Provided>, Tag.Identifier<T>>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 695,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L695"
    },
    {
      id: "HttpRouter.Tag",
      name: "Tag",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "<const Name extends string>(id: Name) => <Self, R = never, E = unknown>() => HttpRouter.TagClass<Self, Name, E, R | HttpRouter.DefaultServices>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "tags"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 711,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L711"
    },
    {
      id: "HttpRouter.toHttpApp",
      name: "toHttpApp",
      module: "HttpRouter",
      package: "@effect/platform",
      signature: "<E, R>(self: HttpRouter<E, R>) => Effect<Default<E | RouteNotFound, R>, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "utils"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpRouter.d.ts",
      sourceLine: 723,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpRouter.ts#L723"
    },
    {
      id: "HttpServer.TypeId",
      name: "TypeId",
      module: "HttpServer",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServer.d.ts",
      sourceLine: 20,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServer.ts#L20"
    },
    {
      id: "HttpServer.HttpServer",
      name: "HttpServer",
      module: "HttpServer",
      package: "@effect/platform",
      signature: "Tag<HttpServer, HttpServer>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServer.d.ts",
      sourceLine: 71,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServer.ts#L71"
    },
    {
      id: "HttpServer.make",
      name: "make",
      module: "HttpServer",
      package: "@effect/platform",
      signature: "(options: { readonly serve: (httpApp: Default<unknown, never>, middleware?: HttpMiddleware) => Effect<void, never, Scope>; readonly address: Address; }) => HttpServer",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServer.d.ts",
      sourceLine: 76,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServer.ts#L76"
    },
    {
      id: "HttpServer.serve",
      name: "serve",
      module: "HttpServer",
      package: "@effect/platform",
      signature: "{ (): <E, R>(httpApp: Default<E, R>) => Layer<never, never, HttpServer | Exclude<R, HttpServerRequest | Scope>>; <E, R, App extends App.Default<any, any>>(middleware: HttpMiddleware.Applied<App, E, R>): (httpApp: Default<E, R>) => Layer<never, never, HttpServer | Exclude<Effect.Context<App>, HttpServerRequest | Scope>>; <E, R>(httpApp: Default<E, R>): Layer<never, never, HttpServer | Exclude<R, HttpServerRequest | Scope>>; <E, R, App extends App.Default<any, any>>(httpApp: Default<E, R>, middleware: HttpMiddleware.Applied<App, E, R>): Layer<never, never, HttpServer | Exclude<Effect.Context<App>, HttpServerRequest | Scope>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "accessors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServer.d.ts",
      sourceLine: 84,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServer.ts#L84"
    },
    {
      id: "HttpServer.serveEffect",
      name: "serveEffect",
      module: "HttpServer",
      package: "@effect/platform",
      signature: "{ (): <E, R>(httpApp: Default<E, R>) => Effect<void, never, Scope | HttpServer | Exclude<R, HttpServerRequest>>; <E, R, App extends App.Default<any, any>>(middleware: HttpMiddleware.Applied<App, E, R>): (httpApp: Default<E, R>) => Effect<void, never, Scope | HttpServer | Exclude<Effect.Context<App>, HttpServerRequest>>; <E, R>(httpApp: Default<E, R>): Effect<void, never, Scope | HttpServer | Exclude<R, HttpServerRequest>>; <E, R, App extends App.Default<any, any>>(httpApp: Default<E, R>, middleware: HttpMiddleware.Applied<App, E, R>): Effect<void, never, Scope | HttpServer | Exclude<Effect.Context<App>, HttpServerRequest>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "accessors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServer.d.ts",
      sourceLine: 110,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServer.ts#L110"
    },
    {
      id: "HttpServer.formatAddress",
      name: "formatAddress",
      module: "HttpServer",
      package: "@effect/platform",
      signature: "(address: Address) => string",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "address"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServer.d.ts",
      sourceLine: 136,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServer.ts#L136"
    },
    {
      id: "HttpServer.addressWith",
      name: "addressWith",
      module: "HttpServer",
      package: "@effect/platform",
      signature: "<A, E, R>(effect: (address: Address) => Effect<A, E, R>) => Effect<A, E, HttpServer | R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "address"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServer.d.ts",
      sourceLine: 141,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServer.ts#L141"
    },
    {
      id: "HttpServer.addressFormattedWith",
      name: "addressFormattedWith",
      module: "HttpServer",
      package: "@effect/platform",
      signature: "<A, E, R>(effect: (address: string) => Effect<A, E, R>) => Effect<A, E, HttpServer | R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "address"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServer.d.ts",
      sourceLine: 146,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServer.ts#L146"
    },
    {
      id: "HttpServer.logAddress",
      name: "logAddress",
      module: "HttpServer",
      package: "@effect/platform",
      signature: "Effect<void, never, HttpServer>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "address"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServer.d.ts",
      sourceLine: 151,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServer.ts#L151"
    },
    {
      id: "HttpServer.withLogAddress",
      name: "withLogAddress",
      module: "HttpServer",
      package: "@effect/platform",
      signature: "<A, E, R>(layer: Layer<A, E, R>) => Layer<A, E, R | Exclude<HttpServer, A>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "address"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServer.d.ts",
      sourceLine: 156,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServer.ts#L156"
    },
    {
      id: "HttpServer.layerTestClient",
      name: "layerTestClient",
      module: "HttpServer",
      package: "@effect/platform",
      signature: "Layer<HttpClient, never, HttpServer | HttpClient>",
      description: "Layer producing an `HttpClient` with prepended url of the running http server.",
      documentation: "Layer producing an `HttpClient` with prepended url of the running http server.",
      examples: [],
      tags: [
        "layers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServer.d.ts",
      sourceLine: 163,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServer.ts#L163"
    },
    {
      id: "HttpServer.layerContext",
      name: "layerContext",
      module: "HttpServer",
      package: "@effect/platform",
      signature: "Layer<HttpPlatform | FileSystem | Generator | Path, never, never>",
      description: "A Layer providing the `HttpPlatform`, `FileSystem`, `Etag.Generator`, and `Path`\nservices. The `FileSystem` service is a no-op implementation, so this layer is only\nuseful for platforms that have no file system.",
      documentation: "A Layer providing the `HttpPlatform`, `FileSystem`, `Etag.Generator`, and `Path`\nservices.\n\nThe `FileSystem` service is a no-op implementation, so this layer is only\nuseful for platforms that have no file system.",
      examples: [],
      tags: [
        "layers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServer.d.ts",
      sourceLine: 174,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServer.ts#L174"
    },
    {
      id: "HttpServerError.TypeId",
      name: "TypeId",
      module: "HttpServerError",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type id"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerError.d.ts",
      sourceLine: 16,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerError.ts#L16"
    },
    {
      id: "HttpServerError.isServerError",
      name: "isServerError",
      module: "HttpServerError",
      package: "@effect/platform",
      signature: "(u: unknown) => u is HttpServerError",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "predicates"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerError.d.ts",
      sourceLine: 51,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerError.ts#L51"
    },
    {
      id: "HttpServerError.clientAbortFiberId",
      name: "clientAbortFiberId",
      module: "HttpServerError",
      package: "@effect/platform",
      signature: "FiberId",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerError.d.ts",
      sourceLine: 106,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerError.ts#L106"
    },
    {
      id: "HttpServerError.causeResponse",
      name: "causeResponse",
      module: "HttpServerError",
      package: "@effect/platform",
      signature: "<E>(cause: Cause<E>) => Effect<readonly [HttpServerResponse, Cause<E>], never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerError.d.ts",
      sourceLine: 110,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerError.ts#L110"
    },
    {
      id: "HttpServerError.causeResponseStripped",
      name: "causeResponseStripped",
      module: "HttpServerError",
      package: "@effect/platform",
      signature: "<E>(cause: Cause<E>) => readonly [response: HttpServerResponse, cause: Option<Cause<E>>]",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerError.d.ts",
      sourceLine: 114,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerError.ts#L114"
    },
    {
      id: "HttpServerError.exitResponse",
      name: "exitResponse",
      module: "HttpServerError",
      package: "@effect/platform",
      signature: "<E>(exit: Exit<HttpServerResponse, E>) => HttpServerResponse",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerError.d.ts",
      sourceLine: 118,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerError.ts#L118"
    },
    {
      id: "HttpServerRequest.TypeId",
      name: "TypeId",
      module: "HttpServerRequest",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerRequest.d.ts",
      sourceLine: 40,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerRequest.ts#L40"
    },
    {
      id: "HttpServerRequest.HttpServerRequest",
      name: "HttpServerRequest",
      module: "HttpServerRequest",
      package: "@effect/platform",
      signature: "Tag<HttpServerRequest, HttpServerRequest>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "context"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerRequest.d.ts",
      sourceLine: 70,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerRequest.ts#L70"
    },
    {
      id: "HttpServerRequest.ParsedSearchParams",
      name: "ParsedSearchParams",
      module: "HttpServerRequest",
      package: "@effect/platform",
      signature: "Tag<ParsedSearchParams, ReadonlyRecord<string, string | string[]>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "search params"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerRequest.d.ts",
      sourceLine: 82,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerRequest.ts#L82"
    },
    {
      id: "HttpServerRequest.searchParamsFromURL",
      name: "searchParamsFromURL",
      module: "HttpServerRequest",
      package: "@effect/platform",
      signature: "(url: URL) => ReadonlyRecord<string, string | string[]>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "search params"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerRequest.d.ts",
      sourceLine: 87,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerRequest.ts#L87"
    },
    {
      id: "HttpServerRequest.persistedMultipart",
      name: "persistedMultipart",
      module: "HttpServerRequest",
      package: "@effect/platform",
      signature: "Effect<unknown, MultipartError, HttpServerRequest | FileSystem | Scope | Path>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "accessors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerRequest.d.ts",
      sourceLine: 92,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerRequest.ts#L92"
    },
    {
      id: "HttpServerRequest.upgrade",
      name: "upgrade",
      module: "HttpServerRequest",
      package: "@effect/platform",
      signature: "Effect<Socket, RequestError, HttpServerRequest>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "accessors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerRequest.d.ts",
      sourceLine: 97,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerRequest.ts#L97"
    },
    {
      id: "HttpServerRequest.upgradeChannel",
      name: "upgradeChannel",
      module: "HttpServerRequest",
      package: "@effect/platform",
      signature: "<IE = never>() => Channel<Chunk<Uint8Array>, Chunk<string | Uint8Array | CloseEvent>, RequestError | IE | SocketError, IE, void, unknown, HttpServerRequest>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "accessors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerRequest.d.ts",
      sourceLine: 102,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerRequest.ts#L102"
    },
    {
      id: "HttpServerRequest.schemaCookies",
      name: "schemaCookies",
      module: "HttpServerRequest",
      package: "@effect/platform",
      signature: "<A, I extends Readonly<Record<string, string | undefined>>, R>(schema: Schema<A, I, R>, options?: ParseOptions) => Effect<A, ParseError, HttpServerRequest | R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schema"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerRequest.d.ts",
      sourceLine: 107,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerRequest.ts#L107"
    },
    {
      id: "HttpServerRequest.schemaHeaders",
      name: "schemaHeaders",
      module: "HttpServerRequest",
      package: "@effect/platform",
      signature: "<A, I extends Readonly<Record<string, string | undefined>>, R>(schema: Schema<A, I, R>, options?: ParseOptions) => Effect<A, ParseError, HttpServerRequest | R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schema"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerRequest.d.ts",
      sourceLine: 112,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerRequest.ts#L112"
    },
    {
      id: "HttpServerRequest.schemaSearchParams",
      name: "schemaSearchParams",
      module: "HttpServerRequest",
      package: "@effect/platform",
      signature: "<A, I extends Readonly<Record<string, string | ReadonlyArray<string> | undefined>>, R>(schema: Schema<A, I, R>, options?: ParseOptions) => Effect<A, ParseError, ParsedSearchParams | R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schema"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerRequest.d.ts",
      sourceLine: 117,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerRequest.ts#L117"
    },
    {
      id: "HttpServerRequest.schemaBodyJson",
      name: "schemaBodyJson",
      module: "HttpServerRequest",
      package: "@effect/platform",
      signature: "<A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => Effect<A, RequestError | ParseError, HttpServerRequest | R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schema"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerRequest.d.ts",
      sourceLine: 122,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerRequest.ts#L122"
    },
    {
      id: "HttpServerRequest.schemaBodyForm",
      name: "schemaBodyForm",
      module: "HttpServerRequest",
      package: "@effect/platform",
      signature: "<A, I extends Partial<Multipart.Persisted>, R>(schema: Schema<A, I, R>, options?: ParseOptions) => Effect<A, RequestError | ParseError | MultipartError, HttpServerRequest | FileSystem | Scope | Path | R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schema"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerRequest.d.ts",
      sourceLine: 127,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerRequest.ts#L127"
    },
    {
      id: "HttpServerRequest.schemaBodyUrlParams",
      name: "schemaBodyUrlParams",
      module: "HttpServerRequest",
      package: "@effect/platform",
      signature: "<A, I extends Readonly<Record<string, string | ReadonlyArray<string> | undefined>>, R>(schema: Schema<A, I, R>, options?: ParseOptions) => Effect<A, RequestError | ParseError, HttpServerRequest | R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schema"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerRequest.d.ts",
      sourceLine: 132,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerRequest.ts#L132"
    },
    {
      id: "HttpServerRequest.schemaBodyMultipart",
      name: "schemaBodyMultipart",
      module: "HttpServerRequest",
      package: "@effect/platform",
      signature: "<A, I extends Partial<Multipart.Persisted>, R>(schema: Schema<A, I, R>, options?: ParseOptions) => Effect<A, ParseError | MultipartError, HttpServerRequest | FileSystem | Scope | Path | R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schema"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerRequest.d.ts",
      sourceLine: 137,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerRequest.ts#L137"
    },
    {
      id: "HttpServerRequest.schemaBodyFormJson",
      name: "schemaBodyFormJson",
      module: "HttpServerRequest",
      package: "@effect/platform",
      signature: "<A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (field: string) => Effect<A, RequestError | ParseError, HttpServerRequest | FileSystem | Scope | Path | R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schema"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerRequest.d.ts",
      sourceLine: 142,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerRequest.ts#L142"
    },
    {
      id: "HttpServerRequest.fromWeb",
      name: "fromWeb",
      module: "HttpServerRequest",
      package: "@effect/platform",
      signature: "(request: Request) => HttpServerRequest",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerRequest.d.ts",
      sourceLine: 147,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerRequest.ts#L147"
    },
    {
      id: "HttpServerRequest.toWebEither",
      name: "toWebEither",
      module: "HttpServerRequest",
      package: "@effect/platform",
      signature: "(self: HttpServerRequest, options?: { readonly signal?: AbortSignal; readonly runtime?: Runtime<never>; }) => Either<Request, RequestError>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerRequest.d.ts",
      sourceLine: 152,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerRequest.ts#L152"
    },
    {
      id: "HttpServerRequest.toWeb",
      name: "toWeb",
      module: "HttpServerRequest",
      package: "@effect/platform",
      signature: "(self: HttpServerRequest, options?: { readonly signal?: AbortSignal; }) => Effect<Request, RequestError, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerRequest.d.ts",
      sourceLine: 160,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerRequest.ts#L160"
    },
    {
      id: "HttpServerRequest.toURL",
      name: "toURL",
      module: "HttpServerRequest",
      package: "@effect/platform",
      signature: "(self: HttpServerRequest) => Option<URL>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerRequest.d.ts",
      sourceLine: 167,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerRequest.ts#L167"
    },
    {
      id: "HttpServerRespondable.symbol",
      name: "symbol",
      module: "HttpServerRespondable",
      package: "@effect/platform",
      signature: "typeof symbol",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerRespondable.d.ts",
      sourceLine: 7,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerRespondable.ts#L7"
    },
    {
      id: "HttpServerRespondable.isRespondable",
      name: "isRespondable",
      module: "HttpServerRespondable",
      package: "@effect/platform",
      signature: "(u: unknown) => u is Respondable",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "guards"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerRespondable.d.ts",
      sourceLine: 19,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerRespondable.ts#L19"
    },
    {
      id: "HttpServerRespondable.toResponse",
      name: "toResponse",
      module: "HttpServerRespondable",
      package: "@effect/platform",
      signature: "(self: Respondable) => Effect<HttpServerResponse, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "accessors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerRespondable.d.ts",
      sourceLine: 24,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerRespondable.ts#L24"
    },
    {
      id: "HttpServerRespondable.toResponseOrElse",
      name: "toResponseOrElse",
      module: "HttpServerRespondable",
      package: "@effect/platform",
      signature: "(u: unknown, orElse: HttpServerResponse) => Effect<HttpServerResponse, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "accessors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerRespondable.d.ts",
      sourceLine: 29,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerRespondable.ts#L29"
    },
    {
      id: "HttpServerRespondable.toResponseOrElseDefect",
      name: "toResponseOrElseDefect",
      module: "HttpServerRespondable",
      package: "@effect/platform",
      signature: "(u: unknown, orElse: HttpServerResponse) => Effect<HttpServerResponse, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "accessors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerRespondable.d.ts",
      sourceLine: 34,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerRespondable.ts#L34"
    },
    {
      id: "HttpServerResponse.TypeId",
      name: "TypeId",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 24,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L24"
    },
    {
      id: "HttpServerResponse.isServerResponse",
      name: "isServerResponse",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "(u: unknown) => u is HttpServerResponse",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 74,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L74"
    },
    {
      id: "HttpServerResponse.empty",
      name: "empty",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "(options?: Options.WithContent) => HttpServerResponse",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 79,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L79"
    },
    {
      id: "HttpServerResponse.redirect",
      name: "redirect",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "(location: string | URL, options?: Options.WithContentType) => HttpServerResponse",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 84,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L84"
    },
    {
      id: "HttpServerResponse.uint8Array",
      name: "uint8Array",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "(body: Uint8Array, options?: Options.WithContentType) => HttpServerResponse",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 89,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L89"
    },
    {
      id: "HttpServerResponse.text",
      name: "text",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "(body: string, options?: Options.WithContentType) => HttpServerResponse",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 94,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L94"
    },
    {
      id: "HttpServerResponse.html",
      name: "html",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "{ <A extends ReadonlyArray<Template.Interpolated>>(strings: TemplateStringsArray, ...args: A): Effect<HttpServerResponse, Interpolated.Error<A[number]>, Interpolated.Context<A[number]>>; (html: string): HttpServerResponse; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 99,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L99"
    },
    {
      id: "HttpServerResponse.htmlStream",
      name: "htmlStream",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "<A extends ReadonlyArray<Template.InterpolatedWithStream>>(strings: TemplateStringsArray, ...args: A) => Effect<HttpServerResponse, never, Interpolated.Context<A[number]>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 115,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L115"
    },
    {
      id: "HttpServerResponse.json",
      name: "json",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "(body: unknown, options?: Options.WithContentType) => Effect<HttpServerResponse, HttpBodyError, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 120,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L120"
    },
    {
      id: "HttpServerResponse.schemaJson",
      name: "schemaJson",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "<A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (body: A, options?: Options.WithContent) => Effect<HttpServerResponse, HttpBodyError, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 125,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L125"
    },
    {
      id: "HttpServerResponse.unsafeJson",
      name: "unsafeJson",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "(body: unknown, options?: Options.WithContentType) => HttpServerResponse",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 130,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L130"
    },
    {
      id: "HttpServerResponse.urlParams",
      name: "urlParams",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "(body: Input, options?: Options.WithContentType) => HttpServerResponse",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 135,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L135"
    },
    {
      id: "HttpServerResponse.raw",
      name: "raw",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "(body: unknown, options?: Options) => HttpServerResponse",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 140,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L140"
    },
    {
      id: "HttpServerResponse.formData",
      name: "formData",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "(body: FormData, options?: Options.WithContent) => HttpServerResponse",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 145,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L145"
    },
    {
      id: "HttpServerResponse.stream",
      name: "stream",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "<E>(body: Stream<Uint8Array, E, never>, options?: Options) => HttpServerResponse",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 150,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L150"
    },
    {
      id: "HttpServerResponse.file",
      name: "file",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "(path: string, options?: Options & StreamOptions) => Effect<HttpServerResponse, PlatformError, HttpPlatform>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 155,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L155"
    },
    {
      id: "HttpServerResponse.fileWeb",
      name: "fileWeb",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "(file: HttpBody.FileLike, options?: Options.WithContent & StreamOptions) => Effect<HttpServerResponse, never, HttpPlatform>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 160,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L160"
    },
    {
      id: "HttpServerResponse.setHeader",
      name: "setHeader",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "{ (key: string, value: string): (self: HttpServerResponse) => HttpServerResponse; (self: HttpServerResponse, key: string, value: string): HttpServerResponse; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 165,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L165"
    },
    {
      id: "HttpServerResponse.setHeaders",
      name: "setHeaders",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "{ (input: Input): (self: HttpServerResponse) => HttpServerResponse; (self: HttpServerResponse, input: Input): HttpServerResponse; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 181,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L181"
    },
    {
      id: "HttpServerResponse.removeCookie",
      name: "removeCookie",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "{ (name: string): (self: HttpServerResponse) => HttpServerResponse; (self: HttpServerResponse, name: string): HttpServerResponse; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 197,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L197"
    },
    {
      id: "HttpServerResponse.expireCookie",
      name: "expireCookie",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: '{ (name: string, options?: Omit<{ readonly domain?: string; readonly expires?: Date; readonly maxAge?: DurationInput; readonly path?: string; readonly priority?: "low" | "medium" | "high"; readonly httpOnly?: boolean; readonly secure?: boolean; readonly partitioned?: boolean; readonly sameSite?: "lax" | "strict" | "none"; }, "expires" | "maxAge">): (self: HttpServerResponse) => HttpServerResponse; (self: HttpServerResponse, name: string, options?: Omit<{ readonly domain?: string; readonly expires?: Date; readonly maxAge?: DurationInput; readonly path?: string; readonly priority?: "low" | "medium" | "high"; readonly httpOnly?: boolean; readonly secure?: boolean; readonly partitioned?: boolean; readonly sameSite?: "lax" | "strict" | "none"; }, "expires" | "maxAge">): HttpServerResponse; }',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 213,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L213"
    },
    {
      id: "HttpServerResponse.replaceCookies",
      name: "replaceCookies",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "{ (cookies: Cookies): (self: HttpServerResponse) => HttpServerResponse; (self: HttpServerResponse, cookies: Cookies): HttpServerResponse; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 229,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L229"
    },
    {
      id: "HttpServerResponse.setCookie",
      name: "setCookie",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: '{ (name: string, value: string, options?: { readonly domain?: string; readonly expires?: Date; readonly maxAge?: DurationInput; readonly path?: string; readonly priority?: "low" | "medium" | "high"; readonly httpOnly?: boolean; readonly secure?: boolean; readonly partitioned?: boolean; readonly sameSite?: "lax" | "strict" | "none"; }): (self: HttpServerResponse) => Effect<HttpServerResponse, CookiesError, never>; (self: HttpServerResponse, name: string, value: string, options?: { readonly domain?: string; readonly expires?: Date; readonly maxAge?: DurationInput; readonly path?: string; readonly priority?: "low" | "medium" | "high"; readonly httpOnly?: boolean; readonly secure?: boolean; readonly partitioned?: boolean; readonly sameSite?: "lax" | "strict" | "none"; }): Effect<HttpServerResponse, CookiesError, never>; }',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 245,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L245"
    },
    {
      id: "HttpServerResponse.unsafeSetCookie",
      name: "unsafeSetCookie",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: '{ (name: string, value: string, options?: { readonly domain?: string; readonly expires?: Date; readonly maxAge?: DurationInput; readonly path?: string; readonly priority?: "low" | "medium" | "high"; readonly httpOnly?: boolean; readonly secure?: boolean; readonly partitioned?: boolean; readonly sameSite?: "lax" | "strict" | "none"; }): (self: HttpServerResponse) => HttpServerResponse; (self: HttpServerResponse, name: string, value: string, options?: { readonly domain?: string; readonly expires?: Date; readonly maxAge?: DurationInput; readonly path?: string; readonly priority?: "low" | "medium" | "high"; readonly httpOnly?: boolean; readonly secure?: boolean; readonly partitioned?: boolean; readonly sameSite?: "lax" | "strict" | "none"; }): HttpServerResponse; }',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 261,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L261"
    },
    {
      id: "HttpServerResponse.updateCookies",
      name: "updateCookies",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "{ (f: (cookies: Cookies) => Cookies): (self: HttpServerResponse) => HttpServerResponse; (self: HttpServerResponse, f: (cookies: Cookies) => Cookies): HttpServerResponse; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 277,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L277"
    },
    {
      id: "HttpServerResponse.mergeCookies",
      name: "mergeCookies",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "{ (cookies: Cookies): (self: HttpServerResponse) => HttpServerResponse; (self: HttpServerResponse, cookies: Cookies): HttpServerResponse; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 293,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L293"
    },
    {
      id: "HttpServerResponse.setCookies",
      name: "setCookies",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: '{ (cookies: Iterable<readonly [name: string, value: string, options?: { readonly domain?: string; readonly expires?: Date; readonly maxAge?: DurationInput; readonly path?: string; readonly priority?: "low" | "medium" | "high"; readonly httpOnly?: boolean; readonly secure?: boolean; readonly partitioned?: boolean; readonly sameSite?: "lax" | "strict" | "none"; }]>): (self: HttpServerResponse) => Effect<HttpServerResponse, CookiesError, never>; (self: HttpServerResponse, cookies: Iterable<readonly [name: string, value: string, options?: { readonly domain?: string; readonly expires?: Date; readonly maxAge?: DurationInput; readonly path?: string; readonly priority?: "low" | "medium" | "high"; readonly httpOnly?: boolean; readonly secure?: boolean; readonly partitioned?: boolean; readonly sameSite?: "lax" | "strict" | "none"; }]>): Effect<HttpServerResponse, CookiesError, never>; }',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 309,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L309"
    },
    {
      id: "HttpServerResponse.unsafeSetCookies",
      name: "unsafeSetCookies",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: '{ (cookies: Iterable<readonly [name: string, value: string, options?: { readonly domain?: string; readonly expires?: Date; readonly maxAge?: DurationInput; readonly path?: string; readonly priority?: "low" | "medium" | "high"; readonly httpOnly?: boolean; readonly secure?: boolean; readonly partitioned?: boolean; readonly sameSite?: "lax" | "strict" | "none"; }]>): (self: HttpServerResponse) => HttpServerResponse; (self: HttpServerResponse, cookies: Iterable<readonly [name: string, value: string, options?: { readonly domain?: string; readonly expires?: Date; readonly maxAge?: DurationInput; readonly path?: string; readonly priority?: "low" | "medium" | "high"; readonly httpOnly?: boolean; readonly secure?: boolean; readonly partitioned?: boolean; readonly sameSite?: "lax" | "strict" | "none"; }]>): HttpServerResponse; }',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 333,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L333"
    },
    {
      id: "HttpServerResponse.setBody",
      name: "setBody",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "{ (body: HttpBody): (self: HttpServerResponse) => HttpServerResponse; (self: HttpServerResponse, body: HttpBody): HttpServerResponse; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 357,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L357"
    },
    {
      id: "HttpServerResponse.setStatus",
      name: "setStatus",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "{ (status: number, statusText?: string): (self: HttpServerResponse) => HttpServerResponse; (self: HttpServerResponse, status: number, statusText?: string): HttpServerResponse; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 373,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L373"
    },
    {
      id: "HttpServerResponse.toWeb",
      name: "toWeb",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "(response: HttpServerResponse, options?: { readonly withoutBody?: boolean; readonly runtime?: Runtime<never>; }) => Response",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 389,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L389"
    },
    {
      id: "HttpServerResponse.fromWeb",
      name: "fromWeb",
      module: "HttpServerResponse",
      package: "@effect/platform",
      signature: "(response: Response) => HttpServerResponse",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpServerResponse.d.ts",
      sourceLine: 397,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpServerResponse.ts#L397"
    },
    {
      id: "HttpTraceContext.toHeaders",
      name: "toHeaders",
      module: "HttpTraceContext",
      package: "@effect/platform",
      signature: "(span: Span) => Headers",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "encoding"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpTraceContext.d.ts",
      sourceLine: 18,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpTraceContext.ts#L18"
    },
    {
      id: "HttpTraceContext.fromHeaders",
      name: "fromHeaders",
      module: "HttpTraceContext",
      package: "@effect/platform",
      signature: "(headers: Headers) => Option<ExternalSpan>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "decoding"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpTraceContext.d.ts",
      sourceLine: 23,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpTraceContext.ts#L23"
    },
    {
      id: "HttpTraceContext.b3",
      name: "b3",
      module: "HttpTraceContext",
      package: "@effect/platform",
      signature: "FromHeaders",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "decoding"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpTraceContext.d.ts",
      sourceLine: 28,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpTraceContext.ts#L28"
    },
    {
      id: "HttpTraceContext.xb3",
      name: "xb3",
      module: "HttpTraceContext",
      package: "@effect/platform",
      signature: "FromHeaders",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "decoding"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpTraceContext.d.ts",
      sourceLine: 33,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpTraceContext.ts#L33"
    },
    {
      id: "HttpTraceContext.w3c",
      name: "w3c",
      module: "HttpTraceContext",
      package: "@effect/platform",
      signature: "FromHeaders",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "decoding"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpTraceContext.d.ts",
      sourceLine: 38,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpTraceContext.ts#L38"
    },
    {
      id: "HttpLayerRouter.TypeId",
      name: "TypeId",
      module: "HttpLayerRouter",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "HttpRouter"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpLayerRouter.d.ts",
      sourceLine: 33,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpLayerRouter.ts#L33"
    },
    {
      id: "HttpLayerRouter.HttpRouter",
      name: "HttpRouter",
      module: "HttpLayerRouter",
      package: "@effect/platform",
      signature: "Tag<HttpRouter, HttpRouter>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "HttpRouter"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpLayerRouter.d.ts",
      sourceLine: 57,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpLayerRouter.ts#L57"
    },
    {
      id: "HttpLayerRouter.make",
      name: "make",
      module: "HttpLayerRouter",
      package: "@effect/platform",
      signature: "Effect<HttpRouter, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "HttpRouter"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpLayerRouter.d.ts",
      sourceLine: 62,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpLayerRouter.ts#L62"
    },
    {
      id: "HttpLayerRouter.use",
      name: "use",
      module: "HttpLayerRouter",
      package: "@effect/platform",
      signature: "<A, E, R>(f: (router: HttpRouter) => Effect<A, E, R>) => Layer<never, E, HttpRouter | Exclude<R, Scope>>",
      description: "A helper function that is the equivalent of:",
      documentation: 'A helper function that is the equivalent of:\n\n```ts\nimport * as HttpLayerRouter from "@effect/platform/HttpLayerRouter"\nimport * as Effect from "effect/Effect"\nimport * as Layer from "effect/Layer"\n\nconst MyRoute = Layer.scopedDiscard(Effect.gen(function*() {\n  const router = yield* HttpLayerRouter.HttpRouter\n\n  // then use `yield* router.add(...)` to add a route\n}))\n```',
      examples: [
        {
          code: 'import * as HttpLayerRouter from "@effect/platform/HttpLayerRouter"\nimport * as Effect from "effect/Effect"\nimport * as Layer from "effect/Layer"\n\nconst MyRoute = Layer.scopedDiscard(Effect.gen(function*() {\n  const router = yield* HttpLayerRouter.HttpRouter\n\n  // then use `yield* router.add(...)` to add a route\n}))'
        }
      ],
      tags: [
        "HttpRouter"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpLayerRouter.d.ts",
      sourceLine: 119,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpLayerRouter.ts#L119"
    },
    {
      id: "HttpLayerRouter.add",
      name: "add",
      module: "HttpLayerRouter",
      package: "@effect/platform",
      signature: '<E, R>(method: "*" | "GET" | "POST" | "PUT" | "PATCH" | "DELETE" | "OPTIONS", path: PathInput, handler: Effect<HttpServerResponse, E, R> | ((request: HttpServerRequest) => Effect<HttpServerResponse, E, R>), options?: { readonly uninterruptible?: boolean; }) => Layer<never, never, HttpRouter | Request.From<"Requires", Exclude<R, Provided>> | Request.From<"Error", E>>',
      description: "Create a layer that adds a single route to the HTTP router.",
      documentation: 'Create a layer that adds a single route to the HTTP router.\n\n```ts\nimport * as HttpLayerRouter from "@effect/platform/HttpLayerRouter"\nimport * as HttpServerResponse from "@effect/platform/HttpServerResponse"\n\nconst Route = HttpLayerRouter.add("GET", "/hello", HttpServerResponse.text("Hello, World!"))\n```',
      examples: [],
      tags: [
        "HttpRouter"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpLayerRouter.d.ts",
      sourceLine: 133,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpLayerRouter.ts#L133"
    },
    {
      id: "HttpLayerRouter.addAll",
      name: "addAll",
      module: "HttpLayerRouter",
      package: "@effect/platform",
      signature: '<Routes extends ReadonlyArray<Route<any, any>>, EX = never, RX = never>(routes: Routes | Effect<Routes, EX, RX>, options?: { readonly prefix?: string; }) => Layer<never, EX, HttpRouter | Exclude<RX, Scope> | Request.From<"Requires", Exclude<Route.Context<Routes[number]>, Provided>> | Request.From<"Error", Route.Error<Routes[number]>>>',
      description: "Create a layer that adds multiple routes to the HTTP router.",
      documentation: 'Create a layer that adds multiple routes to the HTTP router.\n\n```ts\nimport * as HttpLayerRouter from "@effect/platform/HttpLayerRouter"\nimport * as HttpServerResponse from "@effect/platform/HttpServerResponse"\n\nconst Routes = HttpLayerRouter.addAll([\n  HttpLayerRouter.route("GET", "/hello", HttpServerResponse.text("Hello, World!"))\n])\n```',
      examples: [],
      tags: [
        "HttpRouter"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpLayerRouter.d.ts",
      sourceLine: 151,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpLayerRouter.ts#L151"
    },
    {
      id: "HttpLayerRouter.layer",
      name: "layer",
      module: "HttpLayerRouter",
      package: "@effect/platform",
      signature: "Layer<HttpRouter, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "HttpRouter"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpLayerRouter.d.ts",
      sourceLine: 158,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpLayerRouter.ts#L158"
    },
    {
      id: "HttpLayerRouter.toHttpEffect",
      name: "toHttpEffect",
      module: "HttpLayerRouter",
      package: "@effect/platform",
      signature: '<A, E, R>(appLayer: Layer<A, E, R>) => Effect<Effect<HttpServerResponse, Request.Only<"Error", R> | Request.Only<"GlobalRequires", R> | RouteNotFound, Scope | HttpServerRequest | Request.Only<"GlobalRequires", R> | Request.Only<"Requires", R>>, Request.Without<E>, Scope | Exclude<Request.Without<R>, HttpRouter>>',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "HttpRouter"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpLayerRouter.d.ts",
      sourceLine: 163,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpLayerRouter.ts#L163"
    },
    {
      id: "HttpLayerRouter.RouteTypeId",
      name: "RouteTypeId",
      module: "HttpLayerRouter",
      package: "@effect/platform",
      signature: "typeof RouteTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Route"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpLayerRouter.d.ts",
      sourceLine: 168,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpLayerRouter.ts#L168"
    },
    {
      id: "HttpLayerRouter.route",
      name: "route",
      module: "HttpLayerRouter",
      package: "@effect/platform",
      signature: '<E, R>(method: "*" | "GET" | "POST" | "PUT" | "PATCH" | "DELETE" | "OPTIONS", path: PathInput, handler: Effect<HttpServerResponse, E, R> | ((request: HttpServerRequest) => Effect<HttpServerResponse, E, R>), options?: { readonly uninterruptible?: boolean; }) => Route<E, Exclude<R, Provided>>',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Route"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpLayerRouter.d.ts",
      sourceLine: 206,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpLayerRouter.ts#L206"
    },
    {
      id: "HttpLayerRouter.prefixPath",
      name: "prefixPath",
      module: "HttpLayerRouter",
      package: "@effect/platform",
      signature: "{ (prefix: string): (self: string) => string; (self: string, prefix: string): string; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "PathInput"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpLayerRouter.d.ts",
      sourceLine: 218,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpLayerRouter.ts#L218"
    },
    {
      id: "HttpLayerRouter.prefixRoute",
      name: "prefixRoute",
      module: "HttpLayerRouter",
      package: "@effect/platform",
      signature: "{ (prefix: string): <E, R>(self: Route<E, R>) => Route<E, R>; <E, R>(self: Route<E, R>, prefix: string): Route<E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Route"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpLayerRouter.d.ts",
      sourceLine: 234,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpLayerRouter.ts#L234"
    },
    {
      id: "HttpLayerRouter.MiddlewareTypeId",
      name: "MiddlewareTypeId",
      module: "HttpLayerRouter",
      package: "@effect/platform",
      signature: "typeof MiddlewareTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Middleware"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpLayerRouter.d.ts",
      sourceLine: 298,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpLayerRouter.ts#L298"
    },
    {
      id: "HttpLayerRouter.middleware",
      name: "middleware",
      module: "HttpLayerRouter",
      package: "@effect/platform",
      signature: "middleware.Make<never, never> & (<Config extends { provides?: any; handles?: any; } = {}>() => middleware.Make<Config extends { provides: infer R; } ? R : never, Config extends { handles: infer E; } ? E : never>)",
      description: "Create a middleware layer that can be used to modify requests and responses. By default, the middleware only affects the routes that it is provided to. If you want to create a middleware that applies globally to all routes, pass\nthe `global` option as `true`.",
      documentation: 'Create a middleware layer that can be used to modify requests and responses.\n\nBy default, the middleware only affects the routes that it is provided to.\n\nIf you want to create a middleware that applies globally to all routes, pass\nthe `global` option as `true`.\n\n```ts\nimport * as HttpLayerRouter from "@effect/platform/HttpLayerRouter"\nimport * as HttpMiddleware from "@effect/platform/HttpMiddleware"\nimport * as HttpServerResponse from "@effect/platform/HttpServerResponse"\nimport * as Context from "effect/Context"\nimport * as Effect from "effect/Effect"\nimport * as Layer from "effect/Layer"\n\n// Here we are defining a CORS middleware\nconst CorsMiddleware = HttpLayerRouter.middleware(HttpMiddleware.cors()).layer\n// You can also use HttpLayerRouter.cors() to create a CORS middleware\n\nclass CurrentSession extends Context.Tag("CurrentSession")<CurrentSession, {\n  readonly token: string\n}>() {}\n\n// You can create middleware that provides a service to the HTTP requests.\nconst SessionMiddleware = HttpLayerRouter.middleware<{\n  provides: CurrentSession\n}>()(\n  Effect.gen(function*() {\n    yield* Effect.log("SessionMiddleware initialized")\n\n    return (httpEffect) =>\n      Effect.provideService(httpEffect, CurrentSession, {\n        token: "dummy-token"\n      })\n  })\n).layer\n\nEffect.gen(function*() {\n  const router = yield* HttpLayerRouter.HttpRouter\n  yield* router.add(\n    "GET",\n    "/hello",\n    Effect.gen(function*() {\n      // Requests can now access the current session\n      const session = yield* CurrentSession\n      return HttpServerResponse.text(`Hello, World! Your token is ${session.token}`)\n    })\n  )\n}).pipe(\n  Layer.effectDiscard,\n  // Provide the SessionMiddleware & CorsMiddleware to some routes\n  Layer.provide([SessionMiddleware, CorsMiddleware])\n)\n```',
      examples: [
        {
          code: 'import * as HttpLayerRouter from "@effect/platform/HttpLayerRouter"\nimport * as HttpMiddleware from "@effect/platform/HttpMiddleware"\nimport * as HttpServerResponse from "@effect/platform/HttpServerResponse"\nimport * as Context from "effect/Context"\nimport * as Effect from "effect/Effect"\nimport * as Layer from "effect/Layer"\n\n// Here we are defining a CORS middleware\nconst CorsMiddleware = HttpLayerRouter.middleware(HttpMiddleware.cors()).layer\n// You can also use HttpLayerRouter.cors() to create a CORS middleware\n\nclass CurrentSession extends Context.Tag("CurrentSession")<CurrentSession, {\n  readonly token: string\n}>() {}\n\n// You can create middleware that provides a service to the HTTP requests.\nconst SessionMiddleware = HttpLayerRouter.middleware<{\n  provides: CurrentSession\n}>()(\n  Effect.gen(function*() {\n    yield* Effect.log("SessionMiddleware initialized")\n\n    return (httpEffect) =>\n      Effect.provideService(httpEffect, CurrentSession, {\n        token: "dummy-token"\n      })\n  })\n).layer\n\nEffect.gen(function*() {\n  const router = yield* HttpLayerRouter.HttpRouter\n  yield* router.add(\n    "GET",\n    "/hello",\n    Effect.gen(function*() {\n      // Requests can now access the current session\n      const session = yield* CurrentSession\n      return HttpServerResponse.text(`Hello, World! Your token is ${session.token}`)\n    })\n  )\n}).pipe(\n  Layer.effectDiscard,\n  // Provide the SessionMiddleware & CorsMiddleware to some routes\n  Layer.provide([SessionMiddleware, CorsMiddleware])\n)'
        }
      ],
      tags: [
        "Middleware"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpLayerRouter.d.ts",
      sourceLine: 403,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpLayerRouter.ts#L403"
    },
    {
      id: "HttpLayerRouter.cors",
      name: "cors",
      module: "HttpLayerRouter",
      package: "@effect/platform",
      signature: "(options?: { readonly allowedOrigins?: readonly string[] | Predicate<string>; readonly allowedMethods?: readonly string[]; readonly allowedHeaders?: readonly string[]; readonly exposedHeaders?: readonly string[]; readonly maxAge?: number; readonly credentials?: boolean; }) => Layer<never, never, HttpRouter>",
      description: "A middleware that applies CORS headers to the HTTP response.",
      documentation: "A middleware that applies CORS headers to the HTTP response.",
      examples: [],
      tags: [
        "Middleware"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpLayerRouter.d.ts",
      sourceLine: 454,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpLayerRouter.ts#L454"
    },
    {
      id: "HttpLayerRouter.disableLogger",
      name: "disableLogger",
      module: "HttpLayerRouter",
      package: "@effect/platform",
      signature: "Layer<never, never, never>",
      description: "A middleware that disables the logger for some routes.",
      documentation: 'A middleware that disables the logger for some routes.\n\n```ts\nimport * as HttpLayerRouter from "@effect/platform/HttpLayerRouter"\nimport * as HttpServerResponse from "@effect/platform/HttpServerResponse"\nimport * as Layer from "effect/Layer"\n\nconst Route = HttpLayerRouter.add("GET", "/hello", HttpServerResponse.text("Hello, World!")).pipe(\n  // disable the logger for this route\n  Layer.provide(HttpLayerRouter.disableLogger)\n)\n```',
      examples: [],
      tags: [
        "Middleware"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpLayerRouter.d.ts",
      sourceLine: 479,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpLayerRouter.ts#L479"
    },
    {
      id: "HttpLayerRouter.addHttpApi",
      name: "addHttpApi",
      module: "HttpLayerRouter",
      package: "@effect/platform",
      signature: "<Id extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, E, R>(api: HttpApi<Id, Groups, E, R>, options?: { readonly openapiPath?: `/${string}`; }) => Layer<never, never, HttpRouter | R | Generator | FileSystem | HttpPlatform | Path | HttpApiGroup.ToService<Id, Groups> | HttpApiGroup.ErrorContext<Groups>>",
      description: "",
      documentation: '```ts\nimport * as NodeHttpServer from "@effect/platform-node/NodeHttpServer"\nimport * as NodeRuntime from "@effect/platform-node/NodeRuntime"\nimport * as HttpApi from "@effect/platform/HttpApi"\nimport * as HttpApiBuilder from "@effect/platform/HttpApiBuilder"\nimport * as HttpApiEndpoint from "@effect/platform/HttpApiEndpoint"\nimport * as HttpApiGroup from "@effect/platform/HttpApiGroup"\nimport * as HttpApiScalar from "@effect/platform/HttpApiScalar"\nimport * as HttpLayerRouter from "@effect/platform/HttpLayerRouter"\nimport * as HttpMiddleware from "@effect/platform/HttpMiddleware"\nimport * as Effect from "effect/Effect"\nimport * as Layer from "effect/Layer"\nimport { createServer } from "http"\n\n// First, we define our HttpApi\nclass MyApi extends HttpApi.make("api").add(\n  HttpApiGroup.make("users").add(\n    HttpApiEndpoint.get("me", "/me")\n  ).prefix("/users")\n) {}\n\n// Implement the handlers for the API\nconst UsersApiLayer = HttpApiBuilder.group(MyApi, "users", (handers) => handers.handle("me", () => Effect.void))\n\n// Use `HttpLayerRouter.addHttpApi` to register the API with the router\nconst HttpApiRoutes = HttpLayerRouter.addHttpApi(MyApi, {\n  openapiPath: "/docs/openapi.json"\n}).pipe(\n  // Provide the api handlers layer\n  Layer.provide(UsersApiLayer)\n)\n\n// Create a /docs route for the API documentation\nconst DocsRoute = HttpApiScalar.layerHttpLayerRouter({\n  api: MyApi,\n  path: "/docs"\n})\n\nconst CorsMiddleware = HttpLayerRouter.middleware(HttpMiddleware.cors())\n// You can also use HttpLayerRouter.cors() to create a CORS middleware\n\n// Finally, we merge all routes and serve them using the Node HTTP server\nconst AllRoutes = Layer.mergeAll(\n  HttpApiRoutes,\n  DocsRoute\n).pipe(\n  Layer.provide(CorsMiddleware.layer)\n)\n\nHttpLayerRouter.serve(AllRoutes).pipe(\n  Layer.provide(NodeHttpServer.layer(createServer, { port: 3000 })),\n  Layer.launch,\n  NodeRuntime.runMain\n)\n```',
      examples: [
        {
          code: 'import * as NodeHttpServer from "@effect/platform-node/NodeHttpServer"\nimport * as NodeRuntime from "@effect/platform-node/NodeRuntime"\nimport * as HttpApi from "@effect/platform/HttpApi"\nimport * as HttpApiBuilder from "@effect/platform/HttpApiBuilder"\nimport * as HttpApiEndpoint from "@effect/platform/HttpApiEndpoint"\nimport * as HttpApiGroup from "@effect/platform/HttpApiGroup"\nimport * as HttpApiScalar from "@effect/platform/HttpApiScalar"\nimport * as HttpLayerRouter from "@effect/platform/HttpLayerRouter"\nimport * as HttpMiddleware from "@effect/platform/HttpMiddleware"\nimport * as Effect from "effect/Effect"\nimport * as Layer from "effect/Layer"\nimport { createServer } from "http"\n\n// First, we define our HttpApi\nclass MyApi extends HttpApi.make("api").add(\n  HttpApiGroup.make("users").add(\n    HttpApiEndpoint.get("me", "/me")\n  ).prefix("/users")\n) {}\n\n// Implement the handlers for the API\nconst UsersApiLayer = HttpApiBuilder.group(MyApi, "users", (handers) => handers.handle("me", () => Effect.void))\n\n// Use `HttpLayerRouter.addHttpApi` to register the API with the router\nconst HttpApiRoutes = HttpLayerRouter.addHttpApi(MyApi, {\n  openapiPath: "/docs/openapi.json"\n}).pipe(\n  // Provide the api handlers layer\n  Layer.provide(UsersApiLayer)\n)\n\n// Create a /docs route for the API documentation\nconst DocsRoute = HttpApiScalar.layerHttpLayerRouter({\n  api: MyApi,\n  path: "/docs"\n})\n\nconst CorsMiddleware = HttpLayerRouter.middleware(HttpMiddleware.cors())\n// You can also use HttpLayerRouter.cors() to create a CORS middleware\n\n// Finally, we merge all routes and serve them using the Node HTTP server\nconst AllRoutes = Layer.mergeAll(\n  HttpApiRoutes,\n  DocsRoute\n).pipe(\n  Layer.provide(CorsMiddleware.layer)\n)\n\nHttpLayerRouter.serve(AllRoutes).pipe(\n  Layer.provide(NodeHttpServer.layer(createServer, { port: 3000 })),\n  Layer.launch,\n  NodeRuntime.runMain\n)'
        }
      ],
      tags: [
        "HttpApi"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpLayerRouter.d.ts",
      sourceLine: 540,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpLayerRouter.ts#L540"
    },
    {
      id: "HttpLayerRouter.serve",
      name: "serve",
      module: "HttpLayerRouter",
      package: "@effect/platform",
      signature: '<A, E, R, HE, HR = Request.Only<"Requires", R> | Request.Only<"GlobalRequires", R>>(appLayer: Layer<A, E, R>, options?: { readonly routerConfig?: any; readonly disableLogger?: boolean; readonly disableListenLog?: boolean; readonly middleware?: (effect: Effect<HttpServerResponse, RouteNotFound | Request.Only<"Error", R> | Request.Only<"GlobalError", R>, Scope | HttpServerRequest | Request.Only<"Requires", R> | Request.Only<"GlobalRequires", R>>) => Effect<HttpServerResponse, HE, HR>; }) => Layer<A, Request.Without<E>, HttpServer | Exclude<Request.Without<R>, HttpRouter> | Exclude<Exclude<HR, GlobalProvided>, HttpRouter>>',
      description: "Serves the provided application layer as an HTTP server.",
      documentation: "Serves the provided application layer as an HTTP server.",
      examples: [],
      tags: [
        "Server"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpLayerRouter.d.ts",
      sourceLine: 549,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpLayerRouter.ts#L549"
    },
    {
      id: "HttpLayerRouter.toWebHandler",
      name: "toWebHandler",
      module: "HttpLayerRouter",
      package: "@effect/platform",
      signature: '<A, E, R extends HttpRouter | Request<"Requires", any> | Request<"GlobalRequires", any> | Request<"Error", any> | Request<"GlobalError", any>, HE, HR = Exclude<Request.Only<"Requires", R>, A> | Exclude<Request.Only<"GlobalRequires", R>, A>>(appLayer: Layer<A, E, R>, options?: { readonly memoMap?: MemoMap; readonly routerConfig?: any; readonly disableLogger?: boolean; readonly middleware?: (effect: Effect<HttpServerResponse, RouteNotFound | Request.Only<"Error", R> | Request.Only<"GlobalError", R>, Scope | HttpServerRequest | Request.Only<"Requires", R> | Request.Only<"GlobalRequires", R>>) => Effect<HttpServerResponse, HE, HR>; }) => { readonly handler: [HR] extends [never] ? (request: Request, context?: Context<never>) => Promise<Response> : (request: Request, context: Context<HR>) => Promise<Response>; readonly dispose: () => Promise<void>; }',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Server"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/HttpLayerRouter.d.ts",
      sourceLine: 570,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/HttpLayerRouter.ts#L570"
    },
    {
      id: "Command.CommandTypeId",
      name: "CommandTypeId",
      module: "Command",
      package: "@effect/platform",
      signature: "typeof CommandTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Command.d.ts",
      sourceLine: 18,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Command.ts#L18"
    },
    {
      id: "Command.isCommand",
      name: "isCommand",
      module: "Command",
      package: "@effect/platform",
      signature: "(u: unknown) => u is Command",
      description: "Returns `true` if the specified value is a `Command`, otherwise returns\n`false`.",
      documentation: "Returns `true` if the specified value is a `Command`, otherwise returns\n`false`.",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Command.d.ts",
      sourceLine: 110,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Command.ts#L110"
    },
    {
      id: "Command.env",
      name: "env",
      module: "Command",
      package: "@effect/platform",
      signature: "{ (environment: Record<string, string>): (self: Command) => Command; (self: Command, environment: Record<string, string>): Command; }",
      description: "Specify the environment variables that will be used when running this command.",
      documentation: "Specify the environment variables that will be used when running this command.",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Command.d.ts",
      sourceLine: 117,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Command.ts#L117"
    },
    {
      id: "Command.exitCode",
      name: "exitCode",
      module: "Command",
      package: "@effect/platform",
      signature: "(self: Command) => Effect<ExitCode, PlatformError, CommandExecutor>",
      description: "Returns the exit code of the command after the process has completed\nexecution.",
      documentation: "Returns the exit code of the command after the process has completed\nexecution.",
      examples: [],
      tags: [
        "execution"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Command.d.ts",
      sourceLine: 140,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Command.ts#L140"
    },
    {
      id: "Command.feed",
      name: "feed",
      module: "Command",
      package: "@effect/platform",
      signature: "{ (input: string): (self: Command) => Command; (self: Command, input: string): Command; }",
      description: "Feed a string to standard input (default encoding of UTF-8).",
      documentation: "Feed a string to standard input (default encoding of UTF-8).",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Command.d.ts",
      sourceLine: 147,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Command.ts#L147"
    },
    {
      id: "Command.flatten",
      name: "flatten",
      module: "Command",
      package: "@effect/platform",
      signature: "(self: Command) => readonly [StandardCommand, ...StandardCommand[]]",
      description: "Flatten this command to a non-empty array of standard commands. For a `StandardCommand`, this simply returns a `1` element array\nFor a `PipedCommand`, all commands in the pipe will be extracted out into\na array from left to right",
      documentation: "Flatten this command to a non-empty array of standard commands.\n\nFor a `StandardCommand`, this simply returns a `1` element array\nFor a `PipedCommand`, all commands in the pipe will be extracted out into\na array from left to right",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Command.d.ts",
      sourceLine: 173,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Command.ts#L173"
    },
    {
      id: "Command.lines",
      name: "lines",
      module: "Command",
      package: "@effect/platform",
      signature: "(command: Command, encoding?: string) => Effect<string[], PlatformError, CommandExecutor>",
      description: "Runs the command returning the output as an array of lines with the specified\nencoding.",
      documentation: "Runs the command returning the output as an array of lines with the specified\nencoding.",
      examples: [],
      tags: [
        "execution"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Command.d.ts",
      sourceLine: 181,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Command.ts#L181"
    },
    {
      id: "Command.make",
      name: "make",
      module: "Command",
      package: "@effect/platform",
      signature: "(command: string, ...args: string[]) => Command",
      description: "Create a command with the specified process name and an optional list of\narguments.",
      documentation: "Create a command with the specified process name and an optional list of\narguments.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Command.d.ts",
      sourceLine: 189,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Command.ts#L189"
    },
    {
      id: "Command.pipeTo",
      name: "pipeTo",
      module: "Command",
      package: "@effect/platform",
      signature: "{ (into: Command): (self: Command) => Command; (self: Command, into: Command): Command; }",
      description: "Pipe one command to another command from left to right. Conceptually, the equivalent of piping one shell command to another:",
      documentation: "Pipe one command to another command from left to right.\n\nConceptually, the equivalent of piping one shell command to another:\n\n```sh\ncommand1 | command2\n```",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Command.d.ts",
      sourceLine: 202,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Command.ts#L202"
    },
    {
      id: "Command.runInShell",
      name: "runInShell",
      module: "Command",
      package: "@effect/platform",
      signature: "{ (shell: string | boolean): (self: Command) => Command; (self: Command, shell: string | boolean): Command; }",
      description: "Allows for specifying whether or not a `Command` should be run inside a\nshell.",
      documentation: "Allows for specifying whether or not a `Command` should be run inside a\nshell.",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Command.d.ts",
      sourceLine: 237,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Command.ts#L237"
    },
    {
      id: "Command.start",
      name: "start",
      module: "Command",
      package: "@effect/platform",
      signature: "(command: Command) => Effect<Process, PlatformError, CommandExecutor | Scope>",
      description: "Start running the command and return a handle to the running process.",
      documentation: "Start running the command and return a handle to the running process.",
      examples: [],
      tags: [
        "execution"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Command.d.ts",
      sourceLine: 261,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Command.ts#L261"
    },
    {
      id: "Command.stream",
      name: "stream",
      module: "Command",
      package: "@effect/platform",
      signature: "(command: Command) => Stream<Uint8Array, PlatformError, CommandExecutor>",
      description: "Start running the command and return the output as a `Stream`.",
      documentation: "Start running the command and return the output as a `Stream`.",
      examples: [],
      tags: [
        "execution"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Command.d.ts",
      sourceLine: 268,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Command.ts#L268"
    },
    {
      id: "Command.streamLines",
      name: "streamLines",
      module: "Command",
      package: "@effect/platform",
      signature: "(command: Command, encoding?: string) => Stream<string, PlatformError, CommandExecutor>",
      description: "Runs the command returning the output as an stream of lines with the\nspecified encoding.",
      documentation: "Runs the command returning the output as an stream of lines with the\nspecified encoding.",
      examples: [],
      tags: [
        "execution"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Command.d.ts",
      sourceLine: 276,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Command.ts#L276"
    },
    {
      id: "Command.string",
      name: "string",
      module: "Command",
      package: "@effect/platform",
      signature: "{ (encoding?: string): (command: Command) => Effect<string, PlatformError, CommandExecutor>; (command: Command, encoding?: string): Effect<string, PlatformError, CommandExecutor>; }",
      description: "Runs the command returning the entire output as a string with the\nspecified encoding. If an encoding is not specified, the encoding will default to `utf-8`.",
      documentation: "Runs the command returning the entire output as a string with the\nspecified encoding.\n\nIf an encoding is not specified, the encoding will default to `utf-8`.",
      examples: [],
      tags: [
        "execution"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Command.d.ts",
      sourceLine: 286,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Command.ts#L286"
    },
    {
      id: "Command.stderr",
      name: "stderr",
      module: "Command",
      package: "@effect/platform",
      signature: "{ (stderr: CommandOutput): (self: Command) => Command; (self: Command, stderr: CommandOutput): Command; }",
      description: "Specify the standard error stream for a command.",
      documentation: "Specify the standard error stream for a command.",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Command.d.ts",
      sourceLine: 314,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Command.ts#L314"
    },
    {
      id: "Command.stdin",
      name: "stdin",
      module: "Command",
      package: "@effect/platform",
      signature: "{ (stdin: CommandInput): (self: Command) => Command; (self: Command, stdin: CommandInput): Command; }",
      description: "Specify the standard input stream for a command.",
      documentation: "Specify the standard input stream for a command.",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Command.d.ts",
      sourceLine: 336,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Command.ts#L336"
    },
    {
      id: "Command.stdout",
      name: "stdout",
      module: "Command",
      package: "@effect/platform",
      signature: "{ (stdout: CommandOutput): (self: Command) => Command; (self: Command, stdout: CommandOutput): Command; }",
      description: "Specify the standard output stream for a command.",
      documentation: "Specify the standard output stream for a command.",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Command.d.ts",
      sourceLine: 358,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Command.ts#L358"
    },
    {
      id: "Command.workingDirectory",
      name: "workingDirectory",
      module: "Command",
      package: "@effect/platform",
      signature: "{ (cwd: string): (self: Command) => Command; (self: Command, cwd: string): Command; }",
      description: "Set the working directory that will be used when this command will be run. For piped commands, the working directory of each command will be set to the\nspecified working directory.",
      documentation: "Set the working directory that will be used when this command will be run.\n\nFor piped commands, the working directory of each command will be set to the\nspecified working directory.",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Command.d.ts",
      sourceLine: 383,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Command.ts#L383"
    },
    {
      id: "CommandExecutor.TypeId",
      name: "TypeId",
      module: "CommandExecutor",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/CommandExecutor.d.ts",
      sourceLine: 17,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/CommandExecutor.ts#L17"
    },
    {
      id: "CommandExecutor.CommandExecutor",
      name: "CommandExecutor",
      module: "CommandExecutor",
      package: "@effect/platform",
      signature: "Tag<CommandExecutor, CommandExecutor>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "tags"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/CommandExecutor.d.ts",
      sourceLine: 64,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/CommandExecutor.ts#L64"
    },
    {
      id: "CommandExecutor.ProcessTypeId",
      name: "ProcessTypeId",
      module: "CommandExecutor",
      package: "@effect/platform",
      signature: "typeof ProcessTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "symbols"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/CommandExecutor.d.ts",
      sourceLine: 69,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/CommandExecutor.ts#L69"
    },
    {
      id: "CommandExecutor.ExitCode",
      name: "ExitCode",
      module: "CommandExecutor",
      package: "@effect/platform",
      signature: "Brand.Constructor<ExitCode>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/CommandExecutor.d.ts",
      sourceLine: 142,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/CommandExecutor.ts#L142"
    },
    {
      id: "CommandExecutor.ProcessId",
      name: "ProcessId",
      module: "CommandExecutor",
      package: "@effect/platform",
      signature: "Brand.Constructor<ProcessId>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/CommandExecutor.d.ts",
      sourceLine: 147,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/CommandExecutor.ts#L147"
    },
    {
      id: "CommandExecutor.makeExecutor",
      name: "makeExecutor",
      module: "CommandExecutor",
      package: "@effect/platform",
      signature: "(start: (command: Command) => Effect<Process, PlatformError, Scope>) => CommandExecutor",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/CommandExecutor.d.ts",
      sourceLine: 152,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/CommandExecutor.ts#L152"
    },
    {
      id: "Cookies.makeCookie",
      name: "makeCookie",
      module: "Cookies",
      package: "@effect/platform",
      signature: '(name: string, value: string, options: { readonly domain?: string; readonly expires?: Date; readonly maxAge?: DurationInput; readonly path?: string; readonly priority?: "low" | "medium" | "high"; readonly httpOnly?: boolean; readonly secure?: boolean; readonly partitioned?: boolean; readonly sameSite?: "lax" | "strict" | "none"; }) => Either<Cookie, CookiesError>',
      description: "Create a new cookie",
      documentation: "Create a new cookie",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 126,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L126"
    },
    {
      id: "Cookies.serializeCookie",
      name: "serializeCookie",
      module: "Cookies",
      package: "@effect/platform",
      signature: "(self: Cookie) => string",
      description: "Serialize a cookie into a string Adapted from https://github.com/fastify/fastify-cookie under MIT License",
      documentation: "Serialize a cookie into a string\n\nAdapted from https://github.com/fastify/fastify-cookie under MIT License",
      examples: [],
      tags: [
        "encoding"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 362,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L362"
    },
    {
      id: "Cookies.parseHeader",
      name: "parseHeader",
      module: "Cookies",
      package: "@effect/platform",
      signature: "(header: string) => Record<string, string>",
      description: "Parse a cookie header into a record of key-value pairs Adapted from https://github.com/fastify/fastify-cookie under MIT License",
      documentation: "Parse a cookie header into a record of key-value pairs\n\nAdapted from https://github.com/fastify/fastify-cookie under MIT License",
      examples: [],
      tags: [
        "decoding"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 392,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L392"
    },
    {
      id: "Cookies.TypeId",
      name: "TypeId",
      module: "Cookies",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 15,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L15"
    },
    {
      id: "Cookies.isCookies",
      name: "isCookies",
      module: "Cookies",
      package: "@effect/platform",
      signature: "(u: unknown) => u is Cookies",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 25,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L25"
    },
    {
      id: "Cookies.CookieTypeId",
      name: "CookieTypeId",
      module: "Cookies",
      package: "@effect/platform",
      signature: "typeof CookieTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 38,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L38"
    },
    {
      id: "Cookies.ErrorTypeId",
      name: "ErrorTypeId",
      module: "Cookies",
      package: "@effect/platform",
      signature: "typeof ErrorTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 69,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L69"
    },
    {
      id: "Cookies.fromReadonlyRecord",
      name: "fromReadonlyRecord",
      module: "Cookies",
      package: "@effect/platform",
      signature: "(cookies: ReadonlyRecord<string, Cookie>) => Cookies",
      description: "Create a Cookies object from an Iterable",
      documentation: "Create a Cookies object from an Iterable",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 93,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L93"
    },
    {
      id: "Cookies.fromIterable",
      name: "fromIterable",
      module: "Cookies",
      package: "@effect/platform",
      signature: "(cookies: Iterable<Cookie>) => Cookies",
      description: "Create a Cookies object from an Iterable",
      documentation: "Create a Cookies object from an Iterable",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 100,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L100"
    },
    {
      id: "Cookies.fromSetCookie",
      name: "fromSetCookie",
      module: "Cookies",
      package: "@effect/platform",
      signature: "(headers: string | Iterable<string>) => Cookies",
      description: "Create a Cookies object from a set of Set-Cookie headers",
      documentation: "Create a Cookies object from a set of Set-Cookie headers",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 107,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L107"
    },
    {
      id: "Cookies.empty",
      name: "empty",
      module: "Cookies",
      package: "@effect/platform",
      signature: "Cookies",
      description: "An empty Cookies object",
      documentation: "An empty Cookies object",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 114,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L114"
    },
    {
      id: "Cookies.isEmpty",
      name: "isEmpty",
      module: "Cookies",
      package: "@effect/platform",
      signature: "(self: Cookies) => boolean",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 119,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L119"
    },
    {
      id: "Cookies.unsafeMakeCookie",
      name: "unsafeMakeCookie",
      module: "Cookies",
      package: "@effect/platform",
      signature: '(name: string, value: string, options?: { readonly domain?: string; readonly expires?: Date; readonly maxAge?: DurationInput; readonly path?: string; readonly priority?: "low" | "medium" | "high"; readonly httpOnly?: boolean; readonly secure?: boolean; readonly partitioned?: boolean; readonly sameSite?: "lax" | "strict" | "none"; }) => Cookie',
      description: "Create a new cookie, throwing an error if invalid",
      documentation: "Create a new cookie, throwing an error if invalid",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 133,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L133"
    },
    {
      id: "Cookies.setCookie",
      name: "setCookie",
      module: "Cookies",
      package: "@effect/platform",
      signature: "{ (cookie: Cookie): (self: Cookies) => Cookies; (self: Cookies, cookie: Cookie): Cookies; }",
      description: "Add a cookie to a Cookies object",
      documentation: "Add a cookie to a Cookies object",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 140,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L140"
    },
    {
      id: "Cookies.setAllCookie",
      name: "setAllCookie",
      module: "Cookies",
      package: "@effect/platform",
      signature: "{ (cookies: Iterable<Cookie>): (self: Cookies) => Cookies; (self: Cookies, cookies: Iterable<Cookie>): Cookies; }",
      description: "Add multiple cookies to a Cookies object",
      documentation: "Add multiple cookies to a Cookies object",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 162,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L162"
    },
    {
      id: "Cookies.merge",
      name: "merge",
      module: "Cookies",
      package: "@effect/platform",
      signature: "{ (that: Cookies): (self: Cookies) => Cookies; (self: Cookies, that: Cookies): Cookies; }",
      description: "Combine two Cookies objects, removing duplicates from the first",
      documentation: "Combine two Cookies objects, removing duplicates from the first",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 184,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L184"
    },
    {
      id: "Cookies.remove",
      name: "remove",
      module: "Cookies",
      package: "@effect/platform",
      signature: "{ (name: string): (self: Cookies) => Cookies; (self: Cookies, name: string): Cookies; }",
      description: "Remove a cookie by name",
      documentation: "Remove a cookie by name",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 206,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L206"
    },
    {
      id: "Cookies.get",
      name: "get",
      module: "Cookies",
      package: "@effect/platform",
      signature: "{ (name: string): (self: Cookies) => Option<Cookie>; (self: Cookies, name: string): Option<Cookie>; }",
      description: "Get a cookie from a Cookies object",
      documentation: "Get a cookie from a Cookies object",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 228,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L228"
    },
    {
      id: "Cookies.getValue",
      name: "getValue",
      module: "Cookies",
      package: "@effect/platform",
      signature: "{ (name: string): (self: Cookies) => Option<string>; (self: Cookies, name: string): Option<string>; }",
      description: "Get a cookie from a Cookies object",
      documentation: "Get a cookie from a Cookies object",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 250,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L250"
    },
    {
      id: "Cookies.set",
      name: "set",
      module: "Cookies",
      package: "@effect/platform",
      signature: '{ (name: string, value: string, options?: { readonly domain?: string; readonly expires?: Date; readonly maxAge?: DurationInput; readonly path?: string; readonly priority?: "low" | "medium" | "high"; readonly httpOnly?: boolean; readonly secure?: boolean; readonly partitioned?: boolean; readonly sameSite?: "lax" | "strict" | "none"; }): (self: Cookies) => Either<Cookies, CookiesError>; (self: Cookies, name: string, value: string, options?: { readonly domain?: string; readonly expires?: Date; readonly maxAge?: DurationInput; readonly path?: string; readonly priority?: "low" | "medium" | "high"; readonly httpOnly?: boolean; readonly secure?: boolean; readonly partitioned?: boolean; readonly sameSite?: "lax" | "strict" | "none"; }): Either<Cookies, CookiesError>; }',
      description: "Add a cookie to a Cookies object",
      documentation: "Add a cookie to a Cookies object",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 272,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L272"
    },
    {
      id: "Cookies.unsafeSet",
      name: "unsafeSet",
      module: "Cookies",
      package: "@effect/platform",
      signature: '{ (name: string, value: string, options?: { readonly domain?: string; readonly expires?: Date; readonly maxAge?: DurationInput; readonly path?: string; readonly priority?: "low" | "medium" | "high"; readonly httpOnly?: boolean; readonly secure?: boolean; readonly partitioned?: boolean; readonly sameSite?: "lax" | "strict" | "none"; }): (self: Cookies) => Cookies; (self: Cookies, name: string, value: string, options?: { readonly domain?: string; readonly expires?: Date; readonly maxAge?: DurationInput; readonly path?: string; readonly priority?: "low" | "medium" | "high"; readonly httpOnly?: boolean; readonly secure?: boolean; readonly partitioned?: boolean; readonly sameSite?: "lax" | "strict" | "none"; }): Cookies; }',
      description: "Add a cookie to a Cookies object",
      documentation: "Add a cookie to a Cookies object",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 294,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L294"
    },
    {
      id: "Cookies.setAll",
      name: "setAll",
      module: "Cookies",
      package: "@effect/platform",
      signature: '{ (cookies: Iterable<readonly [name: string, value: string, options?: { readonly domain?: string; readonly expires?: Date; readonly maxAge?: DurationInput; readonly path?: string; readonly priority?: "low" | "medium" | "high"; readonly httpOnly?: boolean; readonly secure?: boolean; readonly partitioned?: boolean; readonly sameSite?: "lax" | "strict" | "none"; }]>): (self: Cookies) => Either<Cookies, CookiesError>; (self: Cookies, cookies: Iterable<readonly [name: string, value: string, options?: { readonly domain?: string; readonly expires?: Date; readonly maxAge?: DurationInput; readonly path?: string; readonly priority?: "low" | "medium" | "high"; readonly httpOnly?: boolean; readonly secure?: boolean; readonly partitioned?: boolean; readonly sameSite?: "lax" | "strict" | "none"; }]>): Either<Cookies, CookiesError>; }',
      description: "Add multiple cookies to a Cookies object",
      documentation: "Add multiple cookies to a Cookies object",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 316,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L316"
    },
    {
      id: "Cookies.unsafeSetAll",
      name: "unsafeSetAll",
      module: "Cookies",
      package: "@effect/platform",
      signature: '{ (cookies: Iterable<readonly [name: string, value: string, options?: { readonly domain?: string; readonly expires?: Date; readonly maxAge?: DurationInput; readonly path?: string; readonly priority?: "low" | "medium" | "high"; readonly httpOnly?: boolean; readonly secure?: boolean; readonly partitioned?: boolean; readonly sameSite?: "lax" | "strict" | "none"; }]>): (self: Cookies) => Cookies; (self: Cookies, cookies: Iterable<readonly [name: string, value: string, options?: { readonly domain?: string; readonly expires?: Date; readonly maxAge?: DurationInput; readonly path?: string; readonly priority?: "low" | "medium" | "high"; readonly httpOnly?: boolean; readonly secure?: boolean; readonly partitioned?: boolean; readonly sameSite?: "lax" | "strict" | "none"; }]>): Cookies; }',
      description: "Add multiple cookies to a Cookies object, throwing an error if invalid",
      documentation: "Add multiple cookies to a Cookies object, throwing an error if invalid",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 338,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L338"
    },
    {
      id: "Cookies.toCookieHeader",
      name: "toCookieHeader",
      module: "Cookies",
      package: "@effect/platform",
      signature: "(self: Cookies) => string",
      description: "Serialize a Cookies object into a Cookie header",
      documentation: "Serialize a Cookies object into a Cookie header",
      examples: [],
      tags: [
        "encoding"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 369,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L369"
    },
    {
      id: "Cookies.toRecord",
      name: "toRecord",
      module: "Cookies",
      package: "@effect/platform",
      signature: "(self: Cookies) => Record<string, string>",
      description: "To record",
      documentation: "To record",
      examples: [],
      tags: [
        "encoding"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 376,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L376"
    },
    {
      id: "Cookies.toSetCookieHeaders",
      name: "toSetCookieHeaders",
      module: "Cookies",
      package: "@effect/platform",
      signature: "(self: Cookies) => string[]",
      description: "Serialize a Cookies object into Headers object containing one or more Set-Cookie headers",
      documentation: "Serialize a Cookies object into Headers object containing one or more Set-Cookie headers",
      examples: [],
      tags: [
        "encoding"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Cookies.d.ts",
      sourceLine: 383,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Cookies.ts#L383"
    },
    {
      id: "Error.TypeId",
      name: "TypeId",
      module: "Error",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type id"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Error.d.ts",
      sourceLine: 11,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Error.ts#L11"
    },
    {
      id: "Error.isPlatformError",
      name: "isPlatformError",
      module: "Error",
      package: "@effect/platform",
      signature: "(u: unknown) => u is PlatformError",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Error.d.ts",
      sourceLine: 21,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Error.ts#L21"
    },
    {
      id: "Error.TypeIdError",
      name: "TypeIdError",
      module: "Error",
      package: "@effect/platform",
      signature: "<const TypeId extends symbol, const Tag extends string>(typeId: TypeId, tag: Tag) => new <A extends Record<string, any>>(args: Simplify<A>) => YieldableError & Record<TypeId, TypeId> & { readonly _tag: Tag; } & Readonly<A>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "error"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Error.d.ts",
      sourceLine: 26,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Error.ts#L26"
    },
    {
      id: "Error.Module",
      name: "Module",
      module: "Error",
      package: "@effect/platform",
      signature: 'Literal<["Clipboard", "Command", "FileSystem", "KeyValueStore", "Path", "Stream", "Terminal"]>',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Models"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Error.d.ts",
      sourceLine: 33,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Error.ts#L33"
    },
    {
      id: "Error.SystemErrorReason",
      name: "SystemErrorReason",
      module: "Error",
      package: "@effect/platform",
      signature: 'Literal<["AlreadyExists", "BadResource", "Busy", "InvalidData", "NotFound", "PermissionDenied", "TimedOut", "UnexpectedEof", "Unknown", "WouldBlock", "WriteZero"]>',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Model"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Error.d.ts",
      sourceLine: 60,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Error.ts#L60"
    },
    {
      id: "Error.PlatformError",
      name: "PlatformError",
      module: "Error",
      package: "@effect/platform",
      signature: "Union<[typeof BadArgument, typeof SystemError]>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Models"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Error.d.ts",
      sourceLine: 100,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Error.ts#L100"
    },
    {
      id: "Etag.toString",
      name: "toString",
      module: "Etag",
      package: "@effect/platform",
      signature: "(self: Etag) => string",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "convertions"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Etag.d.ts",
      sourceLine: 34,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Etag.ts#L34"
    },
    {
      id: "Etag.GeneratorTypeId",
      name: "GeneratorTypeId",
      module: "Etag",
      package: "@effect/platform",
      signature: "typeof GeneratorTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Etag.d.ts",
      sourceLine: 39,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Etag.ts#L39"
    },
    {
      id: "Etag.Generator",
      name: "Generator",
      module: "Etag",
      package: "@effect/platform",
      signature: "Tag<Generator, Generator>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "tags"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Etag.d.ts",
      sourceLine: 58,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Etag.ts#L58"
    },
    {
      id: "Etag.layer",
      name: "layer",
      module: "Etag",
      package: "@effect/platform",
      signature: "Layer<Generator, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "layers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Etag.d.ts",
      sourceLine: 63,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Etag.ts#L63"
    },
    {
      id: "Etag.layerWeak",
      name: "layerWeak",
      module: "Etag",
      package: "@effect/platform",
      signature: "Layer<Generator, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "layers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Etag.d.ts",
      sourceLine: 68,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Etag.ts#L68"
    },
    {
      id: "FetchHttpClient.layer",
      name: "layer",
      module: "FetchHttpClient",
      package: "@effect/platform",
      signature: "Layer<HttpClient, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "layers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/FetchHttpClient.d.ts",
      sourceLine: 25,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/FetchHttpClient.ts#L25"
    },
    {
      id: "Headers.HeadersTypeId",
      name: "HeadersTypeId",
      module: "Headers",
      package: "@effect/platform",
      signature: "typeof HeadersTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Headers.d.ts",
      sourceLine: 14,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Headers.ts#L14"
    },
    {
      id: "Headers.isHeaders",
      name: "isHeaders",
      module: "Headers",
      package: "@effect/platform",
      signature: "(u: unknown) => u is Headers",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Headers.d.ts",
      sourceLine: 24,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Headers.ts#L24"
    },
    {
      id: "Headers.schemaFromSelf",
      name: "schemaFromSelf",
      module: "Headers",
      package: "@effect/platform",
      signature: "Schema<Headers, Headers, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schemas"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Headers.d.ts",
      sourceLine: 37,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Headers.ts#L37"
    },
    {
      id: "Headers.schema",
      name: "schema",
      module: "Headers",
      package: "@effect/platform",
      signature: "Schema<Headers, ReadonlyRecord<string, string>, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schemas"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Headers.d.ts",
      sourceLine: 42,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Headers.ts#L42"
    },
    {
      id: "Headers.empty",
      name: "empty",
      module: "Headers",
      package: "@effect/platform",
      signature: "Headers",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Headers.d.ts",
      sourceLine: 52,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Headers.ts#L52"
    },
    {
      id: "Headers.fromInput",
      name: "fromInput",
      module: "Headers",
      package: "@effect/platform",
      signature: "(input?: Input) => Headers",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Headers.d.ts",
      sourceLine: 57,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Headers.ts#L57"
    },
    {
      id: "Headers.unsafeFromRecord",
      name: "unsafeFromRecord",
      module: "Headers",
      package: "@effect/platform",
      signature: "(input: ReadonlyRecord<string, string>) => Headers",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Headers.d.ts",
      sourceLine: 62,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Headers.ts#L62"
    },
    {
      id: "Headers.has",
      name: "has",
      module: "Headers",
      package: "@effect/platform",
      signature: "{ (key: string): (self: Headers) => boolean; (self: Headers, key: string): boolean; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Headers.d.ts",
      sourceLine: 67,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Headers.ts#L67"
    },
    {
      id: "Headers.get",
      name: "get",
      module: "Headers",
      package: "@effect/platform",
      signature: "{ (key: string): (self: Headers) => Option<string>; (self: Headers, key: string): Option<string>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Headers.d.ts",
      sourceLine: 83,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Headers.ts#L83"
    },
    {
      id: "Headers.set",
      name: "set",
      module: "Headers",
      package: "@effect/platform",
      signature: "{ (key: string, value: string): (self: Headers) => Headers; (self: Headers, key: string, value: string): Headers; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Headers.d.ts",
      sourceLine: 99,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Headers.ts#L99"
    },
    {
      id: "Headers.setAll",
      name: "setAll",
      module: "Headers",
      package: "@effect/platform",
      signature: "{ (headers: Input): (self: Headers) => Headers; (self: Headers, headers: Input): Headers; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Headers.d.ts",
      sourceLine: 115,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Headers.ts#L115"
    },
    {
      id: "Headers.merge",
      name: "merge",
      module: "Headers",
      package: "@effect/platform",
      signature: "{ (headers: Headers): (self: Headers) => Headers; (self: Headers, headers: Headers): Headers; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Headers.d.ts",
      sourceLine: 131,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Headers.ts#L131"
    },
    {
      id: "Headers.remove",
      name: "remove",
      module: "Headers",
      package: "@effect/platform",
      signature: "{ (key: string | RegExp | readonly (string | RegExp)[]): (self: Headers) => Headers; (self: Headers, key: string | RegExp | readonly (string | RegExp)[]): Headers; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Headers.d.ts",
      sourceLine: 147,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Headers.ts#L147"
    },
    {
      id: "Headers.redact",
      name: "redact",
      module: "Headers",
      package: "@effect/platform",
      signature: "{ (key: string | RegExp | readonly (string | RegExp)[]): (self: Headers) => Record<string, string | Redacted<string>>; (self: Headers, key: string | RegExp | readonly (string | RegExp)[]): Record<string, string | Redacted<string>>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Headers.d.ts",
      sourceLine: 163,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Headers.ts#L163"
    },
    {
      id: "Headers.currentRedactedNames",
      name: "currentRedactedNames",
      module: "Headers",
      package: "@effect/platform",
      signature: "FiberRef<readonly (string | RegExp)[]>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiber refs"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Headers.d.ts",
      sourceLine: 179,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Headers.ts#L179"
    },
    {
      id: "KeyValueStore.TypeId",
      name: "TypeId",
      module: "KeyValueStore",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type id"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/KeyValueStore.d.ts",
      sourceLine: 18,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/KeyValueStore.ts#L18"
    },
    {
      id: "KeyValueStore.KeyValueStore",
      name: "KeyValueStore",
      module: "KeyValueStore",
      package: "@effect/platform",
      signature: "Tag<KeyValueStore, KeyValueStore>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "tags"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/KeyValueStore.d.ts",
      sourceLine: 88,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/KeyValueStore.ts#L88"
    },
    {
      id: "KeyValueStore.make",
      name: "make",
      module: "KeyValueStore",
      package: "@effect/platform",
      signature: '(impl: Omit<KeyValueStore, typeof TypeId | "has" | "modify" | "modifyUint8Array" | "isEmpty" | "forSchema"> & Partial<KeyValueStore>) => KeyValueStore',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/KeyValueStore.d.ts",
      sourceLine: 93,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/KeyValueStore.ts#L93"
    },
    {
      id: "KeyValueStore.makeStringOnly",
      name: "makeStringOnly",
      module: "KeyValueStore",
      package: "@effect/platform",
      signature: '(impl: Pick<KeyValueStore, "get" | "remove" | "clear" | "size"> & Partial<Omit<KeyValueStore, "set">> & { readonly set: (key: string, value: string) => Effect<void, PlatformError, never>; }) => KeyValueStore',
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/KeyValueStore.d.ts",
      sourceLine: 98,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/KeyValueStore.ts#L98"
    },
    {
      id: "KeyValueStore.prefix",
      name: "prefix",
      module: "KeyValueStore",
      package: "@effect/platform",
      signature: "{ (prefix: string): <S extends KeyValueStore.AnyStore>(self: S) => S; <S extends KeyValueStore.AnyStore>(self: S, prefix: string): S; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/KeyValueStore.d.ts",
      sourceLine: 105,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/KeyValueStore.ts#L105"
    },
    {
      id: "KeyValueStore.layerMemory",
      name: "layerMemory",
      module: "KeyValueStore",
      package: "@effect/platform",
      signature: "Layer<KeyValueStore, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "layers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/KeyValueStore.d.ts",
      sourceLine: 121,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/KeyValueStore.ts#L121"
    },
    {
      id: "KeyValueStore.layerFileSystem",
      name: "layerFileSystem",
      module: "KeyValueStore",
      package: "@effect/platform",
      signature: "(directory: string) => Layer<KeyValueStore, PlatformError, FileSystem | Path>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "layers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/KeyValueStore.d.ts",
      sourceLine: 126,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/KeyValueStore.ts#L126"
    },
    {
      id: "KeyValueStore.SchemaStoreTypeId",
      name: "SchemaStoreTypeId",
      module: "KeyValueStore",
      package: "@effect/platform",
      signature: "typeof SchemaStoreTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type id"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/KeyValueStore.d.ts",
      sourceLine: 131,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/KeyValueStore.ts#L131"
    },
    {
      id: "KeyValueStore.layerSchema",
      name: "layerSchema",
      module: "KeyValueStore",
      package: "@effect/platform",
      signature: "<A, I, R>(schema: Schema<A, I, R>, tagIdentifier: string) => { readonly tag: Tag<SchemaStore<A, R>, SchemaStore<A, R>>; readonly layer: Layer<SchemaStore<A, R>, never, KeyValueStore>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "layers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/KeyValueStore.d.ts",
      sourceLine: 180,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/KeyValueStore.ts#L180"
    },
    {
      id: "KeyValueStore.layerStorage",
      name: "layerStorage",
      module: "KeyValueStore",
      package: "@effect/platform",
      signature: "(evaluate: LazyArg<Storage>) => Layer<KeyValueStore, never, never>",
      description: "Creates an KeyValueStorage from an instance of the `Storage` api.",
      documentation: "Creates an KeyValueStorage from an instance of the `Storage` api.",
      examples: [],
      tags: [
        "layers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/KeyValueStore.d.ts",
      sourceLine: 192,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/KeyValueStore.ts#L192"
    },
    {
      id: "MsgPack.ErrorTypeId",
      name: "ErrorTypeId",
      module: "MsgPack",
      package: "@effect/platform",
      signature: "typeof ErrorTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "errors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/MsgPack.d.ts",
      sourceLine: 12,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/MsgPack.ts#L12"
    },
    {
      id: "MsgPack.pack",
      name: "pack",
      module: "MsgPack",
      package: "@effect/platform",
      signature: "<IE = never, Done = unknown>() => Channel<Chunk<Uint8Array>, Chunk<unknown>, IE | MsgPackError, IE, Done, Done, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/MsgPack.d.ts",
      sourceLine: 42,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/MsgPack.ts#L42"
    },
    {
      id: "MsgPack.packSchema",
      name: "packSchema",
      module: "MsgPack",
      package: "@effect/platform",
      signature: "<A, I, R>(schema: Schema<A, I, R>) => <IE = never, Done = unknown>() => Channel<Chunk<Uint8Array>, Chunk<A>, MsgPackError | IE | ParseError, IE, Done, Done, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/MsgPack.d.ts",
      sourceLine: 47,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/MsgPack.ts#L47"
    },
    {
      id: "MsgPack.unpack",
      name: "unpack",
      module: "MsgPack",
      package: "@effect/platform",
      signature: "<IE = never, Done = unknown>() => Channel<Chunk<unknown>, Chunk<Uint8Array>, MsgPackError | IE, IE, Done, Done, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/MsgPack.d.ts",
      sourceLine: 52,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/MsgPack.ts#L52"
    },
    {
      id: "MsgPack.unpackSchema",
      name: "unpackSchema",
      module: "MsgPack",
      package: "@effect/platform",
      signature: "<A, I, R>(schema: Schema<A, I, R>) => <IE = never, Done = unknown>() => Channel<Chunk<A>, Chunk<Uint8Array>, MsgPackError | ParseError | IE, IE, Done, Done, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/MsgPack.d.ts",
      sourceLine: 57,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/MsgPack.ts#L57"
    },
    {
      id: "MsgPack.duplex",
      name: "duplex",
      module: "MsgPack",
      package: "@effect/platform",
      signature: "<R, IE, OE, OutDone, InDone>(self: Channel<Chunk<Uint8Array>, Chunk<Uint8Array>, OE, MsgPackError | IE, OutDone, InDone, R>) => Channel<Chunk<unknown>, Chunk<unknown>, MsgPackError | OE, IE, OutDone, InDone, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/MsgPack.d.ts",
      sourceLine: 62,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/MsgPack.ts#L62"
    },
    {
      id: "MsgPack.duplexSchema",
      name: "duplexSchema",
      module: "MsgPack",
      package: "@effect/platform",
      signature: "{ <IA, II, IR, OA, OI, OR>(options: { readonly inputSchema: Schema<IA, II, IR>; readonly outputSchema: Schema<OA, OI, OR>; }): <R, InErr, OutErr, OutDone, InDone>(self: Channel<Chunk<Uint8Array>, Chunk<Uint8Array>, OutErr, MsgPackError | ParseError | InErr, OutDone, InDone, R>) => Channel<Chunk<OA>, Chunk<IA>, MsgPackError | ParseError | OutErr, InErr, OutDone, InDone, IR | OR | R>; <R, InErr, OutErr, OutDone, InDone, IA, II, IR, OA, OI, OR>(self: Channel<Chunk<Uint8Array>, Chunk<Uint8Array>, OutErr, MsgPackError | ParseError | InErr, OutDone, InDone, R>, options: { readonly inputSchema: Schema<IA, II, IR>; readonly outputSchema: Schema<OA, OI, OR>; }): Channel<Chunk<OA>, Chunk<IA>, MsgPackError | ParseError | OutErr, InErr, OutDone, InDone, R | IR | OR>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/MsgPack.d.ts",
      sourceLine: 67,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/MsgPack.ts#L67"
    },
    {
      id: "MsgPack.schema",
      name: "schema",
      module: "MsgPack",
      package: "@effect/platform",
      signature: "<S extends Schema.Schema.Any>(schema: S) => schema<S>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schemas"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/MsgPack.d.ts",
      sourceLine: 95,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/MsgPack.ts#L95"
    },
    {
      id: "Multipart.TypeId",
      name: "TypeId",
      module: "Multipart",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Multipart.d.ts",
      sourceLine: 19,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Multipart.ts#L19"
    },
    {
      id: "Multipart.isPart",
      name: "isPart",
      module: "Multipart",
      package: "@effect/platform",
      signature: "(u: unknown) => u is Part",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Guards"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Multipart.d.ts",
      sourceLine: 57,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Multipart.ts#L57"
    },
    {
      id: "Multipart.isField",
      name: "isField",
      module: "Multipart",
      package: "@effect/platform",
      signature: "(u: unknown) => u is Field",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Guards"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Multipart.d.ts",
      sourceLine: 62,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Multipart.ts#L62"
    },
    {
      id: "Multipart.isFile",
      name: "isFile",
      module: "Multipart",
      package: "@effect/platform",
      signature: "(u: unknown) => u is File",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Guards"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Multipart.d.ts",
      sourceLine: 79,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Multipart.ts#L79"
    },
    {
      id: "Multipart.isPersistedFile",
      name: "isPersistedFile",
      module: "Multipart",
      package: "@effect/platform",
      signature: "(u: unknown) => u is PersistedFile",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Guards"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Multipart.d.ts",
      sourceLine: 95,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Multipart.ts#L95"
    },
    {
      id: "Multipart.ErrorTypeId",
      name: "ErrorTypeId",
      module: "Multipart",
      package: "@effect/platform",
      signature: "typeof ErrorTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Errors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Multipart.d.ts",
      sourceLine: 107,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Multipart.ts#L107"
    },
    {
      id: "Multipart.FileSchema",
      name: "FileSchema",
      module: "Multipart",
      package: "@effect/platform",
      signature: "Schema<PersistedFile, PersistedFile, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Schemas"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Multipart.d.ts",
      sourceLine: 137,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Multipart.ts#L137"
    },
    {
      id: "Multipart.FilesSchema",
      name: "FilesSchema",
      module: "Multipart",
      package: "@effect/platform",
      signature: "Schema<readonly PersistedFile[], readonly PersistedFile[], never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Schemas"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Multipart.d.ts",
      sourceLine: 142,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Multipart.ts#L142"
    },
    {
      id: "Multipart.SingleFileSchema",
      name: "SingleFileSchema",
      module: "Multipart",
      package: "@effect/platform",
      signature: "transform<Schema<readonly PersistedFile[], readonly PersistedFile[], never>, Schema<PersistedFile, PersistedFile, never>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Schemas"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Multipart.d.ts",
      sourceLine: 147,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Multipart.ts#L147"
    },
    {
      id: "Multipart.schemaPersisted",
      name: "schemaPersisted",
      module: "Multipart",
      package: "@effect/platform",
      signature: "<A, I extends Partial<Persisted>, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (persisted: Persisted) => Effect<A, ParseError, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Schemas"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Multipart.d.ts",
      sourceLine: 152,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Multipart.ts#L152"
    },
    {
      id: "Multipart.schemaJson",
      name: "schemaJson",
      module: "Multipart",
      package: "@effect/platform",
      signature: "<A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => { (field: string): (persisted: Persisted) => Effect<A, ParseError, R>; (persisted: Persisted, field: string): Effect<A, ParseError, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Schemas"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Multipart.d.ts",
      sourceLine: 157,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Multipart.ts#L157"
    },
    {
      id: "Multipart.makeConfig",
      name: "makeConfig",
      module: "Multipart",
      package: "@effect/platform",
      signature: "(headers: Record<string, string>) => Effect<MP.BaseConfig, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Config"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Multipart.d.ts",
      sourceLine: 165,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Multipart.ts#L165"
    },
    {
      id: "Multipart.makeChannel",
      name: "makeChannel",
      module: "Multipart",
      package: "@effect/platform",
      signature: "<IE>(headers: Record<string, string>, bufferSize?: number) => Channel<Chunk<Part>, Chunk<Uint8Array>, IE | MultipartError, IE, unknown, unknown, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Parsers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Multipart.d.ts",
      sourceLine: 170,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Multipart.ts#L170"
    },
    {
      id: "Multipart.collectUint8Array",
      name: "collectUint8Array",
      module: "Multipart",
      package: "@effect/platform",
      signature: "Channel<never, Chunk<any>, unknown, unknown, any, unknown, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Multipart.d.ts",
      sourceLine: 174,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Multipart.ts#L174"
    },
    {
      id: "Multipart.toPersisted",
      name: "toPersisted",
      module: "Multipart",
      package: "@effect/platform",
      signature: "(stream: Stream<Part, MultipartError, never>, writeFile?: (path: string, file: File) => Effect<void, MultipartError, FileSystem>) => Effect<Persisted, MultipartError, FileSystem | Path | Scope>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "Conversions"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Multipart.d.ts",
      sourceLine: 179,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Multipart.ts#L179"
    },
    {
      id: "Multipart.withLimits",
      name: "withLimits",
      module: "Multipart",
      package: "@effect/platform",
      signature: "{ (options: { readonly maxParts?: Option<number>; readonly maxFieldSize?: SizeInput; readonly maxFileSize?: Option<SizeInput>; readonly maxTotalSize?: Option<SizeInput>; readonly fieldMimeTypes?: readonly string[]; }): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, options: { readonly maxParts?: Option<number>; readonly maxFieldSize?: SizeInput; readonly maxFileSize?: Option<SizeInput>; readonly maxTotalSize?: Option<SizeInput>; readonly fieldMimeTypes?: readonly string[]; }): Effect<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiber refs"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Multipart.d.ts",
      sourceLine: 184,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Multipart.ts#L184"
    },
    {
      id: "Multipart.withLimitsStream",
      name: "withLimitsStream",
      module: "Multipart",
      package: "@effect/platform",
      signature: "{ (options: { readonly maxParts?: Option<number>; readonly maxFieldSize?: SizeInput; readonly maxFileSize?: Option<SizeInput>; readonly maxTotalSize?: Option<SizeInput>; readonly fieldMimeTypes?: readonly string[]; }): <A, E, R>(stream: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(stream: Stream<A, E, R>, options: { readonly maxParts?: Option<number>; readonly maxFieldSize?: SizeInput; readonly maxFileSize?: Option<SizeInput>; readonly maxTotalSize?: Option<SizeInput>; readonly fieldMimeTypes?: readonly string[]; }): Stream<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiber refs"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Multipart.d.ts",
      sourceLine: 212,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Multipart.ts#L212"
    },
    {
      id: "Multipart.withMaxParts",
      name: "withMaxParts",
      module: "Multipart",
      package: "@effect/platform",
      signature: "{ (count: Option<number>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, count: Option<number>): Effect<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiber refs"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Multipart.d.ts",
      sourceLine: 264,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Multipart.ts#L264"
    },
    {
      id: "Multipart.withMaxFieldSize",
      name: "withMaxFieldSize",
      module: "Multipart",
      package: "@effect/platform",
      signature: "{ (size: SizeInput): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, size: SizeInput): Effect<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiber refs"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Multipart.d.ts",
      sourceLine: 287,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Multipart.ts#L287"
    },
    {
      id: "Multipart.withMaxFileSize",
      name: "withMaxFileSize",
      module: "Multipart",
      package: "@effect/platform",
      signature: "{ (size: Option<SizeInput>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, size: Option<SizeInput>): Effect<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiber refs"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Multipart.d.ts",
      sourceLine: 310,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Multipart.ts#L310"
    },
    {
      id: "Multipart.withFieldMimeTypes",
      name: "withFieldMimeTypes",
      module: "Multipart",
      package: "@effect/platform",
      signature: "{ (mimeTypes: readonly string[]): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, mimeTypes: readonly string[]): Effect<A, E, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiber refs"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Multipart.d.ts",
      sourceLine: 333,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Multipart.ts#L333"
    },
    {
      id: "Ndjson.ErrorTypeId",
      name: "ErrorTypeId",
      module: "Ndjson",
      package: "@effect/platform",
      signature: "typeof ErrorTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Ndjson.d.ts",
      sourceLine: 13,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ndjson.ts#L13"
    },
    {
      id: "Ndjson.packString",
      name: "packString",
      module: "Ndjson",
      package: "@effect/platform",
      signature: "<IE = never, Done = unknown>() => Channel<Chunk<string>, Chunk<unknown>, IE | NdjsonError, IE, Done, Done, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Ndjson.d.ts",
      sourceLine: 59,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ndjson.ts#L59"
    },
    {
      id: "Ndjson.pack",
      name: "pack",
      module: "Ndjson",
      package: "@effect/platform",
      signature: "<IE = never, Done = unknown>() => Channel<Chunk<Uint8Array>, Chunk<unknown>, NdjsonError | IE, IE, Done, Done, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Ndjson.d.ts",
      sourceLine: 64,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ndjson.ts#L64"
    },
    {
      id: "Ndjson.packSchema",
      name: "packSchema",
      module: "Ndjson",
      package: "@effect/platform",
      signature: "<A, I, R>(schema: Schema<A, I, R>) => <IE = never, Done = unknown>() => Channel<Chunk<Uint8Array>, Chunk<A>, NdjsonError | IE | ParseError, IE, Done, Done, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Ndjson.d.ts",
      sourceLine: 69,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ndjson.ts#L69"
    },
    {
      id: "Ndjson.packSchemaString",
      name: "packSchemaString",
      module: "Ndjson",
      package: "@effect/platform",
      signature: "<A, I, R>(schema: Schema<A, I, R>) => <IE = never, Done = unknown>() => Channel<Chunk<string>, Chunk<A>, NdjsonError | ParseError | IE, IE, Done, Done, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Ndjson.d.ts",
      sourceLine: 74,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ndjson.ts#L74"
    },
    {
      id: "Ndjson.unpackString",
      name: "unpackString",
      module: "Ndjson",
      package: "@effect/platform",
      signature: "<IE = never, Done = unknown>(options?: NdjsonOptions) => Channel<Chunk<unknown>, Chunk<string>, NdjsonError | IE, IE, Done, Done, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Ndjson.d.ts",
      sourceLine: 79,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ndjson.ts#L79"
    },
    {
      id: "Ndjson.unpack",
      name: "unpack",
      module: "Ndjson",
      package: "@effect/platform",
      signature: "<IE = never, Done = unknown>(options?: NdjsonOptions) => Channel<Chunk<unknown>, Chunk<Uint8Array>, NdjsonError | IE, IE, Done, Done, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Ndjson.d.ts",
      sourceLine: 84,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ndjson.ts#L84"
    },
    {
      id: "Ndjson.unpackSchema",
      name: "unpackSchema",
      module: "Ndjson",
      package: "@effect/platform",
      signature: "<A, I, R>(schema: Schema<A, I, R>) => <IE = never, Done = unknown>(options?: NdjsonOptions) => Channel<Chunk<A>, Chunk<Uint8Array>, NdjsonError | ParseError | IE, IE, Done, Done, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Ndjson.d.ts",
      sourceLine: 89,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ndjson.ts#L89"
    },
    {
      id: "Ndjson.unpackSchemaString",
      name: "unpackSchemaString",
      module: "Ndjson",
      package: "@effect/platform",
      signature: "<A, I, R>(schema: Schema<A, I, R>) => <IE = never, Done = unknown>(options?: NdjsonOptions) => Channel<Chunk<A>, Chunk<string>, NdjsonError | ParseError | IE, IE, Done, Done, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Ndjson.d.ts",
      sourceLine: 94,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ndjson.ts#L94"
    },
    {
      id: "Ndjson.duplex",
      name: "duplex",
      module: "Ndjson",
      package: "@effect/platform",
      signature: "{ (options?: NdjsonOptions): <R, IE, OE, OutDone, InDone>(self: Channel<Chunk<Uint8Array>, Chunk<Uint8Array>, OE, NdjsonError | IE, OutDone, InDone, R>) => Channel<Chunk<unknown>, Chunk<unknown>, NdjsonError | OE, IE, OutDone, InDone, R>; <R, IE, OE, OutDone, InDone>(self: Channel<Chunk<Uint8Array>, Chunk<Uint8Array>, OE, NdjsonError | IE, OutDone, InDone, R>, options?: NdjsonOptions): Channel<Chunk<unknown>, Chunk<unknown>, NdjsonError | OE, IE, OutDone, InDone, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Ndjson.d.ts",
      sourceLine: 99,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ndjson.ts#L99"
    },
    {
      id: "Ndjson.duplexString",
      name: "duplexString",
      module: "Ndjson",
      package: "@effect/platform",
      signature: "{ (options?: NdjsonOptions): <R, IE, OE, OutDone, InDone>(self: Channel<Chunk<string>, Chunk<string>, OE, NdjsonError | IE, OutDone, InDone, R>) => Channel<Chunk<unknown>, Chunk<unknown>, NdjsonError | OE, IE, OutDone, InDone, R>; <R, IE, OE, OutDone, InDone>(self: Channel<Chunk<string>, Chunk<string>, OE, NdjsonError | IE, OutDone, InDone, R>, options?: NdjsonOptions): Channel<Chunk<unknown>, Chunk<unknown>, NdjsonError | OE, IE, OutDone, InDone, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Ndjson.d.ts",
      sourceLine: 115,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ndjson.ts#L115"
    },
    {
      id: "Ndjson.duplexSchema",
      name: "duplexSchema",
      module: "Ndjson",
      package: "@effect/platform",
      signature: "{ <IA, II, IR, OA, OI, OR>(options: Partial<NdjsonOptions> & { readonly inputSchema: Schema<IA, II, IR>; readonly outputSchema: Schema<OA, OI, OR>; }): <R, InErr, OutErr, OutDone, InDone>(self: Channel<Chunk<Uint8Array>, Chunk<Uint8Array>, OutErr, NdjsonError | ParseError | InErr, OutDone, InDone, R>) => Channel<Chunk<OA>, Chunk<IA>, NdjsonError | ParseError | OutErr, InErr, OutDone, InDone, IR | OR | R>; <R, InErr, OutErr, OutDone, InDone, IA, II, IR, OA, OI, OR>(self: Channel<Chunk<Uint8Array>, Chunk<Uint8Array>, OutErr, NdjsonError | ParseError | InErr, OutDone, InDone, R>, options: Partial<NdjsonOptions> & { readonly inputSchema: Schema<IA, II, IR>; readonly outputSchema: Schema<OA, OI, OR>; }): Channel<Chunk<OA>, Chunk<IA>, NdjsonError | ParseError | OutErr, InErr, OutDone, InDone, R | IR | OR>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Ndjson.d.ts",
      sourceLine: 131,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ndjson.ts#L131"
    },
    {
      id: "Ndjson.duplexSchemaString",
      name: "duplexSchemaString",
      module: "Ndjson",
      package: "@effect/platform",
      signature: "{ <IA, II, IR, OA, OI, OR>(options: Partial<NdjsonOptions> & { readonly inputSchema: Schema<IA, II, IR>; readonly outputSchema: Schema<OA, OI, OR>; }): <R, InErr, OutErr, OutDone, InDone>(self: Channel<Chunk<string>, Chunk<string>, OutErr, NdjsonError | ParseError | InErr, OutDone, InDone, R>) => Channel<Chunk<OA>, Chunk<IA>, NdjsonError | ParseError | OutErr, InErr, OutDone, InDone, IR | OR | R>; <R, InErr, OutErr, OutDone, InDone, IA, II, IR, OA, OI, OR>(self: Channel<Chunk<string>, Chunk<string>, OutErr, NdjsonError | ParseError | InErr, OutDone, InDone, R>, options: Partial<NdjsonOptions> & { readonly inputSchema: Schema<IA, II, IR>; readonly outputSchema: Schema<OA, OI, OR>; }): Channel<Chunk<OA>, Chunk<IA>, NdjsonError | ParseError | OutErr, InErr, OutDone, InDone, R | IR | OR>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Ndjson.d.ts",
      sourceLine: 153,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Ndjson.ts#L153"
    },
    {
      id: "OpenApi.annotations",
      name: "annotations",
      module: "OpenApi",
      package: "@effect/platform",
      signature: "(options: { readonly identifier?: string; readonly title?: string; readonly version?: string; readonly description?: string; readonly license?: OpenAPISpecLicense; readonly summary?: string; readonly deprecated?: boolean; readonly externalDocs?: OpenAPISpecExternalDocs; readonly servers?: readonly OpenAPISpecServer[]; readonly format?: string; readonly override?: Record<string, unknown>; readonly exclude?: boolean; readonly transform?: (openApiSpec: Record<string, any>) => Record<string, any>; }) => Context<never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "annotations"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/OpenApi.d.ts",
      sourceLine: 105,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/OpenApi.ts#L105"
    },
    {
      id: "OpenApi.fromApi",
      name: "fromApi",
      module: "OpenApi",
      package: "@effect/platform",
      signature: "<Id extends string, Groups extends HttpApiGroup.Any, E, R>(api: HttpApi<Id, Groups, E, R>, options?: { readonly additionalPropertiesStrategy?: AdditionalPropertiesStrategy; }) => OpenAPISpec",
      description: "Converts an `HttpApi` instance into an OpenAPI Specification object.",
      documentation: 'Converts an `HttpApi` instance into an OpenAPI Specification object.\n\n**Details**\n\nThis function takes an `HttpApi` instance, which defines a structured API,\nand generates an OpenAPI Specification (`OpenAPISpec`). The resulting spec\nadheres to the OpenAPI 3.1.0 standard and includes detailed metadata such as\npaths, operations, security schemes, and components. The function processes\nthe API\'s annotations, middleware, groups, and endpoints to build a complete\nand accurate representation of the API in OpenAPI format.\n\nThe function also deduplicates schemas, applies transformations, and\nintegrates annotations like descriptions, summaries, external documentation,\nand overrides. Cached results are used for better performance when the same\n`HttpApi` instance is processed multiple times.\n\n**Options**\n\n- `additionalPropertiesStrategy`: Controls the handling of additional properties. Possible values are:\n  - `"strict"`: Disallow additional properties (default behavior).\n  - `"allow"`: Allow additional properties.\n\n**Example**\n\n```ts\nimport { HttpApi, HttpApiEndpoint, HttpApiGroup, OpenApi } from "@effect/platform"\nimport { Schema } from "effect"\n\nconst api = HttpApi.make("api").add(\n  HttpApiGroup.make("group").add(\n    HttpApiEndpoint.get("get", "/items")\n      .addSuccess(Schema.Array(Schema.String))\n  )\n)\n\nconst spec = OpenApi.fromApi(api)\n\nconsole.log(JSON.stringify(spec, null, 2))\n// Output: OpenAPI specification in JSON format\n```',
      examples: [
        {
          code: 'import { HttpApi, HttpApiEndpoint, HttpApiGroup, OpenApi } from "@effect/platform"\nimport { Schema } from "effect"\n\nconst api = HttpApi.make("api").add(\n  HttpApiGroup.make("group").add(\n    HttpApiEndpoint.get("get", "/items")\n      .addSuccess(Schema.Array(Schema.String))\n  )\n)\n\nconst spec = OpenApi.fromApi(api)\n\nconsole.log(JSON.stringify(spec, null, 2))\n// Output: OpenAPI specification in JSON format'
        }
      ],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/OpenApi.d.ts",
      sourceLine: 170,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/OpenApi.ts#L170"
    },
    {
      id: "Path.TypeId",
      name: "TypeId",
      module: "Path",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Path.d.ts",
      sourceLine: 12,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Path.ts#L12"
    },
    {
      id: "Path.Path",
      name: "Path",
      module: "Path",
      package: "@effect/platform",
      signature: "Tag<Path, Path>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "tag"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Path.d.ts",
      sourceLine: 59,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Path.ts#L59"
    },
    {
      id: "Path.layer",
      name: "layer",
      module: "Path",
      package: "@effect/platform",
      signature: "Layer<Path, never, never>",
      description: "An implementation of the Path interface that can be used in all environments\n(including browsers). It uses the POSIX standard for paths.",
      documentation: "An implementation of the Path interface that can be used in all environments\n(including browsers).\n\nIt uses the POSIX standard for paths.",
      examples: [],
      tags: [
        "layer"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Path.d.ts",
      sourceLine: 69,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Path.ts#L69"
    },
    {
      id: "PlatformConfigProvider.fromFileTree",
      name: "fromFileTree",
      module: "PlatformConfigProvider",
      package: "@effect/platform",
      signature: "(options?: { readonly rootDirectory?: string; }) => Effect<ConfigProvider, never, Path | FileSystem>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/PlatformConfigProvider.d.ts",
      sourceLine: 11,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/PlatformConfigProvider.ts#L11"
    },
    {
      id: "PlatformConfigProvider.layerFileTreeAdd",
      name: "layerFileTreeAdd",
      module: "PlatformConfigProvider",
      package: "@effect/platform",
      signature: "(options?: { readonly rootDirectory?: string; }) => Layer<never, never, Path | FileSystem>",
      description: "Add the file tree ConfigProvider to the environment, as a fallback to the current ConfigProvider.",
      documentation: "Add the file tree ConfigProvider to the environment, as a fallback to the current ConfigProvider.",
      examples: [],
      tags: [
        "layers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/PlatformConfigProvider.d.ts",
      sourceLine: 20,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/PlatformConfigProvider.ts#L20"
    },
    {
      id: "PlatformConfigProvider.layerFileTree",
      name: "layerFileTree",
      module: "PlatformConfigProvider",
      package: "@effect/platform",
      signature: "(options?: { readonly rootDirectory?: string; }) => Layer<never, never, Path | FileSystem>",
      description: "Add the file tree ConfigProvider to the environment, replacing the current ConfigProvider.",
      documentation: "Add the file tree ConfigProvider to the environment, replacing the current ConfigProvider.",
      examples: [],
      tags: [
        "layers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/PlatformConfigProvider.d.ts",
      sourceLine: 29,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/PlatformConfigProvider.ts#L29"
    },
    {
      id: "PlatformConfigProvider.fromDotEnv",
      name: "fromDotEnv",
      module: "PlatformConfigProvider",
      package: "@effect/platform",
      signature: "(paths: string) => Effect<ConfigProvider, PlatformError, FileSystem>",
      description: "Create a dotenv ConfigProvider.",
      documentation: "Create a dotenv ConfigProvider.",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/PlatformConfigProvider.d.ts",
      sourceLine: 38,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/PlatformConfigProvider.ts#L38"
    },
    {
      id: "PlatformConfigProvider.layerDotEnvAdd",
      name: "layerDotEnvAdd",
      module: "PlatformConfigProvider",
      package: "@effect/platform",
      signature: "(path: string) => Layer<never, never, FileSystem>",
      description: "Add the dotenv ConfigProvider to the environment, as a fallback to the current ConfigProvider.\nIf the file is not found, a debug log is produced and empty layer is returned.",
      documentation: "Add the dotenv ConfigProvider to the environment, as a fallback to the current ConfigProvider.\nIf the file is not found, a debug log is produced and empty layer is returned.",
      examples: [],
      tags: [
        "layers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/PlatformConfigProvider.d.ts",
      sourceLine: 46,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/PlatformConfigProvider.ts#L46"
    },
    {
      id: "PlatformConfigProvider.layerDotEnv",
      name: "layerDotEnv",
      module: "PlatformConfigProvider",
      package: "@effect/platform",
      signature: "(path: string) => Layer<never, PlatformError, FileSystem>",
      description: "Add the dotenv ConfigProvider to the environment, replacing the current ConfigProvider.",
      documentation: "Add the dotenv ConfigProvider to the environment, replacing the current ConfigProvider.",
      examples: [],
      tags: [
        "layers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/PlatformConfigProvider.d.ts",
      sourceLine: 53,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/PlatformConfigProvider.ts#L53"
    },
    {
      id: "PlatformLogger.toFile",
      name: "toFile",
      module: "PlatformLogger",
      package: "@effect/platform",
      signature: "{ (path: string, options?: OpenFileOptions & { readonly batchWindow?: DurationInput; }): <Message>(self: Logger<Message, string>) => Effect<Logger<Message, void>, PlatformError, Scope | FileSystem>; <Message>(self: Logger<Message, string>, path: string, options?: OpenFileOptions & { readonly batchWindow?: DurationInput; }): Effect<Logger<Message, void>, PlatformError, Scope | FileSystem>; }",
      description: "Create a Logger from another string Logger that writes to the specified file.",
      documentation: 'Create a Logger from another string Logger that writes to the specified file.\n\n**Example**\n\n```ts\nimport { PlatformLogger } from "@effect/platform"\nimport { NodeFileSystem, NodeRuntime } from "@effect/platform-node"\nimport { Effect, Layer, Logger } from "effect"\n\nconst fileLogger = Logger.logfmtLogger.pipe(\n  PlatformLogger.toFile("/tmp/log.txt")\n)\nconst LoggerLive = Logger.replaceScoped(Logger.defaultLogger, fileLogger).pipe(\n  Layer.provide(NodeFileSystem.layer)\n)\n\nEffect.log("a").pipe(\n  Effect.zipRight(Effect.log("b")),\n  Effect.zipRight(Effect.log("c")),\n  Effect.provide(LoggerLive),\n  NodeRuntime.runMain\n)\n```',
      examples: [
        {
          code: 'import { PlatformLogger } from "@effect/platform"\nimport { NodeFileSystem, NodeRuntime } from "@effect/platform-node"\nimport { Effect, Layer, Logger } from "effect"\n\nconst fileLogger = Logger.logfmtLogger.pipe(\n  PlatformLogger.toFile("/tmp/log.txt")\n)\nconst LoggerLive = Logger.replaceScoped(Logger.defaultLogger, fileLogger).pipe(\n  Layer.provide(NodeFileSystem.layer)\n)\n\nEffect.log("a").pipe(\n  Effect.zipRight(Effect.log("b")),\n  Effect.zipRight(Effect.log("c")),\n  Effect.provide(LoggerLive),\n  NodeRuntime.runMain\n)'
        }
      ],
      tags: [],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/PlatformLogger.d.ts",
      sourceLine: 37,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/PlatformLogger.ts#L37"
    },
    {
      id: "Runtime.defaultTeardown",
      name: "defaultTeardown",
      module: "Runtime",
      package: "@effect/platform",
      signature: "Teardown",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "teardown"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Runtime.d.ts",
      sourceLine: 15,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Runtime.ts#L15"
    },
    {
      id: "Runtime.makeRunMain",
      name: "makeRunMain",
      module: "Runtime",
      package: "@effect/platform",
      signature: "(f: <E, A>(options: { readonly fiber: RuntimeFiber<A, E>; readonly teardown: Teardown; }) => void) => RunMain",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Runtime.d.ts",
      sourceLine: 84,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Runtime.ts#L84"
    },
    {
      id: "Socket.TypeId",
      name: "TypeId",
      module: "Socket",
      package: "@effect/platform",
      signature: "typeof TypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Socket.d.ts",
      sourceLine: 16,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Socket.ts#L16"
    },
    {
      id: "Socket.isSocket",
      name: "isSocket",
      module: "Socket",
      package: "@effect/platform",
      signature: "(u: unknown) => u is Socket",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "guards"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Socket.d.ts",
      sourceLine: 26,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Socket.ts#L26"
    },
    {
      id: "Socket.Socket",
      name: "Socket",
      module: "Socket",
      package: "@effect/platform",
      signature: "Tag<Socket, Socket>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "tags"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Socket.d.ts",
      sourceLine: 31,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Socket.ts#L31"
    },
    {
      id: "Socket.CloseEventTypeId",
      name: "CloseEventTypeId",
      module: "Socket",
      package: "@effect/platform",
      signature: "typeof CloseEventTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Socket.d.ts",
      sourceLine: 50,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Socket.ts#L50"
    },
    {
      id: "Socket.isCloseEvent",
      name: "isCloseEvent",
      module: "Socket",
      package: "@effect/platform",
      signature: "(u: unknown) => u is CloseEvent",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Socket.d.ts",
      sourceLine: 77,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Socket.ts#L77"
    },
    {
      id: "Socket.SocketErrorTypeId",
      name: "SocketErrorTypeId",
      module: "Socket",
      package: "@effect/platform",
      signature: "typeof SocketErrorTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Socket.d.ts",
      sourceLine: 82,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Socket.ts#L82"
    },
    {
      id: "Socket.isSocketError",
      name: "isSocketError",
      module: "Socket",
      package: "@effect/platform",
      signature: "(u: unknown) => u is SocketError",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Socket.d.ts",
      sourceLine: 92,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Socket.ts#L92"
    },
    {
      id: "Socket.toChannelMap",
      name: "toChannelMap",
      module: "Socket",
      package: "@effect/platform",
      signature: "<IE, A>(self: Socket, f: (data: string | Uint8Array) => A) => Channel<Chunk<A>, Chunk<string | CloseEvent | Uint8Array>, SocketError | IE, IE, void, unknown, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Socket.d.ts",
      sourceLine: 137,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Socket.ts#L137"
    },
    {
      id: "Socket.toChannel",
      name: "toChannel",
      module: "Socket",
      package: "@effect/platform",
      signature: "<IE>(self: Socket) => Channel<Chunk<Uint8Array>, Chunk<string | CloseEvent | Uint8Array>, SocketError | IE, IE, void, unknown, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Socket.d.ts",
      sourceLine: 142,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Socket.ts#L142"
    },
    {
      id: "Socket.toChannelString",
      name: "toChannelString",
      module: "Socket",
      package: "@effect/platform",
      signature: "{ (encoding?: string): <IE>(self: Socket) => Channel<Chunk<string>, Chunk<string | CloseEvent | Uint8Array>, SocketError | IE, IE, void, unknown, never>; <IE>(self: Socket, encoding?: string): Channel<Chunk<string>, Chunk<string | CloseEvent | Uint8Array>, SocketError | IE, IE, void, unknown, never>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Socket.d.ts",
      sourceLine: 147,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Socket.ts#L147"
    },
    {
      id: "Socket.toChannelWith",
      name: "toChannelWith",
      module: "Socket",
      package: "@effect/platform",
      signature: "<IE = never>() => (self: Socket) => Channel<Chunk<Uint8Array>, Chunk<string | CloseEvent | Uint8Array>, SocketError | IE, IE, void, unknown, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Socket.d.ts",
      sourceLine: 163,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Socket.ts#L163"
    },
    {
      id: "Socket.makeChannel",
      name: "makeChannel",
      module: "Socket",
      package: "@effect/platform",
      signature: "<IE = never>() => Channel<Chunk<Uint8Array>, Chunk<string | CloseEvent | Uint8Array>, SocketError | IE, IE, void, unknown, Socket>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Socket.d.ts",
      sourceLine: 168,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Socket.ts#L168"
    },
    {
      id: "Socket.defaultCloseCodeIsError",
      name: "defaultCloseCodeIsError",
      module: "Socket",
      package: "@effect/platform",
      signature: "(code: number) => boolean",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Socket.d.ts",
      sourceLine: 172,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Socket.ts#L172"
    },
    {
      id: "Socket.WebSocket",
      name: "WebSocket",
      module: "Socket",
      package: "@effect/platform",
      signature: "Tag<WebSocket, WebSocket>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "tags"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Socket.d.ts",
      sourceLine: 184,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Socket.ts#L184"
    },
    {
      id: "Socket.WebSocketConstructor",
      name: "WebSocketConstructor",
      module: "Socket",
      package: "@effect/platform",
      signature: "Tag<WebSocketConstructor, (url: string, protocols?: string | string[]) => WebSocket>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "tags"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Socket.d.ts",
      sourceLine: 196,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Socket.ts#L196"
    },
    {
      id: "Socket.layerWebSocketConstructorGlobal",
      name: "layerWebSocketConstructorGlobal",
      module: "Socket",
      package: "@effect/platform",
      signature: "Layer<WebSocketConstructor, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "layers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Socket.d.ts",
      sourceLine: 201,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Socket.ts#L201"
    },
    {
      id: "Socket.makeWebSocket",
      name: "makeWebSocket",
      module: "Socket",
      package: "@effect/platform",
      signature: "(url: string | Effect<string, never, never>, options?: { readonly closeCodeIsError?: (code: number) => boolean; readonly openTimeout?: DurationInput; readonly protocols?: string | string[]; }) => Effect<Socket, never, WebSocketConstructor>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Socket.d.ts",
      sourceLine: 206,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Socket.ts#L206"
    },
    {
      id: "Socket.fromWebSocket",
      name: "fromWebSocket",
      module: "Socket",
      package: "@effect/platform",
      signature: "<RO>(acquire: Effect<WebSocket, SocketError, RO>, options?: { readonly closeCodeIsError?: (code: number) => boolean; readonly openTimeout?: DurationInput; }) => Effect<Socket, never, Exclude<RO, Scope>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Socket.d.ts",
      sourceLine: 215,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Socket.ts#L215"
    },
    {
      id: "Socket.makeWebSocketChannel",
      name: "makeWebSocketChannel",
      module: "Socket",
      package: "@effect/platform",
      signature: "<IE = never>(url: string, options?: { readonly closeCodeIsError?: (code: number) => boolean; }) => Channel<Chunk<Uint8Array>, Chunk<string | CloseEvent | Uint8Array>, SocketError | IE, IE, void, unknown, WebSocketConstructor>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Socket.d.ts",
      sourceLine: 223,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Socket.ts#L223"
    },
    {
      id: "Socket.layerWebSocket",
      name: "layerWebSocket",
      module: "Socket",
      package: "@effect/platform",
      signature: "(url: string, options?: { readonly closeCodeIsError?: (code: number) => boolean; }) => Layer<Socket, never, WebSocketConstructor>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "layers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Socket.d.ts",
      sourceLine: 230,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Socket.ts#L230"
    },
    {
      id: "Socket.currentSendQueueCapacity",
      name: "currentSendQueueCapacity",
      module: "Socket",
      package: "@effect/platform",
      signature: "FiberRef<number>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "fiber refs"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Socket.d.ts",
      sourceLine: 237,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Socket.ts#L237"
    },
    {
      id: "Socket.fromTransformStream",
      name: "fromTransformStream",
      module: "Socket",
      package: "@effect/platform",
      signature: "<R>(acquire: Effect<InputTransformStream, SocketError, R>, options?: { readonly closeCodeIsError?: (code: number) => boolean; }) => Effect<Socket, never, Exclude<R, Scope>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Socket.d.ts",
      sourceLine: 250,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Socket.ts#L250"
    },
    {
      id: "SocketServer.ErrorTypeId",
      name: "ErrorTypeId",
      module: "SocketServer",
      package: "@effect/platform",
      signature: "typeof ErrorTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "errors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/SocketServer.d.ts",
      sourceLine: 21,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/SocketServer.ts#L21"
    },
    {
      id: "Template.make",
      name: "make",
      module: "Template",
      package: "@effect/platform",
      signature: "<A extends ReadonlyArray<Interpolated>>(strings: TemplateStringsArray, args: A) => Effect<string, Interpolated.Error<A[number]>, Interpolated.Context<A[number]>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Template.d.ts",
      sourceLine: 47,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Template.ts#L47"
    },
    {
      id: "Template.stream",
      name: "stream",
      module: "Template",
      package: "@effect/platform",
      signature: "<A extends ReadonlyArray<InterpolatedWithStream>>(strings: TemplateStringsArray, args: A) => Stream<string, Interpolated.Error<A[number]>, Interpolated.Context<A[number]>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Template.d.ts",
      sourceLine: 52,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Template.ts#L52"
    },
    {
      id: "Terminal.isQuitException",
      name: "isQuitException",
      module: "Terminal",
      package: "@effect/platform",
      signature: "(u: unknown) => u is QuitException",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "refinements"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Terminal.d.ts",
      sourceLine: 87,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Terminal.ts#L87"
    },
    {
      id: "Terminal.Terminal",
      name: "Terminal",
      module: "Terminal",
      package: "@effect/platform",
      signature: "Tag<Terminal, Terminal>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "tag"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Terminal.d.ts",
      sourceLine: 92,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Terminal.ts#L92"
    },
    {
      id: "Transferable.unsafeMakeCollector",
      name: "unsafeMakeCollector",
      module: "Transferable",
      package: "@effect/platform",
      signature: "() => CollectorService",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Transferable.d.ts",
      sourceLine: 30,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Transferable.ts#L30"
    },
    {
      id: "Transferable.makeCollector",
      name: "makeCollector",
      module: "Transferable",
      package: "@effect/platform",
      signature: "Effect<CollectorService, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Transferable.d.ts",
      sourceLine: 35,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Transferable.ts#L35"
    },
    {
      id: "Transferable.addAll",
      name: "addAll",
      module: "Transferable",
      package: "@effect/platform",
      signature: "(tranferables: Iterable<Transferable>) => Effect<void, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "accessors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Transferable.d.ts",
      sourceLine: 40,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Transferable.ts#L40"
    },
    {
      id: "Transferable.schema",
      name: "schema",
      module: "Transferable",
      package: "@effect/platform",
      signature: "{ <I>(f: (_: I) => Iterable<Transferable>): <A, R>(self: Schema<A, I, R>) => Schema<A, I, R>; <A, I, R>(self: Schema<A, I, R>, f: (_: I) => Iterable<Transferable>): Schema<A, I, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schema"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Transferable.d.ts",
      sourceLine: 45,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Transferable.ts#L45"
    },
    {
      id: "Transferable.ImageData",
      name: "ImageData",
      module: "Transferable",
      package: "@effect/platform",
      signature: "Schema<ImageData, ImageData, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schema"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Transferable.d.ts",
      sourceLine: 61,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Transferable.ts#L61"
    },
    {
      id: "Transferable.MessagePort",
      name: "MessagePort",
      module: "Transferable",
      package: "@effect/platform",
      signature: "Schema<MessagePort, MessagePort, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schema"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Transferable.d.ts",
      sourceLine: 66,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Transferable.ts#L66"
    },
    {
      id: "Transferable.Uint8Array",
      name: "Uint8Array",
      module: "Transferable",
      package: "@effect/platform",
      signature: "Schema<Uint8Array, Uint8Array, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schema"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Transferable.d.ts",
      sourceLine: 71,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Transferable.ts#L71"
    },
    {
      id: "Url.fromString",
      name: "fromString",
      module: "Url",
      package: "@effect/platform",
      signature: "(url: string, base?: string | URL) => Either<URL, IllegalArgumentException>",
      description: "Parses a URL string into a `URL` object, returning an `Either` type for safe\nerror handling.",
      documentation: 'Parses a URL string into a `URL` object, returning an `Either` type for safe\nerror handling.\n\n**Details**\n\nThis function converts a string into a `URL` object, enabling safe URL\nparsing with built-in error handling. If the string is invalid or fails to\nparse, this function does not throw an error; instead, it wraps the error in\na `IllegalArgumentException` and returns it as the `Left` value of an\n`Either`. The `Right` value contains the successfully parsed `URL`.\n\nAn optional `base` parameter can be provided to resolve relative URLs. If\nspecified, the function interprets the input `url` as relative to this\n`base`. This is especially useful when dealing with URLs that might not be\nfully qualified.\n\n**Example**\n\n```ts\nimport { Url } from "@effect/platform"\nimport { Either } from "effect"\n\n// Parse an absolute URL\n//\n//      \u250C\u2500\u2500\u2500 Either<URL, IllegalArgumentException>\n//      \u25BC\nconst parsed = Url.fromString("https://example.com/path")\n\nif (Either.isRight(parsed)) {\n  console.log("Parsed URL:", parsed.right.toString())\n} else {\n  console.log("Error:", parsed.left.message)\n}\n// Output: Parsed URL: https://example.com/path\n\n// Parse a relative URL with a base\nconst relativeParsed = Url.fromString("/relative-path", "https://example.com")\n\nif (Either.isRight(relativeParsed)) {\n  console.log("Parsed relative URL:", relativeParsed.right.toString())\n} else {\n  console.log("Error:", relativeParsed.left.message)\n}\n// Output: Parsed relative URL: https://example.com/relative-path\n```',
      examples: [
        {
          code: 'import { Url } from "@effect/platform"\nimport { Either } from "effect"\n\n// Parse an absolute URL\n//\n//      \u250C\u2500\u2500\u2500 Either<URL, IllegalArgumentException>\n//      \u25BC\nconst parsed = Url.fromString("https://example.com/path")\n\nif (Either.isRight(parsed)) {\n  console.log("Parsed URL:", parsed.right.toString())\n} else {\n  console.log("Error:", parsed.left.message)\n}\n// Output: Parsed URL: https://example.com/path\n\n// Parse a relative URL with a base\nconst relativeParsed = Url.fromString("/relative-path", "https://example.com")\n\nif (Either.isRight(relativeParsed)) {\n  console.log("Parsed relative URL:", relativeParsed.right.toString())\n} else {\n  console.log("Error:", relativeParsed.left.message)\n}\n// Output: Parsed relative URL: https://example.com/relative-path'
        }
      ],
      tags: [
        "Constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Url.d.ts",
      sourceLine: 58,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Url.ts#L58"
    },
    {
      id: "Url.mutate",
      name: "mutate",
      module: "Url",
      package: "@effect/platform",
      signature: "{ (f: (url: URL) => void): (self: URL) => URL; (self: URL, f: (url: URL) => void): URL; }",
      description: "This function clones the original `URL` object and applies a callback to the\nclone, allowing multiple updates at once.",
      documentation: 'This function clones the original `URL` object and applies a callback to the\nclone, allowing multiple updates at once.\n\n**Example**\n\n```ts\nimport { Url } from "@effect/platform"\n\nconst myUrl = new URL("https://example.com")\n\nconst mutatedUrl = Url.mutate(myUrl, (url) => {\n  url.username = "user"\n  url.password = "pass"\n})\n\nconsole.log("Mutated:", mutatedUrl.toString())\n// Output: Mutated: https://user:pass@example.com/\n```',
      examples: [
        {
          code: 'import { Url } from "@effect/platform"\n\nconst myUrl = new URL("https://example.com")\n\nconst mutatedUrl = Url.mutate(myUrl, (url) => {\n  url.username = "user"\n  url.password = "pass"\n})\n\nconsole.log("Mutated:", mutatedUrl.toString())\n// Output: Mutated: https://user:pass@example.com/'
        }
      ],
      tags: [
        "Modifiers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Url.d.ts",
      sourceLine: 134,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Url.ts#L134"
    },
    {
      id: "Url.setHash",
      name: "setHash",
      module: "Url",
      package: "@effect/platform",
      signature: "{ (hash: string): (url: URL) => URL; (url: URL, hash: string): URL; }",
      description: "Updates the hash fragment of the URL.",
      documentation: "Updates the hash fragment of the URL.",
      examples: [],
      tags: [
        "Setters"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Url.d.ts",
      sourceLine: 190,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Url.ts#L190"
    },
    {
      id: "Url.setHost",
      name: "setHost",
      module: "Url",
      package: "@effect/platform",
      signature: "{ (host: string): (url: URL) => URL; (url: URL, host: string): URL; }",
      description: "Updates the host (domain and port) of the URL.",
      documentation: "Updates the host (domain and port) of the URL.",
      examples: [],
      tags: [
        "Setters"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Url.d.ts",
      sourceLine: 212,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Url.ts#L212"
    },
    {
      id: "Url.setHostname",
      name: "setHostname",
      module: "Url",
      package: "@effect/platform",
      signature: "{ (hostname: string): (url: URL) => URL; (url: URL, hostname: string): URL; }",
      description: "Updates the domain of the URL without modifying the port.",
      documentation: "Updates the domain of the URL without modifying the port.",
      examples: [],
      tags: [
        "Setters"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Url.d.ts",
      sourceLine: 234,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Url.ts#L234"
    },
    {
      id: "Url.setHref",
      name: "setHref",
      module: "Url",
      package: "@effect/platform",
      signature: "{ (href: string): (url: URL) => URL; (url: URL, href: string): URL; }",
      description: "Replaces the entire URL string.",
      documentation: "Replaces the entire URL string.",
      examples: [],
      tags: [
        "Setters"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Url.d.ts",
      sourceLine: 256,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Url.ts#L256"
    },
    {
      id: "Url.setPassword",
      name: "setPassword",
      module: "Url",
      package: "@effect/platform",
      signature: "{ (password: string | Redacted<string>): (url: URL) => URL; (url: URL, password: string | Redacted<string>): URL; }",
      description: "Updates the password used for authentication.",
      documentation: "Updates the password used for authentication.",
      examples: [],
      tags: [
        "Setters"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Url.d.ts",
      sourceLine: 278,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Url.ts#L278"
    },
    {
      id: "Url.setPathname",
      name: "setPathname",
      module: "Url",
      package: "@effect/platform",
      signature: "{ (pathname: string): (url: URL) => URL; (url: URL, pathname: string): URL; }",
      description: "Updates the path of the URL.",
      documentation: "Updates the path of the URL.",
      examples: [],
      tags: [
        "Setters"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Url.d.ts",
      sourceLine: 300,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Url.ts#L300"
    },
    {
      id: "Url.setPort",
      name: "setPort",
      module: "Url",
      package: "@effect/platform",
      signature: "{ (port: string | number): (url: URL) => URL; (url: URL, port: string | number): URL; }",
      description: "Updates the port of the URL.",
      documentation: "Updates the port of the URL.",
      examples: [],
      tags: [
        "Setters"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Url.d.ts",
      sourceLine: 322,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Url.ts#L322"
    },
    {
      id: "Url.setProtocol",
      name: "setProtocol",
      module: "Url",
      package: "@effect/platform",
      signature: "{ (protocol: string): (url: URL) => URL; (url: URL, protocol: string): URL; }",
      description: "Updates the protocol (e.g., `http`, `https`).",
      documentation: "Updates the protocol (e.g., `http`, `https`).",
      examples: [],
      tags: [
        "Setters"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Url.d.ts",
      sourceLine: 344,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Url.ts#L344"
    },
    {
      id: "Url.setSearch",
      name: "setSearch",
      module: "Url",
      package: "@effect/platform",
      signature: "{ (search: string): (url: URL) => URL; (url: URL, search: string): URL; }",
      description: "Updates the query string of the URL.",
      documentation: "Updates the query string of the URL.",
      examples: [],
      tags: [
        "Setters"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Url.d.ts",
      sourceLine: 366,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Url.ts#L366"
    },
    {
      id: "Url.setUsername",
      name: "setUsername",
      module: "Url",
      package: "@effect/platform",
      signature: "{ (username: string): (url: URL) => URL; (url: URL, username: string): URL; }",
      description: "Updates the username used for authentication.",
      documentation: "Updates the username used for authentication.",
      examples: [],
      tags: [
        "Setters"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Url.d.ts",
      sourceLine: 388,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Url.ts#L388"
    },
    {
      id: "Url.setUrlParams",
      name: "setUrlParams",
      module: "Url",
      package: "@effect/platform",
      signature: "{ (urlParams: UrlParams): (url: URL) => URL; (url: URL, urlParams: UrlParams): URL; }",
      description: "Updates the query parameters of a URL.",
      documentation: 'Updates the query parameters of a URL.\n\n**Details**\n\nThis function allows you to set or replace the query parameters of a `URL`\nobject using the provided `UrlParams`. It creates a new `URL` object with the\nupdated parameters, leaving the original object unchanged.\n\n**Example**\n\n```ts\nimport { Url, UrlParams } from "@effect/platform"\n\nconst myUrl = new URL("https://example.com?foo=bar")\n\n// Write parameters\nconst updatedUrl = Url.setUrlParams(\n  myUrl,\n  UrlParams.fromInput([["key", "value"]])\n)\n\nconsole.log(updatedUrl.toString())\n// Output: https://example.com/?key=value\n```',
      examples: [
        {
          code: 'import { Url, UrlParams } from "@effect/platform"\n\nconst myUrl = new URL("https://example.com?foo=bar")\n\n// Write parameters\nconst updatedUrl = Url.setUrlParams(\n  myUrl,\n  UrlParams.fromInput([["key", "value"]])\n)\n\nconsole.log(updatedUrl.toString())\n// Output: https://example.com/?key=value'
        }
      ],
      tags: [
        "Setters"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Url.d.ts",
      sourceLine: 433,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Url.ts#L433"
    },
    {
      id: "Url.urlParams",
      name: "urlParams",
      module: "Url",
      package: "@effect/platform",
      signature: "(url: URL) => UrlParams",
      description: "Retrieves the query parameters from a URL.",
      documentation: "Retrieves the query parameters from a URL.\n\n**Details**\n\nThis function extracts the query parameters from a `URL` object and returns\nthem as `UrlParams`. The resulting structure can be easily manipulated or\ninspected.\n\n**Example**\n\n```ts\nimport { Url } from \"@effect/platform\"\n\nconst myUrl = new URL(\"https://example.com?foo=bar\")\n\n// Read parameters\nconst params = Url.urlParams(myUrl)\n\nconsole.log(params)\n// Output: [ [ 'foo', 'bar' ] ]\n```",
      examples: [
        {
          code: `import { Url } from "@effect/platform"

const myUrl = new URL("https://example.com?foo=bar")

// Read parameters
const params = Url.urlParams(myUrl)

console.log(params)
// Output: [ [ 'foo', 'bar' ] ]`
        }
      ],
      tags: [
        "Getters"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Url.d.ts",
      sourceLine: 521,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Url.ts#L521"
    },
    {
      id: "Url.modifyUrlParams",
      name: "modifyUrlParams",
      module: "Url",
      package: "@effect/platform",
      signature: "{ (f: (urlParams: UrlParams) => UrlParams): (url: URL) => URL; (url: URL, f: (urlParams: UrlParams) => UrlParams): URL; }",
      description: "Reads, modifies, and updates the query parameters of a URL.",
      documentation: 'Reads, modifies, and updates the query parameters of a URL.\n\n**Details**\n\nThis function provides a functional way to interact with query parameters by\nreading the current parameters, applying a transformation function, and then\nwriting the updated parameters back to the URL. It returns a new `URL` object\nwith the modified parameters, ensuring immutability.\n\n**Example**\n\n```ts\nimport { Url, UrlParams } from "@effect/platform"\n\nconst myUrl = new URL("https://example.com?foo=bar")\n\nconst changedUrl = Url.modifyUrlParams(myUrl, UrlParams.append("key", "value"))\n\nconsole.log(changedUrl.toString())\n// Output: https://example.com/?foo=bar&key=value\n```',
      examples: [
        {
          code: 'import { Url, UrlParams } from "@effect/platform"\n\nconst myUrl = new URL("https://example.com?foo=bar")\n\nconst changedUrl = Url.modifyUrlParams(myUrl, UrlParams.append("key", "value"))\n\nconsole.log(changedUrl.toString())\n// Output: https://example.com/?foo=bar&key=value'
        }
      ],
      tags: [
        "Modifiers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Url.d.ts",
      sourceLine: 548,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Url.ts#L548"
    },
    {
      id: "UrlParams.fromInput",
      name: "fromInput",
      module: "UrlParams",
      package: "@effect/platform",
      signature: "(input: Input) => UrlParams",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/UrlParams.d.ts",
      sourceLine: 38,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/UrlParams.ts#L38"
    },
    {
      id: "UrlParams.schemaFromSelf",
      name: "schemaFromSelf",
      module: "UrlParams",
      package: "@effect/platform",
      signature: "Schema<UrlParams, UrlParams, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schemas"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/UrlParams.d.ts",
      sourceLine: 43,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/UrlParams.ts#L43"
    },
    {
      id: "UrlParams.empty",
      name: "empty",
      module: "UrlParams",
      package: "@effect/platform",
      signature: "UrlParams",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/UrlParams.d.ts",
      sourceLine: 48,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/UrlParams.ts#L48"
    },
    {
      id: "UrlParams.getAll",
      name: "getAll",
      module: "UrlParams",
      package: "@effect/platform",
      signature: "{ (key: string): (self: UrlParams) => readonly string[]; (self: UrlParams, key: string): readonly string[]; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/UrlParams.d.ts",
      sourceLine: 53,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/UrlParams.ts#L53"
    },
    {
      id: "UrlParams.getFirst",
      name: "getFirst",
      module: "UrlParams",
      package: "@effect/platform",
      signature: "{ (key: string): (self: UrlParams) => Option<string>; (self: UrlParams, key: string): Option<string>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/UrlParams.d.ts",
      sourceLine: 69,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/UrlParams.ts#L69"
    },
    {
      id: "UrlParams.getLast",
      name: "getLast",
      module: "UrlParams",
      package: "@effect/platform",
      signature: "{ (key: string): (self: UrlParams) => Option<string>; (self: UrlParams, key: string): Option<string>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/UrlParams.d.ts",
      sourceLine: 85,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/UrlParams.ts#L85"
    },
    {
      id: "UrlParams.set",
      name: "set",
      module: "UrlParams",
      package: "@effect/platform",
      signature: "{ (key: string, value: Coercible): (self: UrlParams) => UrlParams; (self: UrlParams, key: string, value: Coercible): UrlParams; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/UrlParams.d.ts",
      sourceLine: 101,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/UrlParams.ts#L101"
    },
    {
      id: "UrlParams.setAll",
      name: "setAll",
      module: "UrlParams",
      package: "@effect/platform",
      signature: "{ (input: Input): (self: UrlParams) => UrlParams; (self: UrlParams, input: Input): UrlParams; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/UrlParams.d.ts",
      sourceLine: 117,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/UrlParams.ts#L117"
    },
    {
      id: "UrlParams.append",
      name: "append",
      module: "UrlParams",
      package: "@effect/platform",
      signature: "{ (key: string, value: Coercible): (self: UrlParams) => UrlParams; (self: UrlParams, key: string, value: Coercible): UrlParams; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/UrlParams.d.ts",
      sourceLine: 133,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/UrlParams.ts#L133"
    },
    {
      id: "UrlParams.appendAll",
      name: "appendAll",
      module: "UrlParams",
      package: "@effect/platform",
      signature: "{ (input: Input): (self: UrlParams) => UrlParams; (self: UrlParams, input: Input): UrlParams; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/UrlParams.d.ts",
      sourceLine: 149,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/UrlParams.ts#L149"
    },
    {
      id: "UrlParams.remove",
      name: "remove",
      module: "UrlParams",
      package: "@effect/platform",
      signature: "{ (key: string): (self: UrlParams) => UrlParams; (self: UrlParams, key: string): UrlParams; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/UrlParams.d.ts",
      sourceLine: 165,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/UrlParams.ts#L165"
    },
    {
      id: "UrlParams.makeUrl",
      name: "makeUrl",
      module: "UrlParams",
      package: "@effect/platform",
      signature: "(url: string, params: UrlParams, hash: Option<string>) => Either<URL, Error>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/UrlParams.d.ts",
      sourceLine: 181,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/UrlParams.ts#L181"
    },
    {
      id: "UrlParams.toString",
      name: "toString",
      module: "UrlParams",
      package: "@effect/platform",
      signature: "(self: UrlParams) => string",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "conversions"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/UrlParams.d.ts",
      sourceLine: 186,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/UrlParams.ts#L186"
    },
    {
      id: "UrlParams.toRecord",
      name: "toRecord",
      module: "UrlParams",
      package: "@effect/platform",
      signature: "(self: UrlParams) => Record<string, string | [string, ...string[]]>",
      description: "Builds a `Record` containing all the key-value pairs in the given `UrlParams`\nas `string` (if only one value for a key) or a `NonEmptyArray<string>`\n(when more than one value for a key)",
      documentation: 'Builds a `Record` containing all the key-value pairs in the given `UrlParams`\nas `string` (if only one value for a key) or a `NonEmptyArray<string>`\n(when more than one value for a key)\n\n**Example**\n\n```ts\nimport * as assert from "node:assert"\nimport { UrlParams } from "@effect/platform"\n\nconst urlParams = UrlParams.fromInput({ a: 1, b: true, c: "string", e: [1, 2, 3] })\nconst result = UrlParams.toRecord(urlParams)\n\nassert.deepStrictEqual(\n  result,\n  { "a": "1", "b": "true", "c": "string", "e": ["1", "2", "3"] }\n)\n```',
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { UrlParams } from "@effect/platform"\n\nconst urlParams = UrlParams.fromInput({ a: 1, b: true, c: "string", e: [1, 2, 3] })\nconst result = UrlParams.toRecord(urlParams)\n\nassert.deepStrictEqual(\n  result,\n  { "a": "1", "b": "true", "c": "string", "e": ["1", "2", "3"] }\n)'
        }
      ],
      tags: [
        "conversions"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/UrlParams.d.ts",
      sourceLine: 210,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/UrlParams.ts#L210"
    },
    {
      id: "UrlParams.schemaJson",
      name: "schemaJson",
      module: "UrlParams",
      package: "@effect/platform",
      signature: "<A, I, R>(schema: Schema<A, I, R>, options?: ParseOptions) => { (field: string): (self: UrlParams) => Effect<A, ParseError, R>; (self: UrlParams, field: string): Effect<A, ParseError, R>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schema"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/UrlParams.d.ts",
      sourceLine: 215,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/UrlParams.ts#L215"
    },
    {
      id: "UrlParams.schemaStruct",
      name: "schemaStruct",
      module: "UrlParams",
      package: "@effect/platform",
      signature: "<A, I extends Record<string, string | ReadonlyArray<string> | undefined>, R>(schema: Schema<A, I, R>, options?: ParseOptions) => (self: UrlParams) => Effect<A, ParseError, R>",
      description: "Extract schema from all key-value pairs in the given `UrlParams`.",
      documentation: 'Extract schema from all key-value pairs in the given `UrlParams`.\n\n**Example**\n\n```ts\nimport * as assert from "node:assert"\nimport { Effect, Schema } from "effect"\nimport { UrlParams } from "@effect/platform"\n\nEffect.gen(function* () {\n  const urlParams = UrlParams.fromInput({ "a": [10, "string"], "b": false })\n  const result = yield* UrlParams.schemaStruct(Schema.Struct({\n    a: Schema.Tuple(Schema.NumberFromString, Schema.String),\n    b: Schema.BooleanFromString\n  }))(urlParams)\n\n  assert.deepStrictEqual(result, {\n    a: [10, "string"],\n    b: false\n  })\n})\n```',
      examples: [
        {
          code: 'import * as assert from "node:assert"\nimport { Effect, Schema } from "effect"\nimport { UrlParams } from "@effect/platform"\n\nEffect.gen(function* () {\n  const urlParams = UrlParams.fromInput({ "a": [10, "string"], "b": false })\n  const result = yield* UrlParams.schemaStruct(Schema.Struct({\n    a: Schema.Tuple(Schema.NumberFromString, Schema.String),\n    b: Schema.BooleanFromString\n  }))(urlParams)\n\n  assert.deepStrictEqual(result, {\n    a: [10, "string"],\n    b: false\n  })\n})'
        }
      ],
      tags: [
        "schema"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/UrlParams.d.ts",
      sourceLine: 246,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/UrlParams.ts#L246"
    },
    {
      id: "UrlParams.schemaFromString",
      name: "schemaFromString",
      module: "UrlParams",
      package: "@effect/platform",
      signature: "Schema<UrlParams, string, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schema"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/UrlParams.d.ts",
      sourceLine: 251,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/UrlParams.ts#L251"
    },
    {
      id: "UrlParams.schemaRecord",
      name: "schemaRecord",
      module: "UrlParams",
      package: "@effect/platform",
      signature: "<A, I extends Record<string, string | ReadonlyArray<string> | undefined>, R>(schema: Schema<A, I, R>) => Schema<A, UrlParams, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schema"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/UrlParams.d.ts",
      sourceLine: 256,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/UrlParams.ts#L256"
    },
    {
      id: "UrlParams.schemaParse",
      name: "schemaParse",
      module: "UrlParams",
      package: "@effect/platform",
      signature: "<A, I extends Record<string, string | ReadonlyArray<string> | undefined>, R>(schema: Schema<A, I, R>) => Schema<A, string, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "schema"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/UrlParams.d.ts",
      sourceLine: 261,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/UrlParams.ts#L261"
    },
    {
      id: "Worker.PlatformWorkerTypeId",
      name: "PlatformWorkerTypeId",
      module: "Worker",
      package: "@effect/platform",
      signature: "typeof PlatformWorkerTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Worker.d.ts",
      sourceLine: 39,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Worker.ts#L39"
    },
    {
      id: "Worker.makePlatform",
      name: "makePlatform",
      module: "Worker",
      package: "@effect/platform",
      signature: "<W>() => <P extends { readonly postMessage: (message: any, transfers?: any | undefined) => void; }>(options: { readonly setup: (options: { readonly worker: W; readonly scope: Scope; }) => Effect<P, WorkerError, never>; readonly listen: (options: { readonly port: P; readonly emit: (data: any) => void; readonly deferred: Deferred<never, WorkerError>; readonly scope: Scope; }) => Effect<void, never, never>; }) => PlatformWorker",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Worker.d.ts",
      sourceLine: 56,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Worker.ts#L56"
    },
    {
      id: "Worker.PlatformWorker",
      name: "PlatformWorker",
      module: "Worker",
      package: "@effect/platform",
      signature: "Tag<PlatformWorker, PlatformWorker>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "tags"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Worker.d.ts",
      sourceLine: 74,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Worker.ts#L74"
    },
    {
      id: "Worker.Spawner",
      name: "Spawner",
      module: "Worker",
      package: "@effect/platform",
      signature: "Tag<Spawner, SpawnerFn<unknown>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "tags"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Worker.d.ts",
      sourceLine: 95,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Worker.ts#L95"
    },
    {
      id: "Worker.WorkerManagerTypeId",
      name: "WorkerManagerTypeId",
      module: "Worker",
      package: "@effect/platform",
      signature: "typeof WorkerManagerTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Worker.d.ts",
      sourceLine: 169,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Worker.ts#L169"
    },
    {
      id: "Worker.WorkerManager",
      name: "WorkerManager",
      module: "Worker",
      package: "@effect/platform",
      signature: "Tag<WorkerManager, WorkerManager>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "tags"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Worker.d.ts",
      sourceLine: 187,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Worker.ts#L187"
    },
    {
      id: "Worker.makeManager",
      name: "makeManager",
      module: "Worker",
      package: "@effect/platform",
      signature: "Effect<WorkerManager, never, PlatformWorker>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Worker.d.ts",
      sourceLine: 192,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Worker.ts#L192"
    },
    {
      id: "Worker.layerManager",
      name: "layerManager",
      module: "Worker",
      package: "@effect/platform",
      signature: "Layer<WorkerManager, never, PlatformWorker>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "layers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Worker.d.ts",
      sourceLine: 197,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Worker.ts#L197"
    },
    {
      id: "Worker.makePool",
      name: "makePool",
      module: "Worker",
      package: "@effect/platform",
      signature: "<I, O, E>(options: WorkerPool.Options<I>) => Effect<WorkerPool<I, O, E>, WorkerError, Scope | Spawner | WorkerManager>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Worker.d.ts",
      sourceLine: 202,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Worker.ts#L202"
    },
    {
      id: "Worker.makePoolLayer",
      name: "makePoolLayer",
      module: "Worker",
      package: "@effect/platform",
      signature: "<Tag, I, O, E>(tag: Tag<Tag, WorkerPool<I, O, E>>, options: WorkerPool.Options<I>) => Layer<Tag, WorkerError, Spawner | WorkerManager>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Worker.d.ts",
      sourceLine: 207,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Worker.ts#L207"
    },
    {
      id: "Worker.makeSerialized",
      name: "makeSerialized",
      module: "Worker",
      package: "@effect/platform",
      signature: "<I extends Schema.TaggedRequest.All>(options: SerializedWorker.Options<I>) => Effect<SerializedWorker<I>, WorkerError, Scope | Spawner | WorkerManager>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Worker.d.ts",
      sourceLine: 273,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Worker.ts#L273"
    },
    {
      id: "Worker.makePoolSerialized",
      name: "makePoolSerialized",
      module: "Worker",
      package: "@effect/platform",
      signature: "<I extends Schema.TaggedRequest.All>(options: SerializedWorkerPool.Options<I>) => Effect<SerializedWorkerPool<I>, WorkerError, Scope | Spawner | WorkerManager>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Worker.d.ts",
      sourceLine: 278,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Worker.ts#L278"
    },
    {
      id: "Worker.makePoolSerializedLayer",
      name: "makePoolSerializedLayer",
      module: "Worker",
      package: "@effect/platform",
      signature: "<Tag, I extends Schema.TaggedRequest.All>(tag: Tag<Tag, SerializedWorkerPool<I>>, options: SerializedWorkerPool.Options<I>) => Layer<Tag, WorkerError, Spawner | WorkerManager>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "layers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Worker.d.ts",
      sourceLine: 283,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Worker.ts#L283"
    },
    {
      id: "Worker.layerSpawner",
      name: "layerSpawner",
      module: "Worker",
      package: "@effect/platform",
      signature: "<W = unknown>(spawner: SpawnerFn<W>) => Layer<Spawner, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "layers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Worker.d.ts",
      sourceLine: 288,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Worker.ts#L288"
    },
    {
      id: "WorkerError.WorkerErrorTypeId",
      name: "WorkerErrorTypeId",
      module: "WorkerError",
      package: "@effect/platform",
      signature: "typeof WorkerErrorTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/WorkerError.d.ts",
      sourceLine: 10,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/WorkerError.ts#L10"
    },
    {
      id: "WorkerError.isWorkerError",
      name: "isWorkerError",
      module: "WorkerError",
      package: "@effect/platform",
      signature: "(u: unknown) => u is WorkerError",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "predicates"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/WorkerError.d.ts",
      sourceLine: 20,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/WorkerError.ts#L20"
    },
    {
      id: "WorkerRunner.PlatformRunnerTypeId",
      name: "PlatformRunnerTypeId",
      module: "WorkerRunner",
      package: "@effect/platform",
      signature: "typeof PlatformRunnerTypeId",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "type ids"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/WorkerRunner.d.ts",
      sourceLine: 37,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/WorkerRunner.ts#L37"
    },
    {
      id: "WorkerRunner.PlatformRunner",
      name: "PlatformRunner",
      module: "WorkerRunner",
      package: "@effect/platform",
      signature: "Tag<PlatformRunner, PlatformRunner>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "tags"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/WorkerRunner.d.ts",
      sourceLine: 55,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/WorkerRunner.ts#L55"
    },
    {
      id: "WorkerRunner.CloseLatch",
      name: "CloseLatch",
      module: "WorkerRunner",
      package: "@effect/platform",
      signature: "Reference<CloseLatch, Deferred<void, WorkerError>>",
      description: "The worker close latch is used by platform runners to signal that the worker\nhas been closed.",
      documentation: "The worker close latch is used by platform runners to signal that the worker\nhas been closed.",
      examples: [],
      tags: [
        "CloseLatch"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/WorkerRunner.d.ts",
      sourceLine: 73,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/WorkerRunner.ts#L73"
    },
    {
      id: "WorkerRunner.layerCloseLatch",
      name: "layerCloseLatch",
      module: "WorkerRunner",
      package: "@effect/platform",
      signature: "Layer<CloseLatch, never, never>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "CloseLatch"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/WorkerRunner.d.ts",
      sourceLine: 78,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/WorkerRunner.ts#L78"
    },
    {
      id: "WorkerRunner.make",
      name: "make",
      module: "WorkerRunner",
      package: "@effect/platform",
      signature: "<I, E, R, O>(process: (request: I) => Stream<O, E, R> | Effect<O, E, R>, options?: Runner.Options<I, O, E>) => Effect<void, WorkerError, PlatformRunner | R | Scope>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/WorkerRunner.d.ts",
      sourceLine: 98,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/WorkerRunner.ts#L98"
    },
    {
      id: "WorkerRunner.layer",
      name: "layer",
      module: "WorkerRunner",
      package: "@effect/platform",
      signature: "<I, E, R, O>(process: (request: I) => Stream<O, E, R> | Effect<O, E, R>, options?: Runner.Options<I, O, E>) => Layer<never, WorkerError, PlatformRunner | R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "layers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/WorkerRunner.d.ts",
      sourceLine: 103,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/WorkerRunner.ts#L103"
    },
    {
      id: "WorkerRunner.makeSerialized",
      name: "makeSerialized",
      module: "WorkerRunner",
      package: "@effect/platform",
      signature: "<R, I, A extends Schema.TaggedRequest.All, const Handlers extends SerializedRunner.Handlers<A>>(schema: Schema<A, I, R>, handlers: Handlers) => Effect<void, WorkerError, PlatformRunner | Scope | R | SerializedRunner.HandlersContext<Handlers>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/WorkerRunner.d.ts",
      sourceLine: 136,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/WorkerRunner.ts#L136"
    },
    {
      id: "WorkerRunner.layerSerialized",
      name: "layerSerialized",
      module: "WorkerRunner",
      package: "@effect/platform",
      signature: "<R, I, A extends Schema.TaggedRequest.All, const Handlers extends SerializedRunner.Handlers<A>>(schema: Schema<A, I, R>, handlers: Handlers) => Layer<never, WorkerError, PlatformRunner | R | SerializedRunner.HandlersContext<Handlers>>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "layers"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/WorkerRunner.d.ts",
      sourceLine: 141,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/WorkerRunner.ts#L141"
    },
    {
      id: "WorkerRunner.launch",
      name: "launch",
      module: "WorkerRunner",
      package: "@effect/platform",
      signature: "<A, E, R>(layer: Layer<A, E, R>) => Effect<void, WorkerError | E, R>",
      description: "Launch the specified layer, interrupting the fiber when the CloseLatch is\ntriggered.",
      documentation: "Launch the specified layer, interrupting the fiber when the CloseLatch is\ntriggered.",
      examples: [],
      tags: [
        "Execution"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/WorkerRunner.d.ts",
      sourceLine: 149,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/WorkerRunner.ts#L149"
    },
    {
      id: "ChannelSchema.encode",
      name: "encode",
      module: "ChannelSchema",
      package: "@effect/platform",
      signature: "<A, I, R>(schema: Schema<A, I, R>) => <IE = never, Done = unknown>() => Channel<Chunk<I>, Chunk<A>, IE | ParseError, IE, Done, Done, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/ChannelSchema.d.ts",
      sourceLine: 9,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ChannelSchema.ts#L9"
    },
    {
      id: "ChannelSchema.encodeUnknown",
      name: "encodeUnknown",
      module: "ChannelSchema",
      package: "@effect/platform",
      signature: "<A, I, R>(schema: Schema<A, I, R>) => <IE = never, Done = unknown>() => Channel<Chunk<unknown>, Chunk<A>, ParseError | IE, IE, Done, Done, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/ChannelSchema.d.ts",
      sourceLine: 14,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ChannelSchema.ts#L14"
    },
    {
      id: "ChannelSchema.decode",
      name: "decode",
      module: "ChannelSchema",
      package: "@effect/platform",
      signature: "<A, I, R>(schema: Schema<A, I, R>) => <IE = never, Done = unknown>() => Channel<Chunk<A>, Chunk<I>, ParseError | IE, IE, Done, Done, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/ChannelSchema.d.ts",
      sourceLine: 19,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ChannelSchema.ts#L19"
    },
    {
      id: "ChannelSchema.decodeUnknown",
      name: "decodeUnknown",
      module: "ChannelSchema",
      package: "@effect/platform",
      signature: "<A, I, R>(schema: Schema<A, I, R>) => <IE = never, Done = unknown>() => Channel<Chunk<A>, Chunk<any>, ParseError | IE, IE, Done, Done, R>",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "constructors"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/ChannelSchema.d.ts",
      sourceLine: 24,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ChannelSchema.ts#L24"
    },
    {
      id: "ChannelSchema.duplex",
      name: "duplex",
      module: "ChannelSchema",
      package: "@effect/platform",
      signature: "{ <IA, II, IR, OA, OI, OR>(options: { readonly inputSchema: Schema<IA, II, IR>; readonly outputSchema: Schema<OA, OI, OR>; }): <R, InErr, OutErr, OutDone, InDone>(self: Channel<Chunk<OI>, Chunk<II>, OutErr, ParseError | InErr, OutDone, InDone, R>) => Channel<Chunk<OA>, Chunk<IA>, ParseError | OutErr, InErr, OutDone, InDone, IR | OR | R>; <R, InErr, OutErr, OutDone, InDone, IA, II, IR, OA, OI, OR>(self: Channel<Chunk<OI>, Chunk<II>, OutErr, ParseError | InErr, OutDone, InDone, R>, options: { readonly inputSchema: Schema<IA, II, IR>; readonly outputSchema: Schema<OA, OI, OR>; }): Channel<Chunk<OA>, Chunk<IA>, ParseError | OutErr, InErr, OutDone, InDone, R | IR | OR>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/ChannelSchema.d.ts",
      sourceLine: 29,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ChannelSchema.ts#L29"
    },
    {
      id: "ChannelSchema.duplexUnknown",
      name: "duplexUnknown",
      module: "ChannelSchema",
      package: "@effect/platform",
      signature: "{ <IA, II, IR, OA, OI, OR>(options: { readonly inputSchema: Schema<IA, II, IR>; readonly outputSchema: Schema<OA, OI, OR>; }): <R, InErr, OutErr, OutDone, InDone>(self: Channel<Chunk<unknown>, Chunk<any>, OutErr, ParseError | InErr, OutDone, InDone, R>) => Channel<Chunk<OA>, Chunk<IA>, ParseError | OutErr, InErr, OutDone, InDone, IR | OR | R>; <R, InErr, OutErr, OutDone, InDone, IA, II, IR, OA, OI, OR>(self: Channel<Chunk<unknown>, Chunk<any>, OutErr, ParseError | InErr, OutDone, InDone, R>, options: { readonly inputSchema: Schema<IA, II, IR>; readonly outputSchema: Schema<OA, OI, OR>; }): Channel<Chunk<OA>, Chunk<IA>, ParseError | OutErr, InErr, OutDone, InDone, R | IR | OR>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "combinators"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/ChannelSchema.d.ts",
      sourceLine: 51,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/ChannelSchema.ts#L51"
    },
    {
      id: "Effectify.effectify",
      name: "effectify",
      module: "Effectify",
      package: "@effect/platform",
      signature: "{ <F extends (...args: Array<any>) => any>(fn: F): Effectify<F, EffectifyError<F>>; <F extends (...args: Array<any>) => any, E>(fn: F, onError: (error: EffectifyError<F>, args: Parameters<F>) => E): Effectify<F, E>; <F extends (...args: Array<any>) => any, E, E2>(fn: F, onError: (error: EffectifyError<F>, args: Parameters<F>) => E, onSyncError: (error: unknown, args: Parameters<F>) => E2): Effectify<F, E | E2>; }",
      description: "",
      documentation: "",
      examples: [],
      tags: [],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/Effectify.d.ts",
      sourceLine: 219,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Effectify.ts#L219"
    },
    {
      id: "OpenApiJsonSchema.make",
      name: "make",
      module: "OpenApiJsonSchema",
      package: "@effect/platform",
      signature: "<A, I, R>(schema: Schema<A, I, R>) => Root",
      description: "",
      documentation: "",
      examples: [],
      tags: [
        "encoding"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/OpenApiJsonSchema.d.ts",
      sourceLine: 214,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/OpenApiJsonSchema.ts#L214"
    },
    {
      id: "OpenApiJsonSchema.makeWithDefs",
      name: "makeWithDefs",
      module: "OpenApiJsonSchema",
      package: "@effect/platform",
      signature: "<A, I, R>(schema: Schema<A, I, R>, options: { readonly defs: Record<string, any>; readonly defsPath?: string; readonly topLevelReferenceStrategy?: TopLevelReferenceStrategy; readonly additionalPropertiesStrategy?: AdditionalPropertiesStrategy; }) => JsonSchema",
      description: 'Creates a schema with additional options and definitions. Options - `defs`: A record of definitions that are included in the schema.\n- `defsPath`: The path to the definitions within the schema (defaults to "#/$defs/").\n- `topLevelReferenceStrategy`: Controls the handling of the top-level reference. Possible values are:\n  - `"keep"`: Keep the top-level reference (default behavior).\n  - `"skip"`: Skip the top-level reference.\n- `additionalPropertiesStrategy`: Controls the handling of additional properties. Possible values are:\n  - `"strict"`: Disallow additional properties (default behavior).\n  - `"allow"`: Allow additional properties.',
      documentation: 'Creates a schema with additional options and definitions.\n\n**Options**\n\n- `defs`: A record of definitions that are included in the schema.\n- `defsPath`: The path to the definitions within the schema (defaults to "#/$defs/").\n- `topLevelReferenceStrategy`: Controls the handling of the top-level reference. Possible values are:\n  - `"keep"`: Keep the top-level reference (default behavior).\n  - `"skip"`: Skip the top-level reference.\n- `additionalPropertiesStrategy`: Controls the handling of additional properties. Possible values are:\n  - `"strict"`: Disallow additional properties (default behavior).\n  - `"allow"`: Allow additional properties.',
      examples: [],
      tags: [
        "encoding"
      ],
      since: "1.0.0",
      sourceFile: "/Users/benjacobson/conductor/workspaces/hoogle-effect/quito-v1/packages/api/node_modules/@effect/platform/dist/dts/OpenApiJsonSchema.d.ts",
      sourceLine: 234,
      githubUrl: "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/OpenApiJsonSchema.ts#L234"
    }
  ],
  modules: [
    {
      name: "effect",
      package: "effect",
      description: "",
      functionCount: 324,
      path: "effect/effect"
    },
    {
      name: "Effect",
      package: "effect",
      description: "",
      functionCount: 324,
      path: "effect/Effect"
    },
    {
      name: "Stream",
      package: "effect",
      description: "",
      functionCount: 309,
      path: "effect/Stream"
    },
    {
      name: "Option",
      package: "effect",
      description: "",
      functionCount: 55,
      path: "effect/Option"
    },
    {
      name: "Either",
      package: "effect",
      description: "",
      functionCount: 36,
      path: "effect/Either"
    },
    {
      name: "Array",
      package: "effect",
      description: "",
      functionCount: 131,
      path: "effect/Array"
    },
    {
      name: "Ref",
      package: "effect",
      description: "",
      functionCount: 15,
      path: "effect/Ref"
    },
    {
      name: "Queue",
      package: "effect",
      description: "",
      functionCount: 31,
      path: "effect/Queue"
    },
    {
      name: "Schedule",
      package: "effect",
      description: "",
      functionCount: 101,
      path: "effect/Schedule"
    },
    {
      name: "Layer",
      package: "effect",
      description: "",
      functionCount: 85,
      path: "effect/Layer"
    },
    {
      name: "Context",
      package: "effect",
      description: "",
      functionCount: 20,
      path: "effect/Context"
    },
    {
      name: "Scope",
      package: "effect",
      description: "",
      functionCount: 10,
      path: "effect/Scope"
    },
    {
      name: "Fiber",
      package: "effect",
      description: "",
      functionCount: 44,
      path: "effect/Fiber"
    },
    {
      name: "FiberRef",
      package: "effect",
      description: "",
      functionCount: 46,
      path: "effect/FiberRef"
    },
    {
      name: "Runtime",
      package: "effect",
      description: "",
      functionCount: 22,
      path: "effect/Runtime"
    },
    {
      name: "Exit",
      package: "effect",
      description: "",
      functionCount: 34,
      path: "effect/Exit"
    },
    {
      name: "Cause",
      package: "effect",
      description: "",
      functionCount: 71,
      path: "effect/Cause"
    },
    {
      name: "Config",
      package: "effect",
      description: "",
      functionCount: 40,
      path: "effect/Config"
    },
    {
      name: "ConfigProvider",
      package: "effect",
      description: "",
      functionCount: 19,
      path: "effect/ConfigProvider"
    },
    {
      name: "Logger",
      package: "effect",
      description: "",
      functionCount: 41,
      path: "effect/Logger"
    },
    {
      name: "Metric",
      package: "effect",
      description: "",
      functionCount: 45,
      path: "effect/Metric"
    },
    {
      name: "Resource",
      package: "effect",
      description: "",
      functionCount: 5,
      path: "effect/Resource"
    },
    {
      name: "Pool",
      package: "effect",
      description: "",
      functionCount: 6,
      path: "effect/Pool"
    },
    {
      name: "Cache",
      package: "effect",
      description: "",
      functionCount: 6,
      path: "effect/Cache"
    },
    {
      name: "Deferred",
      package: "effect",
      description: "",
      functionCount: 20,
      path: "effect/Deferred"
    },
    {
      name: "PubSub",
      package: "effect",
      description: "",
      functionCount: 14,
      path: "effect/PubSub"
    },
    {
      name: "Chunk",
      package: "effect",
      description: "",
      functionCount: 81,
      path: "effect/Chunk"
    },
    {
      name: "HashMap",
      package: "effect",
      description: "",
      functionCount: 39,
      path: "effect/HashMap"
    },
    {
      name: "HashSet",
      package: "effect",
      description: "",
      functionCount: 26,
      path: "effect/HashSet"
    },
    {
      name: "List",
      package: "effect",
      description: "",
      functionCount: 42,
      path: "effect/List"
    },
    {
      name: "SortedMap",
      package: "effect",
      description: "",
      functionCount: 20,
      path: "effect/SortedMap"
    },
    {
      name: "SortedSet",
      package: "effect",
      description: "",
      functionCount: 22,
      path: "effect/SortedSet"
    },
    {
      name: "Duration",
      package: "effect",
      description: "",
      functionCount: 47,
      path: "effect/Duration"
    },
    {
      name: "DateTime",
      package: "effect",
      description: "",
      functionCount: 90,
      path: "effect/DateTime"
    },
    {
      name: "FileSystem",
      package: "@effect/platform",
      description: "",
      functionCount: 16,
      path: "@effect/platform/FileSystem"
    },
    {
      name: "HttpApi",
      package: "@effect/platform",
      description: "",
      functionCount: 4,
      path: "@effect/platform/HttpApi"
    },
    {
      name: "HttpApiBuilder",
      package: "@effect/platform",
      description: "",
      functionCount: 13,
      path: "@effect/platform/HttpApiBuilder"
    },
    {
      name: "HttpApiClient",
      package: "@effect/platform",
      description: "",
      functionCount: 4,
      path: "@effect/platform/HttpApiClient"
    },
    {
      name: "HttpApiEndpoint",
      package: "@effect/platform",
      description: "",
      functionCount: 10,
      path: "@effect/platform/HttpApiEndpoint"
    },
    {
      name: "HttpApiError",
      package: "@effect/platform",
      description: "",
      functionCount: 1,
      path: "@effect/platform/HttpApiError"
    },
    {
      name: "HttpApiGroup",
      package: "@effect/platform",
      description: "",
      functionCount: 3,
      path: "@effect/platform/HttpApiGroup"
    },
    {
      name: "HttpApiMiddleware",
      package: "@effect/platform",
      description: "",
      functionCount: 4,
      path: "@effect/platform/HttpApiMiddleware"
    },
    {
      name: "HttpApiSchema",
      package: "@effect/platform",
      description: "",
      functionCount: 35,
      path: "@effect/platform/HttpApiSchema"
    },
    {
      name: "HttpApiSecurity",
      package: "@effect/platform",
      description: "",
      functionCount: 6,
      path: "@effect/platform/HttpApiSecurity"
    },
    {
      name: "HttpApiSwagger",
      package: "@effect/platform",
      description: "",
      functionCount: 2,
      path: "@effect/platform/HttpApiSwagger"
    },
    {
      name: "HttpApp",
      package: "@effect/platform",
      description: "",
      functionCount: 11,
      path: "@effect/platform/HttpApp"
    },
    {
      name: "HttpBody",
      package: "@effect/platform",
      description: "",
      functionCount: 18,
      path: "@effect/platform/HttpBody"
    },
    {
      name: "HttpClient",
      package: "@effect/platform",
      description: "",
      functionCount: 40,
      path: "@effect/platform/HttpClient"
    },
    {
      name: "HttpClientError",
      package: "@effect/platform",
      description: "",
      functionCount: 2,
      path: "@effect/platform/HttpClientError"
    },
    {
      name: "HttpClientRequest",
      package: "@effect/platform",
      description: "",
      functionCount: 40,
      path: "@effect/platform/HttpClientRequest"
    },
    {
      name: "HttpClientResponse",
      package: "@effect/platform",
      description: "",
      functionCount: 8,
      path: "@effect/platform/HttpClientResponse"
    },
    {
      name: "HttpIncomingMessage",
      package: "@effect/platform",
      description: "",
      functionCount: 6,
      path: "@effect/platform/HttpIncomingMessage"
    },
    {
      name: "HttpMethod",
      package: "@effect/platform",
      description: "",
      functionCount: 3,
      path: "@effect/platform/HttpMethod"
    },
    {
      name: "HttpMiddleware",
      package: "@effect/platform",
      description: "",
      functionCount: 13,
      path: "@effect/platform/HttpMiddleware"
    },
    {
      name: "HttpMultiplex",
      package: "@effect/platform",
      description: "",
      functionCount: 12,
      path: "@effect/platform/HttpMultiplex"
    },
    {
      name: "HttpPlatform",
      package: "@effect/platform",
      description: "",
      functionCount: 4,
      path: "@effect/platform/HttpPlatform"
    },
    {
      name: "HttpRouter",
      package: "@effect/platform",
      description: "",
      functionCount: 41,
      path: "@effect/platform/HttpRouter"
    },
    {
      name: "HttpServer",
      package: "@effect/platform",
      description: "",
      functionCount: 12,
      path: "@effect/platform/HttpServer"
    },
    {
      name: "HttpServerError",
      package: "@effect/platform",
      description: "",
      functionCount: 6,
      path: "@effect/platform/HttpServerError"
    },
    {
      name: "HttpServerRequest",
      package: "@effect/platform",
      description: "",
      functionCount: 19,
      path: "@effect/platform/HttpServerRequest"
    },
    {
      name: "HttpServerRespondable",
      package: "@effect/platform",
      description: "",
      functionCount: 5,
      path: "@effect/platform/HttpServerRespondable"
    },
    {
      name: "HttpServerResponse",
      package: "@effect/platform",
      description: "",
      functionCount: 32,
      path: "@effect/platform/HttpServerResponse"
    },
    {
      name: "HttpTraceContext",
      package: "@effect/platform",
      description: "",
      functionCount: 5,
      path: "@effect/platform/HttpTraceContext"
    },
    {
      name: "HttpLayerRouter",
      package: "@effect/platform",
      description: "",
      functionCount: 19,
      path: "@effect/platform/HttpLayerRouter"
    },
    {
      name: "Command",
      package: "@effect/platform",
      description: "",
      functionCount: 18,
      path: "@effect/platform/Command"
    },
    {
      name: "CommandExecutor",
      package: "@effect/platform",
      description: "",
      functionCount: 6,
      path: "@effect/platform/CommandExecutor"
    },
    {
      name: "Cookies",
      package: "@effect/platform",
      description: "",
      functionCount: 26,
      path: "@effect/platform/Cookies"
    },
    {
      name: "Error",
      package: "@effect/platform",
      description: "",
      functionCount: 6,
      path: "@effect/platform/Error"
    },
    {
      name: "Etag",
      package: "@effect/platform",
      description: "",
      functionCount: 5,
      path: "@effect/platform/Etag"
    },
    {
      name: "FetchHttpClient",
      package: "@effect/platform",
      description: "",
      functionCount: 1,
      path: "@effect/platform/FetchHttpClient"
    },
    {
      name: "Headers",
      package: "@effect/platform",
      description: "",
      functionCount: 15,
      path: "@effect/platform/Headers"
    },
    {
      name: "KeyValueStore",
      package: "@effect/platform",
      description: "",
      functionCount: 10,
      path: "@effect/platform/KeyValueStore"
    },
    {
      name: "MsgPack",
      package: "@effect/platform",
      description: "",
      functionCount: 8,
      path: "@effect/platform/MsgPack"
    },
    {
      name: "Multipart",
      package: "@effect/platform",
      description: "",
      functionCount: 21,
      path: "@effect/platform/Multipart"
    },
    {
      name: "Ndjson",
      package: "@effect/platform",
      description: "",
      functionCount: 13,
      path: "@effect/platform/Ndjson"
    },
    {
      name: "OpenApi",
      package: "@effect/platform",
      description: "",
      functionCount: 2,
      path: "@effect/platform/OpenApi"
    },
    {
      name: "Path",
      package: "@effect/platform",
      description: "",
      functionCount: 3,
      path: "@effect/platform/Path"
    },
    {
      name: "PlatformConfigProvider",
      package: "@effect/platform",
      description: "",
      functionCount: 6,
      path: "@effect/platform/PlatformConfigProvider"
    },
    {
      name: "PlatformLogger",
      package: "@effect/platform",
      description: "",
      functionCount: 1,
      path: "@effect/platform/PlatformLogger"
    },
    {
      name: "Runtime",
      package: "@effect/platform",
      description: "",
      functionCount: 2,
      path: "@effect/platform/Runtime"
    },
    {
      name: "Socket",
      package: "@effect/platform",
      description: "",
      functionCount: 22,
      path: "@effect/platform/Socket"
    },
    {
      name: "SocketServer",
      package: "@effect/platform",
      description: "",
      functionCount: 1,
      path: "@effect/platform/SocketServer"
    },
    {
      name: "Template",
      package: "@effect/platform",
      description: "",
      functionCount: 2,
      path: "@effect/platform/Template"
    },
    {
      name: "Terminal",
      package: "@effect/platform",
      description: "",
      functionCount: 2,
      path: "@effect/platform/Terminal"
    },
    {
      name: "Transferable",
      package: "@effect/platform",
      description: "",
      functionCount: 7,
      path: "@effect/platform/Transferable"
    },
    {
      name: "Url",
      package: "@effect/platform",
      description: "",
      functionCount: 15,
      path: "@effect/platform/Url"
    },
    {
      name: "UrlParams",
      package: "@effect/platform",
      description: "",
      functionCount: 19,
      path: "@effect/platform/UrlParams"
    },
    {
      name: "Worker",
      package: "@effect/platform",
      description: "",
      functionCount: 14,
      path: "@effect/platform/Worker"
    },
    {
      name: "WorkerError",
      package: "@effect/platform",
      description: "",
      functionCount: 2,
      path: "@effect/platform/WorkerError"
    },
    {
      name: "WorkerRunner",
      package: "@effect/platform",
      description: "",
      functionCount: 9,
      path: "@effect/platform/WorkerRunner"
    },
    {
      name: "ChannelSchema",
      package: "@effect/platform",
      description: "",
      functionCount: 6,
      path: "@effect/platform/ChannelSchema"
    },
    {
      name: "Effectify",
      package: "@effect/platform",
      description: "",
      functionCount: 1,
      path: "@effect/platform/Effectify"
    },
    {
      name: "OpenApiJsonSchema",
      package: "@effect/platform",
      description: "",
      functionCount: 2,
      path: "@effect/platform/OpenApiJsonSchema"
    }
  ]
};

// src/services/search.ts
var fuseInstance = null;
function getIndex() {
  return data_default;
}
__name(getIndex, "getIndex");
function getFuse() {
  if (fuseInstance)
    return fuseInstance;
  const index = getIndex();
  fuseInstance = new Fuse(index.functions, {
    keys: [
      { name: "name", weight: 2 },
      { name: "id", weight: 1.5 },
      { name: "module", weight: 1 },
      { name: "description", weight: 0.8 },
      { name: "signature", weight: 0.5 },
      { name: "tags", weight: 0.7 }
    ],
    threshold: 0.3,
    includeScore: true,
    ignoreLocation: true,
    minMatchCharLength: 2
  });
  return fuseInstance;
}
__name(getFuse, "getFuse");
function searchFunctions(query, options = {}) {
  const trimmed = query.trim();
  if (!trimmed) {
    return [];
  }
  const fuse = getFuse();
  const results = fuse.search(trimmed, { limit: options.limit || 50 });
  return results.map((result) => result.item);
}
__name(searchFunctions, "searchFunctions");
function getFunctionById(id) {
  const index = getIndex();
  return index.functions.find((fn) => fn.id === id);
}
__name(getFunctionById, "getFunctionById");
function getIndexStats() {
  const index = getIndex();
  return {
    totalFunctions: index.functions.length,
    totalModules: index.modules.length,
    effectVersion: index.effectVersion,
    buildDate: index.buildDate
  };
}
__name(getIndexStats, "getIndexStats");

// src/handlers/search.ts
function handleSearch(request) {
  const url = new URL(request.url);
  const query = url.searchParams.get("q") || "";
  const results = query ? searchFunctions(query, { limit: 50 }) : [];
  const stats = getIndexStats();
  const content = `
    <div>
      <div class="mb-6">
        ${SearchBar({ value: query })}
        <div class="mt-3 text-sm text-gray-500">
          ${stats.totalFunctions} functions indexed from Effect ${stats.effectVersion}
        </div>
      </div>
      ${ResultsList({ results, query })}
    </div>
  `;
  const title2 = query ? `"${query}" - Hoogle-Effect` : "Hoogle-Effect";
  const html = Layout({ title: title2, children: content });
  return new Response(html, {
    headers: {
      "Content-Type": "text/html; charset=utf-8",
      "Cache-Control": "public, max-age=60"
    }
  });
}
__name(handleSearch, "handleSearch");
function handleSearchFragment(request) {
  const url = new URL(request.url);
  const query = url.searchParams.get("q") || "";
  const results = query ? searchFunctions(query, { limit: 50 }) : [];
  const html = ResultsList({ results, query });
  return new Response(html, {
    headers: {
      "Content-Type": "text/html; charset=utf-8",
      "Cache-Control": "public, max-age=60"
    }
  });
}
__name(handleSearchFragment, "handleSearchFragment");

// src/components/CodeBlock.ts
function escapeHtml5(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
}
__name(escapeHtml5, "escapeHtml");
function CodeBlock({ code }) {
  const escapedCode = escapeHtml5(code);
  const dataCode = escapeHtml5(code);
  return `
    <div class="relative group">
      <pre class="bg-gray-900 rounded-lg p-4 overflow-x-auto">
        <code class="text-sm text-gray-100 font-mono whitespace-pre">${escapedCode}</code>
      </pre>
      <button
        type="button"
        data-copy="${dataCode}"
        class="absolute top-2 right-2 px-2 py-1 text-xs bg-gray-700 text-gray-300 rounded opacity-0 group-hover:opacity-100 transition-opacity hover:bg-gray-600 copy-btn"
      >
        Copy
      </button>
    </div>
  `;
}
__name(CodeBlock, "CodeBlock");

// src/components/FunctionDetail.ts
function escapeHtml6(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}
__name(escapeHtml6, "escapeHtml");
var GitHubIcon2 = /* @__PURE__ */ __name(() => `
  <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
    <path fill-rule="evenodd" clip-rule="evenodd" d="M12 2C6.477 2 2 6.477 2 12c0 4.42 2.865 8.17 6.839 9.49.5.092.682-.217.682-.482 0-.237-.008-.866-.013-1.7-2.782.604-3.369-1.34-3.369-1.34-.454-1.156-1.11-1.464-1.11-1.464-.908-.62.069-.608.069-.608 1.003.07 1.531 1.03 1.531 1.03.892 1.529 2.341 1.087 2.91.831.092-.646.35-1.086.636-1.336-2.22-.253-4.555-1.11-4.555-4.943 0-1.091.39-1.984 1.029-2.683-.103-.253-.446-1.27.098-2.647 0 0 .84-.269 2.75 1.025A9.578 9.578 0 0112 6.836c.85.004 1.705.114 2.504.336 1.909-1.294 2.747-1.025 2.747-1.025.546 1.377.203 2.394.1 2.647.64.699 1.028 1.592 1.028 2.683 0 3.842-2.339 4.687-4.566 4.935.359.309.678.919.678 1.852 0 1.336-.012 2.415-.012 2.743 0 .267.18.578.688.48C19.138 20.167 22 16.418 22 12c0-5.523-4.477-10-10-10z" />
  </svg>
`, "GitHubIcon");
function FunctionDetail({ func }) {
  const importStatement = `import { ${func.module} } from "${func.package}"`;
  const tagsHtml = func.tags.map((tag) => `<span class="text-xs px-2 py-1 bg-purple-100 text-purple-700 rounded-full">${escapeHtml6(tag)}</span>`).join("\n");
  const sinceTag = func.since ? `<span class="text-xs px-2 py-1 bg-gray-100 text-gray-600 rounded-full">since v${escapeHtml6(func.since)}</span>` : "";
  const deprecatedTag = func.deprecated ? `<span class="text-xs px-2 py-1 bg-red-100 text-red-700 rounded-full">deprecated</span>` : "";
  const examplesHtml = func.examples.length > 0 ? `
        <div class="p-6 border-b border-gray-100">
          <h3 class="text-sm font-semibold text-gray-500 uppercase tracking-wide mb-3">
            Examples
          </h3>
          <div class="space-y-4">
            ${func.examples.map(
    (example) => `
                <div>
                  ${example.title ? `<p class="text-sm font-medium text-gray-700 mb-2">${escapeHtml6(example.title)}</p>` : ""}
                  ${CodeBlock({ code: example.code })}
                </div>
              `
  ).join("\n")}
          </div>
        </div>
      ` : "";
  const sourceHtml = func.githubUrl ? `
      <div class="p-6 bg-gray-50">
        <h3 class="text-sm font-semibold text-gray-500 uppercase tracking-wide mb-3">
          Source
        </h3>
        <a
          href="${escapeHtml6(func.githubUrl)}"
          target="_blank"
          rel="noopener noreferrer"
          class="inline-flex items-center gap-2 text-sm text-purple-600 hover:text-purple-800 transition-colors"
        >
          ${GitHubIcon2()}
          View on GitHub
        </a>
      </div>
    ` : "";
  return `
    <div class="bg-white rounded-lg border border-gray-200 overflow-hidden">
      <!-- Header -->
      <div class="p-6 border-b border-gray-100 bg-gray-50">
        <div class="flex items-center gap-2 mb-2">
          <a href="/" class="text-gray-400 hover:text-purple-600 transition-colors">
            &larr; Back
          </a>
        </div>
        <div class="flex items-center gap-2 mb-2">
          <span class="text-lg text-gray-600">${escapeHtml6(func.module)}</span>
          <span class="text-gray-400">.</span>
          <span class="text-xl font-bold text-purple-600">${escapeHtml6(func.name)}</span>
        </div>

        <div class="flex flex-wrap gap-2 mb-4">
          ${tagsHtml}
          ${sinceTag}
          ${deprecatedTag}
        </div>

        <!-- Type signature -->
        <div class="bg-gray-900 rounded-lg p-4 overflow-x-auto">
          ${SignatureDisplay({ signature: func.signature })}
        </div>
      </div>

      <!-- Description -->
      <div class="p-6 border-b border-gray-100">
        <h3 class="text-sm font-semibold text-gray-500 uppercase tracking-wide mb-3">
          Description
        </h3>
        <p class="text-gray-700 leading-relaxed">
          ${escapeHtml6(func.description || "No description available.")}
        </p>
      </div>

      ${examplesHtml}

      <!-- Import -->
      <div class="p-6 bg-gray-50 border-b border-gray-100">
        <h3 class="text-sm font-semibold text-gray-500 uppercase tracking-wide mb-3">
          Import
        </h3>
        <div class="flex items-center gap-2">
          <code class="flex-1 text-sm bg-gray-100 px-3 py-2 rounded font-mono text-gray-700">
            ${escapeHtml6(importStatement)}
          </code>
          <button
            type="button"
            data-copy="${escapeHtml6(importStatement)}"
            class="px-3 py-2 text-sm bg-purple-100 text-purple-700 rounded hover:bg-purple-200 transition-colors copy-btn"
          >
            Copy
          </button>
        </div>
      </div>

      ${sourceHtml}
    </div>
  `;
}
__name(FunctionDetail, "FunctionDetail");

// src/handlers/function-detail.ts
function escapeHtml7(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}
__name(escapeHtml7, "escapeHtml");
function handleFunctionDetail(request) {
  const url = new URL(request.url);
  const path = url.pathname;
  const id = decodeURIComponent(path.replace("/function/", ""));
  if (!id) {
    return new Response("Function ID required", {
      status: 400,
      headers: { "Content-Type": "text/plain" }
    });
  }
  const func = getFunctionById(id);
  if (!func) {
    const notFoundContent = `
      <div class="bg-white rounded-lg border border-gray-200 p-8 text-center">
        <p class="text-gray-500 mb-4">Function "${escapeHtml7(id)}" not found</p>
        <a href="/" class="text-purple-600 hover:underline">
          &larr; Back to search
        </a>
      </div>
    `;
    const html2 = Layout({
      title: "Function Not Found - Hoogle-Effect",
      children: notFoundContent
    });
    return new Response(html2, {
      status: 404,
      headers: { "Content-Type": "text/html; charset=utf-8" }
    });
  }
  const title2 = `${func.module}.${func.name} - Hoogle-Effect`;
  const html = Layout({ title: title2, children: FunctionDetail({ func }) });
  return new Response(html, {
    headers: {
      "Content-Type": "text/html; charset=utf-8",
      "Cache-Control": "public, max-age=3600"
    }
  });
}
__name(handleFunctionDetail, "handleFunctionDetail");

// src/handlers/api.ts
function handleApiSearch(request) {
  const url = new URL(request.url);
  const query = url.searchParams.get("q") || "";
  const limitParam = url.searchParams.get("limit");
  const limit = limitParam ? parseInt(limitParam, 10) : 50;
  if (!query) {
    const stats = getIndexStats();
    return new Response(JSON.stringify(stats), {
      headers: {
        "Content-Type": "application/json",
        "Cache-Control": "public, max-age=3600"
      }
    });
  }
  const results = searchFunctions(query, { limit });
  return new Response(JSON.stringify({ query, results }), {
    headers: {
      "Content-Type": "application/json",
      "Cache-Control": "public, max-age=60"
    }
  });
}
__name(handleApiSearch, "handleApiSearch");

// src/index.ts
var src_default = {
  async fetch(request, _env) {
    const url = new URL(request.url);
    const path = url.pathname;
    try {
      if (path === "/api/search") {
        return handleApiSearch(request);
      }
      if (path === "/") {
        const wantsFragment = request.headers.get("HX-Request") === "true" || request.headers.get("Accept")?.includes("text/html-partial");
        if (wantsFragment) {
          return handleSearchFragment(request);
        }
        return handleSearch(request);
      }
      if (path.startsWith("/function/")) {
        return handleFunctionDetail(request);
      }
      return new Response("Not Found", {
        status: 404,
        headers: { "Content-Type": "text/plain" }
      });
    } catch (error3) {
      console.error("Worker error:", error3);
      return new Response("Internal Server Error", {
        status: 500,
        headers: { "Content-Type": "text/plain" }
      });
    }
  }
};

// ../../node_modules/.pnpm/wrangler@3.114.16_@cloudflare+workers-types@4.20260108.0/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
var drainBody = /* @__PURE__ */ __name(async (request, env2, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env2);
  } finally {
    try {
      if (request.body !== null && !request.bodyUsed) {
        const reader = request.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e) {
      console.error("Failed to drain the unused request body.", e);
    }
  }
}, "drainBody");
var middleware_ensure_req_body_drained_default = drainBody;

// ../../node_modules/.pnpm/wrangler@3.114.16_@cloudflare+workers-types@4.20260108.0/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
function reduceError(e) {
  return {
    name: e?.name,
    message: e?.message ?? String(e),
    stack: e?.stack,
    cause: e?.cause === void 0 ? void 0 : reduceError(e.cause)
  };
}
__name(reduceError, "reduceError");
var jsonError = /* @__PURE__ */ __name(async (request, env2, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env2);
  } catch (e) {
    const error3 = reduceError(e);
    return Response.json(error3, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
}, "jsonError");
var middleware_miniflare3_json_error_default = jsonError;

// .wrangler/tmp/bundle-89CmXI/middleware-insertion-facade.js
var __INTERNAL_WRANGLER_MIDDLEWARE__ = [
  middleware_ensure_req_body_drained_default,
  middleware_miniflare3_json_error_default
];
var middleware_insertion_facade_default = src_default;

// ../../node_modules/.pnpm/wrangler@3.114.16_@cloudflare+workers-types@4.20260108.0/node_modules/wrangler/templates/middleware/common.ts
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
__name(__facade_register__, "__facade_register__");
function __facade_invokeChain__(request, env2, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request, env2, ctx, middlewareCtx);
}
__name(__facade_invokeChain__, "__facade_invokeChain__");
function __facade_invoke__(request, env2, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request, env2, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}
__name(__facade_invoke__, "__facade_invoke__");

// .wrangler/tmp/bundle-89CmXI/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof __Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
__name(__Facade_ScheduledController__, "__Facade_ScheduledController__");
function wrapExportedHandler(worker) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return worker;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  const fetchDispatcher = /* @__PURE__ */ __name(function(request, env2, ctx) {
    if (worker.fetch === void 0) {
      throw new Error("Handler does not export a fetch() function.");
    }
    return worker.fetch(request, env2, ctx);
  }, "fetchDispatcher");
  return {
    ...worker,
    fetch(request, env2, ctx) {
      const dispatcher = /* @__PURE__ */ __name(function(type, init) {
        if (type === "scheduled" && worker.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init.cron ?? "",
            () => {
            }
          );
          return worker.scheduled(controller, env2, ctx);
        }
      }, "dispatcher");
      return __facade_invoke__(request, env2, ctx, dispatcher, fetchDispatcher);
    }
  };
}
__name(wrapExportedHandler, "wrapExportedHandler");
function wrapWorkerEntrypoint(klass) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return klass;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  return class extends klass {
    #fetchDispatcher = (request, env2, ctx) => {
      this.env = env2;
      this.ctx = ctx;
      if (super.fetch === void 0) {
        throw new Error("Entrypoint class does not define a fetch() function.");
      }
      return super.fetch(request);
    };
    #dispatcher = (type, init) => {
      if (type === "scheduled" && super.scheduled !== void 0) {
        const controller = new __Facade_ScheduledController__(
          Date.now(),
          init.cron ?? "",
          () => {
          }
        );
        return super.scheduled(controller);
      }
    };
    fetch(request) {
      return __facade_invoke__(
        request,
        this.env,
        this.ctx,
        this.#dispatcher,
        this.#fetchDispatcher
      );
    }
  };
}
__name(wrapWorkerEntrypoint, "wrapWorkerEntrypoint");
var WRAPPED_ENTRY;
if (typeof middleware_insertion_facade_default === "object") {
  WRAPPED_ENTRY = wrapExportedHandler(middleware_insertion_facade_default);
} else if (typeof middleware_insertion_facade_default === "function") {
  WRAPPED_ENTRY = wrapWorkerEntrypoint(middleware_insertion_facade_default);
}
var middleware_loader_entry_default = WRAPPED_ENTRY;
export {
  __INTERNAL_WRANGLER_MIDDLEWARE__,
  middleware_loader_entry_default as default
};
//# sourceMappingURL=index.js.map
