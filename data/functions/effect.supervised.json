{
  "id": "Effect.supervised",
  "name": "supervised",
  "module": "Effect",
  "package": "effect",
  "signature": "{ <X>(supervisor: Supervisor<X>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, X>(self: Effect<A, E, R>, supervisor: Supervisor<X>): Effect<A, E, R>; }",
  "description": "Supervises child fibers by reporting them to a specified supervisor.\n*Details This function takes a supervisor as an argument and returns an effect where\nall child fibers forked within it are supervised by the provided supervisor.\nThis enables you to capture detailed information about these child fibers,\nsuch as their status, through the supervisor.\n*Example (Monitoring Fiber Count)",
  "documentation": "Supervises child fibers by reporting them to a specified supervisor.\n*Details**\n\nThis function takes a supervisor as an argument and returns an effect where\nall child fibers forked within it are supervised by the provided supervisor.\nThis enables you to capture detailed information about these child fibers,\nsuch as their status, through the supervisor.\n*Example** (Monitoring Fiber Count)\n\n```ts\nimport { Effect, Supervisor, Schedule, Fiber, FiberStatus } from \"effect\"\n\n// Main program that monitors fibers while calculating a Fibonacci number\nconst program = Effect.gen(function* () {\n// Create a supervisor to track child fibers\nconst supervisor = yield* Supervisor.track\n\n// Start a Fibonacci calculation, supervised by the supervisor\nconst fibFiber = yield* fib(20).pipe(\nEffect.supervised(supervisor),\n// Fork the Fibonacci effect into a fiber\nEffect.fork\n)\n\n// Define a schedule to periodically monitor the fiber count every 500ms\nconst policy = Schedule.spaced(\"500 millis\").pipe(\nSchedule.whileInputEffect((_) =>\nFiber.status(fibFiber).pipe(\n// Continue while the Fibonacci fiber is not done\nEffect.andThen((status) => status !== FiberStatus.done)\n)\n)\n)\n\n// Start monitoring the fibers, using the supervisor to track the count\nconst monitorFiber = yield* monitorFibers(supervisor).pipe(\n// Repeat the monitoring according to the schedule\nEffect.repeat(policy),\n// Fork the monitoring into its own fiber\nEffect.fork\n)\n\n// Join the monitor and Fibonacci fibers to ensure they complete\nyield* Fiber.join(monitorFiber)\nconst result = yield* Fiber.join(fibFiber)\n\nconsole.log(`fibonacci result: ${result}`)\n})\n\n// Function to monitor and log the number of active fibers\nconst monitorFibers = (\nsupervisor: Supervisor.Supervisor<Array<Fiber.RuntimeFiber<any, any>>>\n): Effect.Effect<void> =>\nEffect.gen(function* () {\nconst fibers = yield* supervisor.value // Get the current set of fibers\nconsole.log(`number of fibers: ${fibers.length}`)\n})\n\n// Recursive Fibonacci calculation, spawning fibers for each recursive step\nconst fib = (n: number): Effect.Effect<number> =>\nEffect.gen(function* () {\nif (n <= 1) {\nreturn 1\n}\nyield* Effect.sleep(\"500 millis\") // Simulate work by delaying\n\n// Fork two fibers for the recursive Fibonacci calls\nconst fiber1 = yield* Effect.fork(fib(n - 2))\nconst fiber2 = yield* Effect.fork(fib(n - 1))\n\n// Join the fibers to retrieve their results\nconst v1 = yield* Fiber.join(fiber1)\nconst v2 = yield* Fiber.join(fiber2)\n\nreturn v1 + v2 // Combine the results\n})\n\nEffect.runPromise(program)\n// Output:\n// number of fibers: 0\n// number of fibers: 2\n// number of fibers: 6\n// number of fibers: 14\n// number of fibers: 30\n// number of fibers: 62\n// number of fibers: 126\n// number of fibers: 254\n// number of fibers: 510\n// number of fibers: 1022\n// number of fibers: 2034\n// number of fibers: 3795\n// number of fibers: 5810\n// number of fibers: 6474\n// number of fibers: 4942\n// number of fibers: 2515\n// number of fibers: 832\n// number of fibers: 170\n// number of fibers: 18\n// number of fibers: 0\n// fibonacci result: 10946\n```",
  "examples": [
    {
      "code": "import { Effect, Supervisor, Schedule, Fiber, FiberStatus } from \"effect\"\n\n// Main program that monitors fibers while calculating a Fibonacci number\nconst program = Effect.gen(function* () {\n// Create a supervisor to track child fibers\nconst supervisor = yield* Supervisor.track\n\n// Start a Fibonacci calculation, supervised by the supervisor\nconst fibFiber = yield* fib(20).pipe(\nEffect.supervised(supervisor),\n// Fork the Fibonacci effect into a fiber\nEffect.fork\n)\n\n// Define a schedule to periodically monitor the fiber count every 500ms\nconst policy = Schedule.spaced(\"500 millis\").pipe(\nSchedule.whileInputEffect((_) =>\nFiber.status(fibFiber).pipe(\n// Continue while the Fibonacci fiber is not done\nEffect.andThen((status) => status !== FiberStatus.done)\n)\n)\n)\n\n// Start monitoring the fibers, using the supervisor to track the count\nconst monitorFiber = yield* monitorFibers(supervisor).pipe(\n// Repeat the monitoring according to the schedule\nEffect.repeat(policy),\n// Fork the monitoring into its own fiber\nEffect.fork\n)\n\n// Join the monitor and Fibonacci fibers to ensure they complete\nyield* Fiber.join(monitorFiber)\nconst result = yield* Fiber.join(fibFiber)\n\nconsole.log(`fibonacci result: ${result}`)\n})\n\n// Function to monitor and log the number of active fibers\nconst monitorFibers = (\nsupervisor: Supervisor.Supervisor<Array<Fiber.RuntimeFiber<any, any>>>\n): Effect.Effect<void> =>\nEffect.gen(function* () {\nconst fibers = yield* supervisor.value // Get the current set of fibers\nconsole.log(`number of fibers: ${fibers.length}`)\n})\n\n// Recursive Fibonacci calculation, spawning fibers for each recursive step\nconst fib = (n: number): Effect.Effect<number> =>\nEffect.gen(function* () {\nif (n <= 1) {\nreturn 1\n}\nyield* Effect.sleep(\"500 millis\") // Simulate work by delaying\n\n// Fork two fibers for the recursive Fibonacci calls\nconst fiber1 = yield* Effect.fork(fib(n - 2))\nconst fiber2 = yield* Effect.fork(fib(n - 1))\n\n// Join the fibers to retrieve their results\nconst v1 = yield* Fiber.join(fiber1)\nconst v2 = yield* Fiber.join(fiber2)\n\nreturn v1 + v2 // Combine the results\n})\n\nEffect.runPromise(program)\n// Output:\n// number of fibers: 0\n// number of fibers: 2\n// number of fibers: 6\n// number of fibers: 14\n// number of fibers: 30\n// number of fibers: 62\n// number of fibers: 126\n// number of fibers: 254\n// number of fibers: 510\n// number of fibers: 1022\n// number of fibers: 2034\n// number of fibers: 3795\n// number of fibers: 5810\n// number of fibers: 6474\n// number of fibers: 4942\n// number of fibers: 2515\n// number of fibers: 832\n// number of fibers: 170\n// number of fibers: 18\n// number of fibers: 0\n// fibonacci result: 10946"
    }
  ],
  "tags": [
    "Supervision & Fibers"
  ],
  "since": "2.0.0",
  "sourceFile": "/Users/benjacobson/conductor/workspaces/hoogle-effect/san-juan-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
  "sourceLine": 11870,
  "githubUrl": "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L11870"
}