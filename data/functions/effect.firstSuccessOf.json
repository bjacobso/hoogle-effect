{
  "id": "Effect.firstSuccessOf",
  "name": "firstSuccessOf",
  "module": "Effect",
  "package": "effect",
  "signature": "<Eff extends Effect<any, any, any>>(effects: Iterable<Eff>) => Effect<Effect.Success<Eff>, Effect.Error<Eff>, Effect.Context<Eff>>",
  "description": "Runs a sequence of effects and returns the result of the first successful\none.\n*Details This function allows you to execute a collection of effects in sequence,\nstopping at the first success. If an effect succeeds, its result is\nimmediately returned, and no further effects in the sequence are executed.\nHowever, if all the effects fail, the function will return the error of the\nlast effect. The execution is sequential, meaning that effects are evaluated one at a time\nin the order they are provided. This ensures predictable behavior and avoids\nunnecessary computations. If the collection of effects is empty, an `IllegalArgumentException` is\nthrown, indicating that the operation is invalid without any effects to try.\n*When to Use This is particularly useful when you have multiple fallback strategies or\nalternative sources to obtain a result, such as attempting multiple APIs,\nretrieving configurations, or accessing resources in a prioritized manner.\n*Example",
  "documentation": "Runs a sequence of effects and returns the result of the first successful\none.\n*Details**\n\nThis function allows you to execute a collection of effects in sequence,\nstopping at the first success. If an effect succeeds, its result is\nimmediately returned, and no further effects in the sequence are executed.\nHowever, if all the effects fail, the function will return the error of the\nlast effect.\n\nThe execution is sequential, meaning that effects are evaluated one at a time\nin the order they are provided. This ensures predictable behavior and avoids\nunnecessary computations.\n\nIf the collection of effects is empty, an `IllegalArgumentException` is\nthrown, indicating that the operation is invalid without any effects to try.\n*When to Use**\n\nThis is particularly useful when you have multiple fallback strategies or\nalternative sources to obtain a result, such as attempting multiple APIs,\nretrieving configurations, or accessing resources in a prioritized manner.\n*Example**\n\n```ts\nimport { Effect, Console } from \"effect\"\n\ninterface Config {\nhost: string\nport: number\napiKey: string\n}\n\n// Create a configuration object with sample values\nconst makeConfig = (name: string): Config => ({\nhost: `${name}.example.com`,\nport: 8080,\napiKey: \"12345-abcde\"\n})\n\n// Simulate retrieving configuration from a remote node\nconst remoteConfig = (name: string): Effect.Effect<Config, Error> =>\nEffect.gen(function* () {\n// Simulate node3 being the only one with available config\nif (name === \"node3\") {\nyield* Console.log(`Config for ${name} found`)\nreturn makeConfig(name)\n} else {\nyield* Console.log(`Unavailable config for ${name}`)\nreturn yield* Effect.fail(new Error(`Config not found for ${name}`))\n}\n})\n\n// Define the master configuration and potential fallback nodes\nconst masterConfig = remoteConfig(\"master\")\nconst nodeConfigs = [\"node1\", \"node2\", \"node3\", \"node4\"].map(remoteConfig)\n\n// Attempt to find a working configuration,\n// starting with the master and then falling back to other nodes\nconst config = Effect.firstSuccessOf([masterConfig, ...nodeConfigs])\n\n// Run the effect to retrieve the configuration\nconst result = Effect.runSync(config)\n\nconsole.log(result)\n// Output:\n// Unavailable config for master\n// Unavailable config for node1\n// Unavailable config for node2\n// Config for node3 found\n// { host: 'node3.example.com', port: 8080, apiKey: '12345-abcde' }\n```",
  "examples": [
    {
      "code": "import { Effect, Console } from \"effect\"\n\ninterface Config {\nhost: string\nport: number\napiKey: string\n}\n\n// Create a configuration object with sample values\nconst makeConfig = (name: string): Config => ({\nhost: `${name}.example.com`,\nport: 8080,\napiKey: \"12345-abcde\"\n})\n\n// Simulate retrieving configuration from a remote node\nconst remoteConfig = (name: string): Effect.Effect<Config, Error> =>\nEffect.gen(function* () {\n// Simulate node3 being the only one with available config\nif (name === \"node3\") {\nyield* Console.log(`Config for ${name} found`)\nreturn makeConfig(name)\n} else {\nyield* Console.log(`Unavailable config for ${name}`)\nreturn yield* Effect.fail(new Error(`Config not found for ${name}`))\n}\n})\n\n// Define the master configuration and potential fallback nodes\nconst masterConfig = remoteConfig(\"master\")\nconst nodeConfigs = [\"node1\", \"node2\", \"node3\", \"node4\"].map(remoteConfig)\n\n// Attempt to find a working configuration,\n// starting with the master and then falling back to other nodes\nconst config = Effect.firstSuccessOf([masterConfig, ...nodeConfigs])\n\n// Run the effect to retrieve the configuration\nconst result = Effect.runSync(config)\n\nconsole.log(result)\n// Output:\n// Unavailable config for master\n// Unavailable config for node1\n// Unavailable config for node2\n// Config for node3 found\n// { host: 'node3.example.com', port: 8080, apiKey: '12345-abcde' }"
    }
  ],
  "tags": [
    "Fallback"
  ],
  "since": "2.0.0",
  "sourceFile": "/Users/benjacobson/conductor/workspaces/hoogle-effect/san-juan-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
  "sourceLine": 23732,
  "githubUrl": "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L23732"
}