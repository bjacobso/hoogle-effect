{
  "id": "Effect.async",
  "name": "async",
  "module": "Effect",
  "package": "effect",
  "signature": "<A, E = never, R = never>(resume: (callback: (_: Effect<A, E, R>) => void, signal: AbortSignal) => void | Effect<void, never, R>, blockingOn?: FiberId) => Effect<A, E, R>",
  "description": "Creates an `Effect` from a callback-based asynchronous function.\n*Details The `resume` function:\n- Must be called exactly once. Any additional calls will be ignored.\n- Can return an optional `Effect` that will be run if the `Fiber` executing\nthis `Effect` is interrupted. This can be useful in scenarios where you\nneed to handle resource cleanup if the operation is interrupted.\n- Can receive an `AbortSignal` to handle interruption if needed. The `FiberId` of the fiber that may complete the async callback may also be\nspecified using the `blockingOn` argument. This is called the \"blocking\nfiber\" because it suspends the fiber executing the `async` effect (i.e.\nsemantically blocks the fiber from making progress). Specifying this fiber id\nin cases where it is known will improve diagnostics, but not affect the\nbehavior of the returned effect.\n*When to Use Use `Effect.async` when dealing with APIs that use callback-style instead of\n`async/await` or `Promise`.\n*Example (Wrapping a Callback API) *Example (Handling Interruption with Cleanup) *Example (Handling Interruption with AbortSignal)",
  "documentation": "Creates an `Effect` from a callback-based asynchronous function.\n*Details**\n\nThe `resume` function:\n- Must be called exactly once. Any additional calls will be ignored.\n- Can return an optional `Effect` that will be run if the `Fiber` executing\nthis `Effect` is interrupted. This can be useful in scenarios where you\nneed to handle resource cleanup if the operation is interrupted.\n- Can receive an `AbortSignal` to handle interruption if needed.\n\nThe `FiberId` of the fiber that may complete the async callback may also be\nspecified using the `blockingOn` argument. This is called the \"blocking\nfiber\" because it suspends the fiber executing the `async` effect (i.e.\nsemantically blocks the fiber from making progress). Specifying this fiber id\nin cases where it is known will improve diagnostics, but not affect the\nbehavior of the returned effect.\n*When to Use**\n\nUse `Effect.async` when dealing with APIs that use callback-style instead of\n`async/await` or `Promise`.\n*Example** (Wrapping a Callback API)\n\n```ts\nimport { Effect } from \"effect\"\nimport * as NodeFS from \"node:fs\"\n\nconst readFile = (filename: string) =>\nEffect.async<Buffer, Error>((resume) => {\nNodeFS.readFile(filename, (error, data) => {\nif (error) {\n// Resume with a failed Effect if an error occurs\nresume(Effect.fail(error))\n} else {\n// Resume with a succeeded Effect if successful\nresume(Effect.succeed(data))\n}\n})\n})\n\n// ┌─── Effect<Buffer, Error, never>\n// ▼\nconst program = readFile(\"example.txt\")\n```\n*Example** (Handling Interruption with Cleanup)\n\n```ts\nimport { Effect, Fiber } from \"effect\"\nimport * as NodeFS from \"node:fs\"\n\n// Simulates a long-running operation to write to a file\nconst writeFileWithCleanup = (filename: string, data: string) =>\nEffect.async<void, Error>((resume) => {\nconst writeStream = NodeFS.createWriteStream(filename)\n\n// Start writing data to the file\nwriteStream.write(data)\n\n// When the stream is finished, resume with success\nwriteStream.on(\"finish\", () => resume(Effect.void))\n\n// In case of an error during writing, resume with failure\nwriteStream.on(\"error\", (err) => resume(Effect.fail(err)))\n\n// Handle interruption by returning a cleanup effect\nreturn Effect.sync(() => {\nconsole.log(`Cleaning up ${filename}`)\nNodeFS.unlinkSync(filename)\n})\n})\n\nconst program = Effect.gen(function* () {\nconst fiber = yield* Effect.fork(\nwriteFileWithCleanup(\"example.txt\", \"Some long data...\")\n)\n// Simulate interrupting the fiber after 1 second\nyield* Effect.sleep(\"1 second\")\nyield* Fiber.interrupt(fiber) // This will trigger the cleanup\n})\n\n// Run the program\nEffect.runPromise(program)\n// Output:\n// Cleaning up example.txt\n```\n*Example** (Handling Interruption with AbortSignal)\n\n```ts\nimport { Effect, Fiber } from \"effect\"\n\n// A task that supports interruption using AbortSignal\nconst interruptibleTask = Effect.async<void, Error>((resume, signal) => {\n// Handle interruption\nsignal.addEventListener(\"abort\", () => {\nconsole.log(\"Abort signal received\")\nclearTimeout(timeoutId)\n})\n\n// Simulate a long-running task\nconst timeoutId = setTimeout(() => {\nconsole.log(\"Operation completed\")\nresume(Effect.void)\n}, 2000)\n})\n\nconst program = Effect.gen(function* () {\nconst fiber = yield* Effect.fork(interruptibleTask)\n// Simulate interrupting the fiber after 1 second\nyield* Effect.sleep(\"1 second\")\nyield* Fiber.interrupt(fiber)\n})\n\n// Run the program\nEffect.runPromise(program)\n// Output:\n// Abort signal received\n```",
  "examples": [
    {
      "code": "import { Effect } from \"effect\"\nimport * as NodeFS from \"node:fs\"\n\nconst readFile = (filename: string) =>\nEffect.async<Buffer, Error>((resume) => {\nNodeFS.readFile(filename, (error, data) => {\nif (error) {\n// Resume with a failed Effect if an error occurs\nresume(Effect.fail(error))\n} else {\n// Resume with a succeeded Effect if successful\nresume(Effect.succeed(data))\n}\n})\n})\n\n// ┌─── Effect<Buffer, Error, never>\n// ▼\nconst program = readFile(\"example.txt\")"
    },
    {
      "code": "import { Effect, Fiber } from \"effect\"\nimport * as NodeFS from \"node:fs\"\n\n// Simulates a long-running operation to write to a file\nconst writeFileWithCleanup = (filename: string, data: string) =>\nEffect.async<void, Error>((resume) => {\nconst writeStream = NodeFS.createWriteStream(filename)\n\n// Start writing data to the file\nwriteStream.write(data)\n\n// When the stream is finished, resume with success\nwriteStream.on(\"finish\", () => resume(Effect.void))\n\n// In case of an error during writing, resume with failure\nwriteStream.on(\"error\", (err) => resume(Effect.fail(err)))\n\n// Handle interruption by returning a cleanup effect\nreturn Effect.sync(() => {\nconsole.log(`Cleaning up ${filename}`)\nNodeFS.unlinkSync(filename)\n})\n})\n\nconst program = Effect.gen(function* () {\nconst fiber = yield* Effect.fork(\nwriteFileWithCleanup(\"example.txt\", \"Some long data...\")\n)\n// Simulate interrupting the fiber after 1 second\nyield* Effect.sleep(\"1 second\")\nyield* Fiber.interrupt(fiber) // This will trigger the cleanup\n})\n\n// Run the program\nEffect.runPromise(program)\n// Output:\n// Cleaning up example.txt"
    },
    {
      "code": "import { Effect, Fiber } from \"effect\"\n\n// A task that supports interruption using AbortSignal\nconst interruptibleTask = Effect.async<void, Error>((resume, signal) => {\n// Handle interruption\nsignal.addEventListener(\"abort\", () => {\nconsole.log(\"Abort signal received\")\nclearTimeout(timeoutId)\n})\n\n// Simulate a long-running task\nconst timeoutId = setTimeout(() => {\nconsole.log(\"Operation completed\")\nresume(Effect.void)\n}, 2000)\n})\n\nconst program = Effect.gen(function* () {\nconst fiber = yield* Effect.fork(interruptibleTask)\n// Simulate interrupting the fiber after 1 second\nyield* Effect.sleep(\"1 second\")\nyield* Fiber.interrupt(fiber)\n})\n\n// Run the program\nEffect.runPromise(program)\n// Output:\n// Abort signal received"
    }
  ],
  "tags": [
    "Creating Effects"
  ],
  "since": "2.0.0",
  "sourceFile": "/Users/benjacobson/conductor/workspaces/hoogle-effect/san-juan-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
  "sourceLine": 4718,
  "githubUrl": "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L4718"
}