{
  "id": "Effect.retry",
  "name": "retry",
  "module": "Effect",
  "package": "effect",
  "signature": "{ <E, O extends NoExcessProperties<Retry.Options<E>, O>>(options: O): <A, R>(self: Effect<A, E, R>) => Effect<A, (O extends { schedule: Schedule<infer _O, infer _I, infer _R>; } ? E : O extends { until: Refinement<E, infer E2 extends E>; } ? E2 : E) | (O extends { while: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never), R | (O extends { schedule: Schedule<infer _O, infer _I, infer R>; } ? R : never) | (O extends { while: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never)>; <B, E, R1>(policy: Schedule<B, NoInfer<E>, R1>): <A, R>(self: Effect<A, E, R>) => Effect<A, E, R1 | R>; <A, E, R, O extends NoExcessProperties<Retry.Options<E>, O>>(self: Effect<A, E, R>, options: O): Effect<A, (O extends { schedule: Schedule<infer _O, infer _I, infer _R>; } ? E : O extends { until: Refinement<E, infer E2 extends E>; } ? E2 : E) | (O extends { while: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never), R | (O extends { schedule: Schedule<infer _O, infer _I, infer R>; } ? R : never) | (O extends { while: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never)>; <A, E, R, B, R1>(self: Effect<A, E, R>, policy: Schedule<B, NoInfer<E>, R1>): Effect<A, E, R | R1>; }",
  "description": "Retries a failing effect based on a defined retry policy.",
  "documentation": "Retries a failing effect based on a defined retry policy.\n**Details**\nThe `Effect.retry` function takes an effect and a {@link Schedule}policy,\nand will automatically retry the effect if it fails, following the rules of\nthe policy.\nIf the effect ultimately succeeds, the result will be returned.\nIf the maximum retries are exhausted and the effect still fails, the failure\nis propagated.\n**When to Use**\nThis can be useful when dealing with intermittent failures, such as network\nissues or temporary resource unavailability. By defining a retry policy, you\ncan control the number of retries, the delay between them, and when to stop\nretrying.\n**Example** (Retrying with a Fixed Delay)\n```ts\nimport { Effect, Schedule } from \"effect\"\nlet count = 0\n// Simulates an effect with possible failures\nconst task = Effect.async<string, Error>((resume) => {\nif (count <= 2) {\ncount++\nconsole.log(\"failure\")\nresume(Effect.fail(new Error()))\n} else {\nconsole.log(\"success\")\nresume(Effect.succeed(\"yay!\"))\n}\n})\n// Define a repetition policy using a fixed delay between retries\nconst policy = Schedule.fixed(\"100 millis\")\nconst repeated = Effect.retry(task, policy)\nEffect.runPromise(repeated).then(console.log)\n// Output:\n// failure\n// failure\n// failure\n// success\n// yay!\n```\n**Example** (Retrying a Task up to 5 times)\n```ts\nimport { Effect } from \"effect\"\nlet count = 0\n// Simulates an effect with possible failures\nconst task = Effect.async<string, Error>((resume) => {\nif (count <= 2) {\ncount++\nconsole.log(\"failure\")\nresume(Effect.fail(new Error()))\n} else {\nconsole.log(\"success\")\nresume(Effect.succeed(\"yay!\"))\n}\n})\n// Retry the task up to 5 times\nEffect.runPromise(Effect.retry(task, { times: 5 })).then(console.log)\n// Output:\n// failure\n// failure\n// failure\n// success\n```\n**Example** (Retrying Until a Specific Condition is Met)\n```ts\nimport { Effect } from \"effect\"\nlet count = 0\n// Define an effect that simulates varying error on each invocation\nconst action = Effect.failSync(() => {\nconsole.log(`Action called ${++count} time(s)`)\nreturn `Error ${count}`\n})\n// Retry the action until a specific condition is met\nconst program = Effect.retry(action, {\nuntil: (err) => err === \"Error 3\"\n})\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// Action called 1 time(s)\n// Action called 2 time(s)\n// Action called 3 time(s)\n// {\n// _id: 'Exit',\n// _tag: 'Failure',\n// cause: { _id: 'Cause', _tag: 'Fail', failure: 'Error 3' }\n// }\n```",
  "examples": [
    {
      "title": "Retrying with a Fixed Delay",
      "code": "import { Effect, Schedule } from \"effect\"\nlet count = 0\n// Simulates an effect with possible failures\nconst task = Effect.async<string, Error>((resume) => {\nif (count <= 2) {\ncount++\nconsole.log(\"failure\")\nresume(Effect.fail(new Error()))\n} else {\nconsole.log(\"success\")\nresume(Effect.succeed(\"yay!\"))\n}\n})\n// Define a repetition policy using a fixed delay between retries\nconst policy = Schedule.fixed(\"100 millis\")\nconst repeated = Effect.retry(task, policy)\nEffect.runPromise(repeated).then(console.log)\n// Output:\n// failure\n// failure\n// failure\n// success\n// yay!"
    },
    {
      "title": "Retrying a Task up to 5 times",
      "code": "import { Effect } from \"effect\"\nlet count = 0\n// Simulates an effect with possible failures\nconst task = Effect.async<string, Error>((resume) => {\nif (count <= 2) {\ncount++\nconsole.log(\"failure\")\nresume(Effect.fail(new Error()))\n} else {\nconsole.log(\"success\")\nresume(Effect.succeed(\"yay!\"))\n}\n})\n// Retry the task up to 5 times\nEffect.runPromise(Effect.retry(task, { times: 5 })).then(console.log)\n// Output:\n// failure\n// failure\n// failure\n// success"
    },
    {
      "title": "Retrying Until a Specific Condition is Met",
      "code": "import { Effect } from \"effect\"\nlet count = 0\n// Define an effect that simulates varying error on each invocation\nconst action = Effect.failSync(() => {\nconsole.log(`Action called ${++count} time(s)`)\nreturn `Error ${count}`\n})\n// Retry the action until a specific condition is met\nconst program = Effect.retry(action, {\nuntil: (err) => err === \"Error 3\"\n})\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// Action called 1 time(s)\n// Action called 2 time(s)\n// Action called 3 time(s)\n// {\n// _id: 'Exit',\n// _tag: 'Failure',\n// cause: { _id: 'Cause', _tag: 'Fail', failure: 'Error 3' }\n// }"
    }
  ],
  "tags": [
    "Error handling"
  ],
  "since": "2.0.0",
  "sourceFile": "/Users/benjacobson/conductor/workspaces/hoogle-effect/san-juan-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
  "sourceLine": 7449,
  "githubUrl": "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L7449"
}