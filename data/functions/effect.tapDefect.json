{
  "id": "Effect.tapDefect",
  "name": "tapDefect",
  "module": "Effect",
  "package": "effect",
  "signature": "{ <X, E2, R2>(f: (cause: Cause<never>) => Effect<X, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause<never>) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>; }",
  "description": "Inspect severe errors or defects (non-recoverable failures) in an effect.\n*Details This function is specifically designed to handle and inspect defects, which\nare critical failures in your program, such as unexpected runtime exceptions\nor system-level errors. Unlike normal recoverable errors, defects typically\nindicate serious issues that cannot be addressed through standard error\nhandling. When a defect occurs in an effect, the function you provide to this function\nwill be executed, allowing you to log, monitor, or handle the defect in some\nway. Importantly, this does not alter the main result of the effect. If no\ndefect occurs, the effect behaves as if this function was not used.\n*Example",
  "documentation": "Inspect severe errors or defects (non-recoverable failures) in an effect.\n*Details**\n\nThis function is specifically designed to handle and inspect defects, which\nare critical failures in your program, such as unexpected runtime exceptions\nor system-level errors. Unlike normal recoverable errors, defects typically\nindicate serious issues that cannot be addressed through standard error\nhandling.\n\nWhen a defect occurs in an effect, the function you provide to this function\nwill be executed, allowing you to log, monitor, or handle the defect in some\nway. Importantly, this does not alter the main result of the effect. If no\ndefect occurs, the effect behaves as if this function was not used.\n*Example**\n\n```ts\nimport { Effect, Console } from \"effect\"\n\n// Simulate a task that fails with a recoverable error\nconst task1: Effect.Effect<number, string> = Effect.fail(\"NetworkError\")\n\n// tapDefect won't log anything because NetworkError is not a defect\nconst tapping1 = Effect.tapDefect(task1, (cause) =>\nConsole.log(`defect: ${cause}`)\n)\n\nEffect.runFork(tapping1)\n// No Output\n\n// Simulate a severe failure in the system\nconst task2: Effect.Effect<number, string> = Effect.dieMessage(\n\"Something went wrong\"\n)\n\n// Log the defect using tapDefect\nconst tapping2 = Effect.tapDefect(task2, (cause) =>\nConsole.log(`defect: ${cause}`)\n)\n\nEffect.runFork(tapping2)\n// Output:\n// defect: RuntimeException: Something went wrong\n// ... stack trace ...\n```",
  "examples": [
    {
      "code": "import { Effect, Console } from \"effect\"\n\n// Simulate a task that fails with a recoverable error\nconst task1: Effect.Effect<number, string> = Effect.fail(\"NetworkError\")\n\n// tapDefect won't log anything because NetworkError is not a defect\nconst tapping1 = Effect.tapDefect(task1, (cause) =>\nConsole.log(`defect: ${cause}`)\n)\n\nEffect.runFork(tapping1)\n// No Output\n\n// Simulate a severe failure in the system\nconst task2: Effect.Effect<number, string> = Effect.dieMessage(\n\"Something went wrong\"\n)\n\n// Log the defect using tapDefect\nconst tapping2 = Effect.tapDefect(task2, (cause) =>\nConsole.log(`defect: ${cause}`)\n)\n\nEffect.runFork(tapping2)\n// Output:\n// defect: RuntimeException: Something went wrong\n// ... stack trace ..."
    }
  ],
  "tags": [
    "Sequencing"
  ],
  "since": "2.0.0",
  "sourceFile": "/Users/benjacobson/conductor/workspaces/hoogle-effect/san-juan-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
  "sourceLine": 19358,
  "githubUrl": "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L19358"
}