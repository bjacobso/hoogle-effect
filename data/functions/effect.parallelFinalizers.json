{
  "id": "Effect.parallelFinalizers",
  "name": "parallelFinalizers",
  "module": "Effect",
  "package": "effect",
  "signature": "<A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>",
  "description": "Ensures that finalizers are run concurrently when the scope of an effect is\nclosed.\n*Details This function modifies the behavior of finalizers within a scoped workflow to\nallow them to run concurrently when the scope is closed. By default, finalizers are executed sequentially in reverse order of their\naddition, but this function changes that behavior to execute all finalizers\nconcurrently.\n*When to Use Running finalizers concurrently can improve performance when multiple\nindependent cleanup tasks need to be performed. However, it requires that\nthese tasks do not depend on the order of execution or introduce race\nconditions.\n*Example",
  "documentation": "Ensures that finalizers are run concurrently when the scope of an effect is\nclosed.\n*Details**\n\nThis function modifies the behavior of finalizers within a scoped workflow to\nallow them to run concurrently when the scope is closed.\n\nBy default, finalizers are executed sequentially in reverse order of their\naddition, but this function changes that behavior to execute all finalizers\nconcurrently.\n*When to Use**\n\nRunning finalizers concurrently can improve performance when multiple\nindependent cleanup tasks need to be performed. However, it requires that\nthese tasks do not depend on the order of execution or introduce race\nconditions.\n*Example**\n\n```ts\nimport { Console, Effect } from \"effect\"\n\n// Define a program that adds multiple finalizers\nconst program = Effect.gen(function*() {\nyield* Effect.addFinalizer(() => Console.log(\"Finalizer 1 executed\").pipe(Effect.delay(\"300 millis\")))\nyield* Effect.addFinalizer(() => Console.log(\"Finalizer 2 executed\").pipe(Effect.delay(\"100 millis\")))\nyield* Effect.addFinalizer(() => Console.log(\"Finalizer 3 executed\").pipe(Effect.delay(\"200 millis\")))\nreturn \"some result\"\n})\n\n// Modify the program to ensure finalizers run in parallel\nconst modified = program.pipe(Effect.parallelFinalizers)\n\nconst runnable = Effect.scoped(modified)\n\nEffect.runFork(runnable)\n// Output:\n// Finalizer 2 executed\n// Finalizer 3 executed\n// Finalizer 1 executed\n```",
  "examples": [
    {
      "code": "import { Console, Effect } from \"effect\"\n\n// Define a program that adds multiple finalizers\nconst program = Effect.gen(function*() {\nyield* Effect.addFinalizer(() => Console.log(\"Finalizer 1 executed\").pipe(Effect.delay(\"300 millis\")))\nyield* Effect.addFinalizer(() => Console.log(\"Finalizer 2 executed\").pipe(Effect.delay(\"100 millis\")))\nyield* Effect.addFinalizer(() => Console.log(\"Finalizer 3 executed\").pipe(Effect.delay(\"200 millis\")))\nreturn \"some result\"\n})\n\n// Modify the program to ensure finalizers run in parallel\nconst modified = program.pipe(Effect.parallelFinalizers)\n\nconst runnable = Effect.scoped(modified)\n\nEffect.runFork(runnable)\n// Output:\n// Finalizer 2 executed\n// Finalizer 3 executed\n// Finalizer 1 executed"
    }
  ],
  "tags": [
    "Scoping, Resources & Finalization"
  ],
  "since": "2.0.0",
  "sourceFile": "/Users/benjacobson/conductor/workspaces/hoogle-effect/san-juan-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
  "sourceLine": 10968,
  "githubUrl": "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L10968"
}