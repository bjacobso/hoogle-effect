{
  "id": "Effect.runFork",
  "name": "runFork",
  "module": "Effect",
  "package": "effect",
  "signature": "<A, E>(effect: Effect<A, E, never>, options?: RunForkOptions) => RuntimeFiber<A, E>",
  "description": "Runs an effect in the background, returning a fiber that can be observed or\ninterrupted. Unless you specifically need a `Promise` or synchronous operation, `runFork`\nis a good default choice.\n*Details This function is the foundational way to execute an effect in the background.\nIt creates a \"fiber,\" a lightweight, cooperative thread of execution that can\nbe observed (to access its result), interrupted, or joined. Fibers are useful\nfor concurrent programming and allow effects to run independently of the main\nprogram flow. Once the effect is running in a fiber, you can monitor its progress, cancel\nit if necessary, or retrieve its result when it completes. If the effect\nfails, the fiber will propagate the failure, which you can observe and\nhandle.\n*When to Use Use this function when you need to run an effect in the background,\nespecially if the effect is long-running or performs periodic tasks. It's\nsuitable for tasks that need to run independently but might still need\nobservation or management, like logging, monitoring, or scheduled tasks. This function is ideal if you don't need the result immediately or if the\neffect is part of a larger concurrent workflow.\n*Example (Running an Effect in the Background)",
  "documentation": "Runs an effect in the background, returning a fiber that can be observed or\ninterrupted.\n\nUnless you specifically need a `Promise` or synchronous operation, `runFork`\nis a good default choice.\n*Details**\n\nThis function is the foundational way to execute an effect in the background.\nIt creates a \"fiber,\" a lightweight, cooperative thread of execution that can\nbe observed (to access its result), interrupted, or joined. Fibers are useful\nfor concurrent programming and allow effects to run independently of the main\nprogram flow.\n\nOnce the effect is running in a fiber, you can monitor its progress, cancel\nit if necessary, or retrieve its result when it completes. If the effect\nfails, the fiber will propagate the failure, which you can observe and\nhandle.\n*When to Use**\n\nUse this function when you need to run an effect in the background,\nespecially if the effect is long-running or performs periodic tasks. It's\nsuitable for tasks that need to run independently but might still need\nobservation or management, like logging, monitoring, or scheduled tasks.\n\nThis function is ideal if you don't need the result immediately or if the\neffect is part of a larger concurrent workflow.\n*Example** (Running an Effect in the Background)\n\n```ts\nimport { Effect, Console, Schedule, Fiber } from \"effect\"\n\n// ┌─── Effect<number, never, never>\n// ▼\nconst program = Effect.repeat(\nConsole.log(\"running...\"),\nSchedule.spaced(\"200 millis\")\n)\n\n// ┌─── RuntimeFiber<number, never>\n// ▼\nconst fiber = Effect.runFork(program)\n\nsetTimeout(() => {\nEffect.runFork(Fiber.interrupt(fiber))\n}, 500)\n```",
  "examples": [
    {
      "code": "import { Effect, Console, Schedule, Fiber } from \"effect\"\n\n// ┌─── Effect<number, never, never>\n// ▼\nconst program = Effect.repeat(\nConsole.log(\"running...\"),\nSchedule.spaced(\"200 millis\")\n)\n\n// ┌─── RuntimeFiber<number, never>\n// ▼\nconst fiber = Effect.runFork(program)\n\nsetTimeout(() => {\nEffect.runFork(Fiber.interrupt(fiber))\n}, 500)"
    }
  ],
  "tags": [
    "Running Effects"
  ],
  "since": "2.0.0",
  "sourceFile": "/Users/benjacobson/conductor/workspaces/hoogle-effect/san-juan-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
  "sourceLine": 24358,
  "githubUrl": "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L24358"
}