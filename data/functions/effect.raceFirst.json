{
  "id": "Effect.raceFirst",
  "name": "raceFirst",
  "module": "Effect",
  "package": "effect",
  "signature": "{ <A2, E2, R2>(that: Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }",
  "description": "Races two effects and returns the result of the first one to complete.\n*Details This function takes two effects and runs them concurrently, returning the\nresult of the first one that completes, regardless of whether it succeeds or\nfails.\n*When to Use This function is useful when you want to race two operations, and you want to\nproceed with whichever one finishes first, regardless of whether it succeeds\nor fails.\n*Disconnecting Effects The `Effect.raceFirst` function safely interrupts the “loser” effect once the other completes, but it will not resume until the loser is cleanly terminated. If you want a quicker return, you can disconnect the interrupt signal for both effects. Instead of calling: You can use: This allows both effects to complete independently while still terminating the losing effect in the background.\n*Example (Both Tasks Succeed) *Example (One Task Fails, One Succeeds) *Example (Using Effect.disconnect for Quicker Return)",
  "documentation": "Races two effects and returns the result of the first one to complete.\n*Details**\n\nThis function takes two effects and runs them concurrently, returning the\nresult of the first one that completes, regardless of whether it succeeds or\nfails.\n*When to Use**\n\nThis function is useful when you want to race two operations, and you want to\nproceed with whichever one finishes first, regardless of whether it succeeds\nor fails.\n*Disconnecting Effects**\n\nThe `Effect.raceFirst` function safely interrupts the “loser” effect once the other completes, but it will not resume until the loser is cleanly terminated.\n\nIf you want a quicker return, you can disconnect the interrupt signal for both effects. Instead of calling:\n\n```ts skip-type-checking\nEffect.raceFirst(task1, task2)\n```\n\nYou can use:\n\n```ts skip-type-checking\nEffect.raceFirst(Effect.disconnect(task1), Effect.disconnect(task2))\n```\n\nThis allows both effects to complete independently while still terminating the losing effect in the background.\n*Example** (Both Tasks Succeed)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.succeed(\"task1\").pipe(\nEffect.delay(\"100 millis\"),\nEffect.tap(Console.log(\"task1 done\")),\nEffect.onInterrupt(() =>\nConsole.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n)\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\nEffect.delay(\"200 millis\"),\nEffect.tap(Console.log(\"task2 done\")),\nEffect.onInterrupt(() =>\nConsole.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n)\n)\n\nconst program = Effect.raceFirst(task1, task2).pipe(\nEffect.tap(Console.log(\"more work...\"))\n)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// task1 done\n// task2 interrupted\n// more work...\n// { _id: 'Exit', _tag: 'Success', value: 'task1' }\n```\n*Example** (One Task Fails, One Succeeds)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\nEffect.delay(\"100 millis\"),\nEffect.tap(Console.log(\"task1 done\")),\nEffect.onInterrupt(() =>\nConsole.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n)\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\nEffect.delay(\"200 millis\"),\nEffect.tap(Console.log(\"task2 done\")),\nEffect.onInterrupt(() =>\nConsole.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n)\n)\n\nconst program = Effect.raceFirst(task1, task2).pipe(\nEffect.tap(Console.log(\"more work...\"))\n)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// task2 interrupted\n// {\n// _id: 'Exit',\n// _tag: 'Failure',\n// cause: { _id: 'Cause', _tag: 'Fail', failure: 'task1' }\n// }\n```\n*Example** (Using Effect.disconnect for Quicker Return)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.succeed(\"task1\").pipe(\nEffect.delay(\"100 millis\"),\nEffect.tap(Console.log(\"task1 done\")),\nEffect.onInterrupt(() =>\nConsole.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n)\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\nEffect.delay(\"200 millis\"),\nEffect.tap(Console.log(\"task2 done\")),\nEffect.onInterrupt(() =>\nConsole.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n)\n)\n\n// Race the two tasks with disconnect to allow quicker return\nconst program = Effect.raceFirst(\nEffect.disconnect(task1),\nEffect.disconnect(task2)\n).pipe(Effect.tap(Console.log(\"more work...\")))\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// task1 done\n// more work...\n// { _id: 'Exit', _tag: 'Success', value: 'task1' }\n// task2 interrupted\n```",
  "examples": [
    {
      "code": "import { Effect, Console } from \"effect\"\n\nconst task1 = Effect.succeed(\"task1\").pipe(\nEffect.delay(\"100 millis\"),\nEffect.tap(Console.log(\"task1 done\")),\nEffect.onInterrupt(() =>\nConsole.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n)\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\nEffect.delay(\"200 millis\"),\nEffect.tap(Console.log(\"task2 done\")),\nEffect.onInterrupt(() =>\nConsole.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n)\n)\n\nconst program = Effect.raceFirst(task1, task2).pipe(\nEffect.tap(Console.log(\"more work...\"))\n)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// task1 done\n// task2 interrupted\n// more work...\n// { _id: 'Exit', _tag: 'Success', value: 'task1' }"
    },
    {
      "code": "import { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\nEffect.delay(\"100 millis\"),\nEffect.tap(Console.log(\"task1 done\")),\nEffect.onInterrupt(() =>\nConsole.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n)\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\nEffect.delay(\"200 millis\"),\nEffect.tap(Console.log(\"task2 done\")),\nEffect.onInterrupt(() =>\nConsole.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n)\n)\n\nconst program = Effect.raceFirst(task1, task2).pipe(\nEffect.tap(Console.log(\"more work...\"))\n)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// task2 interrupted\n// {\n// _id: 'Exit',\n// _tag: 'Failure',\n// cause: { _id: 'Cause', _tag: 'Fail', failure: 'task1' }\n// }"
    },
    {
      "code": "import { Effect, Console } from \"effect\"\n\nconst task1 = Effect.succeed(\"task1\").pipe(\nEffect.delay(\"100 millis\"),\nEffect.tap(Console.log(\"task1 done\")),\nEffect.onInterrupt(() =>\nConsole.log(\"task1 interrupted\").pipe(Effect.delay(\"100 millis\"))\n)\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\nEffect.delay(\"200 millis\"),\nEffect.tap(Console.log(\"task2 done\")),\nEffect.onInterrupt(() =>\nConsole.log(\"task2 interrupted\").pipe(Effect.delay(\"100 millis\"))\n)\n)\n\n// Race the two tasks with disconnect to allow quicker return\nconst program = Effect.raceFirst(\nEffect.disconnect(task1),\nEffect.disconnect(task2)\n).pipe(Effect.tap(Console.log(\"more work...\")))\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// task1 done\n// more work...\n// { _id: 'Exit', _tag: 'Success', value: 'task1' }\n// task2 interrupted"
    }
  ],
  "tags": [
    "Racing"
  ],
  "since": "2.0.0",
  "sourceFile": "/Users/benjacobson/conductor/workspaces/hoogle-effect/san-juan-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
  "sourceLine": 18161,
  "githubUrl": "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L18161"
}