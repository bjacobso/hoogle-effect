{
  "id": "Stream.debounce",
  "name": "debounce",
  "module": "Stream",
  "package": "effect",
  "signature": "{ (duration: DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, duration: DurationInput): Stream<A, E, R>; }",
  "description": "Delays the emission of values by holding new values for a set duration. If\nno new values arrive during that time the value is emitted, however if a\nnew value is received during the holding period the previous value is\ndiscarded and the process is repeated with the new value. This operator is useful if you have a stream of \"bursty\" events which\neventually settle down and you only need the final event of the burst. For\nexample, a search engine may only want to initiate a search after a user\nhas paused typing so as to not prematurely recommend results.",
  "documentation": "Delays the emission of values by holding new values for a set duration. If\nno new values arrive during that time the value is emitted, however if a\nnew value is received during the holding period the previous value is\ndiscarded and the process is repeated with the new value.\n\nThis operator is useful if you have a stream of \"bursty\" events which\neventually settle down and you only need the final event of the burst. For\nexample, a search engine may only want to initiate a search after a user\nhas paused typing so as to not prematurely recommend results.",
  "examples": [
    {
      "code": "import { Effect, Stream } from \"effect\"\n\nlet last = Date.now()\nconst log = (message: string) =>\nEffect.sync(() => {\nconst end = Date.now()\nconsole.log(`${message} after ${end - last}ms`)\nlast = end\n})\n\nconst stream = Stream.make(1, 2, 3).pipe(\nStream.concat(\nStream.fromEffect(Effect.sleep(\"200 millis\").pipe(Effect.as(4))) // Emit 4 after 200 ms\n),\nStream.concat(Stream.make(5, 6)), // Continue with more rapid values\nStream.concat(\nStream.fromEffect(Effect.sleep(\"150 millis\").pipe(Effect.as(7))) // Emit 7 after 150 ms\n),\nStream.concat(Stream.make(8)),\nStream.tap((n) => log(`Received ${n}`)),\nStream.debounce(\"100 millis\"), // Only emit values after a pause of at least 100 milliseconds,\nStream.tap((n) => log(`> Emitted ${n}`))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// Received 1 after 5ms\n// Received 2 after 2ms\n// Received 3 after 0ms\n// > Emitted 3 after 104ms\n// Received 4 after 99ms\n// Received 5 after 1ms\n// Received 6 after 0ms\n// > Emitted 6 after 101ms\n// Received 7 after 50ms\n// Received 8 after 1ms\n// > Emitted 8 after 101ms\n// { _id: 'Chunk', values: [ 3, 6, 8 ] }"
    }
  ],
  "tags": [
    "utils"
  ],
  "since": "2.0.0",
  "sourceFile": "/Users/benjacobson/conductor/workspaces/hoogle-effect/san-juan-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
  "sourceLine": 1856,
  "githubUrl": "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L1856"
}