{
  "id": "Effect.fn",
  "name": "fn",
  "module": "Effect",
  "package": "effect",
  "signature": "fn.Gen & fn.NonGen & ((name: string, options?: SpanOptions) => fn.Gen & fn.NonGen)",
  "description": "The `Effect.fn` function allows you to create traced functions that return an\neffect. It provides two key features: - Stack traces with location details if an error occurs.\n- Automatic span creation for tracing when a span name is provided. If a span name is passed as the first argument, the function's execution is\ntracked using that name. If no name is provided, stack tracing still works,\nbut spans are not created. A function can be defined using either: - A generator function, allowing the use of `yield*` for effect composition.\n- A regular function that returns an `Effect`.\n*Example (Creating a Traced Function with a Span Name) `Effect.fn` automatically creates spans. The spans capture information about\nthe function execution, including metadata and error details.\n*Example (Exporting Spans to the Console) `Effect.fn` also acts as a pipe function, allowing you to create a pipeline\nafter the function definition using the effect returned by the generator\nfunction as the starting value of the pipeline.\n*Example (Creating a Traced Function with a Delay)",
  "documentation": "The `Effect.fn` function allows you to create traced functions that return an\neffect. It provides two key features:\n\n- **Stack traces with location details** if an error occurs.\n- **Automatic span creation** for tracing when a span name is provided.\n\nIf a span name is passed as the first argument, the function's execution is\ntracked using that name. If no name is provided, stack tracing still works,\nbut spans are not created.\n\nA function can be defined using either:\n\n- A generator function, allowing the use of `yield*` for effect composition.\n- A regular function that returns an `Effect`.\n*Example** (Creating a Traced Function with a Span Name)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst myfunc = Effect.fn(\"myspan\")(function* <N extends number>(n: N) {\nyield* Effect.annotateCurrentSpan(\"n\", n) // Attach metadata to the span\nconsole.log(`got: ${n}`)\nyield* Effect.fail(new Error(\"Boom!\")) // Simulate failure\n})\n\nEffect.runFork(myfunc(100).pipe(Effect.catchAllCause(Effect.logError)))\n// Output:\n// got: 100\n// timestamp=... level=ERROR fiber=#0 cause=\"Error: Boom!\n// at <anonymous> (/.../index.ts:6:22) <= Raise location\n// at myspan (/.../index.ts:3:23) <= Definition location\n// at myspan (/.../index.ts:9:16)\" <= Call location\n```\n\n`Effect.fn` automatically creates spans. The spans capture information about\nthe function execution, including metadata and error details.\n*Example** (Exporting Spans to the Console)\n\n```ts skip-type-checking\nimport { Effect } from \"effect\"\nimport { NodeSdk } from \"@effect/opentelemetry\"\nimport {\nConsoleSpanExporter,\nBatchSpanProcessor\n} from \"@opentelemetry/sdk-trace-base\"\n\nconst myfunc = Effect.fn(\"myspan\")(function* <N extends number>(n: N) {\nyield* Effect.annotateCurrentSpan(\"n\", n)\nconsole.log(`got: ${n}`)\nyield* Effect.fail(new Error(\"Boom!\"))\n})\n\nconst program = myfunc(100)\n\nconst NodeSdkLive = NodeSdk.layer(() => ({\nresource: { serviceName: \"example\" },\n// Export span data to the console\nspanProcessor: new BatchSpanProcessor(new ConsoleSpanExporter())\n}))\n\nEffect.runFork(program.pipe(Effect.provide(NodeSdkLive)))\n// Output:\n// got: 100\n// {\n// resource: {\n// attributes: {\n// 'service.name': 'example',\n// 'telemetry.sdk.language': 'nodejs',\n// 'telemetry.sdk.name': '@effect/opentelemetry',\n// 'telemetry.sdk.version': '1.30.1'\n// }\n// },\n// instrumentationScope: { name: 'example', version: undefined, schemaUrl: undefined },\n// traceId: '22801570119e57a6e2aacda3dec9665b',\n// parentId: undefined,\n// traceState: undefined,\n// name: 'myspan',\n// id: '7af530c1e01bc0cb',\n// kind: 0,\n// timestamp: 1741182277518402.2,\n// duration: 4300.416,\n// attributes: {\n// n: 100,\n// 'code.stacktrace': 'at <anonymous> (/.../index.ts:8:23)\\n' +\n// 'at <anonymous> (/.../index.ts:14:17)'\n// },\n// status: { code: 2, message: 'Boom!' },\n// events: [\n// {\n// name: 'exception',\n// attributes: {\n// 'exception.type': 'Error',\n// 'exception.message': 'Boom!',\n// 'exception.stacktrace': 'Error: Boom!\\n' +\n// ' at <anonymous> (/.../index.ts:11:22)\\n' +\n// ' at myspan (/.../index.ts:8:23)\\n' +\n// ' at myspan (/.../index.ts:14:17)'\n// },\n// time: [ 1741182277, 522702583 ],\n// droppedAttributesCount: 0\n// }\n// ],\n// links: []\n// }\n```\n\n`Effect.fn` also acts as a pipe function, allowing you to create a pipeline\nafter the function definition using the effect returned by the generator\nfunction as the starting value of the pipeline.\n*Example** (Creating a Traced Function with a Delay)\n\n```ts\nimport { Effect } from \"effect\"\n\nconst myfunc = Effect.fn(\nfunction* (n: number) {\nconsole.log(`got: ${n}`)\nyield* Effect.fail(new Error(\"Boom!\"))\n},\n// You can access both the created effect and the original arguments\n(effect, n) => Effect.delay(effect, `${n / 100} seconds`)\n)\n\nEffect.runFork(myfunc(100).pipe(Effect.catchAllCause(Effect.logError)))\n// Output:\n// got: 100\n// timestamp=... level=ERROR fiber=#0 cause=\"Error: Boom! (<= after 1 second)\n```",
  "examples": [
    {
      "code": "import { Effect } from \"effect\"\n\nconst myfunc = Effect.fn(\"myspan\")(function* <N extends number>(n: N) {\nyield* Effect.annotateCurrentSpan(\"n\", n) // Attach metadata to the span\nconsole.log(`got: ${n}`)\nyield* Effect.fail(new Error(\"Boom!\")) // Simulate failure\n})\n\nEffect.runFork(myfunc(100).pipe(Effect.catchAllCause(Effect.logError)))\n// Output:\n// got: 100\n// timestamp=... level=ERROR fiber=#0 cause=\"Error: Boom!\n// at <anonymous> (/.../index.ts:6:22) <= Raise location\n// at myspan (/.../index.ts:3:23) <= Definition location\n// at myspan (/.../index.ts:9:16)\" <= Call location"
    },
    {
      "code": "import { Effect } from \"effect\"\n\nconst myfunc = Effect.fn(\nfunction* (n: number) {\nconsole.log(`got: ${n}`)\nyield* Effect.fail(new Error(\"Boom!\"))\n},\n// You can access both the created effect and the original arguments\n(effect, n) => Effect.delay(effect, `${n / 100} seconds`)\n)\n\nEffect.runFork(myfunc(100).pipe(Effect.catchAllCause(Effect.logError)))\n// Output:\n// got: 100\n// timestamp=... level=ERROR fiber=#0 cause=\"Error: Boom! (<= after 1 second)"
    }
  ],
  "tags": [
    "Tracing"
  ],
  "since": "3.11.0",
  "sourceFile": "/Users/benjacobson/conductor/workspaces/hoogle-effect/san-juan-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
  "sourceLine": 26934,
  "githubUrl": "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L26934"
}