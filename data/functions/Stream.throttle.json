{
  "id": "Stream.throttle",
  "name": "throttle",
  "module": "Stream",
  "package": "effect",
  "signature": "{ <A>(options: { readonly cost: (chunk: Chunk<A>) => number; readonly units: number; readonly duration: DurationInput; readonly burst?: number; readonly strategy?: \"enforce\" | \"shape\"; }): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, options: { readonly cost: (chunk: Chunk<A>) => number; readonly units: number; readonly duration: DurationInput; readonly burst?: number; readonly strategy?: \"enforce\" | \"shape\"; }): Stream<A, E, R>; }",
  "description": "Delays the chunks of this stream according to the given bandwidth\nparameters using the token bucket algorithm. Allows for burst in the\nprocessing of elements by allowing the token bucket to accumulate tokens up\nto a `units + burst` threshold. The weight of each chunk is determined by\nthe `cost` function. If using the \"enforce\" strategy, chunks that do not meet the bandwidth\nconstraints are dropped. If using the \"shape\" strategy, chunks are delayed\nuntil they can be emitted without exceeding the bandwidth constraints. Defaults to the \"shape\" strategy.",
  "documentation": "Delays the chunks of this stream according to the given bandwidth\nparameters using the token bucket algorithm. Allows for burst in the\nprocessing of elements by allowing the token bucket to accumulate tokens up\nto a `units + burst` threshold. The weight of each chunk is determined by\nthe `cost` function.\n\nIf using the \"enforce\" strategy, chunks that do not meet the bandwidth\nconstraints are dropped. If using the \"shape\" strategy, chunks are delayed\nuntil they can be emitted without exceeding the bandwidth constraints.\n\nDefaults to the \"shape\" strategy.",
  "examples": [
    {
      "code": "import { Chunk, Effect, Schedule, Stream } from \"effect\"\n\nlet last = Date.now()\nconst log = (message: string) =>\nEffect.sync(() => {\nconst end = Date.now()\nconsole.log(`${message} after ${end - last}ms`)\nlast = end\n})\n\nconst stream = Stream.fromSchedule(Schedule.spaced(\"50 millis\")).pipe(\nStream.take(6),\nStream.tap((n) => log(`Received ${n}`)),\nStream.throttle({\ncost: Chunk.size,\nduration: \"100 millis\",\nunits: 1\n}),\nStream.tap((n) => log(`> Emitted ${n}`))\n)\n\nEffect.runPromise(Stream.runCollect(stream)).then(console.log)\n// Received 0 after 56ms\n// > Emitted 0 after 0ms\n// Received 1 after 52ms\n// > Emitted 1 after 48ms\n// Received 2 after 52ms\n// > Emitted 2 after 49ms\n// Received 3 after 52ms\n// > Emitted 3 after 48ms\n// Received 4 after 52ms\n// > Emitted 4 after 47ms\n// Received 5 after 52ms\n// > Emitted 5 after 49ms\n// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4, 5 ] }"
    }
  ],
  "tags": [
    "utils"
  ],
  "since": "2.0.0",
  "sourceFile": "/Users/benjacobson/conductor/workspaces/hoogle-effect/san-juan-v1/packages/api/node_modules/effect/dist/dts/Stream.d.ts",
  "sourceLine": 8557,
  "githubUrl": "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/Stream.ts#L8557"
}