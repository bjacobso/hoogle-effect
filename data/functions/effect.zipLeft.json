{
  "id": "Effect.zipLeft",
  "name": "zipLeft",
  "module": "Effect",
  "package": "effect",
  "signature": "{ <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean; readonly batching?: boolean | \"inherit\"; readonly concurrentFinalizers?: boolean; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean; readonly batching?: boolean | \"inherit\"; readonly concurrentFinalizers?: boolean; }): Effect<A, E | E2, R | R2>; }",
  "description": "Executes two effects sequentially, returning the result of the first effect\nand ignoring the result of the second.\n*Details This function allows you to run two effects in sequence, where the result of\nthe first effect is preserved, and the result of the second effect is\ndiscarded. By default, the two effects are executed sequentially. If you need\nthem to run concurrently, you can pass the `{ concurrent: true }` option. The second effect will always be executed, even though its result is ignored.\nThis makes it useful for cases where you want to execute an effect for its\nside effects while keeping the result of another effect.\n*When to Use Use this function when you are only interested in the result of the first\neffect but still need to run the second effect for its side effects, such as\nlogging or performing a cleanup action.\n*Example",
  "documentation": "Executes two effects sequentially, returning the result of the first effect\nand ignoring the result of the second.\n*Details**\n\nThis function allows you to run two effects in sequence, where the result of\nthe first effect is preserved, and the result of the second effect is\ndiscarded. By default, the two effects are executed sequentially. If you need\nthem to run concurrently, you can pass the `{ concurrent: true }` option.\n\nThe second effect will always be executed, even though its result is ignored.\nThis makes it useful for cases where you want to execute an effect for its\nside effects while keeping the result of another effect.\n*When to Use**\n\nUse this function when you are only interested in the result of the first\neffect but still need to run the second effect for its side effects, such as\nlogging or performing a cleanup action.\n*Example**\n\n```ts\nimport { Effect } from \"effect\"\n\nconst task1 = Effect.succeed(1).pipe(\nEffect.delay(\"200 millis\"),\nEffect.tap(Effect.log(\"task1 done\"))\n)\nconst task2 = Effect.succeed(\"hello\").pipe(\nEffect.delay(\"100 millis\"),\nEffect.tap(Effect.log(\"task2 done\"))\n)\n\nconst program = Effect.zipLeft(task1, task2)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n// timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n// 1\n```",
  "examples": [
    {
      "code": "import { Effect } from \"effect\"\n\nconst task1 = Effect.succeed(1).pipe(\nEffect.delay(\"200 millis\"),\nEffect.tap(Effect.log(\"task1 done\"))\n)\nconst task2 = Effect.succeed(\"hello\").pipe(\nEffect.delay(\"100 millis\"),\nEffect.tap(Effect.log(\"task2 done\"))\n)\n\nconst program = Effect.zipLeft(task1, task2)\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// timestamp=... level=INFO fiber=#0 message=\"task1 done\"\n// timestamp=... level=INFO fiber=#0 message=\"task2 done\"\n// 1"
    }
  ],
  "tags": [
    "Zipping"
  ],
  "since": "2.0.0",
  "sourceFile": "/Users/benjacobson/conductor/workspaces/hoogle-effect/san-juan-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
  "sourceLine": 25157,
  "githubUrl": "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L25157"
}