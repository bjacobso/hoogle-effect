{
  "id": "Effect.acquireRelease",
  "name": "acquireRelease",
  "module": "Effect",
  "package": "effect",
  "signature": "{ <A, X, R2>(release: (a: A, exit: Exit<unknown, unknown>) => Effect<X, never, R2>): <E, R>(acquire: Effect<A, E, R>) => Effect<A, E, R2 | R | Scope>; <A, E, R, X, R2>(acquire: Effect<A, E, R>, release: (a: A, exit: Exit<unknown, unknown>) => Effect<X, never, R2>): Effect<A, E, R | R2 | Scope>; }",
  "description": "Creates a scoped resource using an `acquire` and `release` effect.\n*Details This function helps manage resources by combining two `Effect` values: one\nfor acquiring the resource and one for releasing it. `acquireRelease` does the following: 1. Ensures that the effect that acquires the resource will not be\ninterrupted. Note that acquisition may still fail due to internal\nreasons (such as an uncaught exception).\n2. Ensures that the `release` effect will not be interrupted, and will be\nexecuted as long as the acquisition effect successfully acquires the\nresource. If the `acquire` function succeeds, the `release` function is added to the\nlist of finalizers for the scope. This ensures that the release will happen\nautomatically when the scope is closed. Both `acquire` and `release` run uninterruptibly, meaning they cannot be\ninterrupted while they are executing. Additionally, the `release` function can be influenced by the exit value when\nthe scope closes, allowing for custom handling of how the resource is\nreleased based on the execution outcome.\n*When to Use This function is used to ensure that an effect that represents the\nacquisition of a resource (for example, opening a file, launching a thread,\netc.) will not be interrupted, and that the resource will always be released\nwhen the `Effect` completes execution.\n*Example (Defining a Simple Resource)",
  "documentation": "Creates a scoped resource using an `acquire` and `release` effect.\n*Details**\n\nThis function helps manage resources by combining two `Effect` values: one\nfor acquiring the resource and one for releasing it.\n\n`acquireRelease` does the following:\n\n1. Ensures that the effect that acquires the resource will not be\ninterrupted. Note that acquisition may still fail due to internal\nreasons (such as an uncaught exception).\n2. Ensures that the `release` effect will not be interrupted, and will be\nexecuted as long as the acquisition effect successfully acquires the\nresource.\n\nIf the `acquire` function succeeds, the `release` function is added to the\nlist of finalizers for the scope. This ensures that the release will happen\nautomatically when the scope is closed.\n\nBoth `acquire` and `release` run uninterruptibly, meaning they cannot be\ninterrupted while they are executing.\n\nAdditionally, the `release` function can be influenced by the exit value when\nthe scope closes, allowing for custom handling of how the resource is\nreleased based on the execution outcome.\n*When to Use**\n\nThis function is used to ensure that an effect that represents the\nacquisition of a resource (for example, opening a file, launching a thread,\netc.) will not be interrupted, and that the resource will always be released\nwhen the `Effect` completes execution.\n*Example** (Defining a Simple Resource)\n\n```ts\nimport { Effect } from \"effect\"\n\n// Define an interface for a resource\ninterface MyResource {\nreadonly contents: string\nreadonly close: () => Promise<void>\n}\n\n// Simulate resource acquisition\nconst getMyResource = (): Promise<MyResource> =>\nPromise.resolve({\ncontents: \"lorem ipsum\",\nclose: () =>\nnew Promise((resolve) => {\nconsole.log(\"Resource released\")\nresolve()\n})\n})\n\n// Define how the resource is acquired\nconst acquire = Effect.tryPromise({\ntry: () =>\ngetMyResource().then((res) => {\nconsole.log(\"Resource acquired\")\nreturn res\n}),\ncatch: () => new Error(\"getMyResourceError\")\n})\n\n// Define how the resource is released\nconst release = (res: MyResource) => Effect.promise(() => res.close())\n\n// Create the resource management workflow\n//\n// ┌─── Effect<MyResource, Error, Scope>\n// ▼\nconst resource = Effect.acquireRelease(acquire, release)\n```",
  "examples": [
    {
      "code": "import { Effect } from \"effect\"\n\n// Define an interface for a resource\ninterface MyResource {\nreadonly contents: string\nreadonly close: () => Promise<void>\n}\n\n// Simulate resource acquisition\nconst getMyResource = (): Promise<MyResource> =>\nPromise.resolve({\ncontents: \"lorem ipsum\",\nclose: () =>\nnew Promise((resolve) => {\nconsole.log(\"Resource released\")\nresolve()\n})\n})\n\n// Define how the resource is acquired\nconst acquire = Effect.tryPromise({\ntry: () =>\ngetMyResource().then((res) => {\nconsole.log(\"Resource acquired\")\nreturn res\n}),\ncatch: () => new Error(\"getMyResourceError\")\n})\n\n// Define how the resource is released\nconst release = (res: MyResource) => Effect.promise(() => res.close())\n\n// Create the resource management workflow\n//\n// ┌─── Effect<MyResource, Error, Scope>\n// ▼\nconst resource = Effect.acquireRelease(acquire, release)"
    }
  ],
  "tags": [
    "Scoping, Resources & Finalization"
  ],
  "since": "2.0.0",
  "sourceFile": "/Users/benjacobson/conductor/workspaces/hoogle-effect/san-juan-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
  "sourceLine": 9752,
  "githubUrl": "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L9752"
}