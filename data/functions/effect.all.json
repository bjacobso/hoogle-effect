{
  "id": "Effect.all",
  "name": "all",
  "module": "Effect",
  "package": "effect",
  "signature": "<const Arg extends Iterable<Effect<any, any, any>> | Record<string, Effect<any, any, any>>, O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | \"inherit\" | undefined; readonly discard?: boolean | undefined; readonly mode?: \"default\" | \"validate\" | \"either\" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, O>>(arg: Arg, options?: O) => All.Return<Arg, O>",
  "description": "Combines multiple effects into one, returning results based on the input\nstructure.\n*Details Use this function when you need to run multiple effects and combine their\nresults into a single output. It supports tuples, iterables, structs, and\nrecords, making it flexible for different input types. For instance, if the input is a tuple: the effects are executed sequentially, and the result is a new effect\ncontaining the results as a tuple. The results in the tuple match the order\nof the effects passed to `Effect.all`.\n*Concurrency You can control the execution order (e.g., sequential vs. concurrent) using\nthe `concurrency` option.\n*Short-Circuiting Behavior This function stops execution on the first error it encounters, this is\ncalled \"short-circuiting\". If any effect in the collection fails, the\nremaining effects will not run, and the error will be propagated. To change\nthis behavior, you can use the `mode` option, which allows all effects to run\nand collect results as `Either` or `Option`.\n*The `mode` option The `{ mode: \"either\" }` option changes the behavior of `Effect.all` to\nensure all effects run, even if some fail. Instead of stopping on the first\nfailure, this mode collects both successes and failures, returning an array\nof `Either` instances where each result is either a `Right` (success) or a\n`Left` (failure). Similarly, the `{ mode: \"validate\" }` option uses `Option` to indicate\nsuccess or failure. Each effect returns `None` for success and `Some` with\nthe error for failure.\n*Example (Combining Effects in Tuples) *Example (Combining Effects in Iterables) *Example (Combining Effects in Structs) *Example (Combining Effects in Records) *Example (Short-Circuiting Behavior) *Example (Collecting Results with `mode: \"either\"`) *Example (Collecting Results with `mode: \"validate\"`)",
  "documentation": "Combines multiple effects into one, returning results based on the input\nstructure.\n*Details**\n\nUse this function when you need to run multiple effects and combine their\nresults into a single output. It supports tuples, iterables, structs, and\nrecords, making it flexible for different input types.\n\nFor instance, if the input is a tuple:\n\n```ts skip-type-checking\n// ┌─── a tuple of effects\n// ▼\nEffect.all([effect1, effect2, ...])\n```\n\nthe effects are executed sequentially, and the result is a new effect\ncontaining the results as a tuple. The results in the tuple match the order\nof the effects passed to `Effect.all`.\n*Concurrency**\n\nYou can control the execution order (e.g., sequential vs. concurrent) using\nthe `concurrency` option.\n*Short-Circuiting Behavior**\n\nThis function stops execution on the first error it encounters, this is\ncalled \"short-circuiting\". If any effect in the collection fails, the\nremaining effects will not run, and the error will be propagated. To change\nthis behavior, you can use the `mode` option, which allows all effects to run\nand collect results as `Either` or `Option`.\n*The `mode` option**\n\nThe `{ mode: \"either\" }` option changes the behavior of `Effect.all` to\nensure all effects run, even if some fail. Instead of stopping on the first\nfailure, this mode collects both successes and failures, returning an array\nof `Either` instances where each result is either a `Right` (success) or a\n`Left` (failure).\n\nSimilarly, the `{ mode: \"validate\" }` option uses `Option` to indicate\nsuccess or failure. Each effect returns `None` for success and `Some` with\nthe error for failure.\n*Example** (Combining Effects in Tuples)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst tupleOfEffects = [\nEffect.succeed(42).pipe(Effect.tap(Console.log)),\nEffect.succeed(\"Hello\").pipe(Effect.tap(Console.log))\n] as const\n\n// ┌─── Effect<[number, string], never, never>\n// ▼\nconst resultsAsTuple = Effect.all(tupleOfEffects)\n\nEffect.runPromise(resultsAsTuple).then(console.log)\n// Output:\n// 42\n// Hello\n// [ 42, 'Hello' ]\n```\n*Example** (Combining Effects in Iterables)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst iterableOfEffects: Iterable<Effect.Effect<number>> = [1, 2, 3].map(\n(n) => Effect.succeed(n).pipe(Effect.tap(Console.log))\n)\n\n// ┌─── Effect<number[], never, never>\n// ▼\nconst resultsAsArray = Effect.all(iterableOfEffects)\n\nEffect.runPromise(resultsAsArray).then(console.log)\n// Output:\n// 1\n// 2\n// 3\n// [ 1, 2, 3 ]\n```\n*Example** (Combining Effects in Structs)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst structOfEffects = {\na: Effect.succeed(42).pipe(Effect.tap(Console.log)),\nb: Effect.succeed(\"Hello\").pipe(Effect.tap(Console.log))\n}\n\n// ┌─── Effect<{ a: number; b: string; }, never, never>\n// ▼\nconst resultsAsStruct = Effect.all(structOfEffects)\n\nEffect.runPromise(resultsAsStruct).then(console.log)\n// Output:\n// 42\n// Hello\n// { a: 42, b: 'Hello' }\n```\n*Example** (Combining Effects in Records)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst recordOfEffects: Record<string, Effect.Effect<number>> = {\nkey1: Effect.succeed(1).pipe(Effect.tap(Console.log)),\nkey2: Effect.succeed(2).pipe(Effect.tap(Console.log))\n}\n\n// ┌─── Effect<{ [x: string]: number; }, never, never>\n// ▼\nconst resultsAsRecord = Effect.all(recordOfEffects)\n\nEffect.runPromise(resultsAsRecord).then(console.log)\n// Output:\n// 1\n// 2\n// { key1: 1, key2: 2 }\n```\n*Example** (Short-Circuiting Behavior)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst program = Effect.all([\nEffect.succeed(\"Task1\").pipe(Effect.tap(Console.log)),\nEffect.fail(\"Task2: Oh no!\").pipe(Effect.tap(Console.log)),\n// Won't execute due to earlier failure\nEffect.succeed(\"Task3\").pipe(Effect.tap(Console.log))\n])\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// Task1\n// {\n// _id: 'Exit',\n// _tag: 'Failure',\n// cause: { _id: 'Cause', _tag: 'Fail', failure: 'Task2: Oh no!' }\n// }\n```\n*Example** (Collecting Results with `mode: \"either\"`)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst effects = [\nEffect.succeed(\"Task1\").pipe(Effect.tap(Console.log)),\nEffect.fail(\"Task2: Oh no!\").pipe(Effect.tap(Console.log)),\nEffect.succeed(\"Task3\").pipe(Effect.tap(Console.log))\n]\n\nconst program = Effect.all(effects, { mode: \"either\" })\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// Task1\n// Task3\n// {\n// _id: 'Exit',\n// _tag: 'Success',\n// value: [\n// { _id: 'Either', _tag: 'Right', right: 'Task1' },\n// { _id: 'Either', _tag: 'Left', left: 'Task2: Oh no!' },\n// { _id: 'Either', _tag: 'Right', right: 'Task3' }\n// ]\n// }\n```\n*Example** (Collecting Results with `mode: \"validate\"`)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst effects = [\nEffect.succeed(\"Task1\").pipe(Effect.tap(Console.log)),\nEffect.fail(\"Task2: Oh no!\").pipe(Effect.tap(Console.log)),\nEffect.succeed(\"Task3\").pipe(Effect.tap(Console.log))\n]\n\nconst program = Effect.all(effects, { mode: \"validate\" })\n\nEffect.runPromiseExit(program).then((result) => console.log(\"%o\", result))\n// Output:\n// Task1\n// Task3\n// {\n// _id: 'Exit',\n// _tag: 'Failure',\n// cause: {\n// _id: 'Cause',\n// _tag: 'Fail',\n// failure: [\n// { _id: 'Option', _tag: 'None' },\n// { _id: 'Option', _tag: 'Some', value: 'Task2: Oh no!' },\n// { _id: 'Option', _tag: 'None' }\n// ]\n// }\n// }\n```",
  "examples": [
    {
      "code": "import { Effect, Console } from \"effect\"\n\nconst tupleOfEffects = [\nEffect.succeed(42).pipe(Effect.tap(Console.log)),\nEffect.succeed(\"Hello\").pipe(Effect.tap(Console.log))\n] as const\n\n// ┌─── Effect<[number, string], never, never>\n// ▼\nconst resultsAsTuple = Effect.all(tupleOfEffects)\n\nEffect.runPromise(resultsAsTuple).then(console.log)\n// Output:\n// 42\n// Hello\n// [ 42, 'Hello' ]"
    },
    {
      "code": "import { Effect, Console } from \"effect\"\n\nconst iterableOfEffects: Iterable<Effect.Effect<number>> = [1, 2, 3].map(\n(n) => Effect.succeed(n).pipe(Effect.tap(Console.log))\n)\n\n// ┌─── Effect<number[], never, never>\n// ▼\nconst resultsAsArray = Effect.all(iterableOfEffects)\n\nEffect.runPromise(resultsAsArray).then(console.log)\n// Output:\n// 1\n// 2\n// 3\n// [ 1, 2, 3 ]"
    },
    {
      "code": "import { Effect, Console } from \"effect\"\n\nconst structOfEffects = {\na: Effect.succeed(42).pipe(Effect.tap(Console.log)),\nb: Effect.succeed(\"Hello\").pipe(Effect.tap(Console.log))\n}\n\n// ┌─── Effect<{ a: number; b: string; }, never, never>\n// ▼\nconst resultsAsStruct = Effect.all(structOfEffects)\n\nEffect.runPromise(resultsAsStruct).then(console.log)\n// Output:\n// 42\n// Hello\n// { a: 42, b: 'Hello' }"
    },
    {
      "code": "import { Effect, Console } from \"effect\"\n\nconst recordOfEffects: Record<string, Effect.Effect<number>> = {\nkey1: Effect.succeed(1).pipe(Effect.tap(Console.log)),\nkey2: Effect.succeed(2).pipe(Effect.tap(Console.log))\n}\n\n// ┌─── Effect<{ [x: string]: number; }, never, never>\n// ▼\nconst resultsAsRecord = Effect.all(recordOfEffects)\n\nEffect.runPromise(resultsAsRecord).then(console.log)\n// Output:\n// 1\n// 2\n// { key1: 1, key2: 2 }"
    },
    {
      "code": "import { Effect, Console } from \"effect\"\n\nconst program = Effect.all([\nEffect.succeed(\"Task1\").pipe(Effect.tap(Console.log)),\nEffect.fail(\"Task2: Oh no!\").pipe(Effect.tap(Console.log)),\n// Won't execute due to earlier failure\nEffect.succeed(\"Task3\").pipe(Effect.tap(Console.log))\n])\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// Task1\n// {\n// _id: 'Exit',\n// _tag: 'Failure',\n// cause: { _id: 'Cause', _tag: 'Fail', failure: 'Task2: Oh no!' }\n// }"
    },
    {
      "code": "import { Effect, Console } from \"effect\"\n\nconst effects = [\nEffect.succeed(\"Task1\").pipe(Effect.tap(Console.log)),\nEffect.fail(\"Task2: Oh no!\").pipe(Effect.tap(Console.log)),\nEffect.succeed(\"Task3\").pipe(Effect.tap(Console.log))\n]\n\nconst program = Effect.all(effects, { mode: \"either\" })\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// Task1\n// Task3\n// {\n// _id: 'Exit',\n// _tag: 'Success',\n// value: [\n// { _id: 'Either', _tag: 'Right', right: 'Task1' },\n// { _id: 'Either', _tag: 'Left', left: 'Task2: Oh no!' },\n// { _id: 'Either', _tag: 'Right', right: 'Task3' }\n// ]\n// }"
    },
    {
      "code": "import { Effect, Console } from \"effect\"\n\nconst effects = [\nEffect.succeed(\"Task1\").pipe(Effect.tap(Console.log)),\nEffect.fail(\"Task2: Oh no!\").pipe(Effect.tap(Console.log)),\nEffect.succeed(\"Task3\").pipe(Effect.tap(Console.log))\n]\n\nconst program = Effect.all(effects, { mode: \"validate\" })\n\nEffect.runPromiseExit(program).then((result) => console.log(\"%o\", result))\n// Output:\n// Task1\n// Task3\n// {\n// _id: 'Exit',\n// _tag: 'Failure',\n// cause: {\n// _id: 'Cause',\n// _tag: 'Fail',\n// failure: [\n// { _id: 'Option', _tag: 'None' },\n// { _id: 'Option', _tag: 'Some', value: 'Task2: Oh no!' },\n// { _id: 'Option', _tag: 'None' }\n// ]\n// }\n// }"
    }
  ],
  "tags": [
    "Collecting"
  ],
  "since": "2.0.0",
  "sourceFile": "/Users/benjacobson/conductor/workspaces/hoogle-effect/san-juan-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
  "sourceLine": 1044,
  "githubUrl": "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L1044"
}