{
  "id": "Effect.cachedFunction",
  "name": "cachedFunction",
  "module": "Effect",
  "package": "effect",
  "signature": "<A, B, E, R>(f: (a: A) => Effect<B, E, R>, eq?: Equivalence<A>) => Effect<(a: A) => Effect<B, E, R>, never, never>",
  "description": "Returns a memoized version of a function with effects, reusing results for\nthe same inputs.\n*Details This function creates a memoized version of a given function that performs an\neffect. Memoization ensures that once a result is computed for a specific\ninput, it is stored and reused for subsequent calls with the same input,\nreducing the need to recompute the result. The function can optionally take an `Equivalence` parameter to\ndetermine how inputs are compared for caching purposes.\n*When to Use Use this function when you have a function that performs an effect and you\nwant to avoid recomputing the result for the same input multiple times. It's ideal for functions that produce deterministic results based on their\ninputs, and you want to improve performance by caching the output. This is particularly useful in scenarios where the function involves\nexpensive calculations or operations that should be avoided after the first\nexecution with the same parameters.\n*Example",
  "documentation": "Returns a memoized version of a function with effects, reusing results for\nthe same inputs.\n*Details**\n\nThis function creates a memoized version of a given function that performs an\neffect. Memoization ensures that once a result is computed for a specific\ninput, it is stored and reused for subsequent calls with the same input,\nreducing the need to recompute the result.\n\nThe function can optionally take an `Equivalence` parameter to\ndetermine how inputs are compared for caching purposes.\n*When to Use**\n\nUse this function when you have a function that performs an effect and you\nwant to avoid recomputing the result for the same input multiple times.\n\nIt's ideal for functions that produce deterministic results based on their\ninputs, and you want to improve performance by caching the output.\n\nThis is particularly useful in scenarios where the function involves\nexpensive calculations or operations that should be avoided after the first\nexecution with the same parameters.\n*Example**\n\n```ts\nimport { Effect, Random } from \"effect\"\n\nconst program = Effect.gen(function* () {\nconst randomNumber = (n: number) => Random.nextIntBetween(1, n)\nconsole.log(\"non-memoized version:\")\nconsole.log(yield* randomNumber(10))\nconsole.log(yield* randomNumber(10))\n\nconsole.log(\"memoized version:\")\nconst memoized = yield* Effect.cachedFunction(randomNumber)\nconsole.log(yield* memoized(10))\nconsole.log(yield* memoized(10))\n})\n\nEffect.runFork(program)\n// Example Output:\n// non-memoized version:\n// 2\n// 8\n// memoized version:\n// 5\n// 5\n```",
  "examples": [
    {
      "code": "import { Effect, Random } from \"effect\"\n\nconst program = Effect.gen(function* () {\nconst randomNumber = (n: number) => Random.nextIntBetween(1, n)\nconsole.log(\"non-memoized version:\")\nconsole.log(yield* randomNumber(10))\nconsole.log(yield* randomNumber(10))\n\nconsole.log(\"memoized version:\")\nconst memoized = yield* Effect.cachedFunction(randomNumber)\nconsole.log(yield* memoized(10))\nconsole.log(yield* memoized(10))\n})\n\nEffect.runFork(program)\n// Example Output:\n// non-memoized version:\n// 2\n// 8\n// memoized version:\n// 5\n// 5"
    }
  ],
  "tags": [
    "Caching"
  ],
  "since": "2.0.0",
  "sourceFile": "/Users/benjacobson/conductor/workspaces/hoogle-effect/san-juan-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
  "sourceLine": 782,
  "githubUrl": "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L782"
}