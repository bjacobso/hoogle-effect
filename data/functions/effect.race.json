{
  "id": "Effect.race",
  "name": "race",
  "module": "Effect",
  "package": "effect",
  "signature": "{ <A2, E2, R2>(that: Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }",
  "description": "Races two effects and returns the result of the first successful one.\n*Details This function takes two effects and runs them concurrently. The first effect\nthat successfully completes will determine the result of the race, and the\nother effect will be interrupted. If neither effect succeeds, the function will fail with a `Cause`\ncontaining all the errors.\n*When to Use This is useful when you want to run two effects concurrently, but only care\nabout the first one to succeed. It is commonly used in cases like timeouts,\nretries, or when you want to optimize for the faster response without\nworrying about the other effect.\n*Handling Success or Failure with Either If you want to handle the result of whichever task completes first, whether\nit succeeds or fails, you can use the `Effect.either` function. This function\nwraps the result in an `Either` type, allowing you to see if the result\nwas a success (`Right`) or a failure (`Left`).\n*Example (Both Tasks Succeed) *Example (One Task Fails, One Succeeds) *Example (Both Tasks Fail) *Example (Handling Success or Failure with Either)",
  "documentation": "Races two effects and returns the result of the first successful one.\n*Details**\n\nThis function takes two effects and runs them concurrently. The first effect\nthat successfully completes will determine the result of the race, and the\nother effect will be interrupted.\n\nIf neither effect succeeds, the function will fail with a `Cause`\ncontaining all the errors.\n*When to Use**\n\nThis is useful when you want to run two effects concurrently, but only care\nabout the first one to succeed. It is commonly used in cases like timeouts,\nretries, or when you want to optimize for the faster response without\nworrying about the other effect.\n*Handling Success or Failure with Either**\n\nIf you want to handle the result of whichever task completes first, whether\nit succeeds or fails, you can use the `Effect.either` function. This function\nwraps the result in an `Either` type, allowing you to see if the result\nwas a success (`Right`) or a failure (`Left`).\n*Example** (Both Tasks Succeed)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.succeed(\"task1\").pipe(\nEffect.delay(\"200 millis\"),\nEffect.tap(Console.log(\"task1 done\")),\nEffect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\nEffect.delay(\"100 millis\"),\nEffect.tap(Console.log(\"task2 done\")),\nEffect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\nconst program = Effect.race(task1, task2)\n\nEffect.runFork(program)\n// Output:\n// task1 done\n// task2 interrupted\n```\n*Example** (One Task Fails, One Succeeds)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\nEffect.delay(\"100 millis\"),\nEffect.tap(Console.log(\"task1 done\")),\nEffect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\nEffect.delay(\"200 millis\"),\nEffect.tap(Console.log(\"task2 done\")),\nEffect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\nconst program = Effect.race(task1, task2)\n\nEffect.runFork(program)\n// Output:\n// task2 done\n```\n*Example** (Both Tasks Fail)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\nEffect.delay(\"100 millis\"),\nEffect.tap(Console.log(\"task1 done\")),\nEffect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.fail(\"task2\").pipe(\nEffect.delay(\"200 millis\"),\nEffect.tap(Console.log(\"task2 done\")),\nEffect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\nconst program = Effect.race(task1, task2)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// {\n// _id: 'Exit',\n// _tag: 'Failure',\n// cause: {\n// _id: 'Cause',\n// _tag: 'Parallel',\n// left: { _id: 'Cause', _tag: 'Fail', failure: 'task1' },\n// right: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }\n// }\n// }\n```\n*Example** (Handling Success or Failure with Either)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\nEffect.delay(\"100 millis\"),\nEffect.tap(Console.log(\"task1 done\")),\nEffect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\nEffect.delay(\"200 millis\"),\nEffect.tap(Console.log(\"task2 done\")),\nEffect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\n// Run both tasks concurrently, wrapping the result\n// in Either to capture success or failure\nconst program = Effect.race(Effect.either(task1), Effect.either(task2))\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// task2 interrupted\n// { _id: 'Either', _tag: 'Left', left: 'task1' }\n```",
  "examples": [
    {
      "code": "import { Effect, Console } from \"effect\"\n\nconst task1 = Effect.succeed(\"task1\").pipe(\nEffect.delay(\"200 millis\"),\nEffect.tap(Console.log(\"task1 done\")),\nEffect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\nEffect.delay(\"100 millis\"),\nEffect.tap(Console.log(\"task2 done\")),\nEffect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\nconst program = Effect.race(task1, task2)\n\nEffect.runFork(program)\n// Output:\n// task1 done\n// task2 interrupted"
    },
    {
      "code": "import { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\nEffect.delay(\"100 millis\"),\nEffect.tap(Console.log(\"task1 done\")),\nEffect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\nEffect.delay(\"200 millis\"),\nEffect.tap(Console.log(\"task2 done\")),\nEffect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\nconst program = Effect.race(task1, task2)\n\nEffect.runFork(program)\n// Output:\n// task2 done"
    },
    {
      "code": "import { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\nEffect.delay(\"100 millis\"),\nEffect.tap(Console.log(\"task1 done\")),\nEffect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.fail(\"task2\").pipe(\nEffect.delay(\"200 millis\"),\nEffect.tap(Console.log(\"task2 done\")),\nEffect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\nconst program = Effect.race(task1, task2)\n\nEffect.runPromiseExit(program).then(console.log)\n// Output:\n// {\n// _id: 'Exit',\n// _tag: 'Failure',\n// cause: {\n// _id: 'Cause',\n// _tag: 'Parallel',\n// left: { _id: 'Cause', _tag: 'Fail', failure: 'task1' },\n// right: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }\n// }\n// }"
    },
    {
      "code": "import { Effect, Console } from \"effect\"\n\nconst task1 = Effect.fail(\"task1\").pipe(\nEffect.delay(\"100 millis\"),\nEffect.tap(Console.log(\"task1 done\")),\nEffect.onInterrupt(() => Console.log(\"task1 interrupted\"))\n)\nconst task2 = Effect.succeed(\"task2\").pipe(\nEffect.delay(\"200 millis\"),\nEffect.tap(Console.log(\"task2 done\")),\nEffect.onInterrupt(() => Console.log(\"task2 interrupted\"))\n)\n\n// Run both tasks concurrently, wrapping the result\n// in Either to capture success or failure\nconst program = Effect.race(Effect.either(task1), Effect.either(task2))\n\nEffect.runPromise(program).then(console.log)\n// Output:\n// task2 interrupted\n// { _id: 'Either', _tag: 'Left', left: 'task1' }"
    }
  ],
  "tags": [
    "Racing"
  ],
  "since": "2.0.0",
  "sourceFile": "/Users/benjacobson/conductor/workspaces/hoogle-effect/san-juan-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
  "sourceLine": 17628,
  "githubUrl": "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L17628"
}