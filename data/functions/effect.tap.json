{
  "id": "Effect.tap",
  "name": "tap",
  "module": "Effect",
  "package": "effect",
  "signature": "{ <A, X>(f: (a: NoInfer<A>) => X): <E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, UnknownException | E, R> : Effect<A, E, R>; <A, X, E1, R1>(f: (a: NoInfer<A>) => Effect<X, E1, R1>, options: { onlyEffect: true; }): <E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R1 | R>; <X>(f: NotFunction<X>): <A, E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, UnknownException | E, R> : Effect<A, E, R>; <X, E1, R1>(f: Effect<X, E1, R1>, options: { onlyEffect: true; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R1 | R>; <A, E, R, X>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => X): [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, UnknownException | E, R> : Effect<A, E, R>; <A, E, R, X, E1, R1>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => Effect<X, E1, R1>, options: { onlyEffect: true; }): Effect<A, E | E1, R | R1>; <A, E, R, X>(self: Effect<A, E, R>, f: NotFunction<X>): [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, UnknownException | E, R> : Effect<A, E, R>; <A, E, R, X, E1, R1>(self: Effect<A, E, R>, f: Effect<X, E1, R1>, options: { onlyEffect: true; }): Effect<A, E | E1, R | R1>; }",
  "description": "Runs a side effect with the result of an effect without changing the original\nvalue.\n*Details This function works similarly to `flatMap`, but it ignores the result of the\nfunction passed to it. The value from the previous effect remains available\nfor the next part of the chain. Note that if the side effect fails, the\nentire chain will fail too.\n*When to Use Use this function when you want to perform a side effect, like logging or\ntracking, without modifying the main value. This is useful when you need to\nobserve or record an action but want the original value to be passed to the\nnext step.\n*Example (Logging a step in a pipeline)",
  "documentation": "Runs a side effect with the result of an effect without changing the original\nvalue.\n*Details**\n\nThis function works similarly to `flatMap`, but it ignores the result of the\nfunction passed to it. The value from the previous effect remains available\nfor the next part of the chain. Note that if the side effect fails, the\nentire chain will fail too.\n*When to Use**\n\nUse this function when you want to perform a side effect, like logging or\ntracking, without modifying the main value. This is useful when you need to\nobserve or record an action but want the original value to be passed to the\nnext step.\n*Example** (Logging a step in a pipeline)\n\n```ts\nimport { Console, Effect, pipe } from \"effect\"\n\n// Function to apply a discount safely to a transaction amount\nconst applyDiscount = (\ntotal: number,\ndiscountRate: number\n): Effect.Effect<number, Error> =>\ndiscountRate === 0\n? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n: Effect.succeed(total - (total * discountRate) / 100)\n\n// Simulated asynchronous task to fetch a transaction amount from database\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\nconst finalAmount = pipe(\nfetchTransactionAmount,\n// Log the fetched transaction amount\nEffect.tap((amount) => Console.log(`Apply a discount to: ${amount}`)),\n// `amount` is still available!\nEffect.flatMap((amount) => applyDiscount(amount, 5))\n)\n\nEffect.runPromise(finalAmount).then(console.log)\n// Output:\n// Apply a discount to: 100\n// 95\n```",
  "examples": [
    {
      "code": "import { Console, Effect, pipe } from \"effect\"\n\n// Function to apply a discount safely to a transaction amount\nconst applyDiscount = (\ntotal: number,\ndiscountRate: number\n): Effect.Effect<number, Error> =>\ndiscountRate === 0\n? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n: Effect.succeed(total - (total * discountRate) / 100)\n\n// Simulated asynchronous task to fetch a transaction amount from database\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n\nconst finalAmount = pipe(\nfetchTransactionAmount,\n// Log the fetched transaction amount\nEffect.tap((amount) => Console.log(`Apply a discount to: ${amount}`)),\n// `amount` is still available!\nEffect.flatMap((amount) => applyDiscount(amount, 5))\n)\n\nEffect.runPromise(finalAmount).then(console.log)\n// Output:\n// Apply a discount to: 100\n// 95"
    }
  ],
  "tags": [
    "Sequencing"
  ],
  "since": "2.0.0",
  "sourceFile": "/Users/benjacobson/conductor/workspaces/hoogle-effect/san-juan-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
  "sourceLine": 18709,
  "githubUrl": "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L18709"
}