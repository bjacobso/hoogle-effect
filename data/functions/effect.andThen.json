{
  "id": "Effect.andThen",
  "name": "andThen",
  "module": "Effect",
  "package": "effect",
  "signature": "{ <A, X>(f: (a: NoInfer<A>) => X): <E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, UnknownException | E, R> : Effect<X, E, R>; <X>(f: NotFunction<X>): <A, E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, UnknownException | E, R> : Effect<X, E, R>; <A, E, R, X>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => X): [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, UnknownException | E, R> : Effect<X, E, R>; <A, E, R, X>(self: Effect<A, E, R>, f: NotFunction<X>): [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, UnknownException | E, R> : Effect<X, E, R>; }",
  "description": "Chains two actions, where the second action can depend on the result of the\nfirst.",
  "documentation": "Chains two actions, where the second action can depend on the result of the\nfirst.\n**Syntax**\n```ts skip-type-checking\nconst transformedEffect = pipe(myEffect, Effect.andThen(anotherEffect))\n// or\nconst transformedEffect = Effect.andThen(myEffect, anotherEffect)\n// or\nconst transformedEffect = myEffect.pipe(Effect.andThen(anotherEffect))\n```\n**When to Use**\nUse `andThen` when you need to run multiple actions in sequence, with the\nsecond action depending on the result of the first. This is useful for\ncombining effects or handling computations that must happen in order.\n**Details**\nThe second action can be:\n- A constant value (similar to {@link as})\n- A function returning a value (similar to {@link map})\n- A `Promise`\n- A function returning a `Promise`\n- An `Effect`\n- A function returning an `Effect` (similar to {@link flatMap})\n**Note:** `andThen` works well with both `Option` and `Either` types,\ntreating them as effects.\n**Example** (Applying a Discount Based on Fetched Amount)\n```ts\nimport { pipe, Effect } from \"effect\"\n// Function to apply a discount safely to a transaction amount\nconst applyDiscount = (\ntotal: number,\ndiscountRate: number\n): Effect.Effect<number, Error> =>\ndiscountRate === 0\n? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n: Effect.succeed(total - (total * discountRate) / 100)\n// Simulated asynchronous task to fetch a transaction amount from database\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n// Using Effect.map and Effect.flatMap\nconst result1 = pipe(\nfetchTransactionAmount,\nEffect.map((amount) => amount * 2),\nEffect.flatMap((amount) => applyDiscount(amount, 5))\n)\nEffect.runPromise(result1).then(console.log)\n// Output: 190\n// Using Effect.andThen\nconst result2 = pipe(\nfetchTransactionAmount,\nEffect.andThen((amount) => amount * 2),\nEffect.andThen((amount) => applyDiscount(amount, 5))\n)\nEffect.runPromise(result2).then(console.log)\n// Output: 190\n```",
  "examples": [
    {
      "title": "Applying a Discount Based on Fetched Amount",
      "code": "import { pipe, Effect } from \"effect\"\n// Function to apply a discount safely to a transaction amount\nconst applyDiscount = (\ntotal: number,\ndiscountRate: number\n): Effect.Effect<number, Error> =>\ndiscountRate === 0\n? Effect.fail(new Error(\"Discount rate cannot be zero\"))\n: Effect.succeed(total - (total * discountRate) / 100)\n// Simulated asynchronous task to fetch a transaction amount from database\nconst fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))\n// Using Effect.map and Effect.flatMap\nconst result1 = pipe(\nfetchTransactionAmount,\nEffect.map((amount) => amount * 2),\nEffect.flatMap((amount) => applyDiscount(amount, 5))\n)\nEffect.runPromise(result1).then(console.log)\n// Output: 190\n// Using Effect.andThen\nconst result2 = pipe(\nfetchTransactionAmount,\nEffect.andThen((amount) => amount * 2),\nEffect.andThen((amount) => applyDiscount(amount, 5))\n)\nEffect.runPromise(result2).then(console.log)\n// Output: 190"
    }
  ],
  "tags": [
    "Sequencing"
  ],
  "since": "2.0.0",
  "sourceFile": "/Users/benjacobson/conductor/workspaces/hoogle-effect/san-juan-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
  "sourceLine": 17180,
  "githubUrl": "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L17180"
}