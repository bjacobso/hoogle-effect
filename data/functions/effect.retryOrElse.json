{
  "id": "Effect.retryOrElse",
  "name": "retryOrElse",
  "module": "Effect",
  "package": "effect",
  "signature": "{ <A1, E, R1, A2, E2, R2>(policy: Schedule<A1, NoInfer<E>, R1>, orElse: (e: NoInfer<E>, out: A1) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R1 | R2 | R>; <A, E, R, A1, R1, A2, E2, R2>(self: Effect<A, E, R>, policy: Schedule<A1, NoInfer<E>, R1>, orElse: (e: NoInfer<E>, out: A1) => Effect<A2, E2, R2>): Effect<A | A2, E2, R | R1 | R2>; }",
  "description": "Retries a failing effect and runs a fallback effect if retries are exhausted.",
  "documentation": "Retries a failing effect and runs a fallback effect if retries are exhausted.\n**Details**\nThe `Effect.retryOrElse` function attempts to retry a failing effect multiple\ntimes according to a defined {@link Schedule}policy.\nIf the retries are exhausted and the effect still fails, it runs a fallback\neffect instead.\n**When to Use**\nThis function is useful when you want to handle failures gracefully by\nspecifying an alternative action after repeated failures.\n**Example** (Retrying with Fallback)\n```ts\nimport { Effect, Schedule, Console } from \"effect\"\nlet count = 0\n// Simulates an effect with possible failures\nconst task = Effect.async<string, Error>((resume) => {\nif (count <= 2) {\ncount++\nconsole.log(\"failure\")\nresume(Effect.fail(new Error()))\n} else {\nconsole.log(\"success\")\nresume(Effect.succeed(\"yay!\"))\n}\n})\n// Retry the task with a delay between retries and a maximum of 2 retries\nconst policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\n// If all retries fail, run the fallback effect\nconst repeated = Effect.retryOrElse(\ntask,\npolicy,\n// fallback\n() => Console.log(\"orElse\").pipe(Effect.as(\"default value\"))\n)\nEffect.runPromise(repeated).then(console.log)\n// Output:\n// failure\n// failure\n// failure\n// orElse\n// default value\n```",
  "examples": [
    {
      "title": "Retrying with Fallback",
      "code": "import { Effect, Schedule, Console } from \"effect\"\nlet count = 0\n// Simulates an effect with possible failures\nconst task = Effect.async<string, Error>((resume) => {\nif (count <= 2) {\ncount++\nconsole.log(\"failure\")\nresume(Effect.fail(new Error()))\n} else {\nconsole.log(\"success\")\nresume(Effect.succeed(\"yay!\"))\n}\n})\n// Retry the task with a delay between retries and a maximum of 2 retries\nconst policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\n// If all retries fail, run the fallback effect\nconst repeated = Effect.retryOrElse(\ntask,\npolicy,\n// fallback\n() => Console.log(\"orElse\").pipe(Effect.as(\"default value\"))\n)\nEffect.runPromise(repeated).then(console.log)\n// Output:\n// failure\n// failure\n// failure\n// orElse\n// default value"
    }
  ],
  "tags": [
    "Error handling"
  ],
  "since": "2.0.0",
  "sourceFile": "/Users/benjacobson/conductor/workspaces/hoogle-effect/san-juan-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
  "sourceLine": 8025,
  "githubUrl": "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L8025"
}