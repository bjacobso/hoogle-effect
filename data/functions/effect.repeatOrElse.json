{
  "id": "Effect.repeatOrElse",
  "name": "repeatOrElse",
  "module": "Effect",
  "package": "effect",
  "signature": "{ <R2, A, B, E, E2, R3>(schedule: Schedule<B, A, R2>, orElse: (error: E, option: Option<B>) => Effect<B, E2, R3>): <R>(self: Effect<A, E, R>) => Effect<B, E2, R2 | R3 | R>; <A, E, R, R2, B, E2, R3>(self: Effect<A, E, R>, schedule: Schedule<B, A, R2>, orElse: (error: E, option: Option<B>) => Effect<B, E2, R3>): Effect<B, E2, R | R2 | R3>; }",
  "description": "Repeats an effect with a schedule, handling failures using a custom handler.\n*Details This function allows you to execute an effect repeatedly based on a specified\nschedule. If the effect fails at any point, a custom failure handler is\ninvoked. The handler is provided with both the failure value and the output\nof the schedule at the time of failure. This enables advanced error recovery\nor alternative fallback logic while maintaining flexibility in how\nrepetitions are handled. For example, using a schedule with `recurs(2)` will allow for two additional\nrepetitions after the initial execution, provided the effect succeeds. If a\nfailure occurs during any iteration, the failure handler is invoked to handle\nthe situation.\n*Example",
  "documentation": "Repeats an effect with a schedule, handling failures using a custom handler.\n*Details**\n\nThis function allows you to execute an effect repeatedly based on a specified\nschedule. If the effect fails at any point, a custom failure handler is\ninvoked. The handler is provided with both the failure value and the output\nof the schedule at the time of failure. This enables advanced error recovery\nor alternative fallback logic while maintaining flexibility in how\nrepetitions are handled.\n\nFor example, using a schedule with `recurs(2)` will allow for two additional\nrepetitions after the initial execution, provided the effect succeeds. If a\nfailure occurs during any iteration, the failure handler is invoked to handle\nthe situation.\n*Example**\n\n```ts\nimport { Effect, Schedule } from \"effect\"\n\nlet count = 0\n\n// Define an async effect that simulates an action with possible failures\nconst action = Effect.async<string, string>((resume) => {\nif (count > 1) {\nconsole.log(\"failure\")\nresume(Effect.fail(\"Uh oh!\"))\n} else {\ncount++\nconsole.log(\"success\")\nresume(Effect.succeed(\"yay!\"))\n}\n})\n\nconst policy = Schedule.addDelay(\nSchedule.recurs(2), // Repeat for a maximum of 2 times\n() => \"100 millis\" // Add a delay of 100 milliseconds between repetitions\n)\n\nconst program = Effect.repeatOrElse(action, policy, () =>\nEffect.sync(() => {\nconsole.log(\"orElse\")\nreturn count - 1\n})\n)\n\nEffect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))\n```",
  "examples": [
    {
      "code": "import { Effect, Schedule } from \"effect\"\n\nlet count = 0\n\n// Define an async effect that simulates an action with possible failures\nconst action = Effect.async<string, string>((resume) => {\nif (count > 1) {\nconsole.log(\"failure\")\nresume(Effect.fail(\"Uh oh!\"))\n} else {\ncount++\nconsole.log(\"success\")\nresume(Effect.succeed(\"yay!\"))\n}\n})\n\nconst policy = Schedule.addDelay(\nSchedule.recurs(2), // Repeat for a maximum of 2 times\n() => \"100 millis\" // Add a delay of 100 milliseconds between repetitions\n)\n\nconst program = Effect.repeatOrElse(action, policy, () =>\nEffect.sync(() => {\nconsole.log(\"orElse\")\nreturn count - 1\n})\n)\n\nEffect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))"
    }
  ],
  "tags": [
    "Repetition / Recursion"
  ],
  "since": "2.0.0",
  "sourceFile": "/Users/benjacobson/conductor/workspaces/hoogle-effect/san-juan-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
  "sourceLine": 21094,
  "githubUrl": "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L21094"
}