{
  "id": "Effect.cachedWithTTL",
  "name": "cachedWithTTL",
  "module": "Effect",
  "package": "effect",
  "signature": "{ (timeToLive: DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<A, E, never>, never, R>; <A, E, R>(self: Effect<A, E, R>, timeToLive: DurationInput): Effect<Effect<A, E, never>, never, R>; }",
  "description": "Returns an effect that caches its result for a specified `Duration`,\nknown as \"timeToLive\" (TTL).\n*Details This function is used to cache the result of an effect for a specified amount\nof time. This means that the first time the effect is evaluated, its result\nis computed and stored. If the effect is evaluated again within the specified `timeToLive`, the\ncached result will be used, avoiding recomputation. After the specified duration has passed, the cache expires, and the effect\nwill be recomputed upon the next evaluation.\n*When to Use Use this function when you have an effect that involves costly operations or\ncomputations, and you want to avoid repeating them within a short time frame. It's ideal for scenarios where the result of an effect doesn't change\nfrequently and can be reused for a specified duration. By caching the result, you can improve efficiency and reduce unnecessary\ncomputations, especially in performance-critical applications.\n*Example",
  "documentation": "Returns an effect that caches its result for a specified `Duration`,\nknown as \"timeToLive\" (TTL).\n*Details**\n\nThis function is used to cache the result of an effect for a specified amount\nof time. This means that the first time the effect is evaluated, its result\nis computed and stored.\n\nIf the effect is evaluated again within the specified `timeToLive`, the\ncached result will be used, avoiding recomputation.\n\nAfter the specified duration has passed, the cache expires, and the effect\nwill be recomputed upon the next evaluation.\n*When to Use**\n\nUse this function when you have an effect that involves costly operations or\ncomputations, and you want to avoid repeating them within a short time frame.\n\nIt's ideal for scenarios where the result of an effect doesn't change\nfrequently and can be reused for a specified duration.\n\nBy caching the result, you can improve efficiency and reduce unnecessary\ncomputations, especially in performance-critical applications.\n*Example**\n\n```ts\nimport { Effect, Console } from \"effect\"\n\nlet i = 1\nconst expensiveTask = Effect.promise<string>(() => {\nconsole.log(\"expensive task...\")\nreturn new Promise((resolve) => {\nsetTimeout(() => {\nresolve(`result ${i++}`)\n}, 100)\n})\n})\n\nconst program = Effect.gen(function* () {\nconst cached = yield* Effect.cachedWithTTL(expensiveTask, \"150 millis\")\nyield* cached.pipe(Effect.andThen(Console.log))\nyield* cached.pipe(Effect.andThen(Console.log))\nyield* Effect.sleep(\"100 millis\")\nyield* cached.pipe(Effect.andThen(Console.log))\n})\n\nEffect.runFork(program)\n// Output:\n// expensive task...\n// result 1\n// result 1\n// expensive task...\n// result 2\n```",
  "examples": [
    {
      "code": "import { Effect, Console } from \"effect\"\n\nlet i = 1\nconst expensiveTask = Effect.promise<string>(() => {\nconsole.log(\"expensive task...\")\nreturn new Promise((resolve) => {\nsetTimeout(() => {\nresolve(`result ${i++}`)\n}, 100)\n})\n})\n\nconst program = Effect.gen(function* () {\nconst cached = yield* Effect.cachedWithTTL(expensiveTask, \"150 millis\")\nyield* cached.pipe(Effect.andThen(Console.log))\nyield* cached.pipe(Effect.andThen(Console.log))\nyield* Effect.sleep(\"100 millis\")\nyield* cached.pipe(Effect.andThen(Console.log))\n})\n\nEffect.runFork(program)\n// Output:\n// expensive task...\n// result 1\n// result 1\n// expensive task...\n// result 2"
    }
  ],
  "tags": [
    "Caching"
  ],
  "since": "2.0.0",
  "sourceFile": "/Users/benjacobson/conductor/workspaces/hoogle-effect/san-juan-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
  "sourceLine": 309,
  "githubUrl": "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L309"
}