{
  "id": "Effect.repeat",
  "name": "repeat",
  "module": "Effect",
  "package": "effect",
  "signature": "{ <O extends NoExcessProperties<Repeat.Options<A>, O>, A>(options: O): <E, R>(self: Effect<A, E, R>) => Effect<O extends { schedule: Schedule<infer Out, infer _I, infer _R>; } ? Out : O extends { until: Refinement<A, infer B extends A>; } ? B : A, E | (O extends { while: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never), R | (O extends { schedule: Schedule<infer _O, infer _I, infer R>; } ? R : never) | (O extends { while: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never)>; <B, A, R1>(schedule: Schedule<B, A, R1>): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R1 | R>; <A, E, R, O extends NoExcessProperties<Repeat.Options<A>, O>>(self: Effect<A, E, R>, options: O): Effect<O extends { schedule: Schedule<infer Out, infer _I, infer _R>; } ? Out : O extends { until: Refinement<A, infer B extends A>; } ? B : A, E | (O extends { while: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer E, infer _R>; } ? E : never), R | (O extends { schedule: Schedule<infer _O, infer _I, infer R>; } ? R : never) | (O extends { while: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never) | (O extends { until: (...args: any[]) => Effect<infer _A, infer _E, infer R>; } ? R : never)>; <A, E, R, B, R1>(self: Effect<A, E, R>, schedule: Schedule<B, A, R1>): Effect<B, E, R | R1>; }",
  "description": "Repeats an effect based on a specified schedule or until the first failure.\n*Details This function executes an effect repeatedly according to the given schedule.\nEach repetition occurs after the initial execution of the effect, meaning\nthat the schedule determines the number of additional repetitions. For\nexample, using `Schedule.once` will result in the effect being executed twice\n(once initially and once as part of the repetition). If the effect succeeds, it is repeated according to the schedule. If it\nfails, the repetition stops immediately, and the failure is returned. The schedule can also specify delays between repetitions, making it useful\nfor tasks like retrying operations with backoff, periodic execution, or\nperforming a series of dependent actions. You can combine schedules for more advanced repetition logic, such as adding\ndelays, limiting recursions, or dynamically adjusting based on the outcome of\neach execution.\n*Example (Success Example) *Example (Failure Example)",
  "documentation": "Repeats an effect based on a specified schedule or until the first failure.\n*Details**\n\nThis function executes an effect repeatedly according to the given schedule.\nEach repetition occurs after the initial execution of the effect, meaning\nthat the schedule determines the number of additional repetitions. For\nexample, using `Schedule.once` will result in the effect being executed twice\n(once initially and once as part of the repetition).\n\nIf the effect succeeds, it is repeated according to the schedule. If it\nfails, the repetition stops immediately, and the failure is returned.\n\nThe schedule can also specify delays between repetitions, making it useful\nfor tasks like retrying operations with backoff, periodic execution, or\nperforming a series of dependent actions.\n\nYou can combine schedules for more advanced repetition logic, such as adding\ndelays, limiting recursions, or dynamically adjusting based on the outcome of\neach execution.\n*Example** (Success Example)\n\n```ts\nimport { Effect, Schedule, Console } from \"effect\"\n\nconst action = Console.log(\"success\")\nconst policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\nconst program = Effect.repeat(action, policy)\n\nEffect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))\n```\n*Example** (Failure Example)\n\n```ts\nimport { Effect, Schedule } from \"effect\"\n\nlet count = 0\n\n// Define an async effect that simulates an action with possible failures\nconst action = Effect.async<string, string>((resume) => {\nif (count > 1) {\nconsole.log(\"failure\")\nresume(Effect.fail(\"Uh oh!\"))\n} else {\ncount++\nconsole.log(\"success\")\nresume(Effect.succeed(\"yay!\"))\n}\n})\n\nconst policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\nconst program = Effect.repeat(action, policy)\n\nEffect.runPromiseExit(program).then(console.log)\n```",
  "examples": [
    {
      "code": "import { Effect, Schedule, Console } from \"effect\"\n\nconst action = Console.log(\"success\")\nconst policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\nconst program = Effect.repeat(action, policy)\n\nEffect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))"
    },
    {
      "code": "import { Effect, Schedule } from \"effect\"\n\nlet count = 0\n\n// Define an async effect that simulates an action with possible failures\nconst action = Effect.async<string, string>((resume) => {\nif (count > 1) {\nconsole.log(\"failure\")\nresume(Effect.fail(\"Uh oh!\"))\n} else {\ncount++\nconsole.log(\"success\")\nresume(Effect.succeed(\"yay!\"))\n}\n})\n\nconst policy = Schedule.addDelay(Schedule.recurs(2), () => \"100 millis\")\nconst program = Effect.repeat(action, policy)\n\nEffect.runPromiseExit(program).then(console.log)"
    }
  ],
  "tags": [
    "Repetition / Recursion"
  ],
  "since": "2.0.0",
  "sourceFile": "/Users/benjacobson/conductor/workspaces/hoogle-effect/san-juan-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
  "sourceLine": 20686,
  "githubUrl": "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L20686"
}