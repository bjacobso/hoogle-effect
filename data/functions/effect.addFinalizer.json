{
  "id": "Effect.addFinalizer",
  "name": "addFinalizer",
  "module": "Effect",
  "package": "effect",
  "signature": "<X, R>(finalizer: (exit: Exit<unknown, unknown>) => Effect<X, never, R>) => Effect<void, never, Scope | R>",
  "description": "Ensures a finalizer is added to the scope of the calling effect, guaranteeing\nit runs when the scope is closed.\n*Details This function adds a finalizer that will execute whenever the scope of the\neffect is closed, regardless of whether the effect succeeds, fails, or is\ninterrupted. The finalizer receives the `Exit` value of the effect's scope,\nallowing it to react differently depending on how the effect concludes. Finalizers are a reliable way to manage resource cleanup, ensuring that\nresources such as file handles, network connections, or database transactions\nare properly closed even in the event of an unexpected interruption or error. Finalizers operate in conjunction with Effect's scoped resources. If an\neffect with a finalizer is wrapped in a scope, the finalizer will execute\nautomatically when the scope ends.\n*Example (Adding a Finalizer on Success) *Example (Adding a Finalizer on Failure) *Example (Adding a Finalizer on Interruption)",
  "documentation": "Ensures a finalizer is added to the scope of the calling effect, guaranteeing\nit runs when the scope is closed.\n*Details**\n\nThis function adds a finalizer that will execute whenever the scope of the\neffect is closed, regardless of whether the effect succeeds, fails, or is\ninterrupted. The finalizer receives the `Exit` value of the effect's scope,\nallowing it to react differently depending on how the effect concludes.\n\nFinalizers are a reliable way to manage resource cleanup, ensuring that\nresources such as file handles, network connections, or database transactions\nare properly closed even in the event of an unexpected interruption or error.\n\nFinalizers operate in conjunction with Effect's scoped resources. If an\neffect with a finalizer is wrapped in a scope, the finalizer will execute\nautomatically when the scope ends.\n*Example** (Adding a Finalizer on Success)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\n// ┌─── Effect<string, never, Scope>\n// ▼\nconst program = Effect.gen(function* () {\nyield* Effect.addFinalizer((exit) =>\nConsole.log(`Finalizer executed. Exit status: ${exit._tag}`)\n)\nreturn \"some result\"\n})\n\n// Wrapping the effect in a scope\n//\n// ┌─── Effect<string, never, never>\n// ▼\nconst runnable = Effect.scoped(program)\n\nEffect.runPromiseExit(runnable).then(console.log)\n// Output:\n// Finalizer executed. Exit status: Success\n// { _id: 'Exit', _tag: 'Success', value: 'some result' }\n```\n*Example** (Adding a Finalizer on Failure)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\n// ┌─── Effect<never, string, Scope>\n// ▼\nconst program = Effect.gen(function* () {\nyield* Effect.addFinalizer((exit) =>\nConsole.log(`Finalizer executed. Exit status: ${exit._tag}`)\n)\nreturn yield* Effect.fail(\"Uh oh!\")\n})\n\n// Wrapping the effect in a scope\n//\n// ┌─── Effect<never, string, never>\n// ▼\nconst runnable = Effect.scoped(program)\n\nEffect.runPromiseExit(runnable).then(console.log)\n// Output:\n// Finalizer executed. Exit status: Failure\n// {\n// _id: 'Exit',\n// _tag: 'Failure',\n// cause: { _id: 'Cause', _tag: 'Fail', failure: 'Uh oh!' }\n// }\n```\n*Example** (Adding a Finalizer on Interruption)\n\n```ts\nimport { Effect, Console } from \"effect\"\n\n// ┌─── Effect<never, never, Scope>\n// ▼\nconst program = Effect.gen(function* () {\nyield* Effect.addFinalizer((exit) =>\nConsole.log(`Finalizer executed. Exit status: ${exit._tag}`)\n)\nreturn yield* Effect.interrupt\n})\n\n// Wrapping the effect in a scope\n//\n// ┌─── Effect<never, never, never>\n// ▼\nconst runnable = Effect.scoped(program)\n\nEffect.runPromiseExit(runnable).then(console.log)\n// Output:\n// Finalizer executed. Exit status: Failure\n// {\n// _id: 'Exit',\n// _tag: 'Failure',\n// cause: {\n// _id: 'Cause',\n// _tag: 'Interrupt',\n// fiberId: {\n// _id: 'FiberId',\n// _tag: 'Runtime',\n// id: 0,\n// startTimeMillis: ...\n// }\n// }\n// }\n```",
  "examples": [
    {
      "code": "import { Effect, Console } from \"effect\"\n\n// ┌─── Effect<string, never, Scope>\n// ▼\nconst program = Effect.gen(function* () {\nyield* Effect.addFinalizer((exit) =>\nConsole.log(`Finalizer executed. Exit status: ${exit._tag}`)\n)\nreturn \"some result\"\n})\n\n// Wrapping the effect in a scope\n//\n// ┌─── Effect<string, never, never>\n// ▼\nconst runnable = Effect.scoped(program)\n\nEffect.runPromiseExit(runnable).then(console.log)\n// Output:\n// Finalizer executed. Exit status: Success\n// { _id: 'Exit', _tag: 'Success', value: 'some result' }"
    },
    {
      "code": "import { Effect, Console } from \"effect\"\n\n// ┌─── Effect<never, string, Scope>\n// ▼\nconst program = Effect.gen(function* () {\nyield* Effect.addFinalizer((exit) =>\nConsole.log(`Finalizer executed. Exit status: ${exit._tag}`)\n)\nreturn yield* Effect.fail(\"Uh oh!\")\n})\n\n// Wrapping the effect in a scope\n//\n// ┌─── Effect<never, string, never>\n// ▼\nconst runnable = Effect.scoped(program)\n\nEffect.runPromiseExit(runnable).then(console.log)\n// Output:\n// Finalizer executed. Exit status: Failure\n// {\n// _id: 'Exit',\n// _tag: 'Failure',\n// cause: { _id: 'Cause', _tag: 'Fail', failure: 'Uh oh!' }\n// }"
    },
    {
      "code": "import { Effect, Console } from \"effect\"\n\n// ┌─── Effect<never, never, Scope>\n// ▼\nconst program = Effect.gen(function* () {\nyield* Effect.addFinalizer((exit) =>\nConsole.log(`Finalizer executed. Exit status: ${exit._tag}`)\n)\nreturn yield* Effect.interrupt\n})\n\n// Wrapping the effect in a scope\n//\n// ┌─── Effect<never, never, never>\n// ▼\nconst runnable = Effect.scoped(program)\n\nEffect.runPromiseExit(runnable).then(console.log)\n// Output:\n// Finalizer executed. Exit status: Failure\n// {\n// _id: 'Exit',\n// _tag: 'Failure',\n// cause: {\n// _id: 'Cause',\n// _tag: 'Interrupt',\n// fiberId: {\n// _id: 'FiberId',\n// _tag: 'Runtime',\n// id: 0,\n// startTimeMillis: ...\n// }\n// }\n// }"
    }
  ],
  "tags": [
    "Scoping, Resources & Finalization"
  ],
  "since": "2.0.0",
  "sourceFile": "/Users/benjacobson/conductor/workspaces/hoogle-effect/san-juan-v1/packages/api/node_modules/effect/dist/dts/effect.d.ts",
  "sourceLine": 10278,
  "githubUrl": "https://github.com/Effect-TS/effect/blob/main/packages/effect/src/effect.ts#L10278"
}